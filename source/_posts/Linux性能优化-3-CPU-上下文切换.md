---
title: Linux性能优化(3)-CPU 上下文切换
date: 2020-01-30 20:50:10
categories: Linux
tags:
    - Linux
    - Context Switch
top:
---
# 1. Overview

多个进程竞争CPU会导致系统的负载升高，这是因为CPU会进行上下文切换。Linux是一个多任务操作系统，它可以支持远大于CPU数量的任务同时进行，然而，并不是真的同时运行，而是系统在很短的时间内，将CPU轮流分配给它们，造成多任务同时运行的错觉。

而在每个任务运行之前，CPU需要知道任务从哪里加载，又从哪里开始运行的。即***系统需要事先设置好CPU寄存器和程序计数器***。

CPU 寄存器，是 CPU 内置的容量小、但速度极快的内存。而程序计数器，则是用来存储 CPU 正在执行的指令位置、或者即将执行的下一条指令位置。它们都是 CPU 在运行任何任务前，必须的依赖环境，因此也被叫做 CPU上下文。

![fig1.png](https://i.loli.net/2020/01/31/3jaulkJAZwrsYBm.png)

而CPU上下文切换，就是先把前一个任务的CPU上下文，(CPU寄存器和程序计数器)保存起来,然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。

而这些保存下来的上下文，会存储在系统内核中，并在任务重新调度执行时再次加载进来。这样就能保证任务原来的状态不受影响，让任务看起来还是连续运行。

而CPU的上下文切换，可以分为几个不同的场景，进程上下文切换，线程上下文切换以及中断上下文切换。

# 2 系统调用

Linux 按照特权等级，把进程的运行空间分为内核空间和用户空间，分别对应着下图中， CPU 特权等级的 Ring 0 和 Ring 3。

![fig2.png](https://i.loli.net/2020/01/31/itzhDSE6eTcVOGP.png)

+ 内核空间具有最高权限，可以直接访问所有资源
+ 用户空间只能访问受限资源，不能直接访问内存等硬件设备，必须通过系统调用陷入内核状态中，才能访问这些特权资源。


> 进程既可以在用户空间运行，也可以在内核空间中运行。分别称为进程的用户态和内核态。

从用户态到内核态的转变，需要通过系统调用来完成。而这实际上也发生了CPU的上下文切换，CPU 寄存器里原来用户态的指令位置，需要先保存起来。接着，为了执行内核态代码，CPU 寄存器需要更新为内核态指令的新位置。最后才是跳转到内核态运行内核任务。

而系统调用结束后，CPU 寄存器需要恢复原来保存的用户态，然后再切换到用户空间，继续运行进程。所以一次系统调用的过程，实际上是发生了两次CPU上下文切换。

系统调用过程，不会切换进程的，不涉及到虚拟内存等进程用户态的资源，也不会切换进程。

+ 进程的上下文切换，是指从一个进程切换到另一个进程运行。
+ 系统调用过程一直在同一个进程当中


# 3. 进程上下文切换

## 3.1 进程上下文切换和系统调用的区别

+ 进程是由内核来管理和调度的，**进程的切换只能发生在内核态**。所以，进程的上下文不仅包括了**虚拟内存、栈、全局变量**等用户空间的资源，还包括了**内核堆栈、寄存器**等内核空间的状态。
+ 因此，进程的上下文切换就比系统调用时多了一步：在保存当前进程的内核状态和 CPU 寄存器之前，需要先把该进程的虚拟内存、栈等保存下来；而加载了下一进程的内核态后，还需要刷新进程的虚拟内存和用户栈。

![fig3.png](https://i.loli.net/2020/01/31/qum5ICSpUbZcjyR.png)


每次上下文切换都需要几十纳秒到数微秒的 CPU 时间。这个时间还是相当可观的，特别是在进程上下文切换次数较多的情况下，很容易导致 CPU 将大量时间耗费在寄存器、内核栈以及虚拟内存等资源的保存和恢复上，进而大大缩短了真正运行进程的时间。这也正是上一节中我们所讲的，导致平均负载升高的一个重要因素。

另外，我们知道， **Linux 通过 TLB（Translation Lookaside Buffer）来管理虚拟内存到物理内存的映射关系**。当虚拟内存更新后，TLB 也需要刷新，内存的访问也会随之变慢。特别是在多处理器系统上，缓存是被多个处理器共享的，刷新缓存不仅会影响当前处理器的进程，还会影响共享缓存的其他处理器的进程。

## 3.2 何时需要进程切换

进程调度的时候，按照优先级和等待的时间进行排序，对CPU的使用进行分配。

1. 为了保证所有进程可以得到公平调度，CPU 时间被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。这样，当某个进程的时间片耗尽了，就会被系统挂起，切换到其它正在等待 CPU 的进程运行。
2. **进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行**，这个时候进程也会被挂起，并由系统调度其他进程运行。
3. 当进程通过睡眠函数  sleep 这样的方法将自己主动挂起时，自然也会重新调度。
4. 当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行。
5. 发生**硬件中断**时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序。

# 4. 线程上下文切换

## 4.1 线程 vs 进程

> 线程是调度的基本单温，而进程是资源拥有的基本单位。

+ 内核当中的任务调度，实际上的调用对象是线程
+ 进程在为线程提供虚拟内存，全局变量等资源
+ 当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源，这些资源在上下文切换的时候是不需要修改的
+ 线程自己的私有数据比如栈还有寄存器，在上下文切换的时候是需要保存的

## 4.2 线程切换

两种情况：

+ 两个线程属于不同进程，因为资源不共享，所以切换过程跟进程上下文切换时一样的
+ 两个线程属于同一个进程，虚拟内存是共享的，在切换的时候，虚拟内存等资源保持不动，只需要切换线程的私有数据，寄存器等不共享的数据

# 5. 中断上下文切换

快速响应硬件时间的方式，中断处理会打断进程的正常调度和执行，转而调用中断处理程序，响应设备事件。而在打断其他进程时，需要将进程当前的状态保存下来，这样在中断结束以后，进程仍可以从原来的状态恢复运行。

跟进程上下文不同，中断上下文切换并不涉及到进程的用户态。所以，即便中断过程打断了一个正处在用户态的进程，也不需要保存和恢复这个进程的虚拟内存、全局变量等用户态资源。中断上下文，其实只包括内核态中断服务程序执行所必需的状态，包括 CPU 寄存器、内核堆栈、硬件中断参数等。

对同一个 CPU 来说，中断处理比进程拥有更高的优先级。，所以中断上下文切换并不会与进程上下文切换同时发生。同样道理，由于中断会打断正常进程的调度和执行，所以大部分中断处理程序都短小精悍，以便尽可能快的执行结束。

# 5. 实践

## 5.1 使用`vmstat`分析内存使用情况

    # 每隔 5 秒输出 1 组数据
    $ vmstat 5
    procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
     r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
     0  0      0 7005360  91564 818900    0    0     0     0   25   33  0  0 100  0  0


+ cs: 每秒上下文切换的次数
+ in: 每秒中断的次数
+ r (Running or Runnable): 就绪队列的长度，即正在运行和等待CPU的进程数
+ b (Blocked) 处于不可中断睡眠状态的进程数

## 5.2 使用`pidstat -w` 查看每个进程的上下文切换情况

    # 每隔 5 秒输出 1 组数据
    $ pidstat -w 5
    Linux 4.15.0 (ubuntu)  09/23/18  _x86_64_  (2 CPU)
    
    08:18:26      UID       PID   cswch/s nvcswch/s  Command
    08:18:31        0         1      0.20      0.00  systemd
    08:18:31        0         8      5.40      0.00  rcu_sched
    ...


+ cswch: 每秒资源上下文切换
    + 指进程无法获取所需的资源，导致的上下文切换
+ nvcswch: 每秒非资源上下文切换
    + 指进程由于时间片已经到了等原因，被系统强制调度，进而发生的上下文切换

## 5.3 从`/proc/interrupts`读取中断信息

/proc是Linux的一个虚拟文件系统，用于内核空间与用户空间之间的通信。/proc/interrupts是这种通信机制的一部分，提供了一个只读的中断使用情况。