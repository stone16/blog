---
title: 理解面向对象
date: 2020-02-24 21:20:52
categories: BackEnd
tags: 
    - OOP
top:
---
这篇博文主要想说面向对象的几大特性：封装，抽象，继承，多态，以及我们究竟如何去使用。

# 1. 面向对象概述

## 1.1 面向对象编程

一种编程范式/风格，以类或对象作为组织代码的基本单元，并将封装，抽象，继承，多态四个特性作为代码设计和实现的基石。

整个编程的过程：
+ Object Oriented Analysis
+ Object Oriented Design
+ Object Oriented Programming 

## 1.2 面向对象编程的四大特征

### 1.2.1 封装 Encapsulation 


    public class Wallet {
      private String id;
      private long createTime;
      private BigDecimal balance;
      private long balanceLastModifiedTime;
      // ...省略其他属性...
    
      public Wallet() {
         this.id = IdGenerator.getInstance().generate();
         this.createTime = System.currentTimeMillis();
         this.balance = BigDecimal.ZERO;
         this.balanceLastModifiedTime = System.currentTimeMillis();
      }
    
      // 注意：下面对get方法做了代码折叠，是为了减少代码所占文章的篇幅
      public String getId() { return this.id; }
      public long getCreateTime() { return this.createTime; }
      public BigDecimal getBalance() { return this.balance; }
      public long getBalanceLastModifiedTime() { return this.balanceLastModifiedTime;  }
    
      public void increaseBalance(BigDecimal increasedAmount) {
        if (increasedAmount.compareTo(BigDecimal.ZERO) < 0) {
          throw new InvalidAmountException("...");
        }
        this.balance.add(increasedAmount);
        this.balanceLastModifiedTime = System.currentTimeMillis();
      }
    
      public void decreaseBalance(BigDecimal decreasedAmount) {
        if (decreasedAmount.compareTo(BigDecimal.ZERO) < 0) {
          throw new InvalidAmountException("...");
        }
        if (decreasedAmount.compareTo(this.balance) > 0) {
          throw new InsufficientAmountException("...");
        }
        this.balance.subtract(decreasedAmount);
        this.balanceLastModifiedTime = System.currentTimeMillis();
      }
    }

虚拟钱包，对于自身变量，用private来标注，然后通过对应的getter，setter方法允许外界来访问一部分变量，允许进行一定的修改。

没有封装则意味着不可控，即任何代码都可以被任何人访问，修改的代码可以遍布在包的任何角落，会影响代码的可读性，以及可维护性。只暴露出有限多的接口，供外界来使用。

总结： 封装是为了隐藏信息，保护数据

### 1.2.2 继承 Inheritance

用来表述is a的关系，java支持单继承。

继承最大的好处就是代码复用，比如两个子类的共同代码抽取到父类当中，然后父类来共同使用。

但是过度使用的话会容易导致层级数量太多，反而降低代码的可读性。

### 1.2.3 多态 Polymorphism 

+ 继承加方法重写实现


    public class DynamicArray {
      private static final int DEFAULT_CAPACITY = 10;
      protected int size = 0;
      protected int capacity = DEFAULT_CAPACITY;
      protected Integer[] elements = new Integer[DEFAULT_CAPACITY];
      
      public int size() { return this.size; }
      public Integer get(int index) { return elements[index];}
      //...省略n多方法...
      
      public void add(Integer e) {
        ensureCapacity();
        elements[size++] = e;
      }
      
      protected void ensureCapacity() {
        //...如果数组满了就扩容...代码省略...
      }
    }
    
    public class SortedDynamicArray extends DynamicArray {
      @Override
      public void add(Integer e) {
        ensureCapacity();
        int i;
        for (i = size-1; i>=0; --i) { //保证数组中的数据有序
          if (elements[i] > e) {
            elements[i+1] = elements[i];
          } else {
            break;
          }
        }
        elements[i+1] = e;
        ++size;
      }
    }
    
    public class Example {
      public static void test(DynamicArray dynamicArray) {
        dynamicArray.add(5);
        dynamicArray.add(1);
        dynamicArray.add(3);
        for (int i = 0; i < dynamicArray.size(); ++i) {
          System.out.println(dynamicArray.get(i));
        }
      }
      
      public static void main(String args[]) {
        DynamicArray dynamicArray = new SortedDynamicArray();
        test(dynamicArray); // 打印结果：1、3、5
      }
    }

+ 利用接口类实现多态特性

    
    public interface Iterator {
      String hasNext();
      String next();
      String remove();
    }
    
    public class Array implements Iterator {
      private String[] data;
      
      public String hasNext() { ... }
      public String next() { ... }
      public String remove() { ... }
      //...省略其他方法...
    }
    
    public class LinkedList implements Iterator {
      private LinkedListNode head;
      
      public String hasNext() { ... }
      public String next() { ... }
      public String remove() { ... }
      //...省略其他方法... 
    }
    
    public class Demo {
      private static void print(Iterator iterator) {
        while (iterator.hasNext()) {
          System.out.println(iterator.next());
        }
      }
      
      public static void main(String[] args) {
        Iterator arrayIterator = new Array();
        print(arrayIterator);
        
        Iterator linkedListIterator = new LinkedList();
        print(linkedListIterator);
      }
    }
    
多态可以很大程度上提高代码的可扩展性和复用性
### 1.2.4 抽象 Abstraction 

抽象，主要是为了隐藏方法的具体实现，让调用者只需要关心方法提供了哪些功能，并不需要知道这些方法具体是如何实现的。


    public interface IPictureStorage {
      void savePicture(Picture picture);
      Image getPicture(String pictureId);
      void deletePicture(String pictureId);
      void modifyMetaInfo(String pictureId, PictureMetaInfo metaInfo);
    }
    
    public class PictureStorage implements IPictureStorage {
      // ...省略其他属性...
      @Override
      public void savePicture(Picture picture) { ... }
      @Override
      public Image getPicture(String pictureId) { ... }
      @Override
      public void deletePicture(String pictureId) { ... }
      @Override
      public void modifyMetaInfo(String pictureId, PictureMetaInfo metaInfo) { ... }
    }

使用接口或者abstract class，然后调用者就只需要知道需要传入什么参数，传出什么参数，就可以试用了。


# 2. 接口 vs 抽象类

# 3. 组合 vs 继承

# Reference

1. https://github.com/gdhucoder/Algorithms4/blob/master/designpattern/pic/umlcheatsheet.jpg 