---
title: 理解面向对象
date: 2020-02-24 21:20:52
categories: BackEnd
tags: 
    - OOP
top:
---
这篇博文主要想说面向对象的几大特性：封装，抽象，继承，多态，以及我们究竟如何去使用。

# 1. 面向对象概述

## 1.1 面向对象编程

一种编程范式/风格，以类或对象作为组织代码的基本单元，并将封装，抽象，继承，多态四个特性作为代码设计和实现的基石。

整个编程的过程：
+ Object Oriented Analysis
+ Object Oriented Design
+ Object Oriented Programming 

## 1.2 面向对象编程的四大特征

### 1.2.1 封装 Encapsulation 


    public class Wallet {
      private String id;
      private long createTime;
      private BigDecimal balance;
      private long balanceLastModifiedTime;
      // ...省略其他属性...
    
      public Wallet() {
         this.id = IdGenerator.getInstance().generate();
         this.createTime = System.currentTimeMillis();
         this.balance = BigDecimal.ZERO;
         this.balanceLastModifiedTime = System.currentTimeMillis();
      }
    
      // 注意：下面对get方法做了代码折叠，是为了减少代码所占文章的篇幅
      public String getId() { return this.id; }
      public long getCreateTime() { return this.createTime; }
      public BigDecimal getBalance() { return this.balance; }
      public long getBalanceLastModifiedTime() { return this.balanceLastModifiedTime;  }
    
      public void increaseBalance(BigDecimal increasedAmount) {
        if (increasedAmount.compareTo(BigDecimal.ZERO) < 0) {
          throw new InvalidAmountException("...");
        }
        this.balance.add(increasedAmount);
        this.balanceLastModifiedTime = System.currentTimeMillis();
      }
    
      public void decreaseBalance(BigDecimal decreasedAmount) {
        if (decreasedAmount.compareTo(BigDecimal.ZERO) < 0) {
          throw new InvalidAmountException("...");
        }
        if (decreasedAmount.compareTo(this.balance) > 0) {
          throw new InsufficientAmountException("...");
        }
        this.balance.subtract(decreasedAmount);
        this.balanceLastModifiedTime = System.currentTimeMillis();
      }
    }

虚拟钱包，对于自身变量，用private来标注，然后通过对应的getter，setter方法允许外界来访问一部分变量，允许进行一定的修改。

没有封装则意味着不可控，即任何代码都可以被任何人访问，修改的代码可以遍布在包的任何角落，会影响代码的可读性，以及可维护性。只暴露出有限多的接口，供外界来使用。

总结： 封装是为了隐藏信息，保护数据

### 1.2.2 继承 Inheritance

用来表述is a的关系，java支持单继承。

继承最大的好处就是代码复用，比如两个子类的共同代码抽取到父类当中，然后父类来共同使用。

但是过度使用的话会容易导致层级数量太多，反而降低代码的可读性。

### 1.2.3 多态 Polymorphism 

+ 继承加方法重写实现


    public class DynamicArray {
      private static final int DEFAULT_CAPACITY = 10;
      protected int size = 0;
      protected int capacity = DEFAULT_CAPACITY;
      protected Integer[] elements = new Integer[DEFAULT_CAPACITY];
      
      public int size() { return this.size; }
      public Integer get(int index) { return elements[index];}
      //...省略n多方法...
      
      public void add(Integer e) {
        ensureCapacity();
        elements[size++] = e;
      }
      
      protected void ensureCapacity() {
        //...如果数组满了就扩容...代码省略...
      }
    }
    
    public class SortedDynamicArray extends DynamicArray {
      @Override
      public void add(Integer e) {
        ensureCapacity();
        int i;
        for (i = size-1; i>=0; --i) { //保证数组中的数据有序
          if (elements[i] > e) {
            elements[i+1] = elements[i];
          } else {
            break;
          }
        }
        elements[i+1] = e;
        ++size;
      }
    }
    
    public class Example {
      public static void test(DynamicArray dynamicArray) {
        dynamicArray.add(5);
        dynamicArray.add(1);
        dynamicArray.add(3);
        for (int i = 0; i < dynamicArray.size(); ++i) {
          System.out.println(dynamicArray.get(i));
        }
      }
      
      public static void main(String args[]) {
        DynamicArray dynamicArray = new SortedDynamicArray();
        test(dynamicArray); // 打印结果：1、3、5
      }
    }

+ 利用接口类实现多态特性

    
    public interface Iterator {
      String hasNext();
      String next();
      String remove();
    }
    
    public class Array implements Iterator {
      private String[] data;
      
      public String hasNext() { ... }
      public String next() { ... }
      public String remove() { ... }
      //...省略其他方法...
    }
    
    public class LinkedList implements Iterator {
      private LinkedListNode head;
      
      public String hasNext() { ... }
      public String next() { ... }
      public String remove() { ... }
      //...省略其他方法... 
    }
    
    public class Demo {
      private static void print(Iterator iterator) {
        while (iterator.hasNext()) {
          System.out.println(iterator.next());
        }
      }
      
      public static void main(String[] args) {
        Iterator arrayIterator = new Array();
        print(arrayIterator);
        
        Iterator linkedListIterator = new LinkedList();
        print(linkedListIterator);
      }
    }
    
多态可以很大程度上提高代码的可扩展性和复用性
### 1.2.4 抽象 Abstraction 

抽象，主要是为了隐藏方法的具体实现，让调用者只需要关心方法提供了哪些功能，并不需要知道这些方法具体是如何实现的。


    public interface IPictureStorage {
      void savePicture(Picture picture);
      Image getPicture(String pictureId);
      void deletePicture(String pictureId);
      void modifyMetaInfo(String pictureId, PictureMetaInfo metaInfo);
    }
    
    public class PictureStorage implements IPictureStorage {
      // ...省略其他属性...
      @Override
      public void savePicture(Picture picture) { ... }
      @Override
      public Image getPicture(String pictureId) { ... }
      @Override
      public void deletePicture(String pictureId) { ... }
      @Override
      public void modifyMetaInfo(String pictureId, PictureMetaInfo metaInfo) { ... }
    }

使用接口或者abstract class，然后调用者就只需要知道需要传入什么参数，传出什么参数，就可以试用了。

# 2. 面向对象 vs 面向过程

需要对这两个概念有更深的理解，很多时候，我们是在用面向对象的语言写面向过程的代码，对于到底什么是面向对象，如何写真的面向对象的代码，我们还是有很多无法确定的地方。

面向过程的编程是一种编程范式，以过程(方法，函数，操作)作为组织代码的基本单元，以数据(可以理解为成员变量，属性)与方法相分离为最主要的特点。面向过程风格是一种流程化的编程风格，通过拼接一组顺序执行的方法来操作数据完成一项功能。

## 2.1 面向对象编程的优势

### 2.1.1 更能够应对大规模复杂程序的开发

因为对于面向过程的编程风格来说，整个程序的处理流程会偏向于线性，流程化，但是实际应用场景中，关系错综复杂，会很难将程序拆解为一组顺序执行的方法。而面向对象的方式就可以比较好的解决这个问题了。

### 2.1.2 更易复用，扩展和维护

面向对象通过类这种组织方式能够将数据和方法绑定在一起，通过访问权限控制，只允许外部调用者通过类暴露的有限方法访问数据，而不会像面向过程编程那样，数据可以被任意方法的随意修改

我们通过使用多态的特性，可以在需要修改一个功能实现的时候，通过实现一个新的子类的方式，在子类当中重写原来的功能逻辑，用子类替代父类。 ---- 对修改关闭，对扩展开放。


# 2. 接口 vs 抽象类

# 3. 组合 vs 继承

# Reference

1. https://github.com/gdhucoder/Algorithms4/blob/master/designpattern/pic/umlcheatsheet.jpg 