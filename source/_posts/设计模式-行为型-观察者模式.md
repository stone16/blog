---
title: 设计模式-行为型-观察者模式
date: 2020-06-29 20:48:34
categories: SystemDesign
tags:
    - 观察者模式
top:
---
 + 创建型设计模式
     + 解决对象创建的问题

+ 结构型设计模式
    + 解决类或者对象的组合或组装问题

+ 行为型设计模式
    + 解决类或对象之间的交互问题

# 1. 观察者模式原理

根据应用场景的不同，观察者模式是会有不同的代码实现的
    + 同步阻塞
    + 异步非阻塞
    + 进程内的实现方式
    + 跨进程的实现方式
    
+ 观察者模式  Observer Design Pattern
    + 发布订阅模式 Publish - Subscribe Design Pattern 
    + Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically. 
    + 角色划分
        + observable and observer 
        + publisher and subscriber 
        + producer and consumer 
        + subject and observer 
        + dispatcher and listener 
        + eventEmitter and EventListener 


    // Example 
    public interface RegObserver {
      void handleRegSuccess(long userId);
    }

    public class RegPromotionObserver implements RegObserver {
      private PromotionService promotionService; // 依赖注入

      @Override
      public void handleRegSuccess(long userId) {
        promotionService.issueNewUserExperienceCash(userId);
      }
    }

    public class RegNotificationObserver implements RegObserver {
      private NotificationService notificationService;

      @Override
      public void handleRegSuccess(long userId) {
        notificationService.sendInboxMessage(userId, "Welcome...");
      }
    }

    public class UserController {
      private UserService userService; // 依赖注入
      private List<RegObserver> regObservers = new ArrayList<>();

      // 一次性设置好，之后也不可能动态的修改
      public void setRegObservers(List<RegObserver> observers) {
        regObservers.addAll(observers);
      }

      public Long register(String telephone, String password) {
        //省略输入参数的校验代码
        //省略userService.register()异常的try-catch代码
        long userId = userService.register(telephone, password);

        for (RegObserver observer : regObservers) {
          observer.handleRegSuccess(userId);
        }

        return userId;
      }
    }
    
# 2. 探究异步非阻塞的EventBus框架


## 2.1 基本的异步非阻塞模式



    // 第一种实现方式，其他类代码不变，就没有再重复罗列
    public class RegPromotionObserver implements RegObserver {
      private PromotionService promotionService; // 依赖注入

      @Override
      public void handleRegSuccess(long userId) {
        Thread thread = new Thread(new Runnable() {
          @Override
          public void run() {
            promotionService.issueNewUserExperienceCash(userId);
          }
        });
        thread.start();
      }
    }

    // 第二种实现方式，其他类代码不变，就没有再重复罗列
    public class UserController {
      private UserService userService; // 依赖注入
      private List<RegObserver> regObservers = new ArrayList<>();
      private Executor executor;

      public UserController(Executor executor) {
        this.executor = executor;
      }

      public void setRegObservers(List<RegObserver> observers) {
        regObservers.addAll(observers);
      }

      public Long register(String telephone, String password) {
        //省略输入参数的校验代码
        //省略userService.register()异常的try-catch代码
        long userId = userService.register(telephone, password);

        for (RegObserver observer : regObservers) {
          executor.execute(new Runnable() {
            @Override
            public void run() {
              observer.handleRegSuccess(userId);
            }
          });
        }

        return userId;
      }
    }

+ 方法1 
    + 频繁创建销毁线程比较耗时
    + 并且创建过多线程会导致堆栈溢出

+ 方法2 
    + 线程池，异步执行的逻辑耦合在了register()函数当中，维护成本会提高