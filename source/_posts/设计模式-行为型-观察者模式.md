---
title: 设计模式-行为型-观察者模式
date: 2020-06-29 20:48:34
categories: SystemDesign
tags:
    - 观察者模式
top:
---
  + 创建型设计模式
     + 解决对象创建的问题

+ 结构型设计模式
    + 解决类或者对象的组合或组装问题

+ 行为型设计模式
    + 解决类或对象之间的交互问题

# 1. 观察者模式原理

根据应用场景的不同，观察者模式是会有不同的代码实现的
    + 同步阻塞
    + 异步非阻塞
    + 进程内的实现方式
    + 跨进程的实现方式
    
+ 观察者模式  Observer Design Pattern
    + 发布订阅模式 Publish - Subscribe Design Pattern 
    + Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically. 
    + 角色划分
        + observable and observer 
        + publisher and subscriber 
        + producer and consumer 
        + subject and observer 
        + dispatcher and listener 
        + eventEmitter and EventListener 


    // Example 
    public interface RegObserver {
      void handleRegSuccess(long userId);
    }

    public class RegPromotionObserver implements RegObserver {
      private PromotionService promotionService; // 依赖注入

      @Override
      public void handleRegSuccess(long userId) {
        promotionService.issueNewUserExperienceCash(userId);
      }
    }

    public class RegNotificationObserver implements RegObserver {
      private NotificationService notificationService;

      @Override
      public void handleRegSuccess(long userId) {
        notificationService.sendInboxMessage(userId, "Welcome...");
      }
    }

    public class UserController {
      private UserService userService; // 依赖注入
      private List<RegObserver> regObservers = new ArrayList<>();

      // 一次性设置好，之后也不可能动态的修改
      public void setRegObservers(List<RegObserver> observers) {
        regObservers.addAll(observers);
      }

      public Long register(String telephone, String password) {
        //省略输入参数的校验代码
        //省略userService.register()异常的try-catch代码
        long userId = userService.register(telephone, password);

        for (RegObserver observer : regObservers) {
          observer.handleRegSuccess(userId);
        }

        return userId;
      }
    }
    
# 2. 探究异步非阻塞的EventBus框架


## 2.1 基本的异步非阻塞模式



    // 第一种实现方式，其他类代码不变，就没有再重复罗列
    public class RegPromotionObserver implements RegObserver {
      private PromotionService promotionService; // 依赖注入

      @Override
      public void handleRegSuccess(long userId) {
        Thread thread = new Thread(new Runnable() {
          @Override
          public void run() {
            promotionService.issueNewUserExperienceCash(userId);
          }
        });
        thread.start();
      }
    }

    // 第二种实现方式，其他类代码不变，就没有再重复罗列
    public class UserController {
      private UserService userService; // 依赖注入
      private List<RegObserver> regObservers = new ArrayList<>();
      private Executor executor;

      public UserController(Executor executor) {
        this.executor = executor;
      }

      public void setRegObservers(List<RegObserver> observers) {
        regObservers.addAll(observers);
      }

      public Long register(String telephone, String password) {
        //省略输入参数的校验代码
        //省略userService.register()异常的try-catch代码
        long userId = userService.register(telephone, password);

        for (RegObserver observer : regObservers) {
          executor.execute(new Runnable() {
            @Override
            public void run() {
              observer.handleRegSuccess(userId);
            }
          });
        }

        return userId;
      }
    }

+ 方法1 
    + 频繁创建销毁线程比较耗时
    + 并且创建过多线程会导致堆栈溢出

+ 方法2 
    + 线程池，异步执行的逻辑耦合在了register()函数当中，维护成本会提高


## 2.2 EventBus功能需求

以google guava eventBus为例


    public class UserController {
      private UserService userService; // 依赖注入

      private EventBus eventBus;
      private static final int DEFAULT_EVENTBUS_THREAD_POOL_SIZE = 20;

      public UserController() {
        //eventBus = new EventBus(); // 同步阻塞模式
        eventBus = new AsyncEventBus(Executors.newFixedThreadPool(DEFAULT_EVENTBUS_THREAD_POOL_SIZE)); // 异步非阻塞模式
      }

      public void setRegObservers(List<Object> observers) {
        for (Object observer : observers) {
          eventBus.register(observer);
        }
      }

      public Long register(String telephone, String password) {
        //省略输入参数的校验代码
        //省略userService.register()异常的try-catch代码
        long userId = userService.register(telephone, password);

        eventBus.post(userId);

        return userId;
      }
    }

    public class RegPromotionObserver {
      private PromotionService promotionService; // 依赖注入

      @Subscribe
      public void handleRegSuccess(long userId) {
        promotionService.issueNewUserExperienceCash(userId);
      }
    }

    public class RegNotificationObserver {
      private NotificationService notificationService;

      @Subscribe
      public void handleRegSuccess(long userId) {
        notificationService.sendInboxMessage(userId, "...");
      }
    }
    
+ 使用EventBus框架实现的观察者模式，大流程上相同，但是区别在于
    + 不用定义Observer接口了
    + 任意类型的对象都可以注册到EventBus当中，通过`@Subscribe`注解来标明类当中哪个函数可以接收被观察者发送的消息


+ EventBus, AsyncEventBus 
    + Guava EventBus 的所有可调用接口



    EventBus eventBus = new EventBus(); // 同步阻塞模式
    EventBus eventBus = new AsyncEventBus(Executors.newFixedThreadPool(8))；// 异步阻塞模式

+ `register()`函数
    + 用来注册观察者
    + 可以接受任何类型的观察者

+ `unregister()`函数
    + 删除某个观察者

+ `post()`函数
    + 用于给观察者发送消息

+ `@Subscribe`注解
    + 通过注解说明某个函数能够接收哪种类型的消息


最关键的一个数据结构是 Observer 注册表，记录了消息类型和可接收消息函数的对应关系。当调用 register() 函数注册观察者的时候，EventBus 通过解析 @Subscribe 注解，生成 Observer 注册表。当调用 post() 函数发送消息的时候，EventBus 通过注册表找到相应的可接收消息的函数，然后通过 Java 的反射语法来动态地创建对象、执行函数。对于同步阻塞模式，EventBus 在一个线程内依次执行相应的函数。对于异步非阻塞模式，EventBus 通过一个线程池来执行相应的函数。

## 2.3 EventBus的实现

1. Subscirbe 注解

用于标明观察者中的哪个函数可以接收信息

    @Retention(RetentionPolicy.RUNTIME)
    @Target(ElementType.METHOD)
    @Beta
    public @interface Subscribe {}
    
2. ObserverAction

ObserverAction类用来表示Subscribe注解的方法，其中target表示观察者类，method表示方法，主要用在ObserverRegistry观察者注册表当中。


    public class ObserverAction {
      private Object target;
      private Method method;

      public ObserverAction(Object target, Method method) {
        this.target = Preconditions.checkNotNull(target);
        this.method = method;
        this.method.setAccessible(true);
      }

      public void execute(Object event) { // event是method方法的参数
        try {
          method.invoke(target, event);
        } catch (InvocationTargetException | IllegalAccessException e) {
          e.printStackTrace();
        }
      }
    }
    
3. ObserverRegistry

Observer注册表类，大量使用Java的反射语法


    public class ObserverRegistry {
      private ConcurrentMap<Class<?>, CopyOnWriteArraySet<ObserverAction>> registry = new ConcurrentHashMap<>();

      public void register(Object observer) {
        Map<Class<?>, Collection<ObserverAction>> observerActions = findAllObserverActions(observer);
        for (Map.Entry<Class<?>, Collection<ObserverAction>> entry : observerActions.entrySet()) {
          Class<?> eventType = entry.getKey();
          Collection<ObserverAction> eventActions = entry.getValue();
          CopyOnWriteArraySet<ObserverAction> registeredEventActions = registry.get(eventType);
          if (registeredEventActions == null) {
            registry.putIfAbsent(eventType, new CopyOnWriteArraySet<>());
            registeredEventActions = registry.get(eventType);
          }
          registeredEventActions.addAll(eventActions);
        }
      }

      public List<ObserverAction> getMatchedObserverActions(Object event) {
        List<ObserverAction> matchedObservers = new ArrayList<>();
        Class<?> postedEventType = event.getClass();
        for (Map.Entry<Class<?>, CopyOnWriteArraySet<ObserverAction>> entry : registry.entrySet()) {
          Class<?> eventType = entry.getKey();
          Collection<ObserverAction> eventActions = entry.getValue();
          if (postedEventType.isAssignableFrom(eventType)) {
            matchedObservers.addAll(eventActions);
          }
        }
        return matchedObservers;
      }

      private Map<Class<?>, Collection<ObserverAction>> findAllObserverActions(Object observer) {
        Map<Class<?>, Collection<ObserverAction>> observerActions = new HashMap<>();
        Class<?> clazz = observer.getClass();
        for (Method method : getAnnotatedMethods(clazz)) {
          Class<?>[] parameterTypes = method.getParameterTypes();
          Class<?> eventType = parameterTypes[0];
          if (!observerActions.containsKey(eventType)) {
            observerActions.put(eventType, new ArrayList<>());
          }
          observerActions.get(eventType).add(new ObserverAction(observer, method));
        }
        return observerActions;
      }

      private List<Method> getAnnotatedMethods(Class<?> clazz) {
        List<Method> annotatedMethods = new ArrayList<>();
        for (Method method : clazz.getDeclaredMethods()) {
          if (method.isAnnotationPresent(Subscribe.class)) {
            Class<?>[] parameterTypes = method.getParameterTypes();
            Preconditions.checkArgument(parameterTypes.length == 1,
                    "Method %s has @Subscribe annotation but has %s parameters."
                            + "Subscriber methods must have exactly 1 parameter.",
                    method, parameterTypes.length);
            annotatedMethods.add(method);
          }
        }
        return annotatedMethods;
      }
    }

4. EventBus


    public class EventBus {
      private Executor executor;
      private ObserverRegistry registry = new ObserverRegistry();

      public EventBus() {
        this(MoreExecutors.directExecutor());
      }

      protected EventBus(Executor executor) {
        this.executor = executor;
      }

      public void register(Object object) {
        registry.register(object);
      }

      public void post(Object event) {
        List<ObserverAction> observerActions = registry.getMatchedObserverActions(event);
        for (ObserverAction observerAction : observerActions) {
          executor.execute(new Runnable() {
            @Override
            public void run() {
              observerAction.execute(event);
            }
          });
        }
      }
    }
    
5. AsyncEventBus


    public class AsyncEventBus extends EventBus {
      public AsyncEventBus(Executor executor) {
        super(executor);
      }
    }