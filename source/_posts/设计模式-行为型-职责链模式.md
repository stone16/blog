---
title: 设计模式-行为型-职责链模式
date: 2020-07-11 18:22:10
categories: SystemDesign
tags:
    - 职责链模式
top:
---
# 1. 原理与实现

+ 职责链模式
    + Chian of Responsibility Design Pattern 
    + Avoid coupling the sender of a request to its receiver by giving more than one object a chance to hadle the request. Chain the receiving objects and pass the request along the chain until an object handles it. 
    + 将请求的发送和接收解耦，让多个接收对象都有机会处理这个请求。将这些接收对象串成一条链，并沿着这条链传递这个请求，直到链上的某个接收对象能够处理它为止
    + 在职责链模式当中，多个处理器依次处理同一个请求，一个请求先经过A处理器处理，再把请求传递给B处理器，B处理器处理完以后再传递给C处理器。各个处理器之间形成了一个链条，链条上的每个处理器各自承担各自的处理职责，所以叫做职责链模式。

## 1.1 使用链表实现HandlerChain

+ Handler是所有处理器的抽象父类
+ handle()是抽象方法
+ 每个具体的处理器类的handle()函数结构会比较类似，如果能处理请求，则进行处理；如果不能，则交由后面的处理器来进行处理
+ HandlerChain是处理器链，从数据结构来看，是一个记录了链头、链尾的链表。


public abstract class Handler {
  protected Handler successor = null;

  public void setSuccessor(Handler successor) {
    this.successor = successor;
  }

  public final void handle() {
    boolean handled = doHandle();
    
    if (successor != null && !handled) {
        successor.handle();
    }
  }
  public abstract boolean doHandle();
}

public class HandlerA extends Handler {
  @Override
  public void doHandle() {
    boolean handled = false;
    //...
    return handled;
  }
}

public class HandlerB extends Handler {
  @Override
  public void doHandle() {
    boolean handled = false;
    //...
    return handled;
  }
}

public class HandlerChain {
  private Handler head = null;
  private Handler tail = null;

  public void addHandler(Handler handler) {
    handler.setSuccessor(null);

    if (head == null) {
      head = handler;
      tail = handler;
      return;
    }

    tail.setSuccessor(handler);
    tail = handler;
  }

  public void handle() {
    if (head != null) {
      head.handle();
    }
  }
}

// 使用举例
public class Application {
  public static void main(String[] args) {
    HandlerChain chain = new HandlerChain();
    chain.addHandler(new HandlerA());
    chain.addHandler(new HandlerB());
    chain.handle();
  }
}

## 1.2 使用数组实现HandlerChain


    public interface IHandler {
      boolean handle();
    }

    public class HandlerA implements IHandler {
      @Override
      public boolean handle() {
        boolean handled = false;
        //...
        return handled;
      }
    }

    public class HandlerB implements IHandler {
      @Override
      public boolean handle() {
        boolean handled = false;
        //...
        return handled;
      }
    }

    public class HandlerChain {
      private List<IHandler> handlers = new ArrayList<>();

      public void addHandler(IHandler handler) {
        this.handlers.add(handler);
      }

      public void handle() {
        for (IHandler handler : handlers) {
          boolean handled = handler.handle();
          if (handled) {
            break;
          }
        }
      }
    }

    // 使用举例
    public class Application {
      public static void main(String[] args) {
        HandlerChain chain = new HandlerChain();
        chain.addHandler(new HandlerA());
        chain.addHandler(new HandlerB());
        chain.handle();
      }
    }
    
# 2. 过滤器、拦截器的实现