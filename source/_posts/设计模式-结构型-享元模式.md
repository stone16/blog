---
title: 设计模式-结构型-享元模式
date: 2020-06-27 20:14:26
categories: SystemDesign
tags:
    - 享元模式
top:
---
# 1. 原理与实现

+ 享元模式 Flyweight Design Pattern 
    + 用来复用对象，节省内存，
    + 前提条件，享元对象是不可变对象
        + 不可以暴露任何set（）等修改内部状态的方法

    + 当一个系统中存在大量重复对象的时候，如果重复对象都是不可变对象，我们就可以利用享元模式将对象设计成享元，在内存中只保留一份实例，供多处代码来引用。


+ 是通过工厂模式，在工厂类当中，通过一个Map来缓存已经创建过的享元对象，来达到复用的目的


+ 文本文件对于字体格式进行享元操作


    public class CharacterStyle {
      private Font font;
      private int size;
      private int colorRGB;

      public CharacterStyle(Font font, int size, int colorRGB) {
        this.font = font;
        this.size = size;
        this.colorRGB = colorRGB;
      }

      @Override
      public boolean equals(Object o) {
        CharacterStyle otherStyle = (CharacterStyle) o;
        return font.equals(otherStyle.font)
                && size == otherStyle.size
                && colorRGB == otherStyle.colorRGB;
      }
    }

    public class CharacterStyleFactory {
      private static final List<CharacterStyle> styles = new ArrayList<>();

      public static CharacterStyle getStyle(Font font, int size, int colorRGB) {
        CharacterStyle newStyle = new CharacterStyle(font, size, colorRGB);
        for (CharacterStyle style : styles) {
          if (style.equals(newStyle)) {
            return style;
          }
        }
        styles.add(newStyle);
        return newStyle;
      }
    }

    public class Character {
      private char c;
      private CharacterStyle style;

      public Character(char c, CharacterStyle style) {
        this.c = c;
        this.style = style;
      }
    }

    public class Editor {
      private List<Character> chars = new ArrayList<>();

      public void appendCharacter(char c, Font font, int size, int colorRGB) {
        Character character = new Character(c, CharacterStyleFactory.getStyle(font, size, colorRGB));
        chars.add(character);
      }
    }
    
# 2. 享元模式在Java Integer以及String当中的应用


    /**
     * Cache to support the object identity semantics of autoboxing for values between
     * -128 and 127 (inclusive) as required by JLS.
     *
     * The cache is initialized on first usage.  The size of the cache
     * may be controlled by the {@code -XX:AutoBoxCacheMax=<size>} option.
     * During VM initialization, java.lang.Integer.IntegerCache.high property
     * may be set and saved in the private system properties in the
     * sun.misc.VM class.
     */
    private static class IntegerCache {
        static final int low = -128;
        static final int high;
        static final Integer cache[];

        static {
            // high value may be configured by property
            int h = 127;
            String integerCacheHighPropValue =
                sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high");
            if (integerCacheHighPropValue != null) {
                try {
                    int i = parseInt(integerCacheHighPropValue);
                    i = Math.max(i, 127);
                    // Maximum array size is Integer.MAX_VALUE
                    h = Math.min(i, Integer.MAX_VALUE - (-low) -1);
                } catch( NumberFormatException nfe) {
                    // If the property cannot be parsed into an int, ignore it.
                }
            }
            high = h;

            cache = new Integer[(high - low) + 1];
            int j = low;
            for(int k = 0; k < cache.length; k++)
                cache[k] = new Integer(j++);

            // range [-128, 127] must be interned (JLS7 5.1.7)
            assert IntegerCache.high >= 127;
        }

        private IntegerCache() {}
    }
    
IntegerCache 缓存在-128到127之间的内容，即指向的是同样的内存地址的