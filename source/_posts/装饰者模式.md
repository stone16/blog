---
title: 装饰者模式
date: 2022-09-19 22:48:01
categories: Design Pattern 
tags:
top:
---
# 1. 装饰者模式Overview

- Attach additional responsibilities to an object **dynamically**. Decorator provides a flexible alternative to subclassing for extending functionality.
    - inheriting behavior at runtime through composition and delegation
    - open for extension but close for modification
    - decorator has the same super type as the objects they decorate
    - we could use one or more decorators to wrap an object
    - the decorator **adds its own behavior** before and/or after delegating to the object it decorates to do the rest of the job

# 2. 使用场景

- when we want to give some other responsibility at run time
- kind of like continue to wrap the intrinsic object with some new responsibility, still an is-a relationship

# 3. 使用目的

- Extends the class at run time instead of compile time
- To give objects some new responsibilities without making any code changes to the underlying classes
- pitfall
    - sometimes it could lead to a lot of new classes

# 4. 具体实现

- One highlight
    - the condimentDecorator is a beverage, and also need to has a beverage
    - we are using inheritance to achieve the type matching, but we aren’t using inheritance to get behavior
    
    ![Class Diagram](https://s2.loli.net/2022/09/19/YshIa9SnT65NH17.png)
    

## 4.1 接口和数据对象定义

```java
public abstract class Beverage {
    String description = "Unknown Beverage";

    public abstract double cost();

    public String getDescription() {
        return description;
    }
}

public abstract class CondimentDecorator extends Beverage{

    Beverage beverage;

    public abstract String getDescription();
}
```

## 4.2 具体实现类的定义

```java
public class DecafCoffee extends Beverage {
    @Override
    public double cost() {
        return 2.5f;
    }

    String description() {
        return "Decat coffee";
    }
}

public class Espresso extends Beverage{

    public Espresso() {
        description = "Espresso";
    }
    @Override
    public double cost() {
        return 4;
    }
}

public class HouseBlend extends Beverage{

    public HouseBlend() {
        description = "House Blend Coffee";
    }

    @Override
    public double cost() {
        return 0.99;
    }
}

public class MilkDecorator extends CondimentDecorator{

    public MilkDecorator(Beverage beverage) {
        this.beverage = beverage;
    }

    @Override
    public double cost() {
        return beverage.cost() + 0.8;
    }

    @Override
    public String getDescription() {
        return beverage.getDescription() + "with milk";
    }
}

public class MochaDecorator extends CondimentDecorator{

    public MochaDecorator(Beverage beverage) {
        this.beverage = beverage;
    }

    @Override
    public double cost() {
        return beverage.cost() + 0.5;
    }

    @Override
    public String getDescription() {
        return beverage.getDescription() + "with Mocha";
    }
}
```

## 4.3 测试

```java
@GetMapping("/decorator")
    public String decorator() {
        Beverage decafCoffee = new DecafCoffee();
        log.info("before decoration" + decafCoffee.cost());

        Beverage decafWithMocha = new MochaDecorator(decafCoffee);
        log.info("after decoration" + decafWithMocha.cost());
        log.info("after decoration 2" + new MochaDecorator(new MochaDecorator(decafCoffee)).cost());

        return "check the log";
    }
```

# Reference

1. [https://learning.oreilly.com/library/view/head-first-design/9781492077992/ch02.html](https://learning.oreilly.com/library/view/head-first-design/9781492077992/ch02.html) 