---
title: 设计模式-结构型-装饰器模式
date: 2020-06-22 20:09:04
categories: SystemDesign
tags:
    - 装饰器模式
top:
---

# 1. Overview

## 1.1 Java IO类的使用


|  |字节流  |字符流  |
| --- | --- | --- |
|输入流  | InputStream |Reader  |
| 输出流 | OutputStream | Writer |

JavaIO库非常庞大，几十个类一同来负责IO数据的读取和写入。


    InputStream in = new FileInputStream("/user/wangzheng/test.txt");
    InputStream bin = new BufferedInputStream(in);
    byte[] data = new byte[128];
    while (bin.read(data) != -1) {
      //...
    }

上述代码先使用了FileInputStream来读取文件流，然后又使用了BufferedInputStream，来支持缓存。

问题来了，为什么不能设置一个继承了FileInputStream并且支持缓存的BufferedFileInputStream类呢？ 

问题在于各种use case太多，如果为了各种功能的组合都设置一个类的话，那么类的继承结构会变得非常负责，代码会变得很难扩展和维护。


Java IO的设计思路，就是使用组合来替代继承


    public abstract class InputStream {
      //...
      public int read(byte b[]) throws IOException {
        return read(b, 0, b.length);
      }

      public int read(byte b[], int off, int len) throws IOException {
        //...
      }

      public long skip(long n) throws IOException {
        //...
      }

      public int available() throws IOException {
        return 0;
      }

      public void close() throws IOException {}

      public synchronized void mark(int readlimit) {}

      public synchronized void reset() throws IOException {
        throw new IOException("mark/reset not supported");
      }

      public boolean markSupported() {
        return false;
      }
    }

    public class BufferedInputStream extends InputStream {
      protected volatile InputStream in;

      protected BufferedInputStream(InputStream in) {
        this.in = in;
      }

      //...实现基于缓存的读数据接口...  
    }

    public class DataInputStream extends InputStream {
      protected volatile InputStream in;

      protected DataInputStream(InputStream in) {
        this.in = in;
      }

      //...实现读取基本类型数据的接口
    }
    
## 1.2 装饰器模式

+ 使用组合来替代继承关系
+ 装饰器类和原始类继承同样的父类，这样我们就可以对原始类嵌套多个装饰器类
+ 是对功能的增强，是和原始功能相关的
+ 为了解决继承关系过于复杂的问题



