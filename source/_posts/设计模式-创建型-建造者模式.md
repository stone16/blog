---
title: 设计模式-创建型-建造者模式
date: 2020-06-15 21:17:36
categories: SystemDesign
tags:
    - 建造者模式
top:
---
# 1. 为什么需要建造者模式

一个关于如何使用建造者模式的问题是：当我们能够使用构造函数或者使用set方法就能够创建对象的时候，我们为什么会需要建造者模式来创建呢？ 

一个例子，假设我们要定义一个类，其大部分的属性都是可以选择的，那么我们可以使用构造函数来做如下的声明： 


    public class ResourcePoolConfig {
      private static final int DEFAULT_MAX_TOTAL = 8;
      private static final int DEFAULT_MAX_IDLE = 8;
      private static final int DEFAULT_MIN_IDLE = 0;

      private String name;
      private int maxTotal = DEFAULT_MAX_TOTAL;
      private int maxIdle = DEFAULT_MAX_IDLE;
      private int minIdle = DEFAULT_MIN_IDLE;

      public ResourcePoolConfig(String name, Integer maxTotal, Integer maxIdle, Integer minIdle) {
        if (StringUtils.isBlank(name)) {
          throw new IllegalArgumentException("name should not be empty.");
        }
        this.name = name;

        if (maxTotal != null) {
          if (maxTotal <= 0) {
            throw new IllegalArgumentException("maxTotal should be positive.");
          }
          this.maxTotal = maxTotal;
        }

        if (maxIdle != null) {
          if (maxIdle < 0) {
            throw new IllegalArgumentException("maxIdle should not be negative.");
          }
          this.maxIdle = maxIdle;
        }

        if (minIdle != null) {
          if (minIdle < 0) {
            throw new IllegalArgumentException("minIdle should not be negative.");
          }
          this.minIdle = minIdle;
        }
      }
      //...省略getter方法...
    }
    
在这个例子当中，除了name以外的所有选项都是可选的，因此会看到在构造函数当中，我们做了很多的null check。这样做当参数很多的时候，是很难看懂的。我们可以将其改良为一系列的set()函数，构造函数只实例化NonNull的参数，对于Nullable的参数，我们可以用set方法来实现声明。如下所示： 


    public class ResourcePoolConfig {
      private static final int DEFAULT_MAX_TOTAL = 8;
      private static final int DEFAULT_MAX_IDLE = 8;
      private static final int DEFAULT_MIN_IDLE = 0;

      private String name;
      private int maxTotal = DEFAULT_MAX_TOTAL;
      private int maxIdle = DEFAULT_MAX_IDLE;
      private int minIdle = DEFAULT_MIN_IDLE;

      public ResourcePoolConfig(String name) {
        if (StringUtils.isBlank(name)) {
          throw new IllegalArgumentException("name should not be empty.");
        }
        this.name = name;
      }

      public void setMaxTotal(int maxTotal) {
        if (maxTotal <= 0) {
          throw new IllegalArgumentException("maxTotal should be positive.");
        }
        this.maxTotal = maxTotal;
      }

      public void setMaxIdle(int maxIdle) {
        if (maxIdle < 0) {
          throw new IllegalArgumentException("maxIdle should not be negative.");
        }
        this.maxIdle = maxIdle;
      }

      public void setMinIdle(int minIdle) {
        if (minIdle < 0) {
          throw new IllegalArgumentException("minIdle should not be negative.");
        }
        this.minIdle = minIdle;
      }
      //...省略getter方法...
    }
    
上述的set方法还是有一些缺陷的，即：
+ 首先如果必填的配置项有很多，且都需要放置到构造函数当中，那构造函数就会出现参数列表很长的问题了。
+ 假设配置项之间有一定的依赖关系，我们需要将配置项之间的依赖关系和校验逻辑找地方放
+ 如果我们希望类对象是不可变对象，即对象在创建好之后就不能再修改内部的属性值，那么我们就不能再ResourcePoolConfig类当中暴露set()方法


Builder模式可以很好的解决上述我们的需求，我们可以将校验逻辑放在调用build()方法之前，也可以将构造函数私有化，这样就只能通过建造者来创建ResourcePoolConfig类对象

# 2. 如何使用建造者模式构建对象


    public class ResourcePoolConfig {
      private String name;
      private int maxTotal;
      private int maxIdle;
      private int minIdle;

      private ResourcePoolConfig(Builder builder) {
        this.name = builder.name;
        this.maxTotal = builder.maxTotal;
        this.maxIdle = builder.maxIdle;
        this.minIdle = builder.minIdle;
      }
      //...省略getter方法...

      //我们将Builder类设计成了ResourcePoolConfig的内部类。
      //我们也可以将Builder类设计成独立的非内部类ResourcePoolConfigBuilder。
      public static class Builder {
        private static final int DEFAULT_MAX_TOTAL = 8;
        private static final int DEFAULT_MAX_IDLE = 8;
        private static final int DEFAULT_MIN_IDLE = 0;

        private String name;
        private int maxTotal = DEFAULT_MAX_TOTAL;
        private int maxIdle = DEFAULT_MAX_IDLE;
        private int minIdle = DEFAULT_MIN_IDLE;

        public ResourcePoolConfig build() {
          // 校验逻辑放到这里来做，包括必填项校验、依赖关系校验、约束条件校验等
          if (StringUtils.isBlank(name)) {
            throw new IllegalArgumentException("...");
          }
          if (maxIdle > maxTotal) {
            throw new IllegalArgumentException("...");
          }
          if (minIdle > maxTotal || minIdle > maxIdle) {
            throw new IllegalArgumentException("...");
          }

          return new ResourcePoolConfig(this);
        }

        public Builder setName(String name) {
          if (StringUtils.isBlank(name)) {
            throw new IllegalArgumentException("...");
          }
          this.name = name;
          return this;
        }

        public Builder setMaxTotal(int maxTotal) {
          if (maxTotal <= 0) {
            throw new IllegalArgumentException("...");
          }
          this.maxTotal = maxTotal;
          return this;
        }

        public Builder setMaxIdle(int maxIdle) {
          if (maxIdle < 0) {
            throw new IllegalArgumentException("...");
          }
          this.maxIdle = maxIdle;
          return this;
        }

        public Builder setMinIdle(int minIdle) {
          if (minIdle < 0) {
            throw new IllegalArgumentException("...");
          }
          this.minIdle = minIdle;
          return this;
        }
      }
    }

    // 这段代码会抛出IllegalArgumentException，因为minIdle>maxIdle
    ResourcePoolConfig config = new ResourcePoolConfig.Builder()
            .setName("dbconnectionpool")
            .setMaxTotal(16)
            .setMaxIdle(10)
            .setMinIdle(12)
            .build();
            
# 3. 何时使用

建造者模式用来创建一种类型的复杂对象，通过设置不同的可选参数，定制化地创建不同的对象。建造者模式和工厂模式的区别可以用一个例子来说明，顾客走进一家餐馆点餐，我们利用工厂模式，根据用户不同的选择，来制作不同的食物，比如披萨、汉堡、沙拉。对于披萨来说，用户又有各种配料可以定制，比如奶酪、西红柿、起司，我们通过建造者模式根据用户选择的不同配料来制作披萨。