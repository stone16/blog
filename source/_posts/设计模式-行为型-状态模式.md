---
title: 设计模式-行为型-状态模式
date: 2020-07-20 22:14:07
categories: SystemDesign
tags: 
    - 状态模式
top:
---
# 1. 原理与实现

状态模式一般用来实现状态机，常常用在游戏，工作流引擎等系统开发当中。

做法是将状态，事件，以及动作都放置到不同的类当中，通过接口与继承，来实现各个方法，其中共享变量可以作为输入传入。 

# 2. 以有限状态机的实现为例

+ 有限状态机
    + Finite State Machine
    + 组成部分
        + 状态
        + 事件/ 转移条件
            + 触发状态的转移
            + 动作的执行
        + 动作

以下面的状态转移图为例： 

![状态转移图](https://i.loli.net/2020/07/21/jzSQHTRxkybDBYE.png)

## 2.1 分支逻辑法实现

会包含大量的if-else语句


    public class MarioStateMachine {
      private int score;
      private State currentState;

      public MarioStateMachine() {
        this.score = 0;
        this.currentState = State.SMALL;
      }

      public void obtainMushRoom() {
        if (currentState.equals(State.SMALL)) {
          this.currentState = State.SUPER;
          this.score += 100;
        }
      }

      public void obtainCape() {
        if (currentState.equals(State.SMALL) || currentState.equals(State.SUPER) ) {
          this.currentState = State.CAPE;
          this.score += 200;
        }
      }

      public void obtainFireFlower() {
        if (currentState.equals(State.SMALL) || currentState.equals(State.SUPER) ) {
          this.currentState = State.FIRE;
          this.score += 300;
        }
      }

      public void meetMonster() {
        if (currentState.equals(State.SUPER)) {
          this.currentState = State.SMALL;
          this.score -= 100;
          return;
        }

        if (currentState.equals(State.CAPE)) {
          this.currentState = State.SMALL;
          this.score -= 200;
          return;
        }

        if (currentState.equals(State.FIRE)) {
          this.currentState = State.SMALL;
          this.score -= 300;
          return;
        }
      }

      public int getScore() {
        return this.score;
      }

      public State getCurrentState() {
        return this.currentState;
      }
    }
    
## 2.2 查表法 

![查表法.png](https://i.loli.net/2020/07/21/127jeqv5CwsIWKP.png)

使用一张二维表来表示状态机，纵向表示当前状态，横向表示事件，值表示当前状态经过事件以后，转移到的新状态和其执行的动作


    public enum Event {
      GOT_MUSHROOM(0),
      GOT_CAPE(1),
      GOT_FIRE(2),
      MET_MONSTER(3);

      private int value;

      private Event(int value) {
        this.value = value;
      }

      public int getValue() {
        return this.value;
      }
    }

    public class MarioStateMachine {
      private int score;
      private State currentState;

      private static final State[][] transitionTable = {
              {SUPER, CAPE, FIRE, SMALL},
              {SUPER, CAPE, FIRE, SMALL},
              {CAPE, CAPE, CAPE, SMALL},
              {FIRE, FIRE, FIRE, SMALL}
      };

      private static final int[][] actionTable = {
              {+100, +200, +300, +0},
              {+0, +200, +300, -100},
              {+0, +0, +0, -200},
              {+0, +0, +0, -300}
      };

      public MarioStateMachine() {
        this.score = 0;
        this.currentState = State.SMALL;
      }

      public void obtainMushRoom() {
        executeEvent(Event.GOT_MUSHROOM);
      }

      public void obtainCape() {
        executeEvent(Event.GOT_CAPE);
      }

      public void obtainFireFlower() {
        executeEvent(Event.GOT_FIRE);
      }

      public void meetMonster() {
        executeEvent(Event.MET_MONSTER);
      }

      private void executeEvent(Event event) {
        int stateValue = currentState.getValue();
        int eventValue = event.getValue();
        this.currentState = transitionTable[stateValue][eventValue];
        this.score = actionTable[stateValue][eventValue];
      }

      public int getScore() {
        return this.score;
      }

      public State getCurrentState() {
        return this.currentState;
      }

    }
    
## 2.3 状态模式

当要执行的动作是比较复杂的一系列逻辑操作的时候，我们就无法使用二维数组来表示了。状态模式是将事件触发的状态转移和动作执行来拆分到不同的状态类当中，来避免分支判断逻辑。


    public interface IMario {
      State getName();
      void obtainMushRoom(MarioStateMachine stateMachine);
      void obtainCape(MarioStateMachine stateMachine);
      void obtainFireFlower(MarioStateMachine stateMachine);
      void meetMonster(MarioStateMachine stateMachine);
    }

    public class SmallMario implements IMario {
      private static final SmallMario instance = new SmallMario();
      private SmallMario() {}
      public static SmallMario getInstance() {
        return instance;
      }

      @Override
      public State getName() {
        return State.SMALL;
      }

      @Override
      public void obtainMushRoom(MarioStateMachine stateMachine) {
        stateMachine.setCurrentState(SuperMario.getInstance());
        stateMachine.setScore(stateMachine.getScore() + 100);
      }

      @Override
      public void obtainCape(MarioStateMachine stateMachine) {
        stateMachine.setCurrentState(CapeMario.getInstance());
        stateMachine.setScore(stateMachine.getScore() + 200);
      }

      @Override
      public void obtainFireFlower(MarioStateMachine stateMachine) {
        stateMachine.setCurrentState(FireMario.getInstance());
        stateMachine.setScore(stateMachine.getScore() + 300);
      }

      @Override
      public void meetMonster(MarioStateMachine stateMachine) {
        // do nothing...
      }
    }

    // 省略SuperMario、CapeMario、FireMario类...

    public class MarioStateMachine {
      private int score;
      private IMario currentState;

      public MarioStateMachine() {
        this.score = 0;
        this.currentState = SmallMario.getInstance();
      }

      public void obtainMushRoom() {
        this.currentState.obtainMushRoom(this);
      }

      public void obtainCape() {
        this.currentState.obtainCape(this);
      }

      public void obtainFireFlower() {
        this.currentState.obtainFireFlower(this);
      }

      public void meetMonster() {
        this.currentState.meetMonster(this);
      }

      public int getScore() {
        return this.score;
      }

      public State getCurrentState() {
        return this.currentState.getName();
      }

      public void setScore(int score) {
        this.score = score;
      }

      public void setCurrentState(IMario currentState) {
        this.currentState = currentState;
      }
    }