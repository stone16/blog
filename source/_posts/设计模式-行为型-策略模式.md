---
title: 设计模式-行为型-策略模式
date: 2020-07-09 22:19:17
categories: SystemDesign
tags:
    - 策略模式
top:
---
策略模式，用于避免冗长的if else或者switch分支判断，并且可以像模板模式那样提供框架的扩展点。

# 1. 原理与实现

+ 策略模式
    + Strategy Design Pattern 
    + Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it. 
    + 对策略的定义，创建和使用进行解耦


## 1.1 策略的定义

+ 策略接口
+ 一组实现了这个接口的策略类


    public interface Strategy {
      void algorithmInterface();
    }

    public class ConcreteStrategyA implements Strategy {
      @Override
      public void  algorithmInterface() {
        //具体的算法...
      }
    }

    public class ConcreteStrategyB implements Strategy {
      @Override
      public void  algorithmInterface() {
        //具体的算法...
      }
    }

## 1.2 策略的创建

+ 策略在使用的时候需要根据类型来判断创建哪个策略来使用
+ 因此，为了封装创建逻辑，需要对客户端代码屏蔽创建细节

    public class StrategyFactory {
      private static final Map<String, Strategy> strategies = new HashMap<>();

      static {
        strategies.put("A", new ConcreteStrategyA());
        strategies.put("B", new ConcreteStrategyB());
      }

      public static Strategy getStrategy(String type) {
        if (type == null || type.isEmpty()) {
          throw new IllegalArgumentException("type should not be empty.");
        }
        return strategies.get(type);
      }
    }
    
这里是需要根据策略是否是有状态的，根据业务场景的需要，来看是否需要返回新创建的对象，或者来复用已经创建好的对象。


    // 返回新创建好的对象的范例
    public class StrategyFactory {
      public static Strategy getStrategy(String type) {
        if (type == null || type.isEmpty()) {
          throw new IllegalArgumentException("type should not be empty.");
        }

        if (type.equals("A")) {
          return new ConcreteStrategyA();
        } else if (type.equals("B")) {
          return new ConcreteStrategyB();
        }

        return null;
      }
    }
## 1.3 策略的使用

使用的时候一般是运行时动态来决定使用哪一种策略。即根据配置，用户的输入，计算结果等因素，来决定 


    // 策略接口：EvictionStrategy
    // 策略类：LruEvictionStrategy、FifoEvictionStrategy、LfuEvictionStrategy...
    // 策略工厂：EvictionStrategyFactory

    public class UserCache {
      private Map<String, User> cacheData = new HashMap<>();
      private EvictionStrategy eviction;

      public UserCache(EvictionStrategy eviction) {
        this.eviction = eviction;
      }

      //...
    }

    // 运行时动态确定，根据配置文件的配置决定使用哪种策略
    public class Application {
      public static void main(String[] args) throws Exception {
        EvictionStrategy evictionStrategy = null;
        Properties props = new Properties();
        props.load(new FileInputStream("./config.properties"));
        String type = props.getProperty("eviction_type");
        evictionStrategy = EvictionStrategyFactory.getEvictionStrategy(type);
        UserCache userCache = new UserCache(evictionStrategy);
        //...
      }
    }

    // 非运行时动态确定，在代码中指定使用哪种策略
    public class Application {
      public static void main(String[] args) {
        //...
        EvictionStrategy evictionStrategy = new LruEvictionStrategy();
        UserCache userCache = new UserCache(evictionStrategy);
        //...
      }
    }

# 2. 实例

## 2.1 策略模式避免分支判断


    public class OrderService {
      public double discount(Order order) {
        double discount = 0.0;
        OrderType type = order.getType();
        if (type.equals(OrderType.NORMAL)) { // 普通订单
          //...省略折扣计算算法代码
        } else if (type.equals(OrderType.GROUPON)) { // 团购订单
          //...省略折扣计算算法代码
        } else if (type.equals(OrderType.PROMOTION)) { // 促销订单
          //...省略折扣计算算法代码
        }
        return discount;
      }
    }


    // 策略的定义
    public interface DiscountStrategy {
      double calDiscount(Order order);
    }
    // 省略NormalDiscountStrategy、GrouponDiscountStrategy、PromotionDiscountStrategy类代码...

    // 策略的创建
    public class DiscountStrategyFactory {
      private static final Map<OrderType, DiscountStrategy> strategies = new HashMap<>();

      static {
        strategies.put(OrderType.NORMAL, new NormalDiscountStrategy());
        strategies.put(OrderType.GROUPON, new GrouponDiscountStrategy());
        strategies.put(OrderType.PROMOTION, new PromotionDiscountStrategy());
      }

      public static DiscountStrategy getDiscountStrategy(OrderType type) {
        return strategies.get(type);
      }
    }

    // 策略的使用
    public class OrderService {
      public double discount(Order order) {
        OrderType type = order.getType();
        DiscountStrategy discountStrategy = DiscountStrategyFactory.getDiscountStrategy(type);
        return discountStrategy.calDiscount(order);
      }
    }
    
## 2.2 根据大小对文件排序

+ 对文件进行排序
    + 整型数
    + 逗号间隔

+ 100GB大小的话
    + 利用外部排序算法  -- MapReduce框架



    public class SortAlgFactory {
      private static final Map<String, ISortAlg> algs = new HashMap<>();

      static {
        algs.put("QuickSort", new QuickSort());
        algs.put("ExternalSort", new ExternalSort());
        algs.put("ConcurrentExternalSort", new ConcurrentExternalSort());
        algs.put("MapReduceSort", new MapReduceSort());
      }

      public static ISortAlg getSortAlg(String type) {
        if (type == null || type.isEmpty()) {
          throw new IllegalArgumentException("type should not be empty.");
        }
        return algs.get(type);
      }
    }

    public class Sorter {
      private static final long GB = 1000 * 1000 * 1000;

      public void sortFile(String filePath) {
        // 省略校验逻辑
        File file = new File(filePath);
        long fileSize = file.length();
        ISortAlg sortAlg;
        if (fileSize < 6 * GB) { // [0, 6GB)
          sortAlg = SortAlgFactory.getSortAlg("QuickSort");
        } else if (fileSize < 10 * GB) { // [6GB, 10GB)
          sortAlg = SortAlgFactory.getSortAlg("ExternalSort");
        } else if (fileSize < 100 * GB) { // [10GB, 100GB)
          sortAlg = SortAlgFactory.getSortAlg("ConcurrentExternalSort");
        } else { // [100GB, ~)
          sortAlg = SortAlgFactory.getSortAlg("MapReduceSort");
        }
        sortAlg.sort(filePath);
      }
    }