---
title: 设计模式-行为型-迭代器模式
date: 2020-07-23 23:30:04
categories: SystenDesign
tags:
    - 迭代器模式
top:
---

# 1. 迭代器模式的原理和实现

+ 迭代器模式
    + Iterator Design Pattern / Cursor Design Patten 
    + 用来遍历集合对象
    + 编程语言基本上都将迭代器作为一个基础类库来提供了
    + 集合对象指的是一个容器，而迭代器需要迭代的对象实际上是一组对象的对象
    + 迭代器模式将集合对象的遍历操作从集合类当中拆分出来，放到迭代器类当中，使得二者的职责更加单一


+ 涉及部分
    + 容器
        + 接口
        + 实现类
    + 容器迭代器
        + 接口
        + 实现类


## 1.1 实现一个线性结构容器的迭代器


    // 接口定义方式一
    public interface Iterator<E> {
      boolean hasNext();
      void next();
      E currentItem();
    }

    // 接口定义方式二
    public interface Iterator<E> {
      boolean hasNext();
      E next();
    }
    
+ 定义方式一的好处在可以多次获得当前的对象，会更加灵活



    public class ArrayIterator<E> implements Iterator<E> {
      private int cursor;
      private ArrayList<E> arrayList;

      public ArrayIterator(ArrayList<E> arrayList) {
        this.cursor = 0;
        this.arrayList = arrayList;
      }

      @Override
      public boolean hasNext() {
        return cursor != arrayList.size(); //注意这里，cursor在指向最后一个元素的时候，hasNext()仍旧返回true。
      }

      @Override
      public void next() {
        cursor++;
      }

      @Override
      public E currentItem() {
        if (cursor >= arrayList.size()) {
          throw new NoSuchElementException();
        }
        return arrayList.get(cursor);
      }
    }

    public class Demo {
      public static void main(String[] args) {
        ArrayList<String> names = new ArrayList<>();
        names.add("xzg");
        names.add("wang");
        names.add("zheng");

        Iterator<String> iterator = new ArrayIterator(names);
        while (iterator.hasNext()) {
          System.out.println(iterator.currentItem());
          iterator.next();
        }
      }
    }

+ 这里一个问题是还需要`new ArrayIterator()`，我们可以通过在List的接口当中定义迭代器，然后再ArrayList的类当中定义一个iterator()方法。然后在使用的时候，我们就可以通过实例化以后的容器，比如ArrayList，直接来调用iterator()方法了


    public interface List<E> {
      Iterator iterator();
      //...省略其他接口函数...
    }

    public class ArrayList<E> implements List<E> {
      //...
      public Iterator iterator() {
        return new ArrayIterator(this);
      }
      //...省略其他代码
    }

    public class Demo {
      public static void main(String[] args) {
        List<String> names = new ArrayList<>();
        names.add("xzg");
        names.add("wang");
        names.add("zheng");

        Iterator<String> iterator = names.iterator();
        while (iterator.hasNext()) {
          System.out.println(iterator.currentItem());
          iterator.next();
        }
      }
    }
    
+ 实现方式/ 设计思路
    + 迭代器当中实现
        + hasNext()
        + currentItem()
        + next()

    + 待遍历的容器
        + 通过依赖注入传递到迭代器当中
        + 容器通过iterator()方法来创建迭代器


## 1.2 为什么需要迭代器模式来遍历集合？

1. 复杂数据结构遍历方式也会非常复杂，比如对于树，对于图来说。我们将遍历的方式定义到迭代器当中，这样就避免了要自己实现这样复杂的操作了。
2. 通过迭代器模式，可以同时创建多个不同的迭代器，对同一个容器进行遍历而不互相影响
3. 容器和迭代器都提供了抽象的接口，当我们需要改变遍历算法的时候，对代码的影响会很小，只在依赖注入处使用新的迭代器类所提供的算法即可
