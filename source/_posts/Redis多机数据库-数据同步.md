---
title: Redis多机数据库-数据同步
date: 2021-07-04 20:00:14
categories: 数据存储
tags:
top:
---
# Redis多机数据库-数据同步

# 1. Redis的高可靠性

Redis的高可靠性体现在两个方面：

- 数据尽量少丢失
    - AOF
    - RDB
- 服务尽量少中断
    - 增加副本冗余量 — 将一份数据同时保存在多个实例上

# 2. 数据同步 — 主从库模式

- 主从库之间采用的是读写分离的方式
    - 读操作
        - 主库，从库都可以接收
    - 写操作
        - 首先到主库执行
        - 然后主库将写操作同步给从库

            ![https://i.loli.net/2021/01/04/8wE4dPDgFxqRX6r.png](https://i.loli.net/2021/01/04/8wE4dPDgFxqRX6r.png)

            主从读写分离

- 主从库的好处是修改操作都只会在一个库实现
    - 可以减少加锁，实例间协商这类开销

## 2.1 主从库之间如何进行第一个同步？

- 多个Redis实例之间通过replicaof/ slaveof命令形成主库和从库的关系，然后按照三个阶段完成数据的第一次同步：

    ![https://i.loli.net/2021/01/04/KZemoVB6CFjNlJI.png](https://i.loli.net/2021/01/04/KZemoVB6CFjNlJI.png)

    主从首次同步过程

- 第一阶段
    - 主从库之间建立连接，协商同步
    - 为全量复制做准备
    - 从库和主库建立起连接，并告诉主库即将进行同步，主库确认回复以后，主从库间就可以开始同步了
        - 从库给主库发送psync命令，表示要进行数据同步
        - 主库根据这个命令的参数来启动复制
            - psync命令包含主库的runId和复制进度的offset两个参数
                - runID — Redis实例启动的时候自动随机生成的ID，用来唯一标识当前实例
                    - runId很关键，比如从服务器断线重连主服务器以后，会发送之前保存的主服务器的运行ID，如果ID一致，说明前后连接的是同一个主服务器，那么就可以继续尝试执行部分的重同步操作
                    - 相反，如果运行ID不同，那么就必须通过RDB完成整个重同步操作
                - offset 此时设为-1，表示第一次复制
        - 主库收到psync命令后，使用FULLRESYNC响应命令，包括了主库的runID还有主库目前的复制进度offset，返回给从库
            - 从库记录下两个参数
        - FULLRESYNC表示第一次复制使用的是全量复制
        - 主库与此同时执行BGSAVE命令，在后台生成一个RDB文件，并使用一个缓冲区记录从现在开始执行的所有写命令

            ![主从服务器同步过程](https://i.loli.net/2021/07/05/Kmw8ZsWuzGki25V.png)

- 第二阶段
    - 主库将所有数据同步给从库
    - 从库收到数据后，在本地完成数据加载 — 依赖于内存快照生成的RDB文件
        - 主库执行 bgsave 命令，生成 RDB 文件，接着将文件发给从库。
        - 从库接收到 RDB 文件后，会先**清空当前数据库**，然后加载 RDB 文件。
            - 这是因为从库在通过 replicaof 命令开始和主库同步前，可能保存了其他数据。为了避免之前数据的影响，从库需要先把当前数据库清空
    - 在做数据同步的过程中，主库不会被阻塞。对于这个过程中接收到的正常请求，写操作会记录在主库的**Replication Buffer**当中
- 第三阶段
    - 主库会将第二阶段新收到的修改命令，再发给从库
    - 当主库完成 RDB 文件发送后，就会把此时 replication buffer 中的修改操作发给从库，从库再重新执行这些操作。这样一来，主从库就实现同步了

## 2.2 主从级联方式分担全量复制时的主库压力

- 现状/ 问题
    - 一次全量复制主库需要完成两个耗时操作
        - 生成RDB文件和传输RDB文件
    - 如果从库数量很多，而且都要和主库进行全量复制的话，就会导致主库忙于 fork 子进程生成 RDB 文件，进行数据全量同步。fork 这个操作会阻塞主线程处理正常请求，从而导致主库响应应用程序的请求速度变慢。
    - 传输 RDB 文件也会占用主库的网络带宽，同样会给主库的资源使用带来压力
- 解决方案 — 主从从模式
    - 我们在部署主从集群的时候，可以手动选择一个从库（比如选择内存资源配置较高的从库），用于级联其他的从库。然后，我们可以再选择一些从库（例如三分之一的从库），在这些从库上执行如下命令，让它们和刚才所选的从库，建立起主从关系。replicaof 所选从库的IP 6379

    ![https://i.loli.net/2021/01/04/eihQpmN6FJdRxLy.png](https://i.loli.net/2021/01/04/eihQpmN6FJdRxLy.png)

## 2.3 突发情况下(暂时断网)的增量复制

- 旧版redis在断开重连以后从服务器会向主服务器发出SYNC命令，从头开始进行bootstrap，时间会非常长，非常低效
- 新版本使用PSYNC
    - PSYNC具有full resynchronization, partial resynchronization两种模式
    - partial resync使得断线重连以后可以通过增量来做复制，而不是用RDB重头开始
- 网络断了以后我们需要一种开销相对合理的复制方式，即增量复制
    - 将主从库断联期间主库收到的命令，同步给从库
- 增量复制的时候，主从库之间依靠repl_backlog_buffer这个缓冲区来做同步
- 整个过程如下：
    - 当主从库断连后，主库会把断连期间收到的写操作命令，写入 **replication buffer**，同时也会把这些操作命令也写入 **repl_backlog_buffer** 这个缓冲区。
    - repl_backlog_buffer 是一个**环形缓冲区**，主库会记录自己写到的位置，从库则会记录自己已经读到的位置。
    - 刚开始的时候，主库和从库的写读位置在一起，这算是它们的起始位置。随着主库不断接收新的写操作，它在缓冲区中的写位置会逐步偏离起始位置，我们通常用偏移量来衡量这个偏移距离的大小，对主库来说，对应的偏移量就是 master_repl_offset。主库接收的新写操作越多，这个值就会越大。
    - 同样，从库在复制完写操作命令后，它在缓冲区中的读位置也开始逐步偏移刚才的起始位置，此时，从库已复制的偏移量 slave_repl_offset 也在不断增加。正常情况下，这两个偏移量基本相等。
    - 主从库的连接恢复之后，从库首先会给主库发送 psync 命令，并把自己当前的 slave_repl_offset 发给主库，主库会判断自己的 master_repl_offset 和 slave_repl_offset 之间的差距
    - 在网络断连阶段，主库可能会收到新的写操作命令，所以，一般来说，master_repl_offset 会大于 slave_repl_offset。此时，主库只用把 master_repl_offset 和 slave_repl_offset 之间的命令操作同步给从库就行。就像刚刚示意图的中间部分，主库和从库之间相差了 put d e 和 put d f 两个操作，在增量复制时，主库只需要把它们同步给从库，就行了。

    ![https://i.loli.net/2021/01/04/w3TLhzRgOH2A65d.png](https://i.loli.net/2021/01/04/w3TLhzRgOH2A65d.png)

> 因为 repl_backlog_buffer 是一个环形缓冲区，所以在缓冲区写满后，主库会继续写入，此时，就会覆盖掉之前写入的操作。如果从库的读取速度比较慢，就有可能导致从库还未读取的操作被主库新写的操作覆盖了，这会导致主从库间的数据不一致。

我们要想办法避免这一情况，一般而言，我们可以调整 repl_backlog_size 这个参数。这个参数和所需的缓冲空间大小有关。缓冲空间的计算公式是：**缓冲空间大小 = 主库写入命令速度 * 操作大小 - 主从库间网络传输命令速度 * 操作大小**。在实际应用中，考虑到可能存在一些突发的请求压力，我们通常需要把这个缓冲空间扩大一倍，即 repl_backlog_size = 缓冲空间大小 * 2，这也就是 repl_backlog_size 的最终值

- repl_backlog_buffer
    - 是为了从库断开之后，如何找到主从差异数据而设计的环形缓冲区，从而避免全量同步带来的性能开销
    - 如果从库断开时间太久，repl_backlog_buffer环形缓冲区被主库的写命令覆盖了，那么从库连上主库后只能乖乖地进行一次全量同步，所以repl_backlog_buffer配置尽量大一些，可以降低主从断开后全量同步的概率
    - 而在repl_backlog_buffer中找主从差异的数据后，如何发给从库呢？这就用到了replication buffer
- replication_buffer
    - Redis和客户端通信也好，和从库通信也好，Redis都需要给分配一个 内存buffer进行数据交互
    - 客户端是一个client，从库也是一个client，我们每个client连上Redis后，Redis都会分配一个client buffer，所有数据交互都是通过这个buffer进行的
    - Redis先把数据写到这个buffer中，然后再把buffer中的数据发到client socket中再通过网络发送出去，这样就完成了数据交互。
    - 所以主从在增量同步时，从库作为一个client，也会分配一个buffer，只不过这个buffer专门用来传播用户的写命令到从库，保证主从数据一致，我们通常把它叫做replication buffer
    - 这个buffer需要做大小的限制
        - 如果主从在传播命令时，因为某些原因从库处理得非常慢，那么主库上的这个buffer就会持续增长，消耗大量的内存资源，甚至OOM
        - 所以Redis提供了**client-output-buffer-limit**参数限制这个buffer的大小，如果超过限制，主库会强制断开这个client的连接，也就是说从库处理慢导致主库内存buffer的积压达到限制后，主库会强制断开从库的连接，此时主从复制会中断，中断后如果从库再次发起复制请求，那么此时可能会导致恶性循环，引发复制风暴，这种情况需要格外注意。

## 2.4 主从全量同步 RDB vs AOF

1、RDB文件内容是**经过压缩的二进制数据（不同数据类型数据做了针对性优化）**，文件很小。而AOF文件记录的是每一次写操作的命令，写操作越多文件会变得很大，其中还包括很多对同一个key的多次冗余操作。在主从全量数据同步时，传输RDB文件可以尽量降低对主库机器网络带宽的消耗，从库在加载RDB文件时，一是文件小，读取整个文件的速度会很快，二是因为**RDB文件存储的都是二进制数据，从库直接按照RDB协议解析还原数据即可**，速度会非常快，而AOF需要依次重放每个写命令，这个过程会经历冗长的处理逻辑，恢复速度相比RDB会慢得多，所以使用RDB进行主从全量同步的成本最低。

2、假设要使用AOF做全量同步，意味着必须打开AOF功能，打开AOF就要选择文件刷盘的策略，选择不当会严重影响Redis性能。而RDB只有在需要定时备份和主从全量同步数据时才会触发生成一次快照。而在很多丢失数据不敏感的业务场景，其实是不需要开启AOF的。

# 3. 复制过程的具体实现

- 设置主服务器的地址和端口
- 建立套接字连接
    - 从服务器根据命令所设置的IP和端口，创建连向主服务器的套接字连接
    - 如果连接成功，会为这个套接字关联一个专门用于处理复制工作的文件事件处理器
    - 从服务器这个时候相当于主服务器的客户端
- 建立完成以后，从PING主
    - 检查套接字读写正常
    - 检查主服务器能否正常处理命令请求
- 身份验证
    - masterauth
- 验证成功以后从服务器执行命令  `REPLCONF listerning-port <port-numer>` 向主服务器发送从服务器的监听端口号
- 主服务器接收到以后，会将端口号记录在从服务器所对应的客户端状态的属性当中 `slave_listening_port`
- 同步
    - 从向主发PSYNC命令，执行同步操作
- 命令传播

# Reference

1. 极客时间
2. redis设计与实现