---
title: 设计模式-行为型-模板模式
date: 2020-07-05 10:54:08
categories: SystemDesign
tags:
    - 模板模式
top:
---
# 1. 原理与实现

+ 模板方法设计模式
    + Template Method Design Pattern 
    + Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template method lets subclasses redefine certain steps of an algorithm without changing the algorithm's structure 
    + 在一个方法中定义一个算法股价，并将某些步骤推迟到子类当中进行实现，模板方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些不好走。


实现的基本方式就是设置一个抽象类，对于不想被子类重写的方法可以加上final关键字，其余的可以设置为抽象方法，让子类来实现。

    public abstract class AbstractClass {
      public final void templateMethod() {
        //...
        method1();
        //...
        method2();
        //...
      }

      protected abstract void method1();
      protected abstract void method2();
    }

    public class ConcreteClass1 extends AbstractClass {
      @Override
      protected void method1() {
        //...
      }

      @Override
      protected void method2() {
        //...
      }
    }

    public class ConcreteClass2 extends AbstractClass {
      @Override
      protected void method1() {
        //...
      }

      @Override
      protected void method2() {
        //...
      }
    }

    AbstractClass demo = ConcreteClass1();
    demo.templateMethod();
    
    
# 2. 功能实现的例子

## 2.1 以复用为目的

1. InputStream 类的实现

    public abstract class InputStream implements Closeable {
      //...省略其他代码...

      public int read(byte b[], int off, int len) throws IOException {
        if (b == null) {
          throw new NullPointerException();
        } else if (off < 0 || len < 0 || len > b.length - off) {
          throw new IndexOutOfBoundsException();
        } else if (len == 0) {
          return 0;
        }

        int c = read();
        if (c == -1) {
          return -1;
        }
        b[off] = (byte)c;

        int i = 1;
        try {
          for (; i < len ; i++) {
            c = read();
            if (c == -1) {
              break;
            }
            b[off + i] = (byte)c;
          }
        } catch (IOException ee) {
        }
        return i;
      }

      // 在这里定义了一个可以供子类实现的抽象方法
      public abstract int read() throws IOException;
    }

    public class ByteArrayInputStream extends InputStream {
      //...省略其他代码...

      @Override
      public synchronized int read() {
        return (pos < count) ? (buf[pos++] & 0xff) : -1;
      }
    }
    
    
2. AbstractList的实现


    public boolean addAll(int index, Collection<? extends E> c) {
        rangeCheckForAdd(index);
        boolean modified = false;
        for (E e : c) {
            add(index++, e);
            modified = true;
        }
        return modified;
    }

    public void add(int index, E element) {
        throw new UnsupportedOperationException();
    }

## 2.2 以扩展为目的

1. Java Servlet

抛开框架直接使用Servlet做开发的话，Servlet在接收到请求之后，会根据URL和Servlet的映射关系，找到对应的Servlet，然后来执行它的service()方法。service方法定义在父类HttpServelet当中，会调用doGet()还有doPost()方法。

为了实现上述的整个流程，我们需要继承HttpServlet，重新实现我们自己的doGet()以及doPost()方法。


    public class HelloServlet extends HttpServlet {
      @Override
      protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        this.doPost(req, resp);
      }

      @Override
      protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        resp.getWriter().write("Hello World.");
      }
    }

    // 存储映射关系的xml，也可以使用annotation来实现映射
    <servlet>
        <servlet-name>HelloServlet</servlet-name>
        <servlet-class>com.xzg.cd.HelloServlet</servlet-class>
    </servlet>

    <servlet-mapping>
        <servlet-name>HelloServlet</servlet-name>
        <url-pattern>/hello</url-pattern>
    </servlet-mapping>


    public void service(ServletRequest req, ServletResponse res)
        throws ServletException, IOException
    {
        HttpServletRequest  request;
        HttpServletResponse response;
        if (!(req instanceof HttpServletRequest &&
                res instanceof HttpServletResponse)) {
            throw new ServletException("non-HTTP request or response");
        }
        request = (HttpServletRequest) req;
        response = (HttpServletResponse) res;
        service(request, response);
    }

    protected void service(HttpServletRequest req, HttpServletResponse resp)
        throws ServletException, IOException
    {
        String method = req.getMethod();
        if (method.equals(METHOD_GET)) {
            long lastModified = getLastModified(req);
            if (lastModified == -1) {
                // servlet doesn't support if-modified-since, no reason
                // to go through further expensive logic
                doGet(req, resp);
            } else {
                long ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE);
                if (ifModifiedSince < lastModified) {
                    // If the servlet mod time is later, call doGet()
                    // Round down to the nearest second for a proper compare
                    // A ifModifiedSince of -1 will always be less
                    maybeSetLastModified(resp, lastModified);
                    doGet(req, resp);
                } else {
                    resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);
                }
            }
        } else if (method.equals(METHOD_HEAD)) {
            long lastModified = getLastModified(req);
            maybeSetLastModified(resp, lastModified);
            doHead(req, resp);
        } else if (method.equals(METHOD_POST)) {
            doPost(req, resp);
        } else if (method.equals(METHOD_PUT)) {
            doPut(req, resp);
        } else if (method.equals(METHOD_DELETE)) {
            doDelete(req, resp);
        } else if (method.equals(METHOD_OPTIONS)) {
            doOptions(req,resp);
        } else if (method.equals(METHOD_TRACE)) {
            doTrace(req,resp);
        } else {
            String errMsg = lStrings.getString("http.method_not_implemented");
            Object[] errArgs = new Object[1];
            errArgs[0] = method;
            errMsg = MessageFormat.format(errMsg, errArgs);
            resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);
        }
    }
    
2. JUnit TestCase


Junit定义的功能扩展点为：
+ setUp() 
+ tearDown()
+ etc.

写的测试类都是继承框架提供的testCase类，在这个类当中，runBare()函数是模板方法，定义了执行测试用例的整体流程:先执行setUp()做准备工作，然后执行runTest()运行真正的测试代码，最后执行tearDown()做扫尾工作。



    public abstract class TestCase extends Assert implements Test {
      public void runBare() throws Throwable {
        Throwable exception = null;
        setUp();
        try {
          runTest();
        } catch (Throwable running) {
          exception = running;
        } finally {
          try {
            tearDown();
          } catch (Throwable tearingDown) {
            if (exception == null) exception = tearingDown;
          }
        }
        if (exception != null) throw exception;
      }

      /**
      * Sets up the fixture, for example, open a network connection.
      * This method is called before a test is executed.
      */
      protected void setUp() throws Exception {
      }

      /**
      * Tears down the fixture, for example, close a network connection.
      * This method is called after a test is executed.
      */
      protected void tearDown() throws Exception {
      }
    }
