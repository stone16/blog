---
title: 设计模式-结构型-桥接模式
date: 2020-06-21 14:54:45
categories: SystemDesign
tags:
    - 桥接模式
top:
---
# 1. 原理解析

+ 桥接模式 Bridge Design Pattern
    + 将抽象和实现解耦，使之可以独立变化
    + 一个类存在两个或者多个独立变化的维度，通过组合的方式，让这几个维度都可以独立进行扩展
        + 通过组合关系来替代继承关系，避免继承层次的指数级爆炸


## 1.1 JDBC驱动的实现


```
    Class.forName("com.mysql.jdbc.Driver");//加载及注册JDBC驱动程序
    String url = "jdbc:mysql://localhost:3306/sample_db?user=root&password=your_password";
    Connection con = DriverManager.getConnection(url);
    Statement stmt = con.createStatement()；
    String query = "select * from test";
    ResultSet rs=stmt.executeQuery(query);
    while(rs.next()) {
      rs.getString(1);
      rs.getInt(2);
    }
    
```

+ 上述代码中只要改变forName中的路径，就可以改变数据库了
+ 或者我们可以通过将加载的Driver类写到配置文件当中，来实现数据库的切换，只需要修改配置文件就可以完成数据库的切换了



    package com.mysql.jdbc;
    import java.sql.SQLException;

    public class Driver extends NonRegisteringDriver implements java.sql.Driver {
      static {
        try {
          java.sql.DriverManager.registerDriver(new Driver());
        } catch (SQLException E) {
          throw new RuntimeException("Can't register driver!");
        }
      }

      /**
       * Construct a new driver and register it with DriverManager
       * @throws SQLException if a database error occurs.
       */
      public Driver() throws SQLException {
        // Required for Class.forName().newInstance()
      }
    }
    
+ 在执行`Class.forName`的时候，首先是使得JVM查找并加载指定的Driver类，
+ 其次是执行该类的静态代码
    + 实例变量需要在类实例化以后才能存在
    + 静态变量是该类素有对象公有的，不需要实例化就已经存在了
    + 静态代码会在类被加载的时候自动执行



    public class DriverManager {
      private final static CopyOnWriteArrayList<DriverInfo> registeredDrivers = new CopyOnWriteArrayList<DriverInfo>();

      //...
      static {
        loadInitialDrivers();
        println("JDBC DriverManager initialized");
      }
      //...

      public static synchronized void registerDriver(java.sql.Driver driver) throws SQLException {
        if (driver != null) {
          registeredDrivers.addIfAbsent(new DriverInfo(driver));
        } else {
          throw new NullPointerException();
        }
      }

      public static Connection getConnection(String url, String user, String password) throws SQLException {
        java.util.Properties info = new java.util.Properties();
        if (user != null) {
          info.put("user", user);
        }
        if (password != null) {
          info.put("password", password);
        }
        return (getConnection(url, info, Reflection.getCallerClass()));
      }
      //...
    }


+ JDBC本身相当于抽象，即和具体的数据库无关的被抽象出来的一套类库
+ 具体的Driver相当于实现

## 1.2 实例

设计一个根据不同的告警规则，触发不同的类型的告警。

+ 紧急程度
    + SEVERE
    + URGENCY
    + NORMAL
    + TRIVIAL

+ 通知渠道
    + 邮件
    + 短信
    + 微信
    + 自动语音通话

+ 下述代码实质上就是在实现一个解耦，希望避免复杂的if else逻辑，让代码更易懂，修改更方便。


    public interface MsgSender {
      void send(String message);
    }

    public class TelephoneMsgSender implements MsgSender {
      private List<String> telephones;

      public TelephoneMsgSender(List<String> telephones) {
        this.telephones = telephones;
      }

      @Override
      public void send(String message) {
        //...
      }

    }

    public class EmailMsgSender implements MsgSender {
      // 与TelephoneMsgSender代码结构类似，所以省略...
    }

    public class WechatMsgSender implements MsgSender {
      // 与TelephoneMsgSender代码结构类似，所以省略...
    }

    public abstract class Notification {
      protected MsgSender msgSender;

      public Notification(MsgSender msgSender) {
        this.msgSender = msgSender;
      }

      public abstract void notify(String message);
    }

    public class SevereNotification extends Notification {
      public SevereNotification(MsgSender msgSender) {
        super(msgSender);
      }

      @Override
      public void notify(String message) {
        msgSender.send(message);
      }
    }

    public class UrgencyNotification extends Notification {
      // 与SevereNotification代码结构类似，所以省略...
    }
    public class NormalNotification extends Notification {
      // 与SevereNotification代码结构类似，所以省略...
    }
    public class TrivialNotification extends Notification {
      // 与SevereNotification代码结构类似，所以省略...
    }
    