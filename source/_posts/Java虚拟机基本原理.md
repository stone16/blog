---
title: Java虚拟机基本原理
date: 2021-06-22 21:21:43
categories: BackEnd
tags: 
    - Java
    - JVM
top:
---
# Java虚拟机基本原理

# 1. Java 代码运行方式

## 1.1 为什么需要虚拟机

- 设计一个面向Java语言特性的虚拟机
    - 做这个的原因是为了能够在各种机器上来实现对Java的支持
    - 通过编译器将Java程序转换成该虚拟机所能识别的指令序列，又被称为Java字节码
        - 叫做Java字节码的原因是字节码指令的操作码opcode被定义成了一个字节
- Java的虚拟机是可以由硬件实现的，也可以在各个平台上(Windows/ Linux) 提供软件的实现
    - 好处1： 一旦一个程序被转换成了Java字节码，那么便可以在不同平台上的虚拟机里来运行
    - 好处2： 带来了托管环境，这个托管环境能够代替我们处理一些代码当中冗长而且容易出错的部分
        - 自动内存管理
        - 垃圾回收
        - 诸如数组越界，动态类型，安全权限等等的动态检测功能

## 1.2 如何运行Java字节码的？

- 从虚拟机视角来看
    - 首先将其编译成的class文件加载到Java虚拟机当中
    - 加载后的Java类会被存放于方法区里 Method Area
    - 实际执行的时候，执行方法区的代码
    - 空间分配
        - 线程共享的
            - 方法区
            - 堆
        - 线程私有
            - PC寄存器
            - Java方法栈
                - 当调用一个Java方法的时候，会在当前线程生成一个栈帧，用来存放局部变量以及字节码的操作数
                - 栈帧大小是已经计算好了的，栈帧不需要连续分布
            - 本地方法栈
- 从硬件视角来看
    - 需要虚拟机将字节码翻译成机器码
    - 翻译方式
        - 解释执行
            - 逐条将字节码翻译成机器码并且执行
            - 优势
                - 无需等待编译
        - 即时编译 Just In Time Compilation
            - 将一个方法中包含的所有字节码编译成机器码以后再执行
            - 优势
                - 实际执行速度会更快
    - hotpot的翻译方式
        - 先解释执行字节码
        - 而后将反复执行的热点代码按照方法来作为基本单元进行JIT 即时编译

## 1.3 Java虚拟机执行效率

- 优化方式
    - 即时编译
        - 底层逻辑 — 二八定律
            - 认为20%代码会占据80%的计算资源
        - 编译器类别 — tradeoff 编译时间 vs 执行效率
            - C1
                - Client编译器
                - 面向对启动性能有要求的客户端GUI程序
            - C2
                - Server编译器
                - 面向对峰值性能有要求的服务器端程序
                - 采用的优化手段相对复杂，因此编译时间较长，但同时生成代码的效率比较高
            - Graal
- Hotpot对于各种编译器的采用方式
    - 分层编译
        - 热点方法先被C1 编译
        - 热点方法里的热点会进一步被C2 编译器编译
    - 会影响应用的正常进行么？
        - 即时编译是在额外的编译线程当中进行的
        - 会根据CPU的数量设置编译线程的数目，并且按照1:2的比例配置给C1 及C2 编译器

# 2. 基本类型在虚拟机当中的实现

- 为什么要引入基本类型而不是全都使用对象呢？
    - 基本类型更靠近底层，在执行效率和内存使用方面都能够提升软件的性能
- boolean 类型
    - 映射成int类型
        - true被映射为整数1
        - false被映射为整数0

![Java基本类型](https://i.loli.net/2021/06/24/6o39J4QcZEHOA8d.png)

- Java虚拟机在调用Java方法的时候，会创建出一个栈帧，对于其中的解释栈帧来说，有两个主要组成部分
    - 局部变量区
        - 局部变量
        - this指针
        - 方法接收的参数
        - 各个基本类型在局部变量区的表现
            - 局部变量区等价于一个数组
                - long double需要两个数组单元存储
                - 其他基本类型和引用类型的值均占用一个数组单元
    - 字节码的操作数栈
- 存储操作
    - 如果我们将一个int类型的值放到char short 等里面，相当于做了一次掩码  只会保留低位了
- 加载
    - 算数运算完全依赖于操作数栈
    - 堆当中的boolean, byte, char, short 加载到操作数栈当中，而后将栈上的值当成int类型来运算

# 3. 类的加载