---
title: Java虚拟机基本原理
date: 2021-06-22 21:21:43
categories: BackEnd
tags: 
    - Java
    - JVM
top:
---
# Java虚拟机基本原理

# 1. Java 代码运行方式

## 1.1 为什么需要虚拟机

- 设计一个面向Java语言特性的虚拟机
    - 做这个的原因是为了能够在各种机器上来实现对Java的支持
    - 通过编译器将Java程序转换成该虚拟机所能识别的指令序列，又被称为Java字节码
        - 叫做Java字节码的原因是字节码指令的操作码opcode被定义成了一个字节
- Java的虚拟机是可以由硬件实现的，也可以在各个平台上(Windows/ Linux) 提供软件的实现
    - 好处1： 一旦一个程序被转换成了Java字节码，那么便可以在不同平台上的虚拟机里来运行
    - 好处2： 带来了托管环境，这个托管环境能够代替我们处理一些代码当中冗长而且容易出错的部分
        - 自动内存管理
        - 垃圾回收
        - 诸如数组越界，动态类型，安全权限等等的动态检测功能

## 1.2 如何运行Java字节码的？

- 从虚拟机视角来看
    - 首先将其编译成的class文件加载到Java虚拟机当中
    - 加载后的Java类会被存放于方法区里 Method Area
    - 实际执行的时候，执行方法区的代码
    - 空间分配
        - 线程共享的
            - 方法区
            - 堆
        - 线程私有
            - PC寄存器
            - Java方法栈
                - 当调用一个Java方法的时候，会在当前线程生成一个栈帧，用来存放局部变量以及字节码的操作数
                - 栈帧大小是已经计算好了的，栈帧不需要连续分布
            - 本地方法栈
- 从硬件视角来看
    - 需要虚拟机将字节码翻译成机器码
    - 翻译方式
        - 解释执行
            - 逐条将字节码翻译成机器码并且执行
            - 优势
                - 无需等待编译
        - 即时编译 Just In Time Compilation
            - 将一个方法中包含的所有字节码编译成机器码以后再执行
            - 优势
                - 实际执行速度会更快
    - hotpot的翻译方式
        - 先解释执行字节码
        - 而后将反复执行的热点代码按照方法来作为基本单元进行JIT 即时编译

## 1.3 Java虚拟机执行效率

- 优化方式
    - 即时编译
        - 底层逻辑 — 二八定律
            - 认为20%代码会占据80%的计算资源
        - 编译器类别 — tradeoff 编译时间 vs 执行效率
            - C1
                - Client编译器
                - 面向对启动性能有要求的客户端GUI程序
            - C2
                - Server编译器
                - 面向对峰值性能有要求的服务器端程序
                - 采用的优化手段相对复杂，因此编译时间较长，但同时生成代码的效率比较高
            - Graal
- Hotpot对于各种编译器的采用方式
    - 分层编译
        - 热点方法先被C1 编译
        - 热点方法里的热点会进一步被C2 编译器编译
    - 会影响应用的正常进行么？
        - 即时编译是在额外的编译线程当中进行的
        - 会根据CPU的数量设置编译线程的数目，并且按照1:2的比例配置给C1 及C2 编译器

# 2. 基本类型在虚拟机当中的实现

- 为什么要引入基本类型而不是全都使用对象呢？
    - 基本类型更靠近底层，在执行效率和内存使用方面都能够提升软件的性能
- boolean 类型
    - 映射成int类型
        - true被映射为整数1
        - false被映射为整数0

![Java基本类型](https://i.loli.net/2021/06/24/6o39J4QcZEHOA8d.png)

- Java虚拟机在调用Java方法的时候，会创建出一个栈帧，对于其中的解释栈帧来说，有两个主要组成部分
    - 局部变量区
        - 局部变量
        - this指针
        - 方法接收的参数
        - 各个基本类型在局部变量区的表现
            - 局部变量区等价于一个数组
                - long double需要两个数组单元存储
                - 其他基本类型和引用类型的值均占用一个数组单元
    - 字节码的操作数栈
- 存储操作
    - 如果我们将一个int类型的值放到char short 等里面，相当于做了一次掩码  只会保留低位了
- 加载
    - 算数运算完全依赖于操作数栈
    - 堆当中的boolean, byte, char, short 加载到操作数栈当中，而后将栈上的值当成int类型来运算

# 3. 类的加载，链接，初始化过程

- 从class文件到内存当中的类，需要经过：
    - 加载
        - 查找字节流，并且根据此来创建类的过程
        - 借助类加载器来完成查找字节流的过程
            - 启动类加载器 — bootstrap class loader
                - 负责加载最基础最重要的类，譬如JRE lib目录下Jar包中的类
                - 由虚拟机参数 -Xbootclasspath指定的类
            - 其他类加载器 — 都是java.lang.ClassLoader的子类
                - 需要先由启动类加载器，将其加载至Java虚拟机当中，方能执行类的加载
                - E.G
                    - 扩展类加载器 — 父类是启动类加载器
                        - 负责加载相对次要、但又通用的类，比如存放在 JRE 的 lib/ext 目录下 jar 包中的类（以及由系统变量 java.ext.dirs 指定的类）
                    - 应用类加载器 — 父类是扩展类加载器
                        - 负责加载应用程序路径下的类
                            - 例如虚拟机参数 -cp/-classpath, 系统变量java.class.path或者环境变量CLASSPATH所指定的路径
                            - 默认应用程序里包含的类应该由应用类加载器来进行加载
        - 双亲委派模型
            - 当一个类加载器接收到加载请求时，会先将请求转发给父类加载器
            - 在父类加载器没有找到所请求的类的情况下，该类加载器才会尝试去加载
        - 类加载器 — 命名空间的作用
            - 类的唯一性由类加载器实例和类的全名共同确定
            - 即使同一串字节流，经由不同的类加载器加载，也会得到不同的类
    - 链接
        - 将创建的类合并到Java虚拟机当中，并且使其能够执行的过程
        - 过程
            - 验证
                - 确保被加载类能够满足Java虚拟机的约束条件
            - 准备
                - 为被加载类的静态字段分配内存
                - 也会来构造和其他类层次相关的数据结构，比如说用来实现虚方法的动态绑定的方法表
            - 解析 — 对于字节码符号引用的解析
                - 在 class 文件被加载至 Java 虚拟机之前，这个类无法知道其他类及其方法、字段所对应的具体地址，甚至不知道自己方法、字段的地址。
                - 因此，每当需要引用这些成员时，Java 编译器会生成一个符号引用。在运行阶段，这个符号引用一般都能够无歧义地定位到具体目标上。
                - 举例来说，对于一个方法调用，编译器会生成一个包含目标方法所在类的名字、目标方法的名字、接收参数类型以及返回值类型的符号引用，来指代所要调用的方法。
                - 解析阶段的目的，正是将这些符号引用解析成为实际引用。如果符号引用指向一个未被加载的类，或者未被加载类的字段或方法，那么解析将触发这个类的加载（但未必触发这个类的链接以及初始化。）
    - 初始化
        - 内容
            - 为标记为常量值的字段赋值
            - 执行clinit方法 — Java虚拟机通过加锁确定clinit方法仅仅会被执行一次
                - 如果直接赋值的静态字段被 final 所修饰，并且它的类型是基本类型或字符串时，那么该字段便会被 Java 编译器标记成常量值（ConstantValue），其初始化直接由 Java 虚拟机完成。
                - 除此之外的直接赋值操作，以及所有静态代码块中的代码，则会被 Java 编译器置于同一方法中，并把它命名为 < clinit >。
        - 触发情况
            - 当虚拟机启动时，初始化用户指定的主类；
            - 当遇到用以新建目标类实例的 new 指令时，初始化 new 指令的目标类；
            - 当遇到调用静态方法的指令时，初始化该静态方法所在的类；
            - 当遇到访问静态字段的指令时，初始化该静态字段所在的类；
            - 子类的初始化会触发父类的初始化；
            - 如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，会触发该接口的初始化；
            - 使用反射 API 对某个类进行反射调用时，初始化这个类；
            - 当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。
- 基本类型是Java虚拟机已经设置好的，而另一大类引用类型，Java将其细分为四种
    - 类
        - 有对应的字节流 — class文件
    - 接口
        - 有对应的字节流 - class文件
    - 数组类
        - 由Java虚拟机直接生成
    - 泛型参数

# 4. JVM执行方法调用

## 4.1 重载和重写

- 重载
    - 同一个类当中方法名称相同，但是方法的参数不相同的情况
    - 在编译过程当中就可以完成识别，Java编译器根据传入参数的声明类型，来选取重载方法
        - 三个阶段
            - 不考虑基本类型的自动拆箱装箱，还有可变长参数的情况下选择重载方法
            - 1阶段没有找到适配的方法，那么就在允许自动拆装箱，但不允许可变长参数的情况下选取重载方法
            - 2阶段没有找到适配的方法，那么在允许自动装拆箱以及可变长参数的情况下选取重载方法
        - 如果Java编译器在同一个阶段找到了多个适配方法，那么就会选择一个最为贴切的，决定贴切程度的一个关键就是形式参数类型的继承关系
            - 会选择那个范围更小的，比如某某的子类这样子
- 重写
    - 子类定义了和父类非私有方法同名的方法，而且这两个方法的参数类型相同
    - 如果这两个方法都是静态的，那么子类中的方法隐藏了父类中的方法
    - 如果都不是静态，也不是私有的，那么子类的方法重写了父类当中的方法
    - 方法重写 — 允许子类在继承父类部分功能的同时，拥有自己独特的行为

## 4.2 JVM 静态和动态绑定

- Java虚拟机识别方法
    - 类名
    - 方法名
    - 方法描述符 — method descriptor
        - 由方法的参数类型以及**返回类型**所构成的
- JVM和Java语言在这里不太一样，同一个类下同样方法名，同样参数，但是不同返回值从JVM角度来说是可以被认为是不同的方法，是可以通过的
- 静态绑定
    - 在解析的时候便能够识别目标方法的情况
    - 重载 — 是在编译阶段就完成了的，也可以成为static binding
- 动态绑定
    - 在运行过程当中根据调用者的动态类型来识别目标方法的情况
    - 重写 — 在JVM当中来做识别，dynamic binding
- Java字节码当中和调用相关的指令
    - invokestatic  - 用于调用静态方法
    - invokespecial - 用于调用私有实例方法，构造器  以及使用super关键字调用父类的实例方法或者构造器
    - invokevirtual  - 用于调用非私有实例方法
    - invokeinterface - 用于调用接口方法
    - invokedynamic - 用于调用动态方法

## 4.3 调用指令的符号引用

- 在编译过程当中，我们并不知道目标方法的具体内存地址
    - Java编译器会暂时用符号引用来表示该目标方法
    - 这一符号引用包括目标方法所在的类或接口的名字，以及目标方法的方法名和方法描述符。