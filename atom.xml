<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Leilei&#39;s Blog | 磊磊的博客</title>
  
  <subtitle>Because it&#39;s there</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.llchen60.com/"/>
  <updated>2020-02-09T18:32:28.203Z</updated>
  <id>https://www.llchen60.com/</id>
  
  <author>
    <name>Leilei Chen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构与算法(16)-二叉树</title>
    <link href="https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-16-%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-16-%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2020-02-09T18:31:37.000Z</published>
    <updated>2020-02-09T18:32:28.203Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-树"><a href="#1-树" class="headerlink" title="1. 树"></a>1. 树</h1><ul><li>父节点<ul><li>上层的节点 </li></ul></li><li>兄弟节点<ul><li>父节点是同一个节点 </li></ul></li><li>叶节点<ul><li>没有子节点的节点</li></ul></li><li>高度<ul><li>节点到叶子节点的最长路径 </li></ul></li><li>深度<ul><li>根节点到这个节点所经历的边的个数 </li></ul></li><li>层<ul><li>节点的深度 + 1 </li></ul></li></ul><h1 id="2-二叉树"><a href="#2-二叉树" class="headerlink" title="2. 二叉树"></a>2. 二叉树</h1><p>每个节点最多有两个分叉的树，即最多有两个子节点</p><p><img src="https://i.loli.net/2020/02/10/r72vjaPlpfsHmuE.jpg" alt="fig1.jpg"><br>2 显示的是满二叉树，特点是叶子节点都在最底层，出了叶子节点之外，每个节点都有左右两个子节点</p><p>3 叶子节点都在最底下两层，并且出了最后一层，其他的层的节点数量都要达到最大，并且最后一层的节点都是靠左排列的，这种二叉树叫做完全二叉树。</p><h2 id="2-1-如何表示-存储一棵二叉树？"><a href="#2-1-如何表示-存储一棵二叉树？" class="headerlink" title="2.1 如何表示/ 存储一棵二叉树？"></a>2.1 如何表示/ 存储一棵二叉树？</h2><h3 id="2-1-1-基于指针或者引用的二叉链式存储法"><a href="#2-1-1-基于指针或者引用的二叉链式存储法" class="headerlink" title="2.1.1 基于指针或者引用的二叉链式存储法"></a>2.1.1 基于指针或者引用的二叉链式存储法</h3><p><img src="https://i.loli.net/2020/02/10/M1I6FkWJodTq3fX.jpg" alt="fig2.jpg"></p><p>每个节点都有三个字段，其中一个存储数据，另外两个指向左右子节点的指针。因此通过根节点，我们就可以通过左右子节点的指针将整棵树都串起来了。</p><h3 id="2-1-2-基于数组的顺序存储法"><a href="#2-1-2-基于数组的顺序存储法" class="headerlink" title="2.1.2 基于数组的顺序存储法"></a>2.1.2 基于数组的顺序存储法</h3><p><img src="https://i.loli.net/2020/02/10/P62NlH8EbY3LBXv.jpg" alt="fig3.jpg"><br>如果节点X存储在数组中下标为i的位置，下标为2<em>i的位置存储的是左子节点，下标为2</em>i + 1的位置存储的就是右子节点。下标为i/2的位置存储的就是它的父节点了。通过这种方式，我们只要知道根节点存储的位置，就可以通过下标计算，把整棵树都串起来。 不过对于一棵非完全二叉树而言，会浪费比较多的数组存储空间的。</p><h2 id="2-2-二叉树的遍历"><a href="#2-2-二叉树的遍历" class="headerlink" title="2.2 二叉树的遍历"></a>2.2 二叉树的遍历</h2><h3 id="2-2-0-递归公式"><a href="#2-2-0-递归公式" class="headerlink" title="2.2.0 递归公式"></a>2.2.0 递归公式</h3><p><img src="https://i.loli.net/2020/02/10/o1TLXDnalmgBzAQ.jpg" alt="fig4.jpg"></p><p>二叉树的遍历整体就是一个递归的过程</p><p>写递归代码的关键，就是看能不能写出一个递推公式。而递推公式的关键，就是如果要解决问题A，就假设子问题B,C都已经解决，然后再来看如何利用B，C来解决A</p><pre><code>前序遍历的递推公式：preOrder(r) = print r-&gt;preOrder(r-&gt;left)-&gt;preOrder(r-&gt;right)中序遍历的递推公式：inOrder(r) = inOrder(r-&gt;left)-&gt;print r-&gt;inOrder(r-&gt;right)后序遍历的递推公式：postOrder(r) = postOrder(r-&gt;left)-&gt;postOrder(r-&gt;right)-&gt;print r// 前序遍历void preOrder(Node* root) {  if (root == null) return;  print root // 此处为伪代码，表示打印root节点  preOrder(root-&gt;left);  preOrder(root-&gt;right);}// 中序遍历void inOrder(Node* root) {  if (root == null) return;  inOrder(root-&gt;left);  print root // 此处为伪代码，表示打印root节点  inOrder(root-&gt;right);}// 后序遍历void postOrder(Node* root) {  if (root == null) return;  postOrder(root-&gt;left);  postOrder(root-&gt;right);  print root // 此处为伪代码，表示打印root节点}</code></pre><h3 id="2-2-1-前序遍历"><a href="#2-2-1-前序遍历" class="headerlink" title="2.2.1 前序遍历"></a>2.2.1 前序遍历</h3><p>对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。</p><h3 id="2-2-2-中序遍历"><a href="#2-2-2-中序遍历" class="headerlink" title="2.2.2 中序遍历"></a>2.2.2 中序遍历</h3><p>对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树</p><h3 id="2-2-3-后序遍历"><a href="#2-2-3-后序遍历" class="headerlink" title="2.2.3 后序遍历"></a>2.2.3 后序遍历</h3><p>对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身</p><h1 id="3-二叉查找树"><a href="#3-二叉查找树" class="headerlink" title="3. 二叉查找树"></a>3. 二叉查找树</h1><p>支持动态数据集合的快速插入、删除、查找操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-树&quot;&gt;&lt;a href=&quot;#1-树&quot; class=&quot;headerlink&quot; title=&quot;1. 树&quot;&gt;&lt;/a&gt;1. 树&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;父节点&lt;ul&gt;
&lt;li&gt;上层的节点 &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;兄弟节点&lt;ul&gt;
&lt;li&gt;父节点是同
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://www.llchen60.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://www.llchen60.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法(15)-哈希算法</title>
    <link href="https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-15-%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/"/>
    <id>https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-15-%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/</id>
    <published>2020-02-09T18:30:23.000Z</published>
    <updated>2020-02-09T18:30:43.320Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-什么是哈希算法"><a href="#1-什么是哈希算法" class="headerlink" title="1. 什么是哈希算法"></a>1. 什么是哈希算法</h1><blockquote><p>将任意长度的二进制串映射为固定长度的二进制串，这个映射的规则就是哈希算法，而通过原始数据映射之后得到的二进制串就是哈希值</p></blockquote><ul><li>哈希算法的要求<ul><li>从哈希值无法反向推导出原始数据</li><li>对输入数据非常敏感，哪怕原始数据只修改一个bit，最后得到的哈希值也会大不相同</li><li>散列冲突的概率很小，对于不同的原始数据，哈希值相同的概率非常小</li><li>哈希算法的效率要足够高，针对较长文本，也能快速计算出哈希值</li></ul></li></ul><h1 id="2-哈希算法的应用"><a href="#2-哈希算法的应用" class="headerlink" title="2. 哈希算法的应用"></a>2. 哈希算法的应用</h1><h2 id="2-1-安全加密"><a href="#2-1-安全加密" class="headerlink" title="2.1 安全加密"></a>2.1 安全加密</h2><ul><li>常用de加密算法<ul><li>MD5<ul><li>MD5 Message-Digest Algorithm </li><li>MD5信息摘要算法</li></ul></li><li>SHA <ul><li>Secure Hash Algorithm 安全散列算法</li></ul></li><li>DES <ul><li>Data Encryption Standard 数据加密标准</li></ul></li><li>AES <ul><li>Advanced Encryption Standard 高级加密标准</li></ul></li></ul></li></ul><h2 id="2-2-唯一标识"><a href="#2-2-唯一标识" class="headerlink" title="2.2 唯一标识"></a>2.2 唯一标识</h2><p>图片的标识，从图片的二进制串码的前中后各取出100字节，通过哈希算法得到一个哈希字符串，用它作为图片的唯一标识。然后通过这个唯一标识来判定图片是否在图库当中，通过这种方式来减少工作量。</p><h2 id="2-3-数据校验"><a href="#2-3-数据校验" class="headerlink" title="2.3 数据校验"></a>2.3 数据校验</h2><p>BT协议的数据校验，对每个文件块取哈希值，保存在种子文件当中。当文件块下载完成之后，我们通过相同的哈希算法，对下载好的文件块逐一求哈希值，然后跟种子文件中保存的哈希值进行比对。如果不同，就说明这个文件块不完整或者被篡改了，需要再重新从其他宿主机器上下载这个文件块。</p><h2 id="2-4-散列函数"><a href="#2-4-散列函数" class="headerlink" title="2.4 散列函数"></a>2.4 散列函数</h2><p>哈希表的散列函数，关注的是在做完哈希以后，是否能够平均的分布。一组数据能否均匀散列在各个槽中。 </p><p>另外一个点是其执行速度，散列函数对执行速度的要求会比较高一些。</p><h2 id="2-5-负载均衡"><a href="#2-5-负载均衡" class="headerlink" title="2.5 负载均衡"></a>2.5 负载均衡</h2><p>分布式系统当中需要解决的问题</p><ul><li>负载均衡的算法<ul><li>轮询</li><li>随机</li><li>加权轮询</li></ul></li></ul><p>但是我们需要实现一个会话粘滞的负载均衡算法(session sticky)。即我们需要在一个客户端上，在一次会话上的所有请求都路由到同一个服务器上。</p><p>通过哈希算法，对客户端IP地址或者会话的ID计算哈希值，将取得的哈希值与服务器列表的大小进行取模运算，最终得到的值就是应该被路由到的服务器的编号。</p><h2 id="2-6-数据分片"><a href="#2-6-数据分片" class="headerlink" title="2.6 数据分片"></a>2.6 数据分片</h2><h3 id="2-6-1-如何统计关键词搜索的次数"><a href="#2-6-1-如何统计关键词搜索的次数" class="headerlink" title="2.6.1 如何统计关键词搜索的次数"></a>2.6.1 如何统计关键词搜索的次数</h3><p>假设我们有1T的日志文件，里面记录了用户的关键词，我们想快速统计出来每个关键词被搜索的次数，该怎么做呢？ </p><ol><li>数据量太大的问题</li><li>处理时间太长的问题</li></ol><p>对数据进行分片，然后多台机器进行处理。用哈希算法，将哈希值相同的搜索关键词放到同一台机器上。然后最后做汇总</p><h3 id="2-6-2-如何快速判断图片是否在图库当中"><a href="#2-6-2-如何快速判断图片是否在图库当中" class="headerlink" title="2.6.2 如何快速判断图片是否在图库当中"></a>2.6.2 如何快速判断图片是否在图库当中</h3><p>为每个图片取唯一标识，然后构建散列表，但是当图片量很大的时候，在单台机器上构建散列表是行不通的。</p><p>因为在存储的时候，我们还是需要根据哈希算法取模来进行存储，然后在进行判断的时候，也是用同样的哈希算法，然后与机器个数n求余取模。然后根据得到的值到对应的机器上去进行查找。</p><h2 id="2-7-分布式存储"><a href="#2-7-分布式存储" class="headerlink" title="2.7 分布式存储"></a>2.7 分布式存储</h2><p>分布式存储需要解决的问题是，当我们已经在各个host上按照哈希算法保存了数据以后，再增减host的时候，我们不希望还需要对原先的host里面的数据做迁移。如果说缓存当中的数据会一下子全都失效的话，那么所有数据请求都要从数据库走，直接就压垮数据库了。</p><p>因此在分布式存储当中，我们需要采用<strong><em>一致性哈希算法</em></strong></p><p>假设我们有 k 个机器，数据的哈希值的范围是[0, MAX]。我们将整个范围划分成 m 个小区间（m 远大于 k），每个机器负责 m/k 个小区间。当有新机器加入的时候，我们就将某几个小区间的数据，从原来的机器中搬移到新的机器中。这样，既不用全部重新哈希、搬移数据，也保持了各个机器上数据数量的均衡。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-什么是哈希算法&quot;&gt;&lt;a href=&quot;#1-什么是哈希算法&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是哈希算法&quot;&gt;&lt;/a&gt;1. 什么是哈希算法&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;将任意长度的二进制串映射为固定长度的二进制串，这个映射
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://www.llchen60.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="哈希算法" scheme="https://www.llchen60.com/tags/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法(14)-散列表</title>
    <link href="https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-14-%E6%95%A3%E5%88%97%E8%A1%A8/"/>
    <id>https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-14-%E6%95%A3%E5%88%97%E8%A1%A8/</id>
    <published>2020-02-09T18:21:54.000Z</published>
    <updated>2020-02-09T18:24:07.894Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Intro"><a href="#1-Intro" class="headerlink" title="1. Intro"></a>1. Intro</h1><p>散列表 - Hash Table, 又被称为哈希表或者Hash表。散列表用的是数组支持按照下标来随机访问数据的特性，因此散列表实际上是数组的一种扩展，由数组演化而来。</p><p>散列的思想就是对于key值，通过hash function，对应到table上来进行存储</p><p><img src="https://i.loli.net/2020/02/10/pnWdbkoVjUE7aTw.jpg" alt="fig1.jpg"></p><h1 id="2-散列函数"><a href="#2-散列函数" class="headerlink" title="2. 散列函数"></a>2. 散列函数</h1><p>散列函数就是实现输入到存储的对应的函数，因为最终是要存储到数组当中，故而其基本要求有：</p><ol><li>散列函数计算得到的散列值是一个非负整数</li><li>如果Key1 = Key2,那么hash(key1) == hash(key2)</li><li>如果key1 != key2, 那么hash(key1) != hash(key2)</li></ol><p>条件3 即如何应对散列冲突的问题，首先本身是必须的，而且客观是存在散列冲突的情况的，针对于散列冲突，我们一般会使用开放寻址法和链表法。</p><h1 id="3-如何解决散列冲突"><a href="#3-如何解决散列冲突" class="headerlink" title="3. 如何解决散列冲突"></a>3. 如何解决散列冲突</h1><h2 id="3-1-开放寻址法"><a href="#3-1-开放寻址法" class="headerlink" title="3.1 开放寻址法"></a>3.1 开放寻址法</h2><ul><li>核心思想<ul><li>出现了散列冲突，就重新探测一个空闲位置，将其插入</li></ul></li><li>探测方法<ul><li>线性探测</li><li>二次探测<ul><li>探测步长为二次方的增长 </li></ul></li><li>双重散列<ul><li>使用第一个散列函数进行尝试</li><li>如果计算得到的存储位置已经被占用，再用第二个散列函数，依次类推直到找到空闲的存储位置</li></ul></li></ul></li><li>装载因子<ul><li>引入装在引资的概念来表示空位的多少</li><li><code>装载因子 = 填入表中的元素个数/散列表的长度</code></li></ul></li></ul><h2 id="3-2-链表法"><a href="#3-2-链表法" class="headerlink" title="3.2 链表法"></a>3.2 链表法</h2><p><img src="https://i.loli.net/2020/02/10/VAUezcR2phPlYjT.jpg" alt="fig2.jpg"></p><p>链表法是一种更加常用的散列冲突解决办法，相比开放寻址法，它要简单很多。我们来看这个图，在散列表中，每个“桶（bucket）”或者“槽（slot）”会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中。</p><h1 id="4-工程上使用的散列表"><a href="#4-工程上使用的散列表" class="headerlink" title="4. 工程上使用的散列表"></a>4. 工程上使用的散列表</h1><p>首先我们需要思考下实际应用场景当中的散列表，虽然我们说散列表的查询效率是O(1), 实质上他的真实数据时和散列函数，装载因子，散列冲突都有关系的。如果散列函数设计的不好，或者装载因子过高，都可能导致散列冲突发生的概率升高，从而导致查询的效率下降。</p><p>因此对于在工程上使用的散列表，首先要考虑的就是需要能够应对各种异常情况，来避免散列冲突的情况下散列表性能的急剧下降，并且需要能够抵抗散列碰撞攻击。</p><h2 id="4-1-如何设计散列函数"><a href="#4-1-如何设计散列函数" class="headerlink" title="4.1 如何设计散列函数"></a>4.1 如何设计散列函数</h2><ul><li>需求<ul><li>散列函数的设计不能太复杂 <ul><li>会消耗很多计算时间</li><li>即会影响到散列表的性能</li></ul></li><li>散列函数生成的值需要尽可能随机并且均匀分布</li></ul></li><li>如何解决装载因子过大的问题<ul><li>针对散列表，当装载因子过大的时候，我们也可以进行动态扩容，重新申请一个更大的散列表，将数据搬移到这个新的散列表当中。</li><li>同时也有装载因子太小的情况下，我们可以做动态缩容的工作</li></ul></li><li>如何避免低效扩容<ul><li>所谓低效的扩容指的是如果我们在装载因子超过阈值的时候一下子进行扩容，即数据的搬运和最终的新数据的插入，那针对这一个数据，其时间复杂度变成了O(n).</li><li>为了解决这个问题，我们在需要进行扩容的时候，将扩容的操作穿插在插入操作的过程当中，分批次来完成。当装载因子触达阈值的时候，只申请新空间，但是没有将老的数据搬移到新的散列表当中。</li><li>当有新数据插入的时候，就将新数据放到新的散列表当中，并且从老的散列表当中拿一个数据放到新的散列表当中</li><li>而查询操作，为了兼顾，我们会先从新的散列表当中查找，如果没有找到，再去老的散列表当中查找</li></ul></li></ul><h2 id="4-2-如何解决冲突？"><a href="#4-2-如何解决冲突？" class="headerlink" title="4.2 如何解决冲突？"></a>4.2 如何解决冲突？</h2><h3 id="4-2-1-开放寻址法"><a href="#4-2-1-开放寻址法" class="headerlink" title="4.2.1 开放寻址法"></a>4.2.1 开放寻址法</h3><ul><li>优势<ul><li>数据都存储在数组当中，可以有效利用CPU缓存加快查询速度</li><li>序列化比较简单</li></ul></li><li>缺陷<ul><li>删除数据比较麻烦，需要特殊标记已经删除的数据</li><li>冲突代价高，导致装载因子的上限不能太大</li></ul></li></ul><blockquote><p>当数据量比较小，装载因子小的时候，适合使用开放寻址法。</p></blockquote><h3 id="4-2-2-链表法"><a href="#4-2-2-链表法" class="headerlink" title="4.2.2 链表法"></a>4.2.2 链表法</h3><ul><li>优势<ul><li>对内存的利用率相对比较高，因为链表结点可以在需要的时候再创建，不需要提前申请好</li><li>可以允许很高的装载因子</li></ul></li><li>劣势<ul><li>因为要存储指针，对于小的对象的存储，是更加耗内存的</li><li>因为结点零散分布在内存当中，不是连续的，所以对CPU缓存不友好，对执行效率会造成一定的影响</li></ul></li></ul><h2 id="4-3-Java-HashMap举例"><a href="#4-3-Java-HashMap举例" class="headerlink" title="4.3 Java HashMap举例"></a>4.3 Java HashMap举例</h2><ul><li>初始大小 - 16<ul><li>如果大概知道数据量的大小，可以修改默认，来减少动态扩容的次数</li></ul></li><li>装载因子和动态扩容<ul><li>默认 load factor 0.75 </li><li>每次扩容大小变为两倍</li></ul></li><li>散列冲突解决方法<ul><li>采用链表法</li><li>1.8以后当链表长度超过8以后，链表就会自动转化为红黑树</li></ul></li><li>散列函数</li></ul><pre><code>int hash(Object key) {    int h = key.hashCode()；    return (h ^ (h &gt;&gt;&gt; 16)) &amp; (capicity -1); //capicity表示散列表的大小} </code></pre><p><code>&amp;(capacity - 1)</code> means <code>% capacity</code></p><p>因为hashcode本身是个32位的整型值，获得其hash值以后，将高16位移到低16位，就相当于拿到了高16位和低16位的feature。用自己的高半区和低半区做异或，为的是加大低位的随机性。这样子哪怕是高位的变化也可以反映到低位当中，保证了最终进bin的随机性</p><h1 id="5-散列表实际应用"><a href="#5-散列表实际应用" class="headerlink" title="5. 散列表实际应用"></a>5. 散列表实际应用</h1><p>散列表和链表经常是共同使用的,这一部分会walk through一些常用的场景，看看是如何来共同使用的。</p><h2 id="5-1-LRU缓存淘汰算法"><a href="#5-1-LRU缓存淘汰算法" class="headerlink" title="5.1 LRU缓存淘汰算法"></a>5.1 LRU缓存淘汰算法</h2><p>最基础的LRU实现，我们可以通过链表来做.维护一个按照访问时间从大到小有序排列的链表结构，因为缓存大小有限，当缓存空间不够，需要淘汰一个数据的时候，我们就直接将链表头部的结点删除。</p><p>我们可以选择使用散列表和双向链表一起来实现LRU cache。要实现的操作有：</p><ul><li>往缓存中加入数据</li><li>从缓存中删除数据</li><li>在缓存中查找数据</li></ul><p><img src="https://i.loli.net/2020/02/10/LIB2nkbZYudrq37.jpg" alt="fig3.jpg"></p><p>如图所示，我们相当于在维护两条链表，一条是在哈希表的每个entry上的链，在这上面的链是为了解决哈希冲突的；另外一个点，我们在使用的是维护LRU cache的链表。</p><p>链表当中的每个结点保存了：</p><ul><li>prev</li><li>next</li><li>data</li><li>hnext<ul><li>散列表上碰撞问题的解决的 </li></ul></li></ul><h2 id="5-2-Java-LinkedHashMap"><a href="#5-2-Java-LinkedHashMap" class="headerlink" title="5.2 Java LinkedHashMap"></a>5.2 Java LinkedHashMap</h2><p>LinkedHashMap能够实现按照数据的插入顺序来进行打印，是因为他也是通过散列表和链表组合在一起的方式实现的。它支持按照插入顺序遍历数据，还支持按照访问顺序来遍历数据</p><pre><code>// 10是初始大小，0.75是装载因子，true是表示按照访问时间排序HashMap&lt;Integer, Integer&gt; m = new LinkedHashMap&lt;&gt;(10, 0.75f, true);m.put(3, 11);m.put(1, 12);m.put(5, 23);m.put(2, 22);m.put(3, 26);m.get(5);for (Map.Entry e : m.entrySet()) {  System.out.println(e.getKey());}// print out: 1, 2, 3, 5</code></pre><p><img src="https://i.loli.net/2020/02/10/wxy1tumrZO3DXQz.jpg" alt="fig4.jpg"></p><p><img src="https://i.loli.net/2020/02/10/9phoBuRSI5gsJC4.jpg" alt="fig5.jpg"></p><p><img src="https://i.loli.net/2020/02/10/3KGVI15LDp4PSAZ.jpg" alt="fig6.jpg"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Intro&quot;&gt;&lt;a href=&quot;#1-Intro&quot; class=&quot;headerlink&quot; title=&quot;1. Intro&quot;&gt;&lt;/a&gt;1. Intro&lt;/h1&gt;&lt;p&gt;散列表 - Hash Table, 又被称为哈希表或者Hash表。散列表用的是数组支持按照下标来
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://www.llchen60.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="散列表" scheme="https://www.llchen60.com/tags/%E6%95%A3%E5%88%97%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法(13)-跳表</title>
    <link href="https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-13-%E8%B7%B3%E8%A1%A8/"/>
    <id>https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-13-%E8%B7%B3%E8%A1%A8/</id>
    <published>2020-02-09T18:11:25.000Z</published>
    <updated>2020-02-09T18:12:09.716Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h1><ul><li>跳表<ul><li>动态数据结构</li><li>可以支持快速的插入，删除，查找操作</li><li>写起来也不会很复杂</li></ul></li></ul><p>Redis当中的有序集合就是用跳表来实现的。</p><h1 id="2-如何理解跳表"><a href="#2-如何理解跳表" class="headerlink" title="2. 如何理解跳表"></a>2. 如何理解跳表</h1><p>对于一个单链表来说，即便链表当中存储的数据是有序的，如果我们想要从中查找某个数据，也只能从头到尾遍历链表，这样查找效率就会非常低，时间复杂度比较高，O(n)</p><p>为了解决这个问题，我们可以对链表建立一级索引，每几个结点就提取一个结点到上一级当中，抽出来的那一级我们就可以将其叫做索引或者索引层了。</p><p>通过增加索引的层级，来加快寻找节点的速度，这就是跳表 – 链表加上多级索引的结构</p><ul><li>时间复杂度非常理想 O(logn)</li><li>但是相对来说会更需要内存一些  空间复杂度为O(n)</li></ul><h1 id="3-高效的动态插入和删除操作"><a href="#3-高效的动态插入和删除操作" class="headerlink" title="3. 高效的动态插入和删除操作"></a>3. 高效的动态插入和删除操作</h1><p>其动态的插入和删除操作的时间复杂度为O(logn)</p><p><img src="https://i.loli.net/2020/02/10/f4vdSyzCEs2KWFY.jpg" alt="fig1.jpg"></p><p>删除操作，还是需要拿到删除节点的前驱节点，然后通过指针操作完成删除。</p><h2 id="4-跳表索引动态更新"><a href="#4-跳表索引动态更新" class="headerlink" title="4. 跳表索引动态更新"></a>4. 跳表索引动态更新</h2><p><img src="https://i.loli.net/2020/02/10/J5QxpXFgAeTCa2j.jpg" alt="fig2.jpg"></p><p>跳表是需要不断更新的，因为当我们不断向跳表里面插入数据的时候，如果我们不更新索引，就有可能出现两个索引节点之间数据非常多的情况。极端情况下，跳表就会退化成单链表。</p><ul><li>我们需要某种方式来维护索引与原始链表大小之间的平衡<ul><li>跳表是通过随机函数来维护平衡性的</li><li>当我们往跳表里面插入数据的时候，可以选择同时将这个数据插入到部分索引层当中。</li><li>根据随机函数来决定这个结点插入到哪几级索引当中。</li></ul></li></ul><p><img src="https://i.loli.net/2020/02/10/64FQnKPZ8uWlTCb.jpg" alt="fig3.jpg"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-概念&quot;&gt;&lt;a href=&quot;#1-概念&quot; class=&quot;headerlink&quot; title=&quot;1. 概念&quot;&gt;&lt;/a&gt;1. 概念&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;跳表&lt;ul&gt;
&lt;li&gt;动态数据结构&lt;/li&gt;
&lt;li&gt;可以支持快速的插入，删除，查找操作&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://www.llchen60.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="跳表" scheme="https://www.llchen60.com/tags/%E8%B7%B3%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法(12)-二分查找</title>
    <link href="https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-12-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <id>https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-12-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</id>
    <published>2020-02-09T18:07:07.000Z</published>
    <updated>2020-02-09T18:07:27.910Z</updated>
    
    <content type="html"><![CDATA[<p>二分查找是一种针对于有序数据集合的查找算法，也叫折半查找算法。类似分治的思想，每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为0. 查找速度为O(logn)</p><p>思考题：1000万个整数数据，每个数据8字节，</p><h1 id="1-二分查找的基本实现"><a href="#1-二分查找的基本实现" class="headerlink" title="1. 二分查找的基本实现"></a>1. 二分查找的基本实现</h1><pre><code>public int bsearch(int[] a, int n, int value) {// 定基准点  int low = 0;  int high = n - 1;// 停止条件  while (low &lt;= high) {    // 定二分点    int mid = (low + high) / 2;    if (a[mid] == value) {      return mid;    } else if (a[mid] &lt; value) {     // 保证是活循环..       low = mid + 1;    } else {      high = mid - 1;    }  }  return -1;}// 二分查找的递归实现public int bsearch(int[] a, int n, int val) {  return bsearchInternally(a, 0, n - 1, val);}private int bsearchInternally(int[] a, int low, int high, int value) {  if (low &gt; high) return -1;  int mid =  low + ((high - low) &gt;&gt; 1);  if (a[mid] == value) {    return mid;  } else if (a[mid] &lt; value) {    return bsearchInternally(a, mid+1, high, value);  } else {    return bsearchInternally(a, low, mid-1, value);  }}</code></pre><ul><li>循环退出条件<ul><li>low &lt;= high </li></ul></li><li>mid取值<ul><li>mid = low + (high - low)/2</li><li>因为如果值太大的话，会溢出的</li></ul></li><li>low high的更新<ul><li>low = mid + 1</li><li>high = mid - 1 </li></ul></li></ul><h1 id="2-二分查找的应用场景局限性"><a href="#2-二分查找的应用场景局限性" class="headerlink" title="2. 二分查找的应用场景局限性"></a>2. 二分查找的应用场景局限性</h1><ul><li>二分查找以来的是顺序表结构  – 数组<ul><li>因为二分查找需要按照下标来随机访问元素</li></ul></li><li>针对的是有序数据 – 静态数据集<ul><li>更适用在插入，删除不频繁，一次排序多次查找的场景当中</li><li>针对动态变化的数据集合，二分查找就不再适用了</li></ul></li><li>数据量太小不需要适用二分查找</li><li>如果数据之间的比较非常耗时，我们需要尽力减少比较的次数，那么二分查找就是很好的方式了</li></ul><h1 id="3-二分查找的实际应用与变体"><a href="#3-二分查找的实际应用与变体" class="headerlink" title="3. 二分查找的实际应用与变体"></a>3. 二分查找的实际应用与变体</h1><h2 id="3-1-查找第一个值等于给定值的元素"><a href="#3-1-查找第一个值等于给定值的元素" class="headerlink" title="3.1 查找第一个值等于给定值的元素"></a>3.1 查找第一个值等于给定值的元素</h2><pre><code>public int bsearch(int[] a, int n, int value) {  int low = 0;  int high = n - 1;  while (low &lt;= high) {    int mid =  low + ((high - low) &gt;&gt; 1);    if (a[mid] &gt; value) {      high = mid - 1;    } else if (a[mid] &lt; value) {      low = mid + 1;    } else {      // 注意这里的判断，中止条件时mid为0 或者左一个的值和现在的值不相等       if ((mid == 0) || (a[mid - 1] != value)) return mid;      else high = mid - 1;    }  }  return -1;}</code></pre><ul><li>写二分相关的算法要注意的点有<ul><li>终止条件</li><li>区间上下界的更新方法</li><li>返回值的选择</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;二分查找是一种针对于有序数据集合的查找算法，也叫折半查找算法。类似分治的思想，每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为0. 查找速度为O(logn)&lt;/p&gt;
&lt;p&gt;思考题：1000万个整数数据，每个数据8字节，&lt;
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://www.llchen60.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="二分查找" scheme="https://www.llchen60.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法(11)-应用场景下的排序函数</title>
    <link href="https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-11-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E6%8E%92%E5%BA%8F%E5%87%BD%E6%95%B0/"/>
    <id>https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-11-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E6%8E%92%E5%BA%8F%E5%87%BD%E6%95%B0/</id>
    <published>2020-02-09T18:00:04.000Z</published>
    <updated>2020-02-09T18:00:58.516Z</updated>
    
    <content type="html"><![CDATA[<p>在日常开发当中，无论我们使用的语言是什么，他们几乎都会提供排序算法，本篇博文将尝试着对其进行分析，看看如何实现一个通用的，高性能的排序算法。</p><p>首先看看我们的现有排序算法库，看看我们的选择空间在哪里： </p><p><img src="https://i.loli.net/2020/02/10/2ga9UPTNkOcb8wr.jpg" alt="fig1.jpg"></p><p>如果对于小规模数据排序，可以选择O(n^2); 但是对于大规模的数据，时间复杂度为O(nlogn)的算法会高效很多。因此为了兼顾任意规模数据的排序，一般都会首选时间复杂度为O(nlogn)的排序算法来实现排序函数。</p><p>一般来说会选用堆排序或者快速排序来做。</p><p>因为在实际情况下内存的占用情况是非常关键的参数了，所以我们需要看待选算法的空间复杂度，最好是原地的，即不占用更多的空间。像归并排序，时间复杂度很合适但是空间复杂度为O(n)，那就完全不是一个好选择了</p><p>快速排序想要优化的话，主要的点在于要选准分区点，好的分区点是希望其两个分区数据的数量是差不多的才可以。我们可以随机取值，也可以多取几个随机点，然后求平均。</p><p>还有一点需要注意的是在实际情况当中, O(n^2)有可能会比O(nlogn)要快的，因为小规模数据集的时候首先常量就不能忽略掉了。在这种情况下，可能插入排序反而会更快。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在日常开发当中，无论我们使用的语言是什么，他们几乎都会提供排序算法，本篇博文将尝试着对其进行分析，看看如何实现一个通用的，高性能的排序算法。&lt;/p&gt;
&lt;p&gt;首先看看我们的现有排序算法库，看看我们的选择空间在哪里： &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.lo
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://www.llchen60.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序" scheme="https://www.llchen60.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法(10)-排序(桶排序 计数排序 基数排序)</title>
    <link href="https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-10-%E6%8E%92%E5%BA%8F-%E6%A1%B6%E6%8E%92%E5%BA%8F-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    <id>https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-10-%E6%8E%92%E5%BA%8F-%E6%A1%B6%E6%8E%92%E5%BA%8F-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/</id>
    <published>2020-02-09T17:55:16.000Z</published>
    <updated>2020-02-09T17:55:34.808Z</updated>
    
    <content type="html"><![CDATA[<p>上述三种排序方法的时间复杂度均为线性，因此将其称为线性排序(Linear sort).之所以能做先线性的时间复杂度，是因为他们都不是基于比较的排序算法，并不涉及到元素之间的比较操作。</p><h1 id="1-桶排序-Bucket-Sort"><a href="#1-桶排序-Bucket-Sort" class="headerlink" title="1. 桶排序 Bucket Sort"></a>1. 桶排序 Bucket Sort</h1><ul><li>核心思想<ul><li>将排序的数据分到几个有序的桶当中，每个桶的数据再单独进行排序。桶内排完序之后，再将每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。</li></ul></li><li>分析<ul><li>如果要排序的数据为 n个，将其均匀分到m个桶当中，每个桶就有 k=n/m个元素。每个桶内部使用快排，时间复杂度为O(k*logk)</li><li>m个桶的时间复杂度就为O(n*log(n/m)) </li><li>当m的数量非常接近n的时候，那么log(n/m)就是一个非常小的常量，这时候桶排序的时间复杂度就接近O(n)了</li></ul></li><li>优劣势<ul><li>对数据本身要求比较苛刻</li><li>需要足够均匀，否则桶内排序就不是常量级的复杂度了</li></ul></li><li>桶排序  适合在外部排序当中<ul><li>指数据存储在外部磁盘当中，数据量比较大，内存有限，无法将数据全部加载到内存当中 </li><li>顺序进行划分，挨个顺次放到内存当中</li></ul></li></ul><h1 id="2-计数排序-Counting-Sort"><a href="#2-计数排序-Counting-Sort" class="headerlink" title="2. 计数排序 Counting Sort"></a>2. 计数排序 Counting Sort</h1><p>类似于桶排序，但是每个桶里面存储的只是个数</p><pre><code>// 计数排序，a是数组，n是数组大小。假设数组中存储的都是非负整数。public void countingSort(int[] a, int n) {  if (n &lt;= 1) return;  // 查找数组中数据的范围  int max = a[0];  for (int i = 1; i &lt; n; ++i) {    if (max &lt; a[i]) {      max = a[i];    }  }  int[] c = new int[max + 1]; // 申请一个计数数组c，下标大小[0,max]  for (int i = 0; i &lt;= max; ++i) {    c[i] = 0;  }  // 计算每个元素的个数，放入c中  for (int i = 0; i &lt; n; ++i) {    c[a[i]]++;  }  // 依次累加  for (int i = 1; i &lt;= max; ++i) {    c[i] = c[i-1] + c[i];  }  // 临时数组r，存储排序之后的结果  int[] r = new int[n];  // 计算排序的关键步骤，有点难理解  for (int i = n - 1; i &gt;= 0; --i) {    int index = c[a[i]]-1;    r[index] = a[i];    c[a[i]]--;  }  // 将结果拷贝给a数组  for (int i = 0; i &lt; n; ++i) {    a[i] = r[i];  }}</code></pre><h1 id="3-基数排序-Radix-Sort"><a href="#3-基数排序-Radix-Sort" class="headerlink" title="3. 基数排序 Radix Sort"></a>3. 基数排序 Radix Sort</h1><p>排10万个手机号码，从小到大来排序？ </p><p>按照位来排，需要选用稳定性的算法来做。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上述三种排序方法的时间复杂度均为线性，因此将其称为线性排序(Linear sort).之所以能做先线性的时间复杂度，是因为他们都不是基于比较的排序算法，并不涉及到元素之间的比较操作。&lt;/p&gt;
&lt;h1 id=&quot;1-桶排序-Bucket-Sort&quot;&gt;&lt;a href=&quot;#1-桶排
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://www.llchen60.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序" scheme="https://www.llchen60.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法(9)-排序(归并 快排)</title>
    <link href="https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-9-%E6%8E%92%E5%BA%8F-%E5%BD%92%E5%B9%B6-%E5%BF%AB%E6%8E%92/"/>
    <id>https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-9-%E6%8E%92%E5%BA%8F-%E5%BD%92%E5%B9%B6-%E5%BF%AB%E6%8E%92/</id>
    <published>2020-02-09T17:51:41.000Z</published>
    <updated>2020-02-09T17:55:54.841Z</updated>
    
    <content type="html"><![CDATA[<p>这节主要讲归并排序和快速排序，二者其实都用了分治的思想，可以借鉴这个思想，来解决诸如“如何在O(n)的时间复杂度内查找一个无序数组中的第k大元素”这样的问题。</p><h1 id="1-归并排序"><a href="#1-归并排序" class="headerlink" title="1. 归并排序"></a>1. 归并排序</h1><p><img src="https://i.loli.net/2020/02/10/fVpOLyXAhjn2cKW.jpg" alt="fig1.jpg"></p><ul><li><p>归并排序</p><ul><li>分治思想</li><li>分治是一种解决问题的处理思想，递归是一种编程技巧</li><li>和递归的三要素很类似，先分析得出递推公式，然后找到终止条件，再将递推公式翻译成递归代码。</li></ul></li><li><p>注意是分成了分开和合并两个过程的，在合并的过程当中，需要遍历两个有序子集，相互比较大小，然后放置在另外一个空间当中</p></li></ul><pre><code>递推公式：merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1…r))终止条件：p &gt;= r 不用再继续分解// 归并排序算法, A 是数组，n 表示数组大小merge_sort(A, n) {  merge_sort_c(A, 0, n-1)}// 递归调用函数merge_sort_c(A, p, r) {  // 递归终止条件  if p &gt;= r  then return  // 取 p 到 r 之间的中间位置 q  q = (p+r) / 2  // 分治递归  merge_sort_c(A, p, q)  merge_sort_c(A, q+1, r)  // 将 A[p...q] 和 A[q+1...r] 合并为 A[p...r]  merge(A[p...r], A[p...q], A[q+1...r])}</code></pre><ul><li>稳定排序</li><li>时间复杂度为O(nlog(n))</li><li>需要借助额外空间，不是原地排序算法  空间复杂度 O(n) 每次搞完就会直接释放掉了</li></ul><h1 id="2-快速排序"><a href="#2-快速排序" class="headerlink" title="2. 快速排序"></a>2. 快速排序</h1><p><img src="https://i.loli.net/2020/02/10/J6wH1nKPtv9qIAm.jpg" alt="fig2.jpg"></p><ul><li>快排的思想<ul><li>如果要排序数组中下标从p到r之间的一组数据，我们选择p到r之间的任意一个数据作为pivot(分区点) </li><li>我们遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间。经过这一步骤之后，数组 p 到 r 之间的数据就被分成了三个部分，前面 p 到 q-1 之间都是小于 pivot 的，中间是 pivot，后面的 q+1 到 r 之间是大于 pivot 的。</li><li>快速排序是一种不稳定的排序方法，因为要实现swap</li></ul></li></ul><pre><code>递推公式：quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1, r)终止条件：p &gt;= r// 快速排序，A 是数组，n 表示数组的大小quick_sort(A, n) {  quick_sort_c(A, 0, n-1)}// 快速排序递归函数，p,r 为下标quick_sort_c(A, p, r) {  if p &gt;= r then return  q = partition(A, p, r) // 获取分区点  quick_sort_c(A, p, q-1)  quick_sort_c(A, q+1, r)}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这节主要讲归并排序和快速排序，二者其实都用了分治的思想，可以借鉴这个思想，来解决诸如“如何在O(n)的时间复杂度内查找一个无序数组中的第k大元素”这样的问题。&lt;/p&gt;
&lt;h1 id=&quot;1-归并排序&quot;&gt;&lt;a href=&quot;#1-归并排序&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://www.llchen60.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序" scheme="https://www.llchen60.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法(8)-排序(冒泡 插入 选择)</title>
    <link href="https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-8-%E6%8E%92%E5%BA%8F-%E5%86%92%E6%B3%A1-%E6%8F%92%E5%85%A5-%E9%80%89%E6%8B%A9/"/>
    <id>https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-8-%E6%8E%92%E5%BA%8F-%E5%86%92%E6%B3%A1-%E6%8F%92%E5%85%A5-%E9%80%89%E6%8B%A9/</id>
    <published>2020-02-09T17:49:00.000Z</published>
    <updated>2020-02-09T17:50:06.364Z</updated>
    
    <content type="html"><![CDATA[<ul><li>这里介绍三大类型的排序<ul><li>冒泡，插入，选择  O(n^2)</li><li>快排，归并 O(nlogn)</li><li>桶，计数，基数</li></ul></li></ul><h1 id="1-如何分析一个排序算法？"><a href="#1-如何分析一个排序算法？" class="headerlink" title="1. 如何分析一个排序算法？"></a>1. 如何分析一个排序算法？</h1><h2 id="1-1-执行效率"><a href="#1-1-执行效率" class="headerlink" title="1.1 执行效率"></a>1.1 执行效率</h2><ul><li>最好情况，最坏情况，平均情况时间复杂度<ul><li>要知道针对于数据集的特征，需要采取哪一种排序算法 </li></ul></li><li>时间复杂度的系数，常数，低阶<ul><li>实际开发过程中，面对规模比较小的数据，我们可能需要将系数，常数，低阶都考虑进去才可以的 </li></ul></li><li>比较次数和交换次数<ul><li>对于基于比较的排序算法，会涉及到元素大小的比较以及元素的交换或者移动，因此当我们在分析排序算法的执行效率的时候，应该把比较次数和交换次数也考虑进去 </li></ul></li></ul><h2 id="1-2-排序算法的内存消耗"><a href="#1-2-排序算法的内存消耗" class="headerlink" title="1.2 排序算法的内存消耗"></a>1.2 排序算法的内存消耗</h2><p>内存消耗可以用空间复杂度来衡量，来看算法究竟消耗了多少内存空间</p><h2 id="1-3-排序算法的稳定性"><a href="#1-3-排序算法的稳定性" class="headerlink" title="1.3 排序算法的稳定性"></a>1.3 排序算法的稳定性</h2><p>如果待排序的序列中存在值相等的元素，经过排序以后，相等元素之间原有的先后顺序不变</p><p>稳定性很重要，表现在要对几个影响因素来按照步骤进行排序的情况。</p><h1 id="2-算法分析"><a href="#2-算法分析" class="headerlink" title="2. 算法分析"></a>2. 算法分析</h1><h2 id="2-1-冒泡排序"><a href="#2-1-冒泡排序" class="headerlink" title="2.1 冒泡排序"></a>2.1 冒泡排序</h2><ul><li>操作相邻的两个数据<ul><li>每次冒泡都会对相邻的两个元素进行比较，</li><li>看是否满足大小关系要求</li><li>如果不满足就让它倆互换，一次冒泡至少会让一个元素移动到它应该在的位置，重复n次，就完成了n个数据的排序工作</li></ul></li></ul><p><img src="https://i.loli.net/2020/02/10/zUxOmSFQJLiyGMD.jpg" alt="fig1.jpg"></p><p><img src="https://i.loli.net/2020/02/10/o8L1DHgENfb2su7.jpg" alt="fig2.jpg"></p><pre><code>// 冒泡排序，a 表示数组，n 表示数组大小public void bubbleSort(int[] a, int n) {  if (n &lt;= 1) return; for (int i = 0; i &lt; n; ++i) {    // 提前退出冒泡循环的标志位，如果没有冒泡，说明已经有序了，不用再进行下去了    boolean flag = false;    // -i是因为在进行第i轮次的时候，最末尾的是已经排好了的i个数    for (int j = 0; j &lt; n - i - 1; ++j) {      if (a[j] &gt; a[j+1]) { // 交换        int tmp = a[j];        a[j] = a[j+1];        a[j+1] = tmp;        flag = true;  // 表示有数据交换            }    }    if (!flag) break;  // 没有数据交换，提前退出  }}</code></pre><ul><li>冒泡排序是原地排序算法，空间复杂度为O(1)</li><li>冒泡排序是稳定的排序算法</li><li>时间复杂度<ul><li>最好情况 O(n)</li><li>最坏情况 O(n^2)</li></ul></li></ul><h2 id="2-2-插入排序"><a href="#2-2-插入排序" class="headerlink" title="2.2 插入排序"></a>2.2 插入排序</h2><p>对于一个有序的数组来说，我们往里面添加一个新的数据，就是要遍历数组，找到数据应该插入的位置并将其插入即可。</p><p><img src="https://i.loli.net/2020/02/10/GIRQpFxgunetcr7.jpg" alt="fig3.jpg"></p><ul><li>将数组中的数据分为两个区间，已排序空间和未排序空间</li><li>初始已排序空间有一个元素，即数组的第一个元素</li><li>插入算法的核心思想是取未排序区间当中的元素，在已排序空间中找到合适的插入位置将其插入，并保证已排序空间的数据一致都是有序的</li><li>重复这个过程直到未排序空间中的元素为空</li></ul><p><img src="https://i.loli.net/2020/02/10/r9yq3FfdKginlQI.jpg" alt="fig4.jpg"></p><pre><code>// 插入排序，a 表示数组，n 表示数组大小public void insertionSort(int[] a, int n) {  if (n &lt;= 1) return;  for (int i = 1; i &lt; n; ++i) {    int value = a[i];    int j = i - 1;    // 查找插入的位置    for (; j &gt;= 0; --j) {      if (a[j] &gt; value) {        a[j+1] = a[j];  // 数据移动      } else {        break;      }    }    // 这里注意循环当中j--了，所以这里是a[j+1]    a[j+1] = value; // 插入数据  }}</code></pre><ul><li>原地排序算法，空间复杂度为O(1)</li><li>稳定的排序算法</li><li>时间复杂度<ul><li>最好情况O(n)</li><li>最坏情况O(n^2)</li></ul></li></ul><h2 id="2-3-选择排序"><a href="#2-3-选择排序" class="headerlink" title="2.3 选择排序"></a>2.3 选择排序</h2><p>同样是分成已排序空间和未排序空间，但是选择排序每次都会从未排序空间当中找到最小的元素，将其放到已排序区间的末尾</p><p><img src="https://i.loli.net/2020/02/10/uZH8xBFPs247nCr.jpg" alt="fig5.jpg"></p><ul><li><p>原地排序算法</p></li><li><p>不稳定的，因为每次都要找剩余的未排序的元素当中的最小值，并和前面的元素交换位置</p><p>  public int[] selectSort(int arr[], int n) {</p><pre><code>for (int i = 0; i &lt; n; i++) {  int index = min(i+1, n);   swap(arr[index], arr[i]);}</code></pre></li></ul><pre><code>  return arr;}</code></pre><h1 id="3-冒泡-插入-选择排序的比较"><a href="#3-冒泡-插入-选择排序的比较" class="headerlink" title="3. 冒泡 插入 选择排序的比较"></a>3. 冒泡 插入 选择排序的比较</h1><p>三者的平均时间复杂度均为O(n^2)。但是实际上还是有不同的，冒泡不如插入优秀，因为在循环当中，冒泡有三个操作，而插入只有一个。在实际情况当中，插入会比冒泡快不少。而选择排序的问题是因为它的逻辑是在未选择的数列里面选择最小的，放到已排序的末端，这里是一定会有一个swap发生的，这导致排序不稳定，即对于有相同值的，排列顺序可能会发生变化。这会在实际应用中造成问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;这里介绍三大类型的排序&lt;ul&gt;
&lt;li&gt;冒泡，插入，选择  O(n^2)&lt;/li&gt;
&lt;li&gt;快排，归并 O(nlogn)&lt;/li&gt;
&lt;li&gt;桶，计数，基数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;1-如何分析一个排序算法？&quot;&gt;&lt;a href
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://www.llchen60.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序" scheme="https://www.llchen60.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法(7)-递归</title>
    <link href="https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-7-%E9%80%92%E5%BD%92/"/>
    <id>https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-7-%E9%80%92%E5%BD%92/</id>
    <published>2020-02-09T17:47:26.000Z</published>
    <updated>2020-02-09T17:47:45.905Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-如何理解递归"><a href="#1-如何理解递归" class="headerlink" title="1.如何理解递归"></a>1.如何理解递归</h1><ul><li>递<ul><li>去的过程 </li></ul></li><li>归<ul><li>回来的过程</li></ul></li></ul><p>给我的感觉是先努力去溯源，拿到源数据以后就相当于多了一个信息，然后再依托多了一个的信息，来解决问题。</p><pre><code>f(n) = f(n-1) + 1 </code></pre><h1 id="2-递归的条件"><a href="#2-递归的条件" class="headerlink" title="2. 递归的条件"></a>2. 递归的条件</h1><ul><li>一个问题的解可以分解为几个子问题的解<ul><li>子问题指数据规模更小的解</li></ul></li><li>这个问题与分解之后的子问题，除了数据规模的不同，求解思路完全一样</li><li>存在递归终止条件</li></ul><h1 id="3-如何写递归代码"><a href="#3-如何写递归代码" class="headerlink" title="3. 如何写递归代码"></a>3. 如何写递归代码</h1><ul><li>写出递归公式</li><li>找到终止条件</li></ul><p>E.G </p><p>n个台阶，每次可以跨过1个或者2个，问一共多少种走法？ </p><ul><li>可以划分为子问题，即一共的走法等于我先走一步，剩下的n-1共同的走法和先走两步，剩下的n-1共同的走法的和。就有了一个递归公式：</li></ul><pre><code>f(n) = f(n-1) + f(n-2)</code></pre><p>终止条件，看最后几个corner case，只有一个台阶，只有两个台阶，然后用3，4来验证一下。</p><blockquote><p>写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲出终止条件，最终将递推公式和终止条件翻译成代码</p></blockquote><p>不要人为加大难度，遇到递归，抽象成一个递推公式，不再一层层的想其调用关系，不要试图用人脑去分解递归的步骤</p><p>分解子问题的时候，当我们将其分解成几个子问题B C D以后，我们要做的是在假设子问题 BCD都已经解决的前提下，思考如何解决问题A。这样子我们就可以思考问题A和子问题B,C,D两层之间的关系就可以了，不需要再一层一层往下思考更深的子问题之间的关系了。屏蔽掉递归的实现细节，我们理解起来就会容易很多了</p><h1 id="4-警惕堆栈溢出"><a href="#4-警惕堆栈溢出" class="headerlink" title="4. 警惕堆栈溢出"></a>4. 警惕堆栈溢出</h1><ul><li>递归容易堆栈溢出</li><li>函数调用会使用栈来保存临时变量，每调用一个函数，都会将临时变量封装为栈帧压入内存栈当中。等函数执行完成返回时，才出栈。</li><li>系统栈或者虚拟机栈空间都不大，如果递归层很多的话，那么就会有堆栈溢出的风险。</li><li>可以在代码中限制递归调用的最大深度来解决这个问题</li></ul><p>递归好处是表达能力强，很容易去理顺其想要表达的内容；坏处是空间复杂度会比较高，因为每次递归的时候都需要在内存栈中保存一次现场数据，所以在分析递归代码空间复杂度的时候，是需要额外考虑这部分的开销的。</p><h1 id="5-重复计算问题"><a href="#5-重复计算问题" class="headerlink" title="5. 重复计算问题"></a>5. 重复计算问题</h1><p>子步骤会被计算了很多很多遍，为了避免这种重复计算，可以使用一些数据结构来保存已经求解过得f(k)。当递归调用到f(k)的时候，先看下是否已经求解过了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-如何理解递归&quot;&gt;&lt;a href=&quot;#1-如何理解递归&quot; class=&quot;headerlink&quot; title=&quot;1.如何理解递归&quot;&gt;&lt;/a&gt;1.如何理解递归&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;递&lt;ul&gt;
&lt;li&gt;去的过程 &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;归&lt;u
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://www.llchen60.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="递归" scheme="https://www.llchen60.com/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法(6)-队列</title>
    <link href="https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-6-%E9%98%9F%E5%88%97/"/>
    <id>https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-6-%E9%98%9F%E5%88%97/</id>
    <published>2020-02-09T17:45:37.000Z</published>
    <updated>2020-02-09T17:45:58.480Z</updated>
    
    <content type="html"><![CDATA[<p>CPU资源有限，任务的处理速度和线程个数并不是线性正相关的。相反的，过多的线程会导致CPU频繁切换，处理性能下降。因此，线程池的大小一般都是综合考虑要处理任务的特点和硬件环境，来事先设置的。</p><p>当我们向固定大小的线程池中请求一个线程的时候，如果线程池中没有空闲资源，如何处理这个请求呢？ —–&gt; 队列</p><p>操作受限的线性表。</p><h1 id="1-理解队列"><a href="#1-理解队列" class="headerlink" title="1. 理解队列"></a>1. 理解队列</h1><ul><li>基本操作<ul><li>入队 enqueue()   入栈 push()</li><li>出队 dequeue()   出栈 pop()</li></ul></li><li>操作受限的线性表数据结构</li><li>带有一些特性的队列<ul><li>循环队列</li><li>阻塞队列</li><li>并发队列</li><li>顺序队列 - 数组实现</li><li>链式队列 - 链式队列</li></ul></li></ul><p>在很多偏底层系统，框架，中间件的开发当中，起到关键性作用。比如高性能disruptor,Linux环形缓存，都用到了循环并发队列; Java Concurrent并发包利用ArrayBlockingQueue来实现公平锁。</p><pre><code>// 用数组实现的队列public class ArrayQueue {  // 数组：items，数组大小：n  private String[] items;  private int n = 0;  // head 表示队头下标，tail 表示队尾下标  private int head = 0;  private int tail = 0;  // 申请一个大小为 capacity 的数组  public ArrayQueue(int capacity) {    items = new String[capacity];    n = capacity;  }  // 入队  public boolean enqueue(String item) {    // 如果 tail == n 表示队列已经满了    if (tail == n) return false;    items[tail] = item;    ++tail;    return true;  }  // 出队  public String dequeue() {    // 如果 head == tail 表示队列为空    if (head == tail) return null;    // 为了让其他语言的同学看的更加明确，把 -- 操作放到单独一行来写了    String ret = items[head];    ++head;    return ret;  }}</code></pre><h1 id="2-基于链表的队列实现方法"><a href="#2-基于链表的队列实现方法" class="headerlink" title="2. 基于链表的队列实现方法"></a>2. 基于链表的队列实现方法</h1><ul><li>两个指针<ul><li>head指针 - 指向第一个结点</li><li>tail指针 - 指向最后一个结点</li></ul></li></ul><h1 id="3-循环队列"><a href="#3-循环队列" class="headerlink" title="3. 循环队列"></a>3. 循环队列</h1><p>用数组实现的队列，在tail = n的时候，会有数据搬移操作。这样入队性能就会受到影响。循环队列的可以解决这个问题。</p><ul><li>如何确认队空和队满<ul><li>队空 head == tail</li><li>队满 (tail+1)%n = head</li></ul></li></ul><pre><code>public class CircularQueue {  // 数组：items，数组大小：n  private String[] items;  private int n = 0;  // head 表示队头下标，tail 表示队尾下标  private int head = 0;  private int tail = 0;  // 申请一个大小为 capacity 的数组  public CircularQueue(int capacity) {    items = new String[capacity];    n = capacity;  }  // 入队  public boolean enqueue(String item) {    // 队列满了    if ((tail + 1) % n == head) return false;    items[tail] = item;    tail = (tail + 1) % n;    return true;  }  // 出队  public String dequeue() {    // 如果 head == tail 表示队列为空    if (head == tail) return null;    String ret = items[head];    head = (head + 1) % n;    return ret;  }}</code></pre><h1 id="4-阻塞队列和并发队列"><a href="#4-阻塞队列和并发队列" class="headerlink" title="4. 阻塞队列和并发队列"></a>4. 阻塞队列和并发队列</h1><ul><li>阻塞队列<ul><li>在队列基础上增加了阻塞操作</li><li>队列为空的时候，从队头取数据会被阻塞</li><li>如果队列已经满了，那么插入数据的操作会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回</li><li>生产者 消费者模型  相当于</li><li>基于阻塞队列，我们可以通过协调生产者和消费者的个数来提高数据的处理效率</li><li>我们可以通过配置多几个的消费者，来应对一个生产者</li></ul></li><li>并发队列<ul><li>实现方法<ul><li>在enquue()和dequeue()方法上加锁</li><li>基于CAS原子操作</li></ul></li></ul></li></ul><h1 id="5-对比基于数组和基于链表实现的队列"><a href="#5-对比基于数组和基于链表实现的队列" class="headerlink" title="5. 对比基于数组和基于链表实现的队列"></a>5. 对比基于数组和基于链表实现的队列</h1><ul><li>基于链表的实现方式<ul><li>可以实现一个支持无限排队的无界队列</li><li>可能会导致过多的请求排队等待</li><li>请求处理的响应时间会长很多</li><li>因此对于响应时间比较敏感的系统来说，基于链表实现的无限排队的线程池就不是很合适了</li></ul></li><li>基于数组实现的有界队列<ul><li>队列大小是有限的</li><li>超过一定数量以后，请求就会被拒绝</li><li>队列的大小设置就会是个trade off了</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CPU资源有限，任务的处理速度和线程个数并不是线性正相关的。相反的，过多的线程会导致CPU频繁切换，处理性能下降。因此，线程池的大小一般都是综合考虑要处理任务的特点和硬件环境，来事先设置的。&lt;/p&gt;
&lt;p&gt;当我们向固定大小的线程池中请求一个线程的时候，如果线程池中没有空闲资
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://www.llchen60.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="队列" scheme="https://www.llchen60.com/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法(5)-栈</title>
    <link href="https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-5-%E6%A0%88/"/>
    <id>https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-5-%E6%A0%88/</id>
    <published>2020-02-09T17:44:43.000Z</published>
    <updated>2020-02-09T17:45:06.181Z</updated>
    
    <content type="html"><![CDATA[<p>大家都常用Chrome浏览器，你会发现在你做后退或者前进按钮时，浏览器的加载速度非常快，这里实际上是用的栈这个数据结构来进行处理的。</p><h1 id="1-对栈的理解"><a href="#1-对栈的理解" class="headerlink" title="1. 对栈的理解"></a>1. 对栈的理解</h1><ul><li>先进后出</li><li>操作受限的线性表，只允许在一端插入和删除数据</li><li>实质上栈的功能一定是可以被数组（顺序栈）或者链表（链式栈）来替代的，因为有拿第一个和最后一个的接口，或者说方式</li><li>用栈的好处是操作上的简单，更不容易出错一些</li><li>功能操作受限的线性表，栈可以通过数组或者链表来进行实现</li></ul><h1 id="2-支持动态扩容的顺序栈"><a href="#2-支持动态扩容的顺序栈" class="headerlink" title="2. 支持动态扩容的顺序栈"></a>2. 支持动态扩容的顺序栈</h1><ul><li>动态扩容 - load factor</li><li>顺序栈 - 数组</li></ul><p><img src="fig1.jpg" alt="fig1.jpg"></p><ul><li>注意动态扩容的顺序栈，出栈过程依然可以实现O(1)的时间复杂度，但是在入栈过程当中，如果空间不够了的话，那就需要实现整体的迁移，时间复杂度就变成了O(n)</li></ul><pre><code>// 基于数组实现的顺序栈public class ArrayStack {  private String[] items;  // 数组  private int count;       // 栈中元素个数  private int n;           //栈的大小  // 初始化数组，申请一个大小为n的数组空间  public ArrayStack(int n) {    this.items = new String[n];    this.n = n;    this.count = 0;  }  // 入栈操作  public boolean push(String item) {    // 数组空间不够了，直接返回false，入栈失败。    if (count == n) return false;    // 将item放到下标为count的位置，并且count加一    items[count] = item;    ++count;    return true;  }  // 出栈操作  public String pop() {    // 栈为空，则直接返回null    if (count == 0) return null;    // 返回下标为count-1的数组元素，并且栈中元素个数count减一    String tmp = items[count-1];    --count;    return tmp;  }}</code></pre><h1 id="3-栈的应用"><a href="#3-栈的应用" class="headerlink" title="3. 栈的应用"></a>3. 栈的应用</h1><ul><li>函数调用栈<ul><li>操作系统给每个线程分配一块独立的内存空间，这块内存被组织成栈这种结构，用来存储函数调用时的临时变量</li></ul></li><li>表达式求值<ul><li>计算机会用两个栈来实现</li><li>一个用来保存操作数</li><li>一个用来保存运算符<br>实际上，编译器就是通过两个栈来实现的。其中一个保存操作数的栈，另一个是保存运算符的栈。我们从左向右遍历表达式，当遇到数字，我们就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较。如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取 2 个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。<br><img src="fig2.jpg" alt="fig2.jpg"></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;大家都常用Chrome浏览器，你会发现在你做后退或者前进按钮时，浏览器的加载速度非常快，这里实际上是用的栈这个数据结构来进行处理的。&lt;/p&gt;
&lt;h1 id=&quot;1-对栈的理解&quot;&gt;&lt;a href=&quot;#1-对栈的理解&quot; class=&quot;headerlink&quot; title=&quot;1. 对
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://www.llchen60.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="栈" scheme="https://www.llchen60.com/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法(4)-链表</title>
    <link href="https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-4-%E9%93%BE%E8%A1%A8/"/>
    <id>https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-4-%E9%93%BE%E8%A1%A8/</id>
    <published>2020-02-09T06:48:48.000Z</published>
    <updated>2020-02-09T06:49:54.512Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-链表结构"><a href="#1-链表结构" class="headerlink" title="1. 链表结构"></a>1. 链表结构</h1><ul><li><p>数组需要一块连续的内存空间来存储，对内存的要求比较高</p></li><li><p>链表，通过指针将一组<strong>零散的内存块</strong>串联起来使用</p></li><li><p>链表经典应用场景 - LRU缓存淘汰算法</p><ul><li>缓存是一种提高数据读取性能的技术<ul><li>CPU缓存</li><li>数据库缓存</li><li>浏览器缓存</li></ul></li></ul></li></ul><h2 id="1-1-单链表"><a href="#1-1-单链表" class="headerlink" title="1.1 单链表"></a>1.1 单链表</h2><p><img src="https://i.loli.net/2020/02/09/Q9fFlx6ap5B47Mj.jpg" alt="fig1.jpg"></p><ul><li><p>每个链表的节点 </p><ul><li>存储的数据</li><li>记录链的下一个结点的地址(后继指针next)</li></ul></li><li><p>头结点用来记录链表的<strong>基地址</strong></p></li><li><p>尾结点的指针指向一个<strong>空地址NULL</strong></p></li><li><p>插入和删除结点都非常快 O(1)</p></li><li><p>随机访问其中一个元素，比如按照顺序选第n个就是O(n)的复杂度</p></li></ul><p><img src="https://i.loli.net/2020/02/09/h6maNKWveQnfgGP.jpg" alt="fig2.jpg"></p><h2 id="1-2-双向链表"><a href="#1-2-双向链表" class="headerlink" title="1.2 双向链表"></a>1.2 双向链表</h2><p><img src="https://i.loli.net/2020/02/09/rYhNQ1Zwp5klgVn.jpg" alt="fig4.jpg"></p><ul><li>双向链表支持两个方向，每个节点不止有一个后继指针next指向后面的结点，还有一个前驱指针prev指向前面的结点。</li><li>双向链表可以支持O(1) 的时间复杂度的情况下找到前驱结点，这样就使得双向链表在某些情况下的插入、删除等操作都要比单链表简单高效。</li><li>其实就是无论单链表还是双向链表，在删除的时候都需要找到前驱结点，而单链表在这里想要找到前驱结点的话就得从头开始去找，时间复杂度还是O(n)，而双向链表就可以实现很快的找到对应的前驱节点了。</li><li>因为有prev next两个指针，它黄海军更占用内存的空间</li><li>Java的LinkedHashMap就是用双向链表来实现的</li><li>用空间换时间的设计思想<ul><li>当内存空间充足的时候，如果我们更追求代码的执行速度，那么我们就可以选择空间复杂度相对较高，但时间复杂度相对很低的算法或者数据结构。 </li></ul></li><li>对于有序链表来说，双向链表的按值查询效率也要比单链表高。因为我们可以通过记录上次查找的位置p，每次查询的时候，根据要查找的值和p的大小关系决定是往前还是往后来查找。</li></ul><h2 id="1-3-循环链表"><a href="#1-3-循环链表" class="headerlink" title="1.3 循环链表"></a>1.3 循环链表</h2><p><img src="https://i.loli.net/2020/02/09/BLOXWHUgpeJoQGh.jpg" alt="fig3.jpg"></p><ul><li>循环链表的尾结点指针是指向链表的头结点，像一个环一样首尾相连</li><li>当要处理的数据具有<strong>环形结构特点</strong>时，就特别适合采用循环链表。</li></ul><h1 id="2-链表数组性能对比"><a href="#2-链表数组性能对比" class="headerlink" title="2.链表数组性能对比"></a>2.链表数组性能对比</h1><table><thead><tr><th>时间复杂度</th><th>数组</th><th>链表</th></tr></thead><tbody><tr><td>插入删除</td><td>O(n)</td><td>O(1)</td></tr><tr><td>随机访问</td><td>O(1)</td><td>O(n)</td></tr></tbody></table><p>但是在实际应用开发当中，不能仅仅利用复杂度分析就决定使用哪个数据结构来存储数据。</p><p>数组简单易用，在实现上使用的是连续的内存空间，可以借助CPU的缓存机制，预读数组中的数据，所以访问效率更高。而链表因为不是连续内存存储，所以没办法有效预读。</p><p>数组大小固定，增大如果要做扩容拷贝是非常费时间的。链表本身没有大小的限制，天然支持动态扩容。</p><p>而且，如果代码对于内存的使用很苛刻，那数组会更加合适。因为链表中的每个结点都要消耗额外的存储空间去存储指针，所以内存的消耗会翻倍。而且，对链表进行频繁的插入，删除操作还会导致频繁的内存申请和释放，容易造成内存碎片。Java中就会导致频繁的garbage collection. </p><h1 id="3-写链表代码的技巧"><a href="#3-写链表代码的技巧" class="headerlink" title="3. 写链表代码的技巧"></a>3. 写链表代码的技巧</h1><h2 id="3-1-理解指针或者引用的含义"><a href="#3-1-理解指针或者引用的含义" class="headerlink" title="3.1 理解指针或者引用的含义"></a>3.1 理解指针或者引用的含义</h2><p>指针，是在像C语言这样的语言当中来使用的；对于Java这种面向对象的语言，是用引用来达成存储所指对象的内存地址的目的。</p><p>将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就可以找到这个变量了。</p><pre><code>// p结点的next指针里面存储了q结点的内存地址p-&gt;next = q// p 结点的next指针存储了p结点的下下个结点的内存地址p-&gt;next = p-&gt;next-&gt;next</code></pre><h2 id="3-2-警惕指针丢失和内存泄露"><a href="#3-2-警惕指针丢失和内存泄露" class="headerlink" title="3.2 警惕指针丢失和内存泄露"></a>3.2 警惕指针丢失和内存泄露</h2><p><img src="https://i.loli.net/2020/02/09/ASXEJ4ZYzf6lmrH.jpg" alt="fig5.jpg"></p><pre><code>x-&gt;next = p-&gt;next;  // 将 x 的结点的 next 指针指向 b 结点；p-&gt;next = x;  // 将 p 的 next 指针指向 x 结点；</code></pre><p>两行代码的顺序很重要，你需要先将p的next的地址赋给x的next的地址，然后再来改p的next，改变p的next指针</p><h2 id="3-3-利用哨兵"><a href="#3-3-利用哨兵" class="headerlink" title="3.3 利用哨兵"></a>3.3 利用哨兵</h2><p>对于链表当中的第一个结点和最后一个结点，其实现插入删除的逻辑和其他结点是不一样的。</p><p>利用哨兵结点可以简化整个实现，让针对于第一个结点和最后一个结点的处理和其他结点的处理方式一致。</p><p><img src="https://i.loli.net/2020/02/09/A43BtwNSuvhMy7n.jpg" alt="fig6.jpg"></p><h2 id="3-4-边界条件的思考与判定"><a href="#3-4-边界条件的思考与判定" class="headerlink" title="3.4 边界条件的思考与判定"></a>3.4 边界条件的思考与判定</h2><ul><li>链表为空</li><li>链表只包含一个结点</li><li>链表只包含两个结点</li><li>代码逻辑在处理头结点和尾结点的时候</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-链表结构&quot;&gt;&lt;a href=&quot;#1-链表结构&quot; class=&quot;headerlink&quot; title=&quot;1. 链表结构&quot;&gt;&lt;/a&gt;1. 链表结构&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;数组需要一块连续的内存空间来存储，对内存的要求比较高&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://www.llchen60.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LinkedList" scheme="https://www.llchen60.com/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法(3)-数组</title>
    <link href="https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-3-%E6%95%B0%E7%BB%84/"/>
    <id>https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-3-%E6%95%B0%E7%BB%84/</id>
    <published>2020-02-09T06:46:35.000Z</published>
    <updated>2020-02-09T06:46:53.794Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-什么是数组"><a href="#1-什么是数组" class="headerlink" title="1. 什么是数组"></a>1. 什么是数组</h1><ul><li>是一种<strong>线性表</strong>数据结构，用一组<strong>连续的内存空间</strong>，来存储一组具有<strong>相同类型</strong>的数据</li><li>线性表<ul><li>数据排成了线性的结构</li><li>每个线性表上的数据只有前后两个方向</li><li>除了数组，链表、队列、栈等也是线性表结构</li></ul></li><li>非线性表<ul><li>比如说二叉树，堆，图等  他们的数据之间不是简单的前后关系了 </li></ul></li><li>连续内存空间与相同类型的数据<ul><li>正因为有这个特征其才可以进行随机访问</li><li>但是这也导致了想要在数组当中删除，插入一个数据，为了保证连续性，就需要做大量的数据搬移工作</li><li>数组非常适合根据下标来进行访问</li></ul></li><li>线性表 - 数组<ul><li>表中的数据只有前后两个方向</li><li>数组，链表，队列，栈都是线性表结构</li></ul></li><li>非线性表<ul><li>二叉树，堆，图</li><li>数据之间并不是简单的前后关系</li></ul></li></ul><h1 id="2-数组的插入，删除，随机访问"><a href="#2-数组的插入，删除，随机访问" class="headerlink" title="2. 数组的插入，删除，随机访问"></a>2. 数组的插入，删除，随机访问</h1><ul><li>插入，删除<ul><li>在k位置做操作，那么对于k位置之后的k - n都是需要做移位的 </li></ul></li><li>删除的优化<ul><li>避免每次删除都直接的搬移数据</li><li>先记录下已经删除的数据</li><li>每次删除操作并不是真正搬移数据，只是记录数据已经被删除了</li><li>当数组没有更多空间存储了以后，再触发执行一次真正的删除操作</li><li>通过这种方式大大减少了删除操作导致的数据搬移</li><li>—–&gt; JVM标记清除垃圾回收算法</li></ul></li></ul><h1 id="3-数组的访问越界问题"><a href="#3-数组的访问越界问题" class="headerlink" title="3. 数组的访问越界问题"></a>3. 数组的访问越界问题</h1><pre><code>int main(int argc, char* argv[]){    int i = 0;    int arr[3] = {0};    for(; i&lt;=3; i++){        arr[i] = 0;        printf(&quot;hello world\n&quot;);    }    return 0;}</code></pre><p>当i=3的时候，访问越界。在C语言当中，只要不是访问受限的内存，内存空间都是可以自由访问的。a[3]会被定位到某块不属于数组的内存地址上，而这个地址正好是存储变量i的内存地址，那么arr[3] = 0 就相当于 i=0，因此会导致代码无限循环。</p><p>对这里的无限循环的解释：函数体内的局部变量存在栈上，且是连续压栈。在Linux进程的内存布局中，栈区在高地址空间，从高向低增长。变量i和arr在相邻地址，且i比arr的地址大，所以arr越界正好访问到i。当然，前提是i和arr元素同类型，否则那段代码仍是未决行为。</p><p>数组越界是一种未决行为，并没有规定数组访问越界时编译器应该如何处理。因为，访问数组的本质就是访问一段连续内存，只要数组通过偏移计算得到的内存地址是可用的，那么程序就可能不会报任何错误。</p><p>Java做了封装，会判断出数组越界的行为，并throw exception。</p><h1 id="4-容器-vs-数组"><a href="#4-容器-vs-数组" class="headerlink" title="4. 容器 vs 数组"></a>4. 容器 vs 数组</h1><p>容器，譬如Java中的ArrayList，最大优势是可以将许多数组操作细节封装起来。另外，其支持动态扩容。动态扩容很耗时的，因为牵扯到内存申请，还有整体的数据搬移。因此如果能确定需要村塾的数据的大小，最好<strong>在创建Arraylist的时候事先指定好</strong></p><ul><li>使用数组的情况<ul><li>ArrayList 无法存储基本类型，需要封装，autoBoxing, unboxing本身是有一定的性能消耗的，如果特别关注性能，那么我们就需要用数组</li><li>如果数组大小已知，并且对数据的操作很简单。不需要使用ArrayList所提供的大部分的方法，那么我们可以直接使用数组</li><li>多维数组的表示会更为直观一些</li></ul></li></ul><h1 id="5-为什么数组要从0开始编号？"><a href="#5-为什么数组要从0开始编号？" class="headerlink" title="5. 为什么数组要从0开始编号？"></a>5. 为什么数组要从0开始编号？</h1><p>因为下标最确切的定义是偏移，offset。要算a[k]的内存地址的公式为：</p><pre><code>a[k]_address = base_address + k * type_size</code></pre><p>如果我们从1开始计数，那么我们计算位置的公式就会变成：</p><pre><code>a[k]_address = base_address + (k-1)*type_size</code></pre><p>这样每次访问都会多一次减法运算！！！对于CPU来说，就是多了一次减法指令。从0开始就是为了提高效率，当然这个效率的提升其实很小，也有一大部分是历史原因了，即不同语言的迁移之间的学习成本。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-什么是数组&quot;&gt;&lt;a href=&quot;#1-什么是数组&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是数组&quot;&gt;&lt;/a&gt;1. 什么是数组&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;是一种&lt;strong&gt;线性表&lt;/strong&gt;数据结构，用一组&lt;strong&gt;连续的
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://www.llchen60.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Array" scheme="https://www.llchen60.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法(2)-复杂度分析</title>
    <link href="https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-2-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"/>
    <id>https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-2-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/</id>
    <published>2020-02-09T06:41:40.000Z</published>
    <updated>2020-02-09T06:42:03.983Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-为什么需要复杂度分析？"><a href="#1-为什么需要复杂度分析？" class="headerlink" title="1. 为什么需要复杂度分析？"></a>1. 为什么需要复杂度分析？</h1><p>通过统计和监控得到的算法执行时间的占用的内存的大小的方法称为事后统计法，这种方法有其局限性：</p><ul><li>测试结果非常依赖于测试环境</li><li>测试结果受数据规模的影响很大, 而且会和数据集本身的数据质量有关</li><li>—-&gt; 因此我们需要一个不用具体的测试数据来测试，就可以粗略估计算法的执行效率的方法</li></ul><h1 id="2-大O复杂度表示法"><a href="#2-大O复杂度表示法" class="headerlink" title="2. 大O复杂度表示法"></a>2. 大O复杂度表示法</h1><ul><li>假定每行代码执行时间都一样</li><li>并不表示具体的代码执行时间，而是表示执行时间随着数据规模增大的变化趋势，因此也叫做渐进时间复杂度。</li></ul><h1 id="3-如何分析代码的时间复杂度"><a href="#3-如何分析代码的时间复杂度" class="headerlink" title="3. 如何分析代码的时间复杂度"></a>3. 如何分析代码的时间复杂度</h1><ul><li>只关注循环执行次数最多的一段代码</li><li>加法原则：总复杂度等于量级最大的那段代码的复杂度</li><li>乘法法则： 嵌套代码的复杂度等于签到内外层代码复杂度的乘积</li></ul><h1 id="4-复杂度量级"><a href="#4-复杂度量级" class="headerlink" title="4. 复杂度量级"></a>4. 复杂度量级</h1><ul><li>常量阶 O(1)</li><li>对数阶 O(logn)</li><li>线性阶 O(n)<ul><li>O (m+n) 当我们不知道几个变量的大小的时候 </li></ul></li><li>线性对数阶 O(nlogn)</li><li>平方阶 O(n^2)<ul><li>O (m*n) 乘法关系，不知道参量之间的相对大小 </li></ul></li><li>k次方阶 O(n^k)</li><li>指数阶 O(2^n)</li><li>阶乘阶 O(n!)</li></ul><h1 id="5-空间复杂度分析"><a href="#5-空间复杂度分析" class="headerlink" title="5. 空间复杂度分析"></a>5. 空间复杂度分析</h1><p>空间复杂度的全程是渐进空间复杂度，表示算法的存储空间与数据规模之间的增长关系。</p><p>大O时间复杂度，并不具体表示代码真正的执行时间，而是表示代码执行时间随着数据规模的增大的变化趋势。因此也叫做渐进时间复杂度，(asymptotic time complexity)</p><pre><code>T(n) = O(f(n))</code></pre><p>T(n) - 代码的执行时间<br>n - 数据规模的大小<br>f(n) - 每行代码执行的次数总和<br>O - 表示左右成正比</p><h2 id="5-1-Tips"><a href="#5-1-Tips" class="headerlink" title="5.1 Tips"></a>5.1 Tips</h2><ul><li>只关注循环执行次数最多的一段代码</li><li>总复杂度等于量级最大的那段代码的复杂度</li><li>嵌套代码的复杂度为嵌套内外代码复杂度的乘积</li></ul><h1 id="6-复杂度的分析"><a href="#6-复杂度的分析" class="headerlink" title="6. 复杂度的分析"></a>6. 复杂度的分析</h1><h2 id="6-1-时间复杂度分析"><a href="#6-1-时间复杂度分析" class="headerlink" title="6.1 时间复杂度分析"></a>6.1 时间复杂度分析</h2><h3 id="6-1-1-多项式量级"><a href="#6-1-1-多项式量级" class="headerlink" title="6.1.1 多项式量级"></a>6.1.1 多项式量级</h3><ul><li>O(1) <ul><li>常量级的代码，我们将其时间复杂度都记作O(1)</li></ul></li><li>O(logn)</li></ul><pre><code> i=1; while (i &lt;= n)  {   i = i * 2; }</code></pre><ul><li>O(nlogn)</li><li>O(m+n)</li><li>O(m*n)</li></ul><h3 id="6-1-2-非多项式量级"><a href="#6-1-2-非多项式量级" class="headerlink" title="6.1.2 非多项式量级"></a>6.1.2 非多项式量级</h3><p>非常低效，会随着n的增长急剧增长，因此我们应当尽量不选择有如下时间复杂度的算法</p><ul><li>O(2^n) </li><li>O(n!)</li></ul><h2 id="6-2-空间复杂度分析"><a href="#6-2-空间复杂度分析" class="headerlink" title="6.2 空间复杂度分析"></a>6.2 空间复杂度分析</h2><p>渐进空间复杂度，表示算法的存储空间和数据规模之间的增长关系。</p><p>一般来说在O(1), O(n), O(n^2)这几个可能性上面</p><h1 id="7-浅析最好、最坏、平均、均摊时间复杂度"><a href="#7-浅析最好、最坏、平均、均摊时间复杂度" class="headerlink" title="7. 浅析最好、最坏、平均、均摊时间复杂度"></a>7. 浅析最好、最坏、平均、均摊时间复杂度</h1><pre><code>// n 表示数组 array 的长度int find(int[] array, int n, int x) {  int i = 0;  int pos = -1;  for (; i &lt; n; ++i) {    if (array[i] == x) {       pos = i;       break;    }  }  return pos;}</code></pre><h2 id="7-1-最好情况时间复杂度-best-case-time-complexity"><a href="#7-1-最好情况时间复杂度-best-case-time-complexity" class="headerlink" title="7.1 最好情况时间复杂度(best case time complexity)"></a>7.1 最好情况时间复杂度(best case time complexity)</h2><p>上面这段代码，最好情况是O(1)</p><h2 id="7-2-最坏情况时间复杂度-worst-case-time-complexity"><a href="#7-2-最坏情况时间复杂度-worst-case-time-complexity" class="headerlink" title="7.2 最坏情况时间复杂度(worst case time complexity)"></a>7.2 最坏情况时间复杂度(worst case time complexity)</h2><p>上面这段代码，最坏情况是O(n)</p><h2 id="7-3-平均情况时间复杂度-average-case-time-complexity"><a href="#7-3-平均情况时间复杂度-average-case-time-complexity" class="headerlink" title="7.3 平均情况时间复杂度(average case time complexity)"></a>7.3 平均情况时间复杂度(average case time complexity)</h2><p>需要算上发生的概率</p><p>上述例子当中，因为要查找变量x在数组当中的位置，一共有n+1种情况，在数组的0 - n-1位置中和不在数组当中。将每种情况下，需要遍历的元素个数累加起来，再除以n+1,就可以得到需要遍历的元素个数的平均值了 </p><p>即</p><pre><code>(1+2+3+ ... + n + n) / (n+1) = n(n+3)/(2(n+1))</code></pre><p>故平均复杂度还是O(n)</p><p>然而还要考虑每种情况下 发生的概率实质上是不同的，需要将这个算上</p><h2 id="7-4-均摊时间复杂度-amortized-time-complexity"><a href="#7-4-均摊时间复杂度-amortized-time-complexity" class="headerlink" title="7.4 均摊时间复杂度(amortized time complexity)"></a>7.4 均摊时间复杂度(amortized time complexity)</h2><p>不是遍历case，而是有轮回的，因此算一个轮回里的时间就可以得出平均复杂度了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-为什么需要复杂度分析？&quot;&gt;&lt;a href=&quot;#1-为什么需要复杂度分析？&quot; class=&quot;headerlink&quot; title=&quot;1. 为什么需要复杂度分析？&quot;&gt;&lt;/a&gt;1. 为什么需要复杂度分析？&lt;/h1&gt;&lt;p&gt;通过统计和监控得到的算法执行时间的占用的内存的大
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://www.llchen60.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="复杂度分析" scheme="https://www.llchen60.com/tags/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法(1)-概述</title>
    <link href="https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-1-%E6%A6%82%E8%BF%B0/"/>
    <id>https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-1-%E6%A6%82%E8%BF%B0/</id>
    <published>2020-02-09T06:39:44.000Z</published>
    <updated>2020-02-09T06:40:41.488Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-为什么要学习数据结构与算法？"><a href="#1-为什么要学习数据结构与算法？" class="headerlink" title="1. 为什么要学习数据结构与算法？"></a>1. 为什么要学习数据结构与算法？</h1><p>入职已经快1年的时间了，自己在这一年中确实有很多收获，涨了很多架构上的知识，对于工程上的代码流程有了更深一步的了解。不过愈发感觉到数据结构与算法的重要性，因为在服务出现bug的时候，除了业务逻辑上的问题，剩下的大部分都是数据结构操作上的一些问题，比如常见的Index out of bound，诸如此类。</p><p>我想与其说数据结构与算法是进入大厂的敲门砖，不如说二者是一个优秀工程师和一个CRUD 男孩的分水岭。很多时候，对于基础的理解决定了你的上限，要知道底层的知识是相通的，我们看到的很多现在的新兴技术，实际上底子上还是用的那些十年前，二十年前的理念。学习数据结构与算法，可以算得上是想要去掌握一把屠龙刀。无论遇到什么，庖丁解牛一般。</p><p>在工业界，讲道理对于业务工程师来说，大部分时间都在使用封装好的接口，类库，并翻译业务逻辑，很少需要自己实现数据结构和算法。但是，不用自己实现不代表不需要去了解。</p><p>依旧需要知道这背后的原理；需要懂得分析时间、空间的复杂度；需要能够分辨出几个相似的数据结构的不同；调用了某个函数之后，需要知道如何评估代码的性能和资源的消耗。</p><p>学习数据结构与算法，是为了让自己有能够成长起来的油/ 源。</p><h1 id="2-如何学习？"><a href="#2-如何学习？" class="headerlink" title="2. 如何学习？"></a>2. 如何学习？</h1><p>首先，数据结构与算法的关系是：数据结构为算法服务，而算法要作用在特定的数据结构之上。</p><p>数据结构是静态的，是组织数据的一种方式。我们需要在其基础上操作、构建算法，孤立存在的数据结构是没用的。</p><ul><li>复杂度分析<ul><li>数据结构与算法是解决如何更省，更快的存储和处理数据的问题</li><li>复杂度分析就是对应的考量效率和资源消耗的方法</li></ul></li></ul><p><img src="https://i.loli.net/2020/02/09/LTqyj9aMOQsXw8U.jpg" alt="fig1.png"></p><ul><li>数据结构算法树状图<ul><li>复杂度分析<ul><li>空间复杂度</li><li>时间复杂度<ul><li>最好</li><li>最坏</li><li>平均</li><li>均摊</li></ul></li></ul></li><li>基本算法思想<ul><li>贪心</li><li>分治</li><li>动态规划</li><li>回溯</li><li>枚举</li></ul></li><li>排序<ul><li>O(n^2)<ul><li>冒泡排序</li><li>插入排序</li><li>选择排序</li><li>希尔排序</li></ul></li><li>O(nlogn)<ul><li>归并排序</li><li>快速排序</li><li>堆排序</li></ul></li><li>O(n)<ul><li>计数排序</li><li>基数排序</li><li>桶排序</li></ul></li></ul></li><li>搜索<ul><li>深度优先搜索</li><li>广度优先搜索</li><li>A启发式搜索</li></ul></li><li>查找<ul><li>线性表查找</li><li>树结构查找</li><li>散列表查找</li></ul></li><li>字符串匹配<ul><li>朴素</li><li>KMP</li><li>Robin-Karp</li><li>Boyer-Moore</li><li>AC自动机</li><li>Trie</li><li>后缀数组</li></ul></li><li>图<ul><li>存储<ul><li>邻接矩阵</li><li>邻接表</li></ul></li><li>拓扑排序</li><li>最短路径</li><li>关键路径</li><li>最小生成树</li><li>二分图</li><li>最大流</li></ul></li><li>树<ul><li>二叉树<ul><li>平衡二叉树</li><li>二叉查找树</li><li>平衡二叉查找树<ul><li>AVL树</li><li>红黑树</li></ul></li><li>完全二叉树</li><li>满二叉树</li></ul></li><li>多路查找树<ul><li>B 树</li><li>B+ 树</li><li>2-3 树</li><li>2-3-4 树</li></ul></li><li>堆<ul><li>小顶堆</li><li>大顶堆</li><li>优先级队列</li><li>斐波那契堆</li><li>二项堆</li></ul></li><li>其他<ul><li>梨形数组</li><li>线段树</li></ul></li></ul></li><li>散列表<ul><li>散列函数</li><li>冲突解决<ul><li>链表法</li><li>开放寻址</li><li>其他</li></ul></li><li>动态扩容</li><li>位图</li></ul></li><li>线性表<ul><li>数组</li><li>链表<ul><li>单链表</li><li>双向链表</li><li>循环链表</li><li>双向循环链表</li><li>静态链表</li></ul></li><li>栈<ul><li>顺序栈</li><li>链式栈</li></ul></li><li>队列<ul><li>普通队列</li><li>双端队列</li><li>阻塞队列</li><li>并发队列</li><li>阻塞并发队列</li></ul></li></ul></li></ul></li></ul><h2 id="2-1-最常用的基础总结"><a href="#2-1-最常用的基础总结" class="headerlink" title="2.1 最常用的基础总结"></a>2.1 最常用的基础总结</h2><ul><li>数据结构<ul><li>数组</li><li>链表</li><li>栈</li><li>队列</li><li>散列表</li><li>二叉树</li><li>堆</li><li>跳表</li><li>图</li><li>Trie树</li></ul></li><li>算法<ul><li>递归</li><li>排序</li><li>二分查找</li><li>搜索</li><li>哈希算法</li><li>贪心算法</li><li>分治算法</li><li>回溯算法</li><li>动态规划</li><li>字符串匹配算法</li></ul></li></ul><p>对于数据结构和算法，要学习的是：</p><ul><li>其自身来历</li><li>特点</li><li>适合解决的问题</li><li>实际的应用场景</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-为什么要学习数据结构与算法？&quot;&gt;&lt;a href=&quot;#1-为什么要学习数据结构与算法？&quot; class=&quot;headerlink&quot; title=&quot;1. 为什么要学习数据结构与算法？&quot;&gt;&lt;/a&gt;1. 为什么要学习数据结构与算法？&lt;/h1&gt;&lt;p&gt;入职已经快1年的时间了，
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://www.llchen60.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>后端开发实践-项目模板</title>
    <link href="https://www.llchen60.com/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5-%E9%A1%B9%E7%9B%AE%E6%A8%A1%E6%9D%BF/"/>
    <id>https://www.llchen60.com/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5-%E9%A1%B9%E7%9B%AE%E6%A8%A1%E6%9D%BF/</id>
    <published>2020-02-09T06:26:51.000Z</published>
    <updated>2020-02-09T06:27:26.585Z</updated>
    
    <content type="html"><![CDATA[<p>整理出一套公共性的项目模板，旨在尽量多地包含日常开发所需，减少开发者的重复性工作以及提供一些最佳实践。</p><h1 id="1-从写好README开始"><a href="#1-从写好README开始" class="headerlink" title="1. 从写好README开始"></a>1. 从写好README开始</h1><p>一个好的README给人以项目概览，可以使新人快速上手项目，并降低沟通成本，建议包括：</p><ul><li>项目简介<ul><li>一两句话描述该项目实现的业务功能</li></ul></li><li>技术选型<ul><li>项目的技术栈，包括语言，框架，中间件等</li></ul></li><li>本地构建<ul><li>列出本地开发过程中所用到的工具命令</li></ul></li><li>领域模型<ul><li>核心的领域概念，针对于当前系统所在的领域</li></ul></li><li>测试策略<ul><li>自动化测试如何分类</li></ul></li><li>技术架构<ul><li>技术架构图</li></ul></li><li>部署架构<ul><li>部署架构图</li></ul></li><li>外部依赖<ul><li>项目运行时所以来的外部集成方</li></ul></li><li>环境信息<ul><li>各个环境的访问方式，数据库连接</li></ul></li><li>编码实践<ul><li>统一的编码实践，比如异常处理原则，分页封装等</li></ul></li><li>FAQ<ul><li>开发过程中常见问题的解答</li></ul></li></ul><p>注意保持README的持续更新，一些重要的架构决定可以通过示例代码的形式记录在代码块当中，新开发者可以通过直接阅读这些示例代码快速了解项目的通用实践方式以及架构选择</p><h1 id="2-一键式本地构建"><a href="#2-一键式本地构建" class="headerlink" title="2. 一键式本地构建"></a>2. 一键式本地构建</h1><p>写一个必需的script，自动化完成本地构建的过程</p><ul><li><code>run.sh</code> 进行本地调试或者必要的手动测试</li><li><code>local-build.sh</code>，完成本地构建</li></ul><h1 id="3-日志处理"><a href="#3-日志处理" class="headerlink" title="3. 日志处理"></a>3. 日志处理</h1><ul><li>在日志中加入请求标识，便于链路追踪。在处理一个请求的过程中有时会输出多条日志，如果每条日志都共享统一的请求ID，那么在日志追踪时会更加方便。此时，可以使用Logback原生提供的MDC(Mapped Diagnostic Context)功能，创建一个RequestIdMdcFilter</li></ul><pre><code>    protected void doFilterInternal(HttpServletRequest request,                                HttpServletResponse response,                                FilterChain filterChain)        throws ServletException, IOException {    //request id in header may come from Gateway, eg. Nginx    String headerRequestId = request.getHeader(HEADER_X_REQUEST_ID);    MDC.put(REQUEST_ID, isNullOrEmpty(headerRequestId) ? newUuid() : headerRequestId);    try {        filterChain.doFilter(request, response);    } finally {        clearMdc();    }}</code></pre><ul><li>集中式日志管理，在多节点部署的场景下，各个节点的日志是分散的，为此可以引入诸如ELK之类的工具将日志统一输出到ElasticSearch中。</li></ul><pre><code>&lt;appender name=&quot;REDIS&quot; class=&quot;com.cwbase.logback.RedisAppender&quot;&gt;&lt;tags&gt;ecommerce-order-backend-${ACTIVE_PROFILE}&lt;/tags&gt;&lt;host&gt;elk.yourdomain.com&lt;/host&gt;&lt;port&gt;6379&lt;/port&gt;&lt;password&gt;whatever&lt;/password&gt;&lt;key&gt;ecommerce-ordder-log&lt;/key&gt;&lt;mdc&gt;true&lt;/mdc&gt;&lt;type&gt;redis&lt;/type&gt;&lt;/appender&gt;</code></pre><h1 id="4-异常处理"><a href="#4-异常处理" class="headerlink" title="4. 异常处理"></a>4. 异常处理</h1><p>在设计异常处理的框架的时候，需要考虑到： </p><ul><li>向客户端提供格式统一的异常返回</li><li>异常信息中应该包含足够多的上下文信息，最好是结构化的数据以便于客户端解析</li><li>不同类型的异常应该包含唯一标识，以便客户端精确识别</li></ul><p>异常处理有两种处理形式，一种是层级式，即每种具体的异常都对应了一个异常类，这些类最终继承自某个父异常；另外一种是单一式，即整个程序中只有一个异常类，再以一个字段来区分不同的异常场景。层级式异常的好处能够显化异常的含义，但是如果设计不好可能会导致程序中大量的异常类。</p><p>使用层级式异常的范例：</p><pre><code>public abstract class AppException extends RuntimeException {    private final ErrorCode code;    private final Map&lt;String, Object&gt; data = newHashMap();}</code></pre><p>这里，ErrorCode枚举中包含了异常的唯一标识、HTTP状态码以及错误信息；而data字段表示各个异常的上下文信息。</p><pre><code>public class OrderNotFoundException extends AppException {    public OrderNotFoundException(OrderId orderId) {        super(ErrorCode.ORDER_NOT_FOUND, ImmutableMap.of(&quot;orderId&quot;, orderId.toString()));    }}</code></pre><p>在返回给客户端的时候，通过一个ErrorDetail类来统一异常格式：</p><pre><code>public final class ErrorDetail {    private final ErrorCode code;    private final int status;    private final String message;    private final String path;    private final Instant timestamp;    private final Map&lt;String, Object&gt; data = newHashMap();}</code></pre><p>最终返回给客户端的数据为：</p><pre><code>{  requestId: &quot;d008ef46bb4f4cf19c9081ad50df33bd&quot;,  error: {    code: &quot;ORDER_NOT_FOUND&quot;,    status: 404,    message: &quot;没有找到订单&quot;,    path: &quot;/order&quot;,    timestamp: 1555031270087,    data: {      orderId: &quot;123456789&quot;    }  }}</code></pre><h1 id="5-统一代码风格"><a href="#5-统一代码风格" class="headerlink" title="5. 统一代码风格"></a>5. 统一代码风格</h1><p>除了Checkstyle以外，项目中有些通用的公共编码实践方式也需要进行统一。</p><ul><li>客户端的请求数据类统一使用相同后缀，比如Command</li><li>返回给客户端的数据统一使用相同后缀，比如Represetation</li><li>统一对请求处理的流程框架，比如采用传统的3层架构或者DDD战术模式</li><li>提供一致的异常返回（请参考“异常处理”小节）</li><li>提供统一的分页结构类</li><li>明确测试分类以及统一的测试基础类（请参考“自动化测试分类”小节）<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1></li></ul><p><a href="https://insights.thoughtworks.cn/backend-development-iteration0/" target="_blank" rel="noopener">https://insights.thoughtworks.cn/backend-development-iteration0/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;整理出一套公共性的项目模板，旨在尽量多地包含日常开发所需，减少开发者的重复性工作以及提供一些最佳实践。&lt;/p&gt;
&lt;h1 id=&quot;1-从写好README开始&quot;&gt;&lt;a href=&quot;#1-从写好README开始&quot; class=&quot;headerlink&quot; title=&quot;1. 从写好R
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="项目模板" scheme="https://www.llchen60.com/tags/%E9%A1%B9%E7%9B%AE%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>XML与JSON的比较</title>
    <link href="https://www.llchen60.com/XML%E4%B8%8EJSON%E7%9A%84%E6%AF%94%E8%BE%83/"/>
    <id>https://www.llchen60.com/XML%E4%B8%8EJSON%E7%9A%84%E6%AF%94%E8%BE%83/</id>
    <published>2020-02-09T06:25:58.000Z</published>
    <updated>2020-02-09T06:26:25.494Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-JSON"><a href="#1-JSON" class="headerlink" title="1. JSON"></a>1. JSON</h1><p>JSON - JavaScript Object Notation, an open standard file format uses human-readable text to transmit data objects consisting of attribute–value pairs and array data types (or any other serializable value). It is a very common data format used for asynchronous browser–server communication, including as a replacement for XML in some AJAX-style systems.</p><p>The official Internet media type for JSON is <strong>application/json</strong>. </p><h1 id="2-XML"><a href="#2-XML" class="headerlink" title="2. XML"></a>2. XML</h1><p>JSON is promoted as a <strong>low-overhead alternative</strong> to XML as both of these formats have widespread support for creation, reading, and decoding in the real-world situations where they are commonly used.</p><p>XML has been used to <strong>describe structured data and to serialize objects</strong>. Various XML-based protocols exist to represent the same kind of data structures as JSON for the same kind of data interchange purposes. Data can be encoded in XML in several ways. The most expansive form <strong>using tag pairs results</strong> in a much larger representation than JSON, but if data is stored in attributes and ‘short tag’ form where the closing tag is replaced with ‘/&gt;’, the representation is often about the same size as JSON or just a little larger. If the data is compressed <strong>using an algorithm like gzip</strong>, there is little difference because compression is good at saving space when a pattern is repeated.</p><p>XML also has the concept of <strong>++schema++</strong>. <strong>This permits strong typing, user-defined types, predefined tags, and formal structure, allowing for formal validation of an XML stream in a portable way</strong>. Similarly, there is an IETF draft proposal for a schema system for JSON.[44]</p><p>XML supports comments, but JSON does not</p><h1 id="3-Differences"><a href="#3-Differences" class="headerlink" title="3. Differences"></a>3. Differences</h1><h1 id="3-1-XML-is-a-markup-language-whereas-JSON-is-a-way-of-representing-objects"><a href="#3-1-XML-is-a-markup-language-whereas-JSON-is-a-way-of-representing-objects" class="headerlink" title="3.1 XML is a markup language whereas JSON is a way of representing objects"></a>3.1 XML is a markup language whereas JSON is a way of representing objects</h1><p>A markup language is a way of adding extra information to free-flowing plain text </p><pre><code>&lt;Document&gt;    &lt;Paragraph Align=&quot;Center&quot;&gt;        Here &lt;Bold&gt;is&lt;/Bold&gt; some text.    &lt;/Paragraph&gt;&lt;/Document&gt;</code></pre><p>An object notation like JSON is not as flexible. But this is usually a good thing. When you’re representing objects, you simply don’t need the extra flexibility. To represent the above example in JSON, you’d actually have to solve some problems manually that XML solves for you.</p><pre><code>{    &quot;Paragraphs&quot;: [        {            &quot;align&quot;: &quot;center&quot;,            &quot;content&quot;: [                &quot;Here &quot;, {                    &quot;style&quot; : &quot;bold&quot;,                    &quot;content&quot;: [ &quot;is&quot; ]                },                &quot; some text.&quot;            ]        }    ]}</code></pre><p>JSON is better suited if you have typical a hierarchy of objects and you want to represent them in a stream. </p><pre><code>{    &quot;firstName&quot;: &quot;Homer&quot;,    &quot;lastName&quot;: &quot;Simpson&quot;,    &quot;relatives&quot;: [ &quot;Grandpa&quot;, &quot;Marge&quot;, &quot;The Boy&quot;, &quot;Lisa&quot;, &quot;I think that&#39;s all of them&quot; ]} </code></pre><p>Below is same expression in xml</p><pre><code>&lt;Person&gt;    &lt;FirstName&gt;Homer&lt;/FirstName&gt;    &lt;LastName&gt;Simpsons&lt;/LastName&gt;    &lt;Relatives&gt;        &lt;Relative&gt;Grandpa&lt;/Relative&gt;        &lt;Relative&gt;Marge&lt;/Relative&gt;        &lt;Relative&gt;The Boy&lt;/Relative&gt;        &lt;Relative&gt;Lisa&lt;/Relative&gt;        &lt;Relative&gt;I think that&#39;s all of them&lt;/Relative&gt;    &lt;/Relatives&gt;&lt;/Person&gt;</code></pre><h2 id="3-2-JSON-has-defined-ways-of-distinguishing-records"><a href="#3-2-JSON-has-defined-ways-of-distinguishing-records" class="headerlink" title="3.2 JSON has defined ways of distinguishing records"></a>3.2 JSON has defined ways of distinguishing records</h2><p>You can differenciate records directly in JSON. List and normal record have different expression; wheareas in XML, they look all same. </p><p>We need to use an external schema or extra user defined attributes in XML to express different expressions, or some limitations on it. While in JSON, it’s self describing by default. </p><p>-&gt; JSON should be the first choise for object notation, where XML should spot at document markup. </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-JSON&quot;&gt;&lt;a href=&quot;#1-JSON&quot; class=&quot;headerlink&quot; title=&quot;1. JSON&quot;&gt;&lt;/a&gt;1. JSON&lt;/h1&gt;&lt;p&gt;JSON - JavaScript Object Notation, an open standard 
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/tags/BackEnd/"/>
    
  </entry>
  
  <entry>
    <title>System.gc() and Runtime.gc()</title>
    <link href="https://www.llchen60.com/System-gc-and-Runtime-gc/"/>
    <id>https://www.llchen60.com/System-gc-and-Runtime-gc/</id>
    <published>2020-02-09T06:10:53.000Z</published>
    <updated>2020-02-09T06:11:17.904Z</updated>
    
    <content type="html"><![CDATA[<p>首先在Java中垃圾回收算法是首先遍历所有在堆中的非垃圾的对象，然后推断出那些一段时间内没有被访问的对象一定是垃圾了。call gc()方法不是强制垃圾回收发生的，相反的，它只是在建议JVM现在是不错的做垃圾回收的时间。</p><p>system.gc()是用来运行垃圾收集器的。call这个方法就意味着Java虚拟机正在努力去回收没有被使用的对象，使得他们现在占用的内存可以进行快速地再利用。整个垃圾回收在Java中是自动进行的。</p><p>system.gc()是个静态方法，但是手动调用它很有可能会让整个系统运行更慢的，一般为了加快整体的运行，会使用<code>-XX:+DisableExplicitGC</code>这条指令，这样子JVM就不会在你手动唤醒gc的时候直接call这个方法了。</p><p>runtime.gc()和system.gc()并没有什么区别，实质上system.gc()内部就call了runtime.gc()。 唯一的不同在于System.gc()是类的方法然而runtime.gc()是实例方法。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="http://net-informations.com/java/cjava/gc.htm" target="_blank" rel="noopener">http://net-informations.com/java/cjava/gc.htm</a> </li><li><a href="https://docs.oracle.com/javase/7/docs/api/java/lang/System.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/7/docs/api/java/lang/System.html</a> </li><li><a href="https://www.geeksforgeeks.org/garbage-collection-java/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/garbage-collection-java/</a> </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先在Java中垃圾回收算法是首先遍历所有在堆中的非垃圾的对象，然后推断出那些一段时间内没有被访问的对象一定是垃圾了。call gc()方法不是强制垃圾回收发生的，相反的，它只是在建议JVM现在是不错的做垃圾回收的时间。&lt;/p&gt;
&lt;p&gt;system.gc()是用来运行垃圾收
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Ruby Totorial</title>
    <link href="https://www.llchen60.com/Ruby-Totorial/"/>
    <id>https://www.llchen60.com/Ruby-Totorial/</id>
    <published>2020-02-09T05:22:07.000Z</published>
    <updated>2020-02-09T05:22:33.775Z</updated>
    
    <content type="html"><![CDATA[<p>Met circumstances where need Ruby knowledge to resolve problems, thus need to do a quick touch on Ruby, at least know how to read ruby code. </p><p>Leran by doing, or we say, learn by satisfying current needs. </p><h1 id="1-Basics"><a href="#1-Basics" class="headerlink" title="1. Basics"></a>1. Basics</h1><ul><li>features <ul><li>object-oriented </li><li>server side scripting language </li><li>can be used to write common gateway interface(CGI) scripts</li></ul></li></ul><h2 id="1-1-Syntax-of-Ruby"><a href="#1-1-Syntax-of-Ruby" class="headerlink" title="1.1 Syntax of Ruby"></a>1.1 Syntax of Ruby</h2><ul><li>whitespace <ul><li>ignored in ruby code, except when they appear in strings. </li></ul></li><li>end of line<ul><li>you could use <ul><li>semicolons </li><li>newline characters as the ending of a statement </li></ul></li></ul></li><li>Ruby Identifiers<ul><li>case sensitive </li></ul></li><li>comments<ul><li><code>#</code></li><li><code>=begin</code> at beginning, <code>=end</code> at the end</li></ul></li></ul><pre><code>// Declares code to be called before the program run BEGIN {    code}// Declares code to be called at the end of the program END {    code}</code></pre><ul><li>classes and objects <ul><li>features<ul><li>data encapsulation </li><li>data abstraction </li><li>polymorphism</li><li>inheritance </li></ul></li></ul></li></ul><pre><code>// Class exampleClass Vehicle {   Number no_of_wheels   Number horsepower   Characters type_of_tank   Number Capacity   Function speeding {   }   Function driving {   }   Function halting {   }}</code></pre><h2 id="1-2-Class-and-Objects"><a href="#1-2-Class-and-Objects" class="headerlink" title="1.2 Class and Objects"></a>1.2 Class and Objects</h2><ul><li>Define a class in Ruby </li></ul><pre><code>// A class always starts with keyword class, followed by the name of the class. // Terminate a class by using the keyword end. class Customerend</code></pre><ul><li>Variables in a Ruby Class <ul><li>local variables <ul><li>defined in a method</li><li>begin with a lowercase letter or _. </li></ul></li><li>instance variables <ul><li>available across methods for any particular instance or object </li><li>instance variables change from object to object </li><li><code>@</code></li></ul></li><li>class variables <ul><li>available across different objects </li><li>belongs to the class and is a characteristic of a class </li><li><code>@@</code></li></ul></li><li>global variables <ul><li>Class variables are not available across classes, while global variables are.  </li><li><code>$</code></li></ul></li></ul></li></ul><pre><code>// Determine the number of objects that are being ccreated class Customer   @@no_of_customers = 0end</code></pre><ul><li>creating objects with <code>new</code> method<ul><li><code>object1 = Customer.new</code></li><li>object1 is object name</li><li>Customer is class</li><li>To instantiate a new object, you need to use class name followed by dot and new(keyword)</li></ul></li><li>custom method to create ruby objects (similar to constructor concept in Java)<ul><li>pass parameters to method new </li><li>when you plan to declare new method with parameters, you need to declare the method <strong>initialize</strong> at the time of the class creation </li></ul></li></ul><pre><code>class Customer   @@no_of_customers = 0   def initialize(id, name, addr)      @cust_id = id      @cust_name = name      @cust_addr = addr   endend// To create objects cust1 = Customer.new(&quot;1&quot;, &quot;John&quot;, &quot;Wisdom Apartments, Ludhiya&quot;)</code></pre><ul><li>member functions in class <ul><li>each method in a class starts with the keyword <code>def</code> followed by the method name </li></ul></li></ul><pre><code>class Sample    def function        statement 1        statement 2    endend// A full example #!/usr/bin/rubyclass Sample   def hello      puts &quot;Hello Ruby!&quot;   endend# Now using above class to create objectsobject = Sample. newobject.hello</code></pre><h2 id="1-3-Variables"><a href="#1-3-Variables" class="headerlink" title="1.3 Variables"></a>1.3 Variables</h2><ul><li>Global Variables <ul><li>begin with $ </li><li>uninitialized global variables have the value <code>nil</code> </li></ul></li></ul><pre><code>#!/usr/bin/ruby$global_variable = 10class Class1   def print_global      # In ruby, you can use HashTag to access any variables value       puts &quot;Global variable in Class1 is #$global_variable&quot;   endendclass Class2   def print_global      puts &quot;Global variable in Class2 is #$global_variable&quot;   endendclass1obj = Class1.newclass1obj.print_globalclass2obj = Class2.newclass2obj.print_global</code></pre><ul><li>Instance Variables <ul><li>begin with <code>@</code></li></ul></li></ul><pre><code>#!/usr/bin/rubyclass Customer   def initialize(id, name, addr)      @cust_id = id      @cust_name = name      @cust_addr = addr   end   def display_details()      puts &quot;Customer id #@cust_id&quot;      puts &quot;Customer name #@cust_name&quot;      puts &quot;Customer address #@cust_addr&quot;   endend# Create Objectscust1 = Customer.new(&quot;1&quot;, &quot;John&quot;, &quot;Wisdom Apartments, Ludhiya&quot;)cust2 = Customer.new(&quot;2&quot;, &quot;Poul&quot;, &quot;New Empire road, Khandala&quot;)# Call Methodscust1.display_details()cust2.display_details()</code></pre><ul><li>Class Variables <ul><li>begin with @@</li><li>must be initialized before they can be used in method definitions </li></ul></li></ul><pre><code>#!/usr/bin/rubyclass Customer   @@no_of_customers = 0   def initialize(id, name, addr)      @cust_id = id      @cust_name = name      @cust_addr = addr   end   def display_details()      puts &quot;Customer id #@cust_id&quot;      puts &quot;Customer name #@cust_name&quot;      puts &quot;Customer address #@cust_addr&quot;   end   def total_no_of_customers()      @@no_of_customers += 1      puts &quot;Total number of customers: #@@no_of_customers&quot;   endend# Create Objectscust1 = Customer.new(&quot;1&quot;, &quot;John&quot;, &quot;Wisdom Apartments, Ludhiya&quot;)cust2 = Customer.new(&quot;2&quot;, &quot;Poul&quot;, &quot;New Empire road, Khandala&quot;)# Call Methodscust1.total_no_of_customers()cust2.total_no_of_customers()</code></pre><ul><li><p>Local variables </p><ul><li>begin with a lowercase letter or <code>_</code></li><li>scope<ul><li>class</li><li>module</li><li>def</li><li>do to the corresponding end</li><li>block’s opening brace to its close brace </li></ul></li></ul></li><li><p>Constants</p><ul><li>Begin with an <strong>uppercase</strong> letter  </li><li>defined within a class or module </li></ul></li><li><p>Pseudo-variables </p><ul><li><p>self </p></li><li><p>true</p></li><li><p>false</p></li><li><p>nil </p><ul><li>Value representing undefined </li></ul></li><li><p><code>_FILE_</code></p><ul><li>the name of the current source file </li></ul></li><li><p><code>_LINE_</code></p><ul><li>the current line number in the source file <h2 id="1-4-Arrays"><a href="#1-4-Arrays" class="headerlink" title="1.4 Arrays"></a>1.4 Arrays</h2>Array are created by placing a comma-separated series of object references between the square brackets.</li></ul><p>#!/usr/bin/ruby</p><p>ary = [  “fred”, 10, 3.14, “This is a string”, “last element”, ]<br>ary.each do |i|<br> puts i<br>end</p></li></ul></li></ul><h2 id="1-5-Hashes"><a href="#1-5-Hashes" class="headerlink" title="1.5 Hashes"></a>1.5 Hashes</h2><p>Hash is created by placing a list of key/value pairs between braces, with either a comma or the sequence =&gt; between the key and the value. A trailing comma is ignored.</p><pre><code>#!/usr/bin/rubyhsh = colors = { &quot;red&quot; =&gt; 0xf00, &quot;green&quot; =&gt; 0x0f0, &quot;blue&quot; =&gt; 0x00f }hsh.each do |key, value|   print key, &quot; is &quot;, value, &quot;\n&quot;end</code></pre><h2 id="1-6-Ranges"><a href="#1-6-Ranges" class="headerlink" title="1.6 Ranges"></a>1.6 Ranges</h2><p>A Range represents an interval which is a set of values with a start and an end. Ranges may be constructed using the s..e and s…e literals, or with Range.new.</p><pre><code>#!/usr/bin/ruby(10..15).each do |n|    print n, &#39; &#39; end</code></pre><h2 id="1-7-Operators"><a href="#1-7-Operators" class="headerlink" title="1.7 Operators"></a>1.7 Operators</h2><ul><li><code>&lt;=&gt;</code><ul><li>ruturn 0 if first operand equals second</li><li>1 if first greater than second</li><li>-1 if first less than second </li></ul></li><li><code>.eql?</code><ul><li>true if the receiver and argument have both the same type and equal values</li></ul></li><li><code>equal?</code><ul><li>true if the receiver and argument have the same object id </li></ul></li><li><code>..</code><ul><li>1..10 creates a range from 1 to 10 inclusive</li></ul></li><li><code>...</code><ul><li>1…10 creates a range from 1 to 9  </li></ul></li><li>defined? operators<ul><li>takes the form of a method call to determine whether or not the passed expression is defined</li><li>returns a description string of the expression, or nil if the expression isn’t defined </li></ul></li><li>dot operators<ul><li></li></ul></li><li>double colon <code>::</code> operators<ul><li>You call a module method by preceding its name with the module’s name and a period, and you reference a constant using the module name and two colons. </li><li><code>::</code> us a unary operator that allows constants, instance methods and class methods defined within a class or module to be accessed from anywhere outside the class or module </li><li>*<em>Classes and methods are considered to be constants too *</em></li></ul></li></ul><h2 id="1-8-Conditions"><a href="#1-8-Conditions" class="headerlink" title="1.8 Conditions"></a>1.8 Conditions</h2><pre><code>// if else condition checkif condition    code..elsif condition2    codeelse     codeend// case #!/usr/bin/ruby$age =  5case $agewhen 0 .. 2   puts &quot;baby&quot;when 3 .. 6   puts &quot;little child&quot;when 7 .. 12   puts &quot;child&quot;when 13 .. 18   puts &quot;youth&quot;else   puts &quot;adult&quot;end</code></pre><h2 id="1-9-Loops"><a href="#1-9-Loops" class="headerlink" title="1.9 Loops"></a>1.9 Loops</h2><pre><code>while condition do     codeend</code></pre><p>Executes code while conditional is true </p><pre><code>$i = 0$num = 5begin     puts(&quot;123&quot;)    $i += 1end while $i &lt; $num // for loopfor i in 0..5    puts &quot;Value of local variable is #{i}&quot;end// subtitute way of for loop(expression).each do |variable|     codeend// E.G (0..5).each do |i|    puts &quot;Value of local variable is #{i}&quot;end </code></pre><ul><li><code>next</code><ul><li>jump to the next iteration of the most internal loop </li></ul></li><li><code>redo</code><ul><li>restarts this iteration of the most internal loop, without checking loop condition  </li></ul></li><li><code>retry</code></li><li><code>break</code><ul><li>terminate the most internal loop  </li></ul></li></ul><h2 id="1-10-Methods"><a href="#1-10-Methods" class="headerlink" title="1.10 Methods"></a>1.10 Methods</h2><ul><li><p>used to bundle one or more repeatable statements into a single unit </p></li><li><p>method name should begin with a lowercase lettter </p></li><li><p>method should be defined before calling them </p></li><li><p>call the method by direcly type in the method name <code>method_name</code></p></li><li><p>with parameters <code>method_name 25, 30</code></p></li><li><p>Ruby will return the value of lat statement by default </p></li><li><p>or use the return statement </p></li><li><p>method defined in the class definition are marked as <strong>public</strong> by default </p></li><li><p>a block is always invoked from a function with the same name as that of the block </p><p>  def method_name (var1, var2)</p><pre><code>  expr</code></pre><p>  end </p></li><li><p>variable number of parameters </p><ul><li><code>def sample (*test)</code>   </li></ul></li></ul><h2 id="1-11-Blocks"><a href="#1-11-Blocks" class="headerlink" title="1.11 Blocks"></a>1.11 Blocks</h2><ul><li>definition <ul><li>consists of chunks of code</li><li>assign a name to a block </li><li>code in the block is always enclosed within braces <code>{}</code> or <code>()</code></li><li>a block is always invoked from a function with the same name as that of the block</li><li>invoke a block by using the <code>yield</code> statement </li></ul></li><li>if the last argument of a method is preceded by &amp;, then you can pass a block to this method and this block will be assigned to the last parameter. </li></ul><pre><code>#!/usr/bin/rubydef test(&amp;block)   block.callendtest { puts &quot;Hello World!&quot;}</code></pre><h2 id="1-12-Modules-and-Mixins"><a href="#1-12-Modules-and-Mixins" class="headerlink" title="1.12 Modules and Mixins"></a>1.12 Modules and Mixins</h2><ul><li>Module<ul><li>way of grouping together methods, classes, and constants </li><li>provides namespace and prevent name clashes<ul><li>a sandbox  </li></ul></li><li>implement mixin facility </li></ul></li></ul><pre><code>// syntaxmodule Identifier    statement1    statement2end</code></pre><ul><li>call a module method by precedint its name with the module’s name and a period </li><li>reference a constant using the module name and two colons </li></ul><pre><code>#!/usr/bin/ruby# Module defined in trig.rb filemodule Trig   PI = 3.141592654   def Trig.sin(x)   # ..   end   def Trig.cos(x)   # ..   endend</code></pre><ul><li><p><code>require</code></p><ul><li>similar to import, include</li><li>if a third program wants to use any defined module, it can simply load the module files using the Ruby<code>require</code> statement </li></ul></li><li><p>mixin </p><ul><li>multiple inheratance </li></ul></li></ul><pre><code>module A   def a1   end   def a2   endendmodule B   def b1   end   def b2   endendclass Sampleinclude Ainclude B   def s1   endendsamp = Sample.newsamp.a1samp.a2samp.b1samp.b2samp.s1</code></pre><p>In this way, samp could call method defined in Module A and Module B</p><h2 id="1-13-Strings"><a href="#1-13-Strings" class="headerlink" title="1.13 Strings"></a>1.13 Strings</h2><ul><li>holds and manipulates an arbitrary sequence of one or more bytes</li></ul><h2 id="1-14-Array"><a href="#1-14-Array" class="headerlink" title="1.14 Array"></a>1.14 Array</h2><ul><li>ordered, integer indexed collections of any object</li><li>each element in an array is associated with and referred to by an index </li><li>creating arrays<ul><li><code>Array.new</code> </li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Met circumstances where need Ruby knowledge to resolve problems, thus need to do a quick touch on Ruby, at least know how to read ruby co
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Ruby" scheme="https://www.llchen60.com/tags/Ruby/"/>
    
  </entry>
  
</feed>
