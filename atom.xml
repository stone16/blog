<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Leilei&#39;s Blog | 磊磊的博客</title>
  
  <subtitle>Because it&#39;s there</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.llchen60.com/"/>
  <updated>2020-06-23T03:56:23.132Z</updated>
  <id>https://www.llchen60.com/</id>
  
  <author>
    <name>Leilei Chen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>设计模式-结构型-适配器模式</title>
    <link href="https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-06-24T03:55:54.000Z</published>
    <updated>2020-06-23T03:56:23.132Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-适配器模式原理和实现"><a href="#1-适配器模式原理和实现" class="headerlink" title="1. 适配器模式原理和实现"></a>1. 适配器模式原理和实现</h1><ul><li><p>Adapter Design Pattern </p><ul><li>做适配的，将不兼容的接口转换为可兼容的接口</li><li>将原本由于接口不兼容而不能一起工作的类一起工作</li></ul></li><li><p>实现方式</p><ul><li>类适配器<ul><li>使用继承关系实现</li></ul></li><li>对象适配器<ul><li>使用组合关系实现</li></ul></li></ul></li></ul><pre><code>// 类适配器: 基于继承public interface ITarget {  void f1();  void f2();  void fc();}public class Adaptee {  public void fa() { //... }  public void fb() { //... }  public void fc() { //... }}public class Adaptor extends Adaptee implements ITarget {  public void f1() {    super.fa();  }  public void f2() {    //...重新实现f2()...  }  // 这里fc()不需要实现，直接继承自Adaptee，这是跟对象适配器最大的不同点}// 对象适配器：基于组合public interface ITarget {  void f1();  void f2();  void fc();}public class Adaptee {  public void fa() { //... }  public void fb() { //... }  public void fc() { //... }}public class Adaptor implements ITarget {  private Adaptee adaptee;  public Adaptor(Adaptee adaptee) {    this.adaptee = adaptee;  }  public void f1() {    adaptee.fa(); //委托给Adaptee  }  public void f2() {    //...重新实现f2()...  }  public void fc() {    adaptee.fc();  }}</code></pre><ul><li><p>类适配器和对象适配器的选择取决于</p><ul><li>Adaptee接口的个数</li><li>Adaptee 和Itarget的契合程度</li></ul></li><li><p>如果 Adaptee 接口并不多，那两种实现方式都可以。</p></li><li><p>如果 Adaptee 接口很多，而且 Adaptee 和 ITarget 接口定义大部分都相同，那我们推荐使用类适配器，因为 Adaptor 复用父类 Adaptee 的接口，比起对象适配器的实现方式，Adaptor 的代码量要少一些。</p></li><li><p>如果 Adaptee 接口很多，而且 Adaptee 和 ITarget 接口定义大部分都不相同，那我们推荐使用对象适配器，因为组合结构相对于继承更加灵活。</p></li></ul><h1 id="2-应用场景总结"><a href="#2-应用场景总结" class="headerlink" title="2. 应用场景总结"></a>2. 应用场景总结</h1><ul><li>适配器模式 – 一种补偿模式<ul><li>主要用来弥补一些设计上的缺陷</li><li>主要用来解决接口不兼容的问题</li></ul></li></ul><h2 id="2-1-封装有缺陷的接口设计"><a href="#2-1-封装有缺陷的接口设计" class="headerlink" title="2.1 封装有缺陷的接口设计"></a>2.1 封装有缺陷的接口设计</h2><p>譬如我们依赖的外部系统在接口设计上有缺陷（包含大量的静态方法），引入后会影响到我们自身代码的可测试性。为了隔离设计上的缺陷，我们希望对外部系统提供的接口进行二次封装，抽象出更好的接口设计。</p><pre><code>public class CD { //这个类来自外部sdk，我们无权修改它的代码  //...  public static void staticFunction1() { //... }  public void uglyNamingFunction2() { //... }  public void tooManyParamsFunction3(int paramA, int paramB, ...) { //... }   public void lowPerformanceFunction4() { //... }}// 使用适配器模式进行重构public class ITarget {  void function1();  void function2();  void fucntion3(ParamsWrapperDefinition paramsWrapper);  void function4();  //...}// 注意：适配器类的命名不一定非得末尾带Adaptorpublic class CDAdaptor extends CD implements ITarget {  //...  public void function1() {     super.staticFunction1();  }  public void function2() {    super.uglyNamingFucntion2();  }  public void function3(ParamsWrapperDefinition paramsWrapper) {     super.tooManyParamsFunction3(paramsWrapper.getParamA(), ...);  }  public void function4() {    //...reimplement it...  }}</code></pre><h2 id="2-2-统一多个类的接口设计"><a href="#2-2-统一多个类的接口设计" class="headerlink" title="2.2 统一多个类的接口设计"></a>2.2 统一多个类的接口设计</h2><p>某个功能的实现依赖多个外部系统，通过适配器模式，将其接口适配为统一的接口定义，然后使用多态的特性来复用代码逻辑。</p><p>下述代码使用适配器模式来处理有不同的接口设计的几个来自第三方做词汇过滤的API</p><pre><code>public class ASensitiveWordsFilter { // A敏感词过滤系统提供的接口  //text是原始文本，函数输出用***替换敏感词之后的文本  public String filterSexyWords(String text) {    // ...  }  public String filterPoliticalWords(String text) {    // ...  } }public class BSensitiveWordsFilter  { // B敏感词过滤系统提供的接口  public String filter(String text) {    //...  }}public class CSensitiveWordsFilter { // C敏感词过滤系统提供的接口  public String filter(String text, String mask) {    //...  }}// 未使用适配器模式之前的代码：代码的可测试性、扩展性不好public class RiskManagement {  private ASensitiveWordsFilter aFilter = new ASensitiveWordsFilter();  private BSensitiveWordsFilter bFilter = new BSensitiveWordsFilter();  private CSensitiveWordsFilter cFilter = new CSensitiveWordsFilter();  public String filterSensitiveWords(String text) {    String maskedText = aFilter.filterSexyWords(text);    maskedText = aFilter.filterPoliticalWords(maskedText);    maskedText = bFilter.filter(maskedText);    maskedText = cFilter.filter(maskedText, &quot;***&quot;);    return maskedText;  }}// 使用适配器模式进行改造public interface ISensitiveWordsFilter { // 统一接口定义  String filter(String text);}public class ASensitiveWordsFilterAdaptor implements ISensitiveWordsFilter {  private ASensitiveWordsFilter aFilter;  public String filter(String text) {    String maskedText = aFilter.filterSexyWords(text);    maskedText = aFilter.filterPoliticalWords(maskedText);    return maskedText;  }}//...省略BSensitiveWordsFilterAdaptor、CSensitiveWordsFilterAdaptor...// 扩展性更好，更加符合开闭原则，如果添加一个新的敏感词过滤系统，// 这个类完全不需要改动；而且基于接口而非实现编程，代码的可测试性更好。public class RiskManagement {   private List&lt;ISensitiveWordsFilter&gt; filters = new ArrayList&lt;&gt;();  public void addSensitiveWordsFilter(ISensitiveWordsFilter filter) {    filters.add(filter);  }  public String filterSensitiveWords(String text) {    String maskedText = text;    for (ISensitiveWordsFilter filter : filters) {      maskedText = filter.filter(maskedText);    }    return maskedText;  }}</code></pre><h2 id="2-3-替换依赖的外部系统"><a href="#2-3-替换依赖的外部系统" class="headerlink" title="2.3 替换依赖的外部系统"></a>2.3 替换依赖的外部系统</h2><pre><code>// 外部系统Apublic interface IA {  //...  void fa();}public class A implements IA {  //...  public void fa() { //... }}// 在我们的项目中，外部系统A的使用示例public class Demo {  private IA a;  public Demo(IA a) {    this.a = a;  }  //...}Demo d = new Demo(new A());// 将外部系统A替换成外部系统Bpublic class BAdaptor implemnts IA {  private B b;  public BAdaptor(B b) {    this.b= b;  }  public void fa() {    //...    b.fb();  }}// 借助BAdaptor，Demo的代码中，调用IA接口的地方都无需改动，// 只需要将BAdaptor如下注入到Demo即可。Demo d = new Demo(new BAdaptor(new B()));</code></pre><h2 id="2-4-兼容老版本的接口"><a href="#2-4-兼容老版本的接口" class="headerlink" title="2.4 兼容老版本的接口"></a>2.4 兼容老版本的接口</h2><p>做版本升级的时候，对于一些要废弃的接口，不能直接将其删除，而是暂时保留，并且标注为deprecated，并将内部实现逻辑委托为新的接口实现。这样就可以是的项目有个过渡期。</p><p>Enumeration –&gt; Iterator的升级</p><pre><code>public class Collections {  public static Emueration emumeration(final Collection c) {    return new Enumeration() {      Iterator i = c.iterator();      public boolean hasMoreElments() {        return i.hashNext();      }      public Object nextElement() {        return i.next():      }    }  }}</code></pre><h1 id="3-代理-vs-桥接-vs-装饰器-vs-适配器"><a href="#3-代理-vs-桥接-vs-装饰器-vs-适配器" class="headerlink" title="3. 代理 vs 桥接 vs 装饰器 vs 适配器"></a>3. 代理 vs 桥接 vs 装饰器 vs 适配器</h1><ul><li><p>代理模式</p><ul><li>在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是访问控制，而非加强功能</li></ul></li><li><p>桥接模式</p><ul><li>将接口部分和实现部分分离，使得其能够相对独立的进行改变</li></ul></li><li><p>装饰器模式</p><ul><li>在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用</li></ul></li><li><p>适配器模式</p><ul><li>事后补救策略，适配器提供跟原始类不同的接口</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-适配器模式原理和实现&quot;&gt;&lt;a href=&quot;#1-适配器模式原理和实现&quot; class=&quot;headerlink&quot; title=&quot;1. 适配器模式原理和实现&quot;&gt;&lt;/a&gt;1. 适配器模式原理和实现&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Adapter Design Patt
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="适配器模式" scheme="https://www.llchen60.com/tags/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-结构型-装饰器模式</title>
    <link href="https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-06-23T03:09:04.000Z</published>
    <updated>2020-06-23T03:09:29.625Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a>1. Overview</h1><h2 id="1-1-Java-IO类的使用"><a href="#1-1-Java-IO类的使用" class="headerlink" title="1.1 Java IO类的使用"></a>1.1 Java IO类的使用</h2><table><thead><tr><th></th><th>字节流</th><th>字符流</th></tr></thead><tbody><tr><td>输入流</td><td>InputStream</td><td>Reader</td></tr><tr><td>输出流</td><td>OutputStream</td><td>Writer</td></tr></tbody></table><p>JavaIO库非常庞大，几十个类一同来负责IO数据的读取和写入。</p><pre><code>InputStream in = new FileInputStream(&quot;/user/wangzheng/test.txt&quot;);InputStream bin = new BufferedInputStream(in);byte[] data = new byte[128];while (bin.read(data) != -1) {  //...}</code></pre><p>上述代码先使用了FileInputStream来读取文件流，然后又使用了BufferedInputStream，来支持缓存。</p><p>问题来了，为什么不能设置一个继承了FileInputStream并且支持缓存的BufferedFileInputStream类呢？ </p><p>问题在于各种use case太多，如果为了各种功能的组合都设置一个类的话，那么类的继承结构会变得非常负责，代码会变得很难扩展和维护。</p><p>Java IO的设计思路，就是使用组合来替代继承</p><pre><code>public abstract class InputStream {  //...  public int read(byte b[]) throws IOException {    return read(b, 0, b.length);  }  public int read(byte b[], int off, int len) throws IOException {    //...  }  public long skip(long n) throws IOException {    //...  }  public int available() throws IOException {    return 0;  }  public void close() throws IOException {}  public synchronized void mark(int readlimit) {}  public synchronized void reset() throws IOException {    throw new IOException(&quot;mark/reset not supported&quot;);  }  public boolean markSupported() {    return false;  }}public class BufferedInputStream extends InputStream {  protected volatile InputStream in;  protected BufferedInputStream(InputStream in) {    this.in = in;  }  //...实现基于缓存的读数据接口...  }public class DataInputStream extends InputStream {  protected volatile InputStream in;  protected DataInputStream(InputStream in) {    this.in = in;  }  //...实现读取基本类型数据的接口}</code></pre><h2 id="1-2-装饰器模式"><a href="#1-2-装饰器模式" class="headerlink" title="1.2 装饰器模式"></a>1.2 装饰器模式</h2><ul><li>使用组合来替代继承关系</li><li>装饰器类和原始类继承同样的父类，这样我们就可以对原始类嵌套多个装饰器类</li><li>是对功能的增强，是和原始功能相关的</li><li>为了解决继承关系过于复杂的问题</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Overview&quot;&gt;&lt;a href=&quot;#1-Overview&quot; class=&quot;headerlink&quot; title=&quot;1. Overview&quot;&gt;&lt;/a&gt;1. Overview&lt;/h1&gt;&lt;h2 id=&quot;1-1-Java-IO类的使用&quot;&gt;&lt;a href=&quot;#1-1-
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="装饰器模式" scheme="https://www.llchen60.com/tags/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-结构型-桥接模式</title>
    <link href="https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-06-21T21:54:45.000Z</published>
    <updated>2020-06-21T21:55:09.965Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-原理解析"><a href="#1-原理解析" class="headerlink" title="1. 原理解析"></a>1. 原理解析</h1><ul><li>桥接模式 Bridge Design Pattern<ul><li>将抽象和实现解耦，使之可以独立变化</li><li>一个类存在两个或者多个独立变化的维度，通过组合的方式，让这几个维度都可以独立进行扩展<ul><li>通过组合关系来替代继承关系，避免继承层次的指数级爆炸</li></ul></li></ul></li></ul><h2 id="1-1-JDBC驱动的实现"><a href="#1-1-JDBC驱动的实现" class="headerlink" title="1.1 JDBC驱动的实现"></a>1.1 JDBC驱动的实现</h2><pre><code>    Class.forName(&quot;com.mysql.jdbc.Driver&quot;);//加载及注册JDBC驱动程序    String url = &quot;jdbc:mysql://localhost:3306/sample_db?user=root&amp;password=your_password&quot;;    Connection con = DriverManager.getConnection(url);    Statement stmt = con.createStatement()；    String query = &quot;select * from test&quot;;    ResultSet rs=stmt.executeQuery(query);    while(rs.next()) {      rs.getString(1);      rs.getInt(2);    }</code></pre><ul><li>上述代码中只要改变forName中的路径，就可以改变数据库了</li><li>或者我们可以通过将加载的Driver类写到配置文件当中，来实现数据库的切换，只需要修改配置文件就可以完成数据库的切换了</li></ul><pre><code>package com.mysql.jdbc;import java.sql.SQLException;public class Driver extends NonRegisteringDriver implements java.sql.Driver {  static {    try {      java.sql.DriverManager.registerDriver(new Driver());    } catch (SQLException E) {      throw new RuntimeException(&quot;Can&#39;t register driver!&quot;);    }  }  /**   * Construct a new driver and register it with DriverManager   * @throws SQLException if a database error occurs.   */  public Driver() throws SQLException {    // Required for Class.forName().newInstance()  }}</code></pre><ul><li>在执行<code>Class.forName</code>的时候，首先是使得JVM查找并加载指定的Driver类，</li><li>其次是执行该类的静态代码<ul><li>实例变量需要在类实例化以后才能存在</li><li>静态变量是该类素有对象公有的，不需要实例化就已经存在了</li><li>静态代码会在类被加载的时候自动执行</li></ul></li></ul><pre><code>public class DriverManager {  private final static CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers = new CopyOnWriteArrayList&lt;DriverInfo&gt;();  //...  static {    loadInitialDrivers();    println(&quot;JDBC DriverManager initialized&quot;);  }  //...  public static synchronized void registerDriver(java.sql.Driver driver) throws SQLException {    if (driver != null) {      registeredDrivers.addIfAbsent(new DriverInfo(driver));    } else {      throw new NullPointerException();    }  }  public static Connection getConnection(String url, String user, String password) throws SQLException {    java.util.Properties info = new java.util.Properties();    if (user != null) {      info.put(&quot;user&quot;, user);    }    if (password != null) {      info.put(&quot;password&quot;, password);    }    return (getConnection(url, info, Reflection.getCallerClass()));  }  //...}</code></pre><ul><li>JDBC本身相当于抽象，即和具体的数据库无关的被抽象出来的一套类库</li><li>具体的Driver相当于实现</li></ul><h2 id="1-2-实例"><a href="#1-2-实例" class="headerlink" title="1.2 实例"></a>1.2 实例</h2><p>设计一个根据不同的告警规则，触发不同的类型的告警。</p><ul><li><p>紧急程度</p><ul><li>SEVERE</li><li>URGENCY</li><li>NORMAL</li><li>TRIVIAL</li></ul></li><li><p>通知渠道</p><ul><li>邮件</li><li>短信</li><li>微信</li><li>自动语音通话</li></ul></li><li><p>下述代码实质上就是在实现一个解耦，希望避免复杂的if else逻辑，让代码更易懂，修改更方便。</p></li></ul><pre><code>public interface MsgSender {  void send(String message);}public class TelephoneMsgSender implements MsgSender {  private List&lt;String&gt; telephones;  public TelephoneMsgSender(List&lt;String&gt; telephones) {    this.telephones = telephones;  }  @Override  public void send(String message) {    //...  }}public class EmailMsgSender implements MsgSender {  // 与TelephoneMsgSender代码结构类似，所以省略...}public class WechatMsgSender implements MsgSender {  // 与TelephoneMsgSender代码结构类似，所以省略...}public abstract class Notification {  protected MsgSender msgSender;  public Notification(MsgSender msgSender) {    this.msgSender = msgSender;  }  public abstract void notify(String message);}public class SevereNotification extends Notification {  public SevereNotification(MsgSender msgSender) {    super(msgSender);  }  @Override  public void notify(String message) {    msgSender.send(message);  }}public class UrgencyNotification extends Notification {  // 与SevereNotification代码结构类似，所以省略...}public class NormalNotification extends Notification {  // 与SevereNotification代码结构类似，所以省略...}public class TrivialNotification extends Notification {  // 与SevereNotification代码结构类似，所以省略...}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-原理解析&quot;&gt;&lt;a href=&quot;#1-原理解析&quot; class=&quot;headerlink&quot; title=&quot;1. 原理解析&quot;&gt;&lt;/a&gt;1. 原理解析&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;桥接模式 Bridge Design Pattern&lt;ul&gt;
&lt;li&gt;将抽象和实现解耦，使之
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="桥接模式" scheme="https://www.llchen60.com/tags/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-结构型-代理模式</title>
    <link href="https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-06-19T19:27:01.000Z</published>
    <updated>2020-06-19T19:27:54.269Z</updated>
    
    <content type="html"><![CDATA[<p>结构型模式主要总结了一些类和对象组合在一起的经典结构，这些经典的结构可以解决特定应用场景的问题。结构型模式包括：</p><ul><li>代理模式</li><li>桥接模式</li><li>装饰器模式</li><li>适配器模式</li><li>门面模式</li><li>组合模式</li><li>享元模式</li></ul><h1 id="1-代理模式原理解析"><a href="#1-代理模式原理解析" class="headerlink" title="1. 代理模式原理解析"></a>1. 代理模式原理解析</h1><ul><li>代理模式 Proxy Design Pattern <ul><li>在不改变原始类（被代理类）代码的情况下，通过引入代理类来给原始类附加功能</li></ul></li></ul><ul><li><p>下述是实现MetricsCollector的初始想法</p><ul><li><p>框架代码和业务代码耦合度太高，后期维护或者框架的更换代价都会很大</p></li><li><p>业务类职责最好单一，只聚焦业务处理</p><p>// Original idea for metricsCollector<br>public class UserController {<br>//…省略其他属性和方法…<br>private MetricsCollector metricsCollector; // 依赖注入</p><p>public UserVo login(String telephone, String password) {<br>  long startTimestamp = System.currentTimeMillis();</p><p>  // … 省略login逻辑…</p><p>  long endTimeStamp = System.currentTimeMillis();<br>  long responseTime = endTimeStamp - startTimestamp;<br>  RequestInfo requestInfo = new RequestInfo(“login”, responseTime, startTimestamp);<br>  metricsCollector.recordRequest(requestInfo);</p><p>  //…返回UserVo数据…<br>}</p><p>public UserVo register(String telephone, String password) {<br>  long startTimestamp = System.currentTimeMillis();</p><p>  // … 省略register逻辑…</p><p>  long endTimeStamp = System.currentTimeMillis();<br>  long responseTime = endTimeStamp - startTimestamp;<br>  RequestInfo requestInfo = new RequestInfo(“register”, responseTime, startTimestamp);<br>  metricsCollector.recordRequest(requestInfo);</p><p>  //…返回UserVo数据…<br>}<br>}</p></li></ul></li></ul><ul><li>构建代理类UserControllerProxy<ul><li>代理类UserCOntrollerProxy和原始类UserController实现相同的接口IUserController。UserController只负责业务功能，代理类UserControllerProxy负责在业务代码执行前后附加其他逻辑代码，并通过委托的方式来调用原始类执行业务代码。</li></ul></li></ul><pre><code>    public interface IUserController {      UserVo login(String telephone, String password);      UserVo register(String telephone, String password);    }    public class UserController implements IUserController {      //...省略其他属性和方法...      @Override      public UserVo login(String telephone, String password) {        //...省略login逻辑...        //...返回UserVo数据...      }      @Override      public UserVo register(String telephone, String password) {        //...省略register逻辑...        //...返回UserVo数据...      }    }    public class UserControllerProxy implements IUserController {      private MetricsCollector metricsCollector;      private UserController userController;      public UserControllerProxy(UserController userController) {        this.userController = userController;        this.metricsCollector = new MetricsCollector();      }      @Override      public UserVo login(String telephone, String password) {        long startTimestamp = System.currentTimeMillis();        // 委托        UserVo userVo = userController.login(telephone, password);        long endTimeStamp = System.currentTimeMillis();        long responseTime = endTimeStamp - startTimestamp;        RequestInfo requestInfo = new RequestInfo(&quot;login&quot;, responseTime, startTimestamp);        metricsCollector.recordRequest(requestInfo);        return userVo;      }      @Override      public UserVo register(String telephone, String password) {        long startTimestamp = System.currentTimeMillis();        UserVo userVo = userController.register(telephone, password);        long endTimeStamp = System.currentTimeMillis();        long responseTime = endTimeStamp - startTimestamp;        RequestInfo requestInfo = new RequestInfo(&quot;register&quot;, responseTime, startTimestamp);        metricsCollector.recordRequest(requestInfo);        return userVo;      }    }    //UserControllerProxy使用举例    //因为原始类和代理类实现相同的接口，是基于接口而非实现编程    //将UserController类对象替换为UserControllerProxy类对象，不需要改动太多代码    IUserController userController = new UserControllerProxy(new UserController());</code></pre><ul><li>面对原始类无接口，或者属于其他service无法做改动的时候，可以直接通过继承，来对其进行扩展</li></ul><pre><code>public class UserControllerProxy extends UserController {  private MetricsCollector metricsCollector;  public UserControllerProxy() {    this.metricsCollector = new MetricsCollector();  }  public UserVo login(String telephone, String password) {    long startTimestamp = System.currentTimeMillis();    UserVo userVo = super.login(telephone, password);    long endTimeStamp = System.currentTimeMillis();    long responseTime = endTimeStamp - startTimestamp;    RequestInfo requestInfo = new RequestInfo(&quot;login&quot;, responseTime, startTimestamp);    metricsCollector.recordRequest(requestInfo);    return userVo;  }  public UserVo register(String telephone, String password) {    long startTimestamp = System.currentTimeMillis();    UserVo userVo = super.register(telephone, password);    long endTimeStamp = System.currentTimeMillis();    long responseTime = endTimeStamp - startTimestamp;    RequestInfo requestInfo = new RequestInfo(&quot;register&quot;, responseTime, startTimestamp);    metricsCollector.recordRequest(requestInfo);    return userVo;  }}//UserControllerProxy使用举例UserController userController = new UserControllerProxy();</code></pre><h1 id="2-动态代理原理解析"><a href="#2-动态代理原理解析" class="headerlink" title="2. 动态代理原理解析"></a>2. 动态代理原理解析</h1><p>代理类的实现需要将原始类当中的所有方法都实现一遍，并加上你需要的代码逻辑，这样做会创建大量的代理类，很麻烦。因此我们需要使用动态代理来解决这个问题，即我们不事先为每个原始类编写代理类，而是在运行的时候，动态的创建原始类对应的代理类，然后在系统当中用代理类替换掉原始类。</p><p>Java本身用反射语法来实现动态代理。</p><pre><code>public class MetricsCollectorProxy {  private MetricsCollector metricsCollector;  public MetricsCollectorProxy() {    this.metricsCollector = new MetricsCollector();  }  public Object createProxy(Object proxiedObject) {    Class&lt;?&gt;[] interfaces = proxiedObject.getClass().getInterfaces();    DynamicProxyHandler handler = new DynamicProxyHandler(proxiedObject);    return Proxy.newProxyInstance(proxiedObject.getClass().getClassLoader(), interfaces, handler);  }  private class DynamicProxyHandler implements InvocationHandler {    private Object proxiedObject;    public DynamicProxyHandler(Object proxiedObject) {      this.proxiedObject = proxiedObject;    }    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {      long startTimestamp = System.currentTimeMillis();      Object result = method.invoke(proxiedObject, args);      long endTimeStamp = System.currentTimeMillis();      long responseTime = endTimeStamp - startTimestamp;      String apiName = proxiedObject.getClass().getName() + &quot;:&quot; + method.getName();      RequestInfo requestInfo = new RequestInfo(apiName, responseTime, startTimestamp);      metricsCollector.recordRequest(requestInfo);      return result;    }  }}//MetricsCollectorProxy使用举例MetricsCollectorProxy proxy = new MetricsCollectorProxy();IUserController userController = (IUserController) proxy.createProxy(new UserController());</code></pre><ul><li><p>InvocationHandler </p><ul><li>java的标准接口</li></ul></li><li><p>创建Proxy 实例</p><ul><li>Proxy.newProxyInstance(classLoader, class, handlerClass)</li></ul></li><li><p>Spring的AOP的实现原理就是基于动态代理。用户配置好需要给哪些类创建代理，并定义好在执行原始类的业务代码前后执行哪些附加功能、Spring为这些类创建动态代理对象，并且在JVM中替代原始类对象。通过这种方式，实现了给原始类添加附加功能的目的。</p><h1 id="3-代理模式的应用场景"><a href="#3-代理模式的应用场景" class="headerlink" title="3. 代理模式的应用场景"></a>3. 代理模式的应用场景</h1></li><li><p>业务系统中的非功能性需求的开发</p><ul><li>监控</li><li>统计</li><li>鉴权</li><li>限流</li><li>事务</li><li>幂等</li><li>日志</li></ul></li><li><p>在RPC，缓存中的应用</p><ul><li>RPC将网络通信，数据编解码的细节隐藏起来</li><li>AOP切面完成接口缓存的功能</li></ul></li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://www.baeldung.com/java-dynamic-proxies" target="_blank" rel="noopener">https://www.baeldung.com/java-dynamic-proxies</a></li><li><a href="https://time.geekbang.org/column/article/201823" target="_blank" rel="noopener">https://time.geekbang.org/column/article/201823</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;结构型模式主要总结了一些类和对象组合在一起的经典结构，这些经典的结构可以解决特定应用场景的问题。结构型模式包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;代理模式&lt;/li&gt;
&lt;li&gt;桥接模式&lt;/li&gt;
&lt;li&gt;装饰器模式&lt;/li&gt;
&lt;li&gt;适配器模式&lt;/li&gt;
&lt;li&gt;门面模式&lt;/li&gt;
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="代理模式" scheme="https://www.llchen60.com/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-创建型-原型模式</title>
    <link href="https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-06-17T18:46:18.000Z</published>
    <updated>2020-06-17T18:46:53.268Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-什么是原型模式"><a href="#1-什么是原型模式" class="headerlink" title="1. 什么是原型模式"></a>1. 什么是原型模式</h1><p>如果说对象的创建成本比较大，并且同一个类的不同对象之间的差别不大（大部分字段都相同），在这种情况下，我们可以利用对已有对象(原型)进行复制/拷贝的方式来创建新对象，来达到节省创建时间的目的。</p><ul><li>如何理解对象的创建成本比较大<ul><li>比如对象当中的数据需要经过复杂的计算才能得到（排序，哈希）</li><li>需要IO读取</li></ul></li></ul><p>在这种情况下，我们就可以利用原型模式，从其他已有对象当中直接拷贝，而不是在每次创建对象的时候，重复执行这个非常耗时的操作。</p><h1 id="2-如何使用原型模式"><a href="#2-如何使用原型模式" class="headerlink" title="2.如何使用原型模式"></a>2.如何使用原型模式</h1><h2 id="2-1-实际场景案例"><a href="#2-1-实际场景案例" class="headerlink" title="2.1 实际场景案例"></a>2.1 实际场景案例</h2><ul><li><p>数据库 存储10万条搜索关键词信息</p><ul><li><p>包含关键词，关键词被搜索次数，信息最近被更新的时间</p></li><li><p>系统A启动的时候会加载这份数据到内存当中，用于处理某些其他的业务需求</p></li><li><p>构建散列表索引 – hashmap</p><ul><li>key为搜索关键词</li><li>value为关键词的详细信息</li></ul></li><li><p>系统B分析搜索日志，每隔10分钟就批量更新数据库中的数据，并且标记为新的数据版本</p></li><li><p>系统A需要定期根据数据库的数据更新内存中的索引和数据</p></li></ul></li></ul><h2 id="2-2-根据需求的迭代"><a href="#2-2-根据需求的迭代" class="headerlink" title="2.2 根据需求的迭代"></a>2.2 根据需求的迭代</h2><ul><li>在系统A中记录更新时间，在数据库中拿出更新时间大于系统A当中的搜索关键词，然后针对差集中的每个关键词进行处理</li><li>如果在散列表中了，更新相应的搜索次数，更新时间等</li><li>如果不在，插入散列表当中</li></ul><pre><code>public class Demo {  private ConcurrentHashMap&lt;String, SearchWord&gt; currentKeywords = new ConcurrentHashMap&lt;&gt;();  private long lastUpdateTime = -1;  public void refresh() {    // 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到currentKeywords中    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);    long maxNewUpdatedTime = lastUpdateTime;    for (SearchWord searchWord : toBeUpdatedSearchWords) {      if (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) {        maxNewUpdatedTime = searchWord.getLastUpdateTime();      }      if (currentKeywords.containsKey(searchWord.getKeyword())) {        currentKeywords.replace(searchWord.getKeyword(), searchWord);      } else {        currentKeywords.put(searchWord.getKeyword(), searchWord);      }    }    lastUpdateTime = maxNewUpdatedTime;  }  private List&lt;SearchWord&gt; getSearchWords(long lastUpdateTime) {    // TODO: 从数据库中取出更新时间&gt;lastUpdateTime的数据    return null;  }}</code></pre><ul><li>如果需要任何时刻系统A中的所有数据都必须是同一个版本的</li><li>更新内存数据的时候，系统A不能处于不可用的状态，不能停机更新数据<ul><li>针对需求，我们需要出了正在使用的服务版本之外，创建另外一个版本的数据。当新的版本数据建好之后，再一次性地将服务版本进行切换</li><li>可以保证数据一直可用，并且避免中间状态的存在</li></ul></li></ul><pre><code>public class Demo {  private HashMap&lt;String, SearchWord&gt; currentKeywords=new HashMap&lt;&gt;();  public void refresh() {    HashMap&lt;String, SearchWord&gt; newKeywords = new LinkedHashMap&lt;&gt;();    // 从数据库中取出所有的数据，放入到newKeywords中    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords();    for (SearchWord searchWord : toBeUpdatedSearchWords) {      newKeywords.put(searchWord.getKeyword(), searchWord);    }    currentKeywords = newKeywords;  }  private List&lt;SearchWord&gt; getSearchWords() {    // TODO: 从数据库中取出所有的数据    return null;  }}</code></pre><ul><li>新数据结构的构建成本非常高，需要IO读出数据库，计算哈希值，构建newKeywords</li><li>我们可以拷贝当前的版本到新的待处理的散列表当中，然后从数据库当中拿出新增或者有更新的关键词，来做更新</li></ul><pre><code>public class Demo {  private HashMap&lt;String, SearchWord&gt; currentKeywords=new HashMap&lt;&gt;();  private long lastUpdateTime = -1;  public void refresh() {    // 原型模式就这么简单，拷贝已有对象的数据，更新少量差值    HashMap&lt;String, SearchWord&gt; newKeywords = (HashMap&lt;String, SearchWord&gt;) currentKeywords.clone();    // 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);    long maxNewUpdatedTime = lastUpdateTime;    for (SearchWord searchWord : toBeUpdatedSearchWords) {      if (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) {        maxNewUpdatedTime = searchWord.getLastUpdateTime();      }      if (newKeywords.containsKey(searchWord.getKeyword())) {        SearchWord oldSearchWord = newKeywords.get(searchWord.getKeyword());        oldSearchWord.setCount(searchWord.getCount());        oldSearchWord.setLastUpdateTime(searchWord.getLastUpdateTime());      } else {        newKeywords.put(searchWord.getKeyword(), searchWord);      }    }    lastUpdateTime = maxNewUpdatedTime;    currentKeywords = newKeywords;  }  private List&lt;SearchWord&gt; getSearchWords(long lastUpdateTime) {    // TODO: 从数据库中取出更新时间&gt;lastUpdateTime的数据    return null;  }}</code></pre><ul><li>上述代码做的是浅拷贝，因为在散列表当中，key存的是搜索关键词，而value实际上存储的是对象的内存地址</li><li>当我们做浅拷贝的时候，我们实际上是把内存地址给拷贝了过来；这样的话当我们做修改的话，实际上两个版本的数据都做了变动，并没有将其彻底的分割开</li><li>我们实际需要的是深拷贝，即不仅仅复制索引，并且复制数据本身<ul><li>递归拷贝对象，对象的引用对象以及引用对象的引用对象</li><li>先将对象序列化，再反序列化成新对象</li></ul></li></ul><pre><code>// 实现递归深拷贝public class Demo {  private HashMap&lt;String, SearchWord&gt; currentKeywords=new HashMap&lt;&gt;();  private long lastUpdateTime = -1;  public void refresh() {    // Deep copy    HashMap&lt;String, SearchWord&gt; newKeywords = new HashMap&lt;&gt;();    for (HashMap.Entry&lt;String, SearchWord&gt; e : currentKeywords.entrySet()) {      SearchWord searchWord = e.getValue();      SearchWord newSearchWord = new SearchWord(              searchWord.getKeyword(), searchWord.getCount(), searchWord.getLastUpdateTime());      newKeywords.put(e.getKey(), newSearchWord);    }    // 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);    long maxNewUpdatedTime = lastUpdateTime;    for (SearchWord searchWord : toBeUpdatedSearchWords) {      if (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) {        maxNewUpdatedTime = searchWord.getLastUpdateTime();      }      if (newKeywords.containsKey(searchWord.getKeyword())) {        SearchWord oldSearchWord = newKeywords.get(searchWord.getKeyword());        oldSearchWord.setCount(searchWord.getCount());        oldSearchWord.setLastUpdateTime(searchWord.getLastUpdateTime());      } else {        newKeywords.put(searchWord.getKeyword(), searchWord);      }    }    lastUpdateTime = maxNewUpdatedTime;    currentKeywords = newKeywords;  }  private List&lt;SearchWord&gt; getSearchWords(long lastUpdateTime) {    // TODO: 从数据库中取出更新时间&gt;lastUpdateTime的数据    return null;  }}// 实现递归深拷贝public Object deepCopy(Object object) {  ByteArrayOutputStream bo = new ByteArrayOutputStream();  ObjectOutputStream oo = new ObjectOutputStream(bo);  oo.writeObject(object);  ByteArrayInputStream bi = new ByteArrayInputStream(bo.toByteArray());  ObjectInputStream oi = new ObjectInputStream(bi);  return oi.readObject();}</code></pre><ul><li>最快的方式，是可以先用浅拷贝来创建，对于需要更新的对象，再用深拷贝的方式创建一份新的对象，来做替换</li></ul><pre><code>public class Demo {  private HashMap&lt;String, SearchWord&gt; currentKeywords=new HashMap&lt;&gt;();  private long lastUpdateTime = -1;  public void refresh() {    // Shallow copy    HashMap&lt;String, SearchWord&gt; newKeywords = (HashMap&lt;String, SearchWord&gt;) currentKeywords.clone();    // 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);    long maxNewUpdatedTime = lastUpdateTime;    for (SearchWord searchWord : toBeUpdatedSearchWords) {      if (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) {        maxNewUpdatedTime = searchWord.getLastUpdateTime();      }      if (newKeywords.containsKey(searchWord.getKeyword())) {        newKeywords.remove(searchWord.getKeyword());      }      newKeywords.put(searchWord.getKeyword(), searchWord);    }    lastUpdateTime = maxNewUpdatedTime;    currentKeywords = newKeywords;  }  private List&lt;SearchWord&gt; getSearchWords(long lastUpdateTime) {    // TODO: 从数据库中取出更新时间&gt;lastUpdateTime的数据    return null;  }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-什么是原型模式&quot;&gt;&lt;a href=&quot;#1-什么是原型模式&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是原型模式&quot;&gt;&lt;/a&gt;1. 什么是原型模式&lt;/h1&gt;&lt;p&gt;如果说对象的创建成本比较大，并且同一个类的不同对象之间的差别不大（大部分字段都相
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="原型模式" scheme="https://www.llchen60.com/tags/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-创建型-建造者模式</title>
    <link href="https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-06-16T04:17:36.000Z</published>
    <updated>2020-06-16T04:18:58.833Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-为什么需要建造者模式"><a href="#1-为什么需要建造者模式" class="headerlink" title="1. 为什么需要建造者模式"></a>1. 为什么需要建造者模式</h1><p>一个关于如何使用建造者模式的问题是：当我们能够使用构造函数或者使用set方法就能够创建对象的时候，我们为什么会需要建造者模式来创建呢？ </p><p>一个例子，假设我们要定义一个类，其大部分的属性都是可以选择的，那么我们可以使用构造函数来做如下的声明： </p><pre><code>public class ResourcePoolConfig {  private static final int DEFAULT_MAX_TOTAL = 8;  private static final int DEFAULT_MAX_IDLE = 8;  private static final int DEFAULT_MIN_IDLE = 0;  private String name;  private int maxTotal = DEFAULT_MAX_TOTAL;  private int maxIdle = DEFAULT_MAX_IDLE;  private int minIdle = DEFAULT_MIN_IDLE;  public ResourcePoolConfig(String name, Integer maxTotal, Integer maxIdle, Integer minIdle) {    if (StringUtils.isBlank(name)) {      throw new IllegalArgumentException(&quot;name should not be empty.&quot;);    }    this.name = name;    if (maxTotal != null) {      if (maxTotal &lt;= 0) {        throw new IllegalArgumentException(&quot;maxTotal should be positive.&quot;);      }      this.maxTotal = maxTotal;    }    if (maxIdle != null) {      if (maxIdle &lt; 0) {        throw new IllegalArgumentException(&quot;maxIdle should not be negative.&quot;);      }      this.maxIdle = maxIdle;    }    if (minIdle != null) {      if (minIdle &lt; 0) {        throw new IllegalArgumentException(&quot;minIdle should not be negative.&quot;);      }      this.minIdle = minIdle;    }  }  //...省略getter方法...}</code></pre><p>在这个例子当中，除了name以外的所有选项都是可选的，因此会看到在构造函数当中，我们做了很多的null check。这样做当参数很多的时候，是很难看懂的。我们可以将其改良为一系列的set()函数，构造函数只实例化NonNull的参数，对于Nullable的参数，我们可以用set方法来实现声明。如下所示： </p><pre><code>public class ResourcePoolConfig {  private static final int DEFAULT_MAX_TOTAL = 8;  private static final int DEFAULT_MAX_IDLE = 8;  private static final int DEFAULT_MIN_IDLE = 0;  private String name;  private int maxTotal = DEFAULT_MAX_TOTAL;  private int maxIdle = DEFAULT_MAX_IDLE;  private int minIdle = DEFAULT_MIN_IDLE;  public ResourcePoolConfig(String name) {    if (StringUtils.isBlank(name)) {      throw new IllegalArgumentException(&quot;name should not be empty.&quot;);    }    this.name = name;  }  public void setMaxTotal(int maxTotal) {    if (maxTotal &lt;= 0) {      throw new IllegalArgumentException(&quot;maxTotal should be positive.&quot;);    }    this.maxTotal = maxTotal;  }  public void setMaxIdle(int maxIdle) {    if (maxIdle &lt; 0) {      throw new IllegalArgumentException(&quot;maxIdle should not be negative.&quot;);    }    this.maxIdle = maxIdle;  }  public void setMinIdle(int minIdle) {    if (minIdle &lt; 0) {      throw new IllegalArgumentException(&quot;minIdle should not be negative.&quot;);    }    this.minIdle = minIdle;  }  //...省略getter方法...}</code></pre><p>上述的set方法还是有一些缺陷的，即：</p><ul><li>首先如果必填的配置项有很多，且都需要放置到构造函数当中，那构造函数就会出现参数列表很长的问题了。</li><li>假设配置项之间有一定的依赖关系，我们需要将配置项之间的依赖关系和校验逻辑找地方放</li><li>如果我们希望类对象是不可变对象，即对象在创建好之后就不能再修改内部的属性值，那么我们就不能再ResourcePoolConfig类当中暴露set()方法</li></ul><p>Builder模式可以很好的解决上述我们的需求，我们可以将校验逻辑放在调用build()方法之前，也可以将构造函数私有化，这样就只能通过建造者来创建ResourcePoolConfig类对象</p><h1 id="2-如何使用建造者模式构建对象"><a href="#2-如何使用建造者模式构建对象" class="headerlink" title="2. 如何使用建造者模式构建对象"></a>2. 如何使用建造者模式构建对象</h1><pre><code>public class ResourcePoolConfig {  private String name;  private int maxTotal;  private int maxIdle;  private int minIdle;  private ResourcePoolConfig(Builder builder) {    this.name = builder.name;    this.maxTotal = builder.maxTotal;    this.maxIdle = builder.maxIdle;    this.minIdle = builder.minIdle;  }  //...省略getter方法...  //我们将Builder类设计成了ResourcePoolConfig的内部类。  //我们也可以将Builder类设计成独立的非内部类ResourcePoolConfigBuilder。  public static class Builder {    private static final int DEFAULT_MAX_TOTAL = 8;    private static final int DEFAULT_MAX_IDLE = 8;    private static final int DEFAULT_MIN_IDLE = 0;    private String name;    private int maxTotal = DEFAULT_MAX_TOTAL;    private int maxIdle = DEFAULT_MAX_IDLE;    private int minIdle = DEFAULT_MIN_IDLE;    public ResourcePoolConfig build() {      // 校验逻辑放到这里来做，包括必填项校验、依赖关系校验、约束条件校验等      if (StringUtils.isBlank(name)) {        throw new IllegalArgumentException(&quot;...&quot;);      }      if (maxIdle &gt; maxTotal) {        throw new IllegalArgumentException(&quot;...&quot;);      }      if (minIdle &gt; maxTotal || minIdle &gt; maxIdle) {        throw new IllegalArgumentException(&quot;...&quot;);      }      return new ResourcePoolConfig(this);    }    public Builder setName(String name) {      if (StringUtils.isBlank(name)) {        throw new IllegalArgumentException(&quot;...&quot;);      }      this.name = name;      return this;    }    public Builder setMaxTotal(int maxTotal) {      if (maxTotal &lt;= 0) {        throw new IllegalArgumentException(&quot;...&quot;);      }      this.maxTotal = maxTotal;      return this;    }    public Builder setMaxIdle(int maxIdle) {      if (maxIdle &lt; 0) {        throw new IllegalArgumentException(&quot;...&quot;);      }      this.maxIdle = maxIdle;      return this;    }    public Builder setMinIdle(int minIdle) {      if (minIdle &lt; 0) {        throw new IllegalArgumentException(&quot;...&quot;);      }      this.minIdle = minIdle;      return this;    }  }}// 这段代码会抛出IllegalArgumentException，因为minIdle&gt;maxIdleResourcePoolConfig config = new ResourcePoolConfig.Builder()        .setName(&quot;dbconnectionpool&quot;)        .setMaxTotal(16)        .setMaxIdle(10)        .setMinIdle(12)        .build();</code></pre><h1 id="3-何时使用"><a href="#3-何时使用" class="headerlink" title="3. 何时使用"></a>3. 何时使用</h1><p>建造者模式用来创建一种类型的复杂对象，通过设置不同的可选参数，定制化地创建不同的对象。建造者模式和工厂模式的区别可以用一个例子来说明，顾客走进一家餐馆点餐，我们利用工厂模式，根据用户不同的选择，来制作不同的食物，比如披萨、汉堡、沙拉。对于披萨来说，用户又有各种配料可以定制，比如奶酪、西红柿、起司，我们通过建造者模式根据用户选择的不同配料来制作披萨。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-为什么需要建造者模式&quot;&gt;&lt;a href=&quot;#1-为什么需要建造者模式&quot; class=&quot;headerlink&quot; title=&quot;1. 为什么需要建造者模式&quot;&gt;&lt;/a&gt;1. 为什么需要建造者模式&lt;/h1&gt;&lt;p&gt;一个关于如何使用建造者模式的问题是：当我们能够使用构造函
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="建造者模式" scheme="https://www.llchen60.com/tags/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-创建型-工厂模式</title>
    <link href="https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-06-14T20:58:25.000Z</published>
    <updated>2020-06-16T04:18:00.563Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-简单工厂-Simple-Factory"><a href="#1-简单工厂-Simple-Factory" class="headerlink" title="1. 简单工厂 Simple Factory"></a>1. 简单工厂 Simple Factory</h1><p>假设要做一个parser类，根据后缀来实例化Parser</p><pre><code>public class RuleConfigSource {  public RuleConfig load(String ruleConfigFilePath) {    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);    IRuleConfigParser parser = RuleConfigParserFactory.createParser(ruleConfigFileExtension);    if (parser == null) {      throw new InvalidRuleConfigException(              &quot;Rule config file format is not supported: &quot; + ruleConfigFilePath);    }    String configText = &quot;&quot;;    //从ruleConfigFilePath文件中读取配置文本到configText中    RuleConfig ruleConfig = parser.parse(configText);    return ruleConfig;  }  private String getFileExtension(String filePath) {    //...解析文件名获取扩展名，比如rule.json，返回json    return &quot;json&quot;;  }}public class RuleConfigParserFactory {  public static IRuleConfigParser createParser(String configFormat) {    IRuleConfigParser parser = null;    if (&quot;json&quot;.equalsIgnoreCase(configFormat)) {      parser = new JsonRuleConfigParser();    } else if (&quot;xml&quot;.equalsIgnoreCase(configFormat)) {      parser = new XmlRuleConfigParser();    } else if (&quot;yaml&quot;.equalsIgnoreCase(configFormat)) {      parser = new YamlRuleConfigParser();    } else if (&quot;properties&quot;.equalsIgnoreCase(configFormat)) {      parser = new PropertiesRuleConfigParser();    }    return parser;  }}</code></pre><p>上述代码是创建了工厂类，并且在工厂类当中制定了静态方法，根据输入参数的不同来分别实例化不同的parser。一般来说工厂当中创建对象的方法都是create开头，或者说明对于instance的操作，常见的方法名比如：</p><ul><li>createXXX()</li><li>getInstance()</li><li>createInstance()</li><li>newInstance() </li></ul><p>同样，如果要声明的类时很可能可以复用的，那么我们就可以在调用前就创建好，来节省对象创建的时间</p><pre><code>public class RuleConfigParserFactory {  private static final Map&lt;String, RuleConfigParser&gt; cachedParsers = new HashMap&lt;&gt;();  static {    cachedParsers.put(&quot;json&quot;, new JsonRuleConfigParser());    cachedParsers.put(&quot;xml&quot;, new XmlRuleConfigParser());    cachedParsers.put(&quot;yaml&quot;, new YamlRuleConfigParser());    cachedParsers.put(&quot;properties&quot;, new PropertiesRuleConfigParser());  }  public static IRuleConfigParser createParser(String configFormat) {    if (configFormat == null || configFormat.isEmpty()) {      return null;//返回null还是IllegalArgumentException全凭你自己说了算    }    IRuleConfigParser parser = cachedParsers.get(configFormat.toLowerCase());    return parser;  }}</code></pre><h1 id="2-工厂方法"><a href="#2-工厂方法" class="headerlink" title="2. 工厂方法"></a>2. 工厂方法</h1><p>利用多态将if分支逻辑给去掉： </p><pre><code>public interface IRuleConfigParserFactory {  IRuleConfigParser createParser();}public class JsonRuleConfigParserFactory implements IRuleConfigParserFactory {  @Override  public IRuleConfigParser createParser() {    return new JsonRuleConfigParser();  }}public class XmlRuleConfigParserFactory implements IRuleConfigParserFactory {  @Override  public IRuleConfigParser createParser() {    return new XmlRuleConfigParser();  }}public class YamlRuleConfigParserFactory implements IRuleConfigParserFactory {  @Override  public IRuleConfigParser createParser() {    return new YamlRuleConfigParser();  }}public class PropertiesRuleConfigParserFactory implements IRuleConfigParserFactory {  @Override  public IRuleConfigParser createParser() {    return new PropertiesRuleConfigParser();  }}// 关于如何选取需要import的factory，使用hashmap，相当于为工厂类创建了一个简单的工厂；一种委托给别人进行生产的模式思路public class RuleConfigSource {  public RuleConfig load(String ruleConfigFilePath) {    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);    IRuleConfigParserFactory parserFactory = RuleConfigParserFactoryMap.getParserFactory(ruleConfigFileExtension);    if (parserFactory == null) {      throw new InvalidRuleConfigException(&quot;Rule config file format is not supported: &quot; + ruleConfigFilePath);    }    IRuleConfigParser parser = parserFactory.createParser();    String configText = &quot;&quot;;    //从ruleConfigFilePath文件中读取配置文本到configText中    RuleConfig ruleConfig = parser.parse(configText);    return ruleConfig;  }  private String getFileExtension(String filePath) {    //...解析文件名获取扩展名，比如rule.json，返回json    return &quot;json&quot;;  }}//因为工厂类只包含方法，不包含成员变量，完全可以复用，//不需要每次都创建新的工厂类对象，所以，简单工厂模式的第二种实现思路更加合适。public class RuleConfigParserFactoryMap { //工厂的工厂  private static final Map&lt;String, IRuleConfigParserFactory&gt; cachedFactories = new HashMap&lt;&gt;();  static {    cachedFactories.put(&quot;json&quot;, new JsonRuleConfigParserFactory());    cachedFactories.put(&quot;xml&quot;, new XmlRuleConfigParserFactory());    cachedFactories.put(&quot;yaml&quot;, new YamlRuleConfigParserFactory());    cachedFactories.put(&quot;properties&quot;, new PropertiesRuleConfigParserFactory());  }  public static IRuleConfigParserFactory getParserFactory(String type) {    if (type == null || type.isEmpty()) {      return null;    }    IRuleConfigParserFactory parserFactory = cachedFactories.get(type.toLowerCase());    return parserFactory;  }}</code></pre><h1 id="3-Dependency-Injection-框架"><a href="#3-Dependency-Injection-框架" class="headerlink" title="3. Dependency Injection 框架"></a>3. Dependency Injection 框架</h1><p>依赖注入框架想要解决的是在基于Inversion of control的理念下，我们应该如何做，如何简化整个创建对象的过程。</p><p>DI容器底层最基本的设计思路是基于工厂模式来进行的，DI容器就相当于一个大的工厂类，复杂在程序启动的时候，根据配置（需要创建哪些类对象，每个类对象的创建需要依赖哪些其他类的对象）事先创建好对象。当应用程序需要使用某个类对象的时候，直接从容器当中获取即可。</p><p>DI容器的核心功能主要有：</p><ul><li>配置解析</li><li>对象创建</li><li>对象生命周期管理</li></ul><h2 id="3-1-配置解析"><a href="#3-1-配置解析" class="headerlink" title="3.1 配置解析"></a>3.1 配置解析</h2><p>应用需要告知DI容器需要创建哪些对象，需要将由DI容器来创建的类对象和创建类对象的必要信息，放到配置文件当中。容器读取配置文件，根据配置文件提供的信息来创建对象。像在spring当中，就是依靠xml文件或者注解，来告诉spring 用何种方式来创建对象。</p><h2 id="3-2-对象创建"><a href="#3-2-对象创建" class="headerlink" title="3.2 对象创建"></a>3.2 对象创建</h2><p>Spring当中将所有类对象的创建都放到了一个工厂类当中实现</p><h2 id="3-3-对象生命周期管理"><a href="#3-3-对象生命周期管理" class="headerlink" title="3.3 对象生命周期管理"></a>3.3 对象生命周期管理</h2><ul><li><p>通过配置scope属性，决定是每次都返回一个新创建的对象还是每次都返回一个事先创建好的对象 – 单例对象</p></li><li><p>配置是否懒加载；lazy-init</p><ul><li>真正被使用的时候被创建</li><li>在应用启动的时候就事先创建好</li></ul></li><li><p>配置对象的init-method, destroy-method </p><ul><li>DI容器在创建好对象之后，会主动调用init-method属性指定的方法来初始化对象</li><li>在对象被最终销毁之前，DI容器会主动调用destroy-method属性指定的方法来做一些清理工作</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-简单工厂-Simple-Factory&quot;&gt;&lt;a href=&quot;#1-简单工厂-Simple-Factory&quot; class=&quot;headerlink&quot; title=&quot;1. 简单工厂 Simple Factory&quot;&gt;&lt;/a&gt;1. 简单工厂 Simple Factory
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="工厂模式" scheme="https://www.llchen60.com/tags/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>思维模型的搜集/整理</title>
    <link href="https://www.llchen60.com/%E6%80%9D%E7%BB%B4%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%90%9C%E9%9B%86-%E6%95%B4%E7%90%86/"/>
    <id>https://www.llchen60.com/%E6%80%9D%E7%BB%B4%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%90%9C%E9%9B%86-%E6%95%B4%E7%90%86/</id>
    <published>2020-06-12T05:46:32.000Z</published>
    <updated>2020-06-16T04:35:44.663Z</updated>
    
    <content type="html"><![CDATA[<p>看到了Adam Amran的<a href="https://untools.co/，感觉是有一些元知识是衍生的根本，希望能够用这篇blog作为总结分享的集散地，把自己看到的认为在某些方面有实际效用的思维模型分享给大家。" target="_blank" rel="noopener">https://untools.co/，感觉是有一些元知识是衍生的根本，希望能够用这篇blog作为总结分享的集散地，把自己看到的认为在某些方面有实际效用的思维模型分享给大家。</a></p><h1 id="1-问题树-Issue-Tree"><a href="#1-问题树-Issue-Tree" class="headerlink" title="1. 问题树 - Issue Tree"></a>1. 问题树 - <a href="https://untools.co/issue-trees" target="_blank" rel="noopener">Issue Tree</a></h1><h2 id="1-1-是什么"><a href="#1-1-是什么" class="headerlink" title="1.1 是什么"></a>1.1 是什么</h2><ul><li>一个问题地图</li><li>旨在给你需要解决的问题一个清晰而系统的思考方式</li><li>帮助你对问题进行拆分，其实很符合divide and conquer 即分治的思想</li></ul><p>对自己而言，确实有在做，在思考。值得注意且需要加强的一点是MECE原则 – mutually exclusive, collectively exhaustive。 对提高思维的完备性很有作用</p><h2 id="1-2-怎么做"><a href="#1-2-怎么做" class="headerlink" title="1.2 怎么做"></a>1.2 怎么做</h2><ul><li><p>问题树应该能够覆盖所有的问题，需要非常细致</p></li><li><p>一些需要遵循的原则</p><ul><li><p><strong>MECE - mutually exclusive, collectively exhaustive</strong> </p><ul><li><strong>需要做到相互之间没有交集，并集即为全集</strong></li></ul></li><li><p>不要过度纠结于太小的细节，需要先做大类目的划分，来定义问题</p></li><li><p>二八法则，专注于起于数据的有价值的问题</p></li></ul></li></ul><h1 id="2-Second-order-thinking"><a href="#2-Second-order-thinking" class="headerlink" title="2. Second-order thinking"></a>2. <a href="https://untools.co/second-order-thinking" target="_blank" rel="noopener">Second-order thinking</a></h1><h2 id="2-1-Overview"><a href="#2-1-Overview" class="headerlink" title="2.1 Overview"></a>2.1 Overview</h2><p>有的时候我们下的决定看起来直观上会给我们带来好处，但是长远看来是对我们不利的。我们通常的思考链条是 需求 - 设定方案 - 评估方案 - 执行。其实大到公司的项目，小到晚上吃什么，我们的脑海里都会先给出需求，饿了，需要吃饭。到设定方案，在家吃vs出去吃，然后是吃什么，然后做出决定，并且按照决定来执行。</p><p>这种思考方式希望你做的是在要做出决定的时候，在想了决定的直接影响之后。再多问自己一个问题，即 – 然后呢？ 这个决定后续还会带来什么结果呢？ </p><p><strong>从事情发展的阶段来看，思考二度的发展；也可以从时间维度，去思考做出的决定在接下来几天，几个月，甚至相对更长的时间里可能对你带来的影响。</strong></p><h1 id="3-第一性原理"><a href="#3-第一性原理" class="headerlink" title="3. 第一性原理"></a>3. 第一性原理</h1><p>在每一种系统的探索当中，存在第一性原理，这是一个最基本的命题或假设，不能被忽略或删除，也不能被违反。</p><p>首先是归纳法与演绎法的对比，我们生活中最经常使用的是归纳法，即根据经验，现象到结果的链条来总结事情是如何发生的；而演绎法是基于一些元知识，做出自己的推论。</p><p>第一性原理 – First Principle，说的就是不能被省略，不能被删除，不能违反的最基本的命题或假设。是演绎法的一种，即从根本原理上，剔除干扰因素和常识性知识的思考方法。目的是希望能够将人从错综复杂的现实问题中换一个视角，将复杂的事情努力转化为简单的结构，来从源头上理解。</p><p>“我们运用第一性原理，而不是比较思维去思考问题是非常重要的。我们在生活中总是倾向于比较，对别人已经做过或者正在做的事情我们也都去做，这样发展的结果只能产生细小的迭代发展。</p><p>第一性原理的思想方式是用物理学的角度看待世界，也就是说一层层拨开事物表象，看到里面的本质，再从本质一层层往上走。”</p><h2 id="3-1-如何使用第一性原理"><a href="#3-1-如何使用第一性原理" class="headerlink" title="3.1 如何使用第一性原理"></a>3.1 如何使用第一性原理</h2><ul><li><p>苏格拉底式的提问</p><ul><li>问题源头，源起，具体表现形式？</li><li>这个情况总是发生么？什么因素会导致问题出现？</li><li>假设的证据在哪里？是否可靠？</li><li>替代观点和角度</li><li>影响和后果</li><li>对问题本身的质疑</li></ul></li><li><p>实践过程</p><ul><li>溯源</li><li>拆解</li><li>重构</li><li>迭代</li></ul></li><li><p>比较思维 vs 第一性原理</p><ul><li>看资讯</li><li>自己总结分析想法</li></ul></li></ul><h1 id="4-抽象梯子"><a href="#4-抽象梯子" class="headerlink" title="4. 抽象梯子"></a>4. 抽象梯子</h1><p>通过在不同的抽象层的移动来更好的构建你的问题。我们可以向上移动，从更大的视角看问题，看到树木背后的森林；也可以向下移动，来演化出一个更加精细的解决方案。</p><h2 id="4-1-如何使用"><a href="#4-1-如何使用" class="headerlink" title="4.1 如何使用"></a>4.1 如何使用</h2><ul><li>从一个普通的问题开始</li><li>通过问为什么来获得更大更远的视角</li><li>通过问如何做来逐步获得一个更具体的解决方案</li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://untools.co/issue-trees" target="_blank" rel="noopener">https://untools.co/issue-trees</a></li><li><a href="https://medium.com/@idtimw/%E6%80%9D%E7%BB%B4%E6%A8%A1%E5%9E%8B03-first-principles-%E7%AC%AC%E4%B8%80%E6%80%A7%E5%8E%9F%E7%90%86-7571fc664faf" target="_blank" rel="noopener">https://medium.com/@idtimw/%E6%80%9D%E7%BB%B4%E6%A8%A1%E5%9E%8B03-first-principles-%E7%AC%AC%E4%B8%80%E6%80%A7%E5%8E%9F%E7%90%86-7571fc664faf</a></li><li><a href="http://fund.jrj.com.cn/2018/06/04151524634381.shtml" target="_blank" rel="noopener">http://fund.jrj.com.cn/2018/06/04151524634381.shtml</a></li><li><a href="https://36kr.com/p/5068808" target="_blank" rel="noopener">https://36kr.com/p/5068808</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;看到了Adam Amran的&lt;a href=&quot;https://untools.co/，感觉是有一些元知识是衍生的根本，希望能够用这篇blog作为总结分享的集散地，把自己看到的认为在某些方面有实际效用的思维模型分享给大家。&quot; target=&quot;_blank&quot; rel=&quot;noop
      
    
    </summary>
    
    
      <category term="Notes" scheme="https://www.llchen60.com/categories/Notes/"/>
    
    
      <category term="思维模型" scheme="https://www.llchen60.com/tags/%E6%80%9D%E7%BB%B4%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-创建型-单例模式</title>
    <link href="https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-06-11T22:00:48.000Z</published>
    <updated>2020-06-13T05:00:36.811Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-为什么需要单例模式"><a href="#1-为什么需要单例模式" class="headerlink" title="1. 为什么需要单例模式"></a>1. 为什么需要单例模式</h1><p>windows系统的任务管理器，只能有一个,唯一性的原因：</p><ol><li>如果能弹出多个窗口，且这些窗口的内容完全一致，全都是重复对象，那势必会浪费资源，尤其是任务管理器会需要进入内核态调取各种状态信息，会对性能造成一定的影响。</li><li>而且多个窗口之间需要保持一致性，绝对的同步，相互之间的同步也是资源的浪费。</li></ol><p>现实中的例子，就是为了节约系统资源，有时需要确保系统中某个类只有唯一一个实例，当这个实例创建成功以后，我们无法再创建一个同类型的其他对象，所有的操作都只能基于这个唯一的实例。</p><h2 id="1-1-处理资源的访问冲突"><a href="#1-1-处理资源的访问冲突" class="headerlink" title="1.1 处理资源的访问冲突"></a>1.1 处理资源的访问冲突</h2><p>下述代码自定义了一个往文件当中打印日志的logger类： </p><pre><code>public class Logger {  private FileWriter writer;  public Logger() {    File file = new File(&quot;/Users/leilei/log.txt&quot;);    writer = new FileWriter(file, true); //true表示追加写入  }  public void log(String message) {    writer.write(mesasge);  }}// Logger类的应用示例：public class UserController {  private Logger logger = new Logger();  public void login(String username, String password) {    // ...省略业务逻辑代码...    logger.log(username + &quot; logined!&quot;);  }}public class OrderController {  private Logger logger = new Logger();  public void create(OrderVo order) {    // ...省略业务逻辑代码...    logger.log(&quot;Created an order: &quot; + order.toString());  }}</code></pre><p>这段代码的问题在于每个类在实现的过程中都创建了一个新的Logger对象，如果我们同时创建了两个controller，然后执行的话，会同时写入同一个文件当中，这会有可能导致日志信息互相覆盖的情况。</p><p>想要解决这个问题，我们需要加上类级别的锁，让所有的对象都能够共享一把锁：</p><pre><code>public class Logger {  private FileWriter writer;  public Logger() {    File file = new File(&quot;/Users/wangzheng/log.txt&quot;);    writer = new FileWriter(file, true); //true表示追加写入  }  public void log(String message) {    synchronized(Logger.class) { // 类级别的锁      writer.write(mesasge);    }  }}</code></pre><p>我们也可以使用单例模式，使得程序当中只允许创建一个Logger对象，所有的线程共享这一个Logger对象，共享一个FileWriter对象（本身有对象级别的线程安全的保障）</p><pre><code>public class Logger {  private FileWriter writer;  private static final Logger instance = new Logger();  private Logger() {    File file = new File(&quot;/Users/leilei/log.txt&quot;);    writer = new FileWriter(file, true); //true表示追加写入  }  public static Logger getInstance() {    return instance;  }  public void log(String message) {    writer.write(mesasge);  }}// Logger类的应用示例：public class UserController {  public void login(String username, String password) {    // ...省略业务逻辑代码...    Logger.getInstance().log(username + &quot; logined!&quot;);  }}public class OrderController {    public void create(OrderVo order) {    // ...省略业务逻辑代码...    Logger.getInstance().log(&quot;Created a order: &quot; + order.toString());  }}</code></pre><h2 id="1-2-表示全局唯一类"><a href="#1-2-表示全局唯一类" class="headerlink" title="1.2 表示全局唯一类"></a>1.2 表示全局唯一类</h2><p>对于只应该在系统当中保存一份的数据，比较适合设计为单例类。</p><pre><code>import java.util.concurrent.atomic.AtomicLong;public class IdGenerator {  // AtomicLong是一个Java并发库中提供的一个原子变量类型,  // 它将一些线程不安全需要加锁的复合操作封装为了线程安全的原子操作，  // 比如下面会用到的incrementAndGet().  private AtomicLong id = new AtomicLong(0);  private static final IdGenerator instance = new IdGenerator();  private IdGenerator() {}  public static IdGenerator getInstance() {    return instance;  }  public long getId() {     return id.incrementAndGet();  }}// IdGenerator使用举例long id = IdGenerator.getInstance().getId();</code></pre><h1 id="2-单例模式概述"><a href="#2-单例模式概述" class="headerlink" title="2. 单例模式概述"></a>2. 单例模式概述</h1><ul><li><p>单例的定义</p><ul><li>一个类只允许创建唯一一个对象，那这个类就是一个单例类</li></ul></li><li><p>对象的唯一性指</p><ul><li>进程内只允许创建一个对象</li><li>进程之间是不唯一的</li></ul></li></ul><h2 id="2-1-模拟任务管理类"><a href="#2-1-模拟任务管理类" class="headerlink" title="2.1 模拟任务管理类"></a>2.1 模拟任务管理类</h2><pre><code>class TaskManager{     public TaskManager() {...} //初始化窗口     public void displayProcesses()  {……} //显示进程     public void  displayServices() {……} //显示服务}</code></pre><p>对其进行重构，为了使其是单一实例的，那我们需要禁止类的外部直接使用new来创建对象  —–&gt;  将其构造函数的可见性变为private</p><pre><code>public TaskManager() {...}</code></pre><p>在类内部创建对象，保存这个唯一实例</p><pre><code>private static TaskManager tm = null;public static TaskManager getInstance() {    if (tm == null) {        tm = new TaskManager();    }    return tm;}</code></pre><p><code>getInstance()</code>定义成一个静态方法，这样可以直接通过类名来使用</p><h2 id="2-2-定义"><a href="#2-2-定义" class="headerlink" title="2.2 定义"></a>2.2 定义</h2><blockquote><p>单例模式(Singleton Pattern)：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式是一种对象创建型模式。</p></blockquote><ol><li>只有一个实例</li><li>必须自行创建这个实例</li><li>必须自行向整个系统提供这个实例</li></ol><p><img src="https://i.loli.net/2020/02/03/vKPVAeCrImYXq1U.gif" alt="s1.gif"></p><h2 id="2-3-负载均衡器的设计与实现"><a href="#2-3-负载均衡器的设计与实现" class="headerlink" title="2.3 负载均衡器的设计与实现"></a>2.3 负载均衡器的设计与实现</h2><p> Sunny软件公司承接了一个服务器负载均衡(Load Balance)软件的开发工作，该软件运行在一台负载均衡服务器上，可以将并发访问和数据流量分发到服务器集群中的多台设备上进行并发处理，提高系统的整体处理能力，缩短响应时间。由于集群中的服务器需要动态删减，且客户端请求需要统一分发，因此需要确保负载均衡器的唯一性，只能有一个负载均衡器来负责服务器的管理和请求的分发，否则将会带来服务器状态的不一致以及请求分配冲突等问题。如何确保负载均衡器的唯一性是该软件成功的关键。</p><p>使用单例模式来设计该负载均衡器： </p><p><img src="https://i.loli.net/2020/02/03/4vJzXqlRCITLUge.gif" alt="s2.gif"></p><pre><code>import java.util.*;//负载均衡器LoadBalancer：单例类，真实环境下该类将非常复杂，包括大量初始化的工作和业务方法，考虑到代码的可读性和易理解性，只列出部分与模式相关的核心代码class LoadBalancer {    //私有静态成员变量，存储唯一实例    private static LoadBalancer instance = null;    //服务器集合    private List serverList = null;    //私有构造函数    private LoadBalancer() {        serverList = new ArrayList();    }    //公有静态成员方法，返回唯一实例    public static LoadBalancer getLoadBalancer() {        if (instance == null) {            instance = new LoadBalancer();        }        return instance;    }    //增加服务器    public void addServer(String server) {        serverList.add(server);    }    //删除服务器    public void removeServer(String server) {        serverList.remove(server);    }    //使用Random类随机获取服务器    public String getServer() {        Random random = new Random();        int i = random.nextInt(serverList.size());        return (String)serverList.get(i);    }}</code></pre><h1 id="3-饿汉式单例模式和懒汉式单例模式"><a href="#3-饿汉式单例模式和懒汉式单例模式" class="headerlink" title="3. 饿汉式单例模式和懒汉式单例模式"></a>3. 饿汉式单例模式和懒汉式单例模式</h1><h2 id="3-1-饿汉式单例模式"><a href="#3-1-饿汉式单例模式" class="headerlink" title="3.1 饿汉式单例模式"></a>3.1 饿汉式单例模式</h2><p><img src="https://i.loli.net/2020/02/03/UAk8topvxWQTwfd.gif" alt="s3.gif"></p><pre><code>class EagerSingleton {     private static final EagerSingleton instance = new EagerSingleton();     private EagerSingleton() { }     public static EagerSingleton getInstance() {        return instance;     }   }</code></pre><p>在类加载的时候，静态变量instance就会被初始化，此时类的私有构造函数会被调用，然后单例类的唯一实例会在这个时候被创建出来。</p><p>恶汉模式的好处是没有延迟加载，这样子是在需要用到它的时候才来执行这个耗时长的初始化过程，可以避免在程序运行的时候才初始化导致的新跟那个问题。</p><h2 id="3-2-懒汉式单例模式"><a href="#3-2-懒汉式单例模式" class="headerlink" title="3.2 懒汉式单例模式"></a>3.2 懒汉式单例模式</h2><p><img src="https://i.loli.net/2020/02/03/bDLQtESdzF8Ugmq.gif" alt="s4.gif"></p><p>在第一个调用getInstance()方法的时候进行实例化。又叫做延迟加载技术——在需要的时候再加载实例，为了避免多个线程同时调用getInstance()方法，我们需要使用<strong><em>synchronized关键字</em></strong>：</p><pre><code>class LazySingleton {     private static LazySingleton instance = null;     private LazySingleton() { }     synchronized public static LazySingleton getInstance() {         if (instance == null) {            instance = new LazySingleton();         }        return instance;     }}</code></pre><p>getInstance()方法带锁，并发度很低，如果频繁调用，需要频繁开关锁的话，效率是很低的。</p><h2 id="3-3-兼顾效率和安全性的方式-饱汉-饿汉"><a href="#3-3-兼顾效率和安全性的方式-饱汉-饿汉" class="headerlink" title="3.3 兼顾效率和安全性的方式(饱汉+饿汉)"></a>3.3 兼顾效率和安全性的方式(饱汉+饿汉)</h2><pre><code>class LazySingleton {     private static LazySingleton instance；     private LazySingleton() { }     public static LazySingleton getInstance() {         if (instance == null) {            synchronized(LazySingleton.class) {                instance = new LazySingleton();             }        }        return instance;     }}</code></pre><h2 id="3-4-使用静态内部类"><a href="#3-4-使用静态内部类" class="headerlink" title="3.4 使用静态内部类"></a>3.4 使用静态内部类</h2><p>利用Java的静态内部类，因为静态内部类只有在被调用的时候，才会被加载。而静态内部类的唯一性，线程安全型都由JVM来保证。</p><p>public class LazySingleton {<br>    private static class LazySingletonHolder{<br>        private static final LazySingleton instance = new LazySingleton();<br>    }</p><pre><code>public static LazySingleton getInstance() {    return LazySingletonHolder.instance;}</code></pre><p>}</p><h1 id="4-单例的问题"><a href="#4-单例的问题" class="headerlink" title="4. 单例的问题"></a>4. 单例的问题</h1><ul><li>违背了基于接口而非实现的设计原则，如果我们想要更改的话，是需要到每个类的位置去做更改的</li><li>单例会隐藏类之间的依赖关系<ul><li>一般来说我们通过构造函数，参数传递来声明类之间的依赖关系</li><li>单例不需要显示创建，不需要依赖参数传递，在函数中直接调用</li><li>对代码的扩展性不友好<h1 id="5-优缺点分析"><a href="#5-优缺点分析" class="headerlink" title="5. 优缺点分析"></a>5. 优缺点分析</h1></li></ul></li></ul><h2 id="5-1-优点"><a href="#5-1-优点" class="headerlink" title="5.1 优点"></a>5.1 优点</h2><ol><li>提供了对唯一实例的访问控制</li><li>因为内存中只存在一个对象，因此可以节约系统资源。尤其是对于一些需要频繁创建和销毁的对象，单例模式可以很大程度上提高系统性能</li></ol><h2 id="5-2-缺点"><a href="#5-2-缺点" class="headerlink" title="5.2 缺点"></a>5.2 缺点</h2><ol><li>扩展困难</li><li>职责相对比较重。因为单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身的功能融合到一起。</li><li>一些语言的垃圾自动回收技术，如果实例化的对象在一段时间内没有被使用，系统会认为它是垃圾，会自动销毁并回收资源。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-为什么需要单例模式&quot;&gt;&lt;a href=&quot;#1-为什么需要单例模式&quot; class=&quot;headerlink&quot; title=&quot;1. 为什么需要单例模式&quot;&gt;&lt;/a&gt;1. 为什么需要单例模式&lt;/h1&gt;&lt;p&gt;windows系统的任务管理器，只能有一个,唯一性的原因：&lt;/p
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="Design Pattern" scheme="https://www.llchen60.com/tags/Design-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>设计原则，编程规范的总结</title>
    <link href="https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%EF%BC%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83%E7%9A%84%E6%80%BB%E7%BB%93/"/>
    <id>https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%EF%BC%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83%E7%9A%84%E6%80%BB%E7%BB%93/</id>
    <published>2020-06-07T18:12:00.000Z</published>
    <updated>2020-06-11T04:21:56.586Z</updated>
    
    <content type="html"><![CDATA[<p>本文作为一个对于整理过的设计原则和思想的总结，包括：</p><ul><li>面向对象<ul><li>封装、继承、抽象、多态</li><li>面向对象编程 vs 面向过程编程</li><li>面向对象分析、设计、编程</li><li>接口 vs 抽象类</li><li>基于接口而非实现编程</li><li>多用组合少用继承</li><li>贫血模式 vs 充血模式 </li></ul></li><li>设计原则<ul><li>单一职责原则</li><li>开闭原则</li><li>里氏替换原则</li><li>接口隔离原则</li><li>依赖倒置原则</li><li>DRY</li><li>KISS</li><li>YAGNI</li><li>LOD</li></ul></li><li>规范与重构<ul><li>目的，对象，时机，方法</li><li>单元测试和代码的可测试性</li><li>大重构</li><li>小重构</li></ul></li></ul><h1 id="1-代码质量的评判标准"><a href="#1-代码质量的评判标准" class="headerlink" title="1. 代码质量的评判标准"></a>1. 代码质量的评判标准</h1><ul><li>常用评价标准<ul><li>最常用<ul><li>可维护性</li><li>可读性</li><li>可扩展性</li></ul></li><li>其他<ul><li>灵活性</li><li>简洁性</li><li>可复用性</li><li>可测试性</li></ul></li></ul></li><li>如何写出高质量代码？<ul><li>设计思想</li><li>设计原则</li><li>设计模式</li><li>编码规范</li><li>重构技巧</li></ul></li></ul><h1 id="2-面向对象"><a href="#2-面向对象" class="headerlink" title="2. 面向对象"></a>2. 面向对象</h1><ul><li><p>特性</p><ul><li>封装<ul><li>隐藏信息，数据访问保护</li></ul></li><li>继承<ul><li>is a</li></ul></li><li>多态<ul><li>子类可以替代父类的模式</li><li>在实际代码运行当中，通过调用子类的方法来实现</li></ul></li><li>抽象<ul><li>隐藏类的具体实现方法</li><li>使得修改实现不需要改变定义</li></ul></li></ul></li><li><p>面向对象设计 – 如何设计出具体的类</p><ul><li>划分职责</li><li>定义类及其属性和方法</li><li>定义类和类之间的交互关系</li><li>将类组装起来并提供执行入口</li></ul></li><li><p>接口 vs 抽象类</p><ul><li><p>接口</p><ul><li>对方法的抽象</li><li>是一种has a的关系</li><li>表示具有某一组行为特性</li><li>为了解决解耦问题，隔离接口和具体实现，提高代码扩展性</li></ul></li><li><p>抽象类</p><ul><li>对成员变量和方法的抽象</li><li>是一种is a的关系</li><li>为了解决代码复用的问题</li></ul></li></ul></li><li><p>贫血模型 vs 充血模型</p><ul><li>MVC  贫血模型</li><li>充血模型的设计<ul><li>与贫血模型的区别在于Service层</li><li>在基于充血模型的开发模式下，将service类中的业务逻辑移动到一个充血的domain领域模型当中</li><li>让Service类的实现依赖这个domain类</li></ul></li></ul></li></ul><h1 id="3-设计原则"><a href="#3-设计原则" class="headerlink" title="3. 设计原则"></a>3. 设计原则</h1><ul><li><p>单一职责原则</p><ul><li>一个类只负责一个职责或者功能</li></ul></li><li><p>开闭原则</p><ul><li>对扩展开放，对修改关闭<ul><li>添加一个新的功能，应该是通过在已有的代码基础上扩展代码(新增模块，类，方法，属性)，而非修改已有的代码的方式来完成的</li><li>指的是以最小的修改代码的代价来完成新功能的开发</li></ul></li></ul></li><li><p>里氏替代原则</p><ul><li>子类对象能够替代程序当中父类对象出现的任何地方，并且保证原来程序的逻辑行为不变及正确性不被破坏。</li><li>理解 Design by contract 按照协议来设计</li><li>父类定义函数的约定/协议</li><li>子类可以改变函数的内部实现逻辑，但不能改变函数的原有约定<ul><li>约定包括<ul><li>函数声明要实现的功能</li><li>对输入 输出 异常的约定</li><li>注释中罗列的特殊说明</li></ul></li></ul></li></ul></li><li><p>接口隔离原则</p><ul><li>客户端不应该强迫依赖它不需要的接口<ul><li>将接口理解为一组接口集合<ul><li>如果部分接口只被部分调用者使用，应该将这部分接口隔离起来，单独给他们使用</li></ul></li><li>理解为单个API接口或函数<ul><li>部分调用者只需要函数的部分功能，那我们就应该将函数拆分为粒度更细的多个函数，让调用者只依赖它需要的那个细粒度的函数</li></ul></li><li>理解为OOP中的接口<ul><li>接口的设计需要尽量单一，不要让接口的实现类和调用者，依赖不需要的接口函数</li></ul></li></ul></li></ul></li><li><p>YAGNI - you ain’t gonna need it </p></li><li><p>LOD - 高内聚，低耦合</p></li><li><p>迪米特法则</p><ul><li>不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口</li></ul></li></ul><h1 id="4-相关的文章"><a href="#4-相关的文章" class="headerlink" title="4. 相关的文章"></a>4. 相关的文章</h1><ol><li><a href="https://llchen60.com/%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0-general/" target="_blank" rel="noopener">架构学习-general</a></li><li><a href="https://llchen60.com/%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0-%E5%8E%9F%E5%88%99/" target="_blank" rel="noopener">架构学习-原则</a></li><li><a href="https://llchen60.com/%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0-%E5%8F%AF%E6%89%A9%E5%B1%95%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">架构学习-可扩展架构模式</a></li><li><a href="https://llchen60.com/%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0-%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%9D%A5%E6%BA%90/" target="_blank" rel="noopener">架构学习-复杂度来源</a></li><li><a href="https://llchen60.com/%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0-%E5%AE%9E%E6%88%98/" target="_blank" rel="noopener">架构学习 - 实战</a></li><li><a href="https://llchen60.com/%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3%E6%A8%A1%E6%9D%BF/" target="_blank" rel="noopener">架构学习 - 架构设计文档模板</a></li><li><a href="https://llchen60.com/%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%B5%81%E7%A8%8B/" target="_blank" rel="noopener">架构学习-架构设计流程</a></li><li><a href="https://llchen60.com/%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0-%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">架构学习-高可用架构模式</a></li><li><a href="https://llchen60.com/%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">架构学习-高性能架构模式</a></li><li><a href="https://llchen60.com/%E5%9F%BA%E4%BA%8E%E5%85%85%E8%A1%80%E6%A8%A1%E5%9E%8B%E7%9A%84DDD%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B/" target="_blank" rel="noopener">基于充血模型的DDD开发模型</a></li><li><a href="https://llchen60.com/SOLID-%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99/" target="_blank" rel="noopener">SOLID-单一职责原则</a></li><li><a href="https://llchen60.com/SOLID-%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/" target="_blank" rel="noopener">SOLID - 开闭原则</a></li><li><a href="https://llchen60.com/SOLID-%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99/" target="_blank" rel="noopener">SOLID - 里氏替换原则</a></li><li><a href="https://llchen60.com/SOLID-%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99/" target="_blank" rel="noopener">SOLID - 接口隔离原则</a></li><li><a href="https://llchen60.com/SOLID-%E4%BE%9D%E8%B5%96%E5%8F%8D%E8%BD%AC%E5%8E%9F%E5%88%99/" target="_blank" rel="noopener">SOLID - 依赖反转原则</a></li><li><a href="https://llchen60.com/KISS-and-YAGNI%E5%8E%9F%E5%88%99/" target="_blank" rel="noopener">KISS and YAGNI原则</a></li><li><a href="https://llchen60.com/DRY-%E5%8E%9F%E5%88%99/" target="_blank" rel="noopener">DRY 原则</a></li><li><a href="https://llchen60.com/%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99-LOD-%E2%80%94-%E9%AB%98%E5%86%85%E8%81%9A%EF%BC%8C%E4%BD%8E%E8%80%A6%E5%90%88/" target="_blank" rel="noopener">迪米特法则 (LOD) — 高内聚，低耦合</a></li><li><a href="https://llchen60.com/%E5%BA%94%E7%94%A8%E8%AE%BE%E8%AE%A1-Practice/" target="_blank" rel="noopener">应用设计 Practice</a></li><li><a href="https://llchen60.com/%E5%85%B3%E4%BA%8E%E6%8F%90%E9%AB%98%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E7%9A%84Tips/" target="_blank" rel="noopener">提高代码质量的Tips</a></li></ol><h1 id="5-实战：ID生成器"><a href="#5-实战：ID生成器" class="headerlink" title="5. 实战：ID生成器"></a>5. 实战：ID生成器</h1><p>使用ID来做服务内部的请求追踪，因为在日志文件当中，不同请求的日志是会交织到一起的。我们需要使用ID来标识哪些日志属于同一个请求。</p><p>因此我们需要做的事情就是给每个请求分配一个唯一的ID，并且保存在请求的上下文当中。Java当中可以将ID存储在ThreadLocal当中，或者使用Slf4j的MDC(Mapped Diagnostic Contexts)来实现。每次打印日志的时候，我们就可以从请求上下文当中取出请求ID，跟日志一块输出。</p><h2 id="5-1-原始的生成ID的代码"><a href="#5-1-原始的生成ID的代码" class="headerlink" title="5.1 原始的生成ID的代码"></a>5.1 原始的生成ID的代码</h2><pre><code>public class IdGenerator {  private static final Logger logger = LoggerFactory.getLogger(IdGenerator.class);  public static String generate() {    String id = &quot;&quot;;    try {      String hostName = InetAddress.getLocalHost().getHostName();      String[] tokens = hostName.split(&quot;\\.&quot;);      if (tokens.length &gt; 0) {        hostName = tokens[tokens.length - 1];      }      char[] randomChars = new char[8];      int count = 0;      Random random = new Random();      while (count &lt; 8) {        int randomAscii = random.nextInt(122);        if (randomAscii &gt;= 48 &amp;&amp; randomAscii &lt;= 57) {          randomChars[count] = (char)(&#39;0&#39; + (randomAscii - 48));          count++;        } else if (randomAscii &gt;= 65 &amp;&amp; randomAscii &lt;= 90) {          randomChars[count] = (char)(&#39;A&#39; + (randomAscii - 65));          count++;        } else if (randomAscii &gt;= 97 &amp;&amp; randomAscii &lt;= 122) {          randomChars[count] = (char)(&#39;a&#39; + (randomAscii - 97));          count++;        }      }      id = String.format(&quot;%s-%d-%s&quot;, hostName,              System.currentTimeMillis(), new String(randomChars));    } catch (UnknownHostException e) {      logger.warn(&quot;Failed to get the host name.&quot;, e);    }    return id;  }}</code></pre><ul><li>上述代码存在的问题<ul><li>static 方法可测试性太低</li><li>generate函数的代码实现依赖运行环境，时间函数以及随机函数，本身的可测试性也不强</li><li>随机字符串生成代码难以看懂</li><li>有太多的魔法数，需要告诉读代码的人这些都是什么意思才可以的</li></ul></li></ul><h2 id="5-2-完善后的代码"><a href="#5-2-完善后的代码" class="headerlink" title="5.2 完善后的代码"></a>5.2 完善后的代码</h2><pre><code>public interface IdGenerator {  String generate();}public interface LogTraceIdGenerator extends IdGenerator {}public class RandomIdGenerator implements IdGenerator {  private static final Logger logger = LoggerFactory.getLogger(RandomIdGenerator.class);  @Override  public String generate() {    String substrOfHostName = getLastfieldOfHostName();    long currentTimeMillis = System.currentTimeMillis();    String randomString = generateRandomAlphameric(8);    String id = String.format(&quot;%s-%d-%s&quot;,            substrOfHostName, currentTimeMillis, randomString);    return id;  }  private String getLastfieldOfHostName() {    String substrOfHostName = null;    try {      String hostName = InetAddress.getLocalHost().getHostName();      String[] tokens = hostName.split(&quot;\\.&quot;);      substrOfHostName = tokens[tokens.length - 1];      return substrOfHostName;    } catch (UnknownHostException e) {      logger.warn(&quot;Failed to get the host name.&quot;, e);    }    return substrOfHostName;  }  private String generateRandomAlphameric(int length) {    char[] randomChars = new char[length];    int count = 0;    Random random = new Random();    while (count &lt; length) {      int maxAscii = &#39;z&#39;;      int randomAscii = random.nextInt(maxAscii);      boolean isDigit= randomAscii &gt;= &#39;0&#39; &amp;&amp; randomAscii &lt;= &#39;9&#39;;      boolean isUppercase= randomAscii &gt;= &#39;A&#39; &amp;&amp; randomAscii &lt;= &#39;Z&#39;;      boolean isLowercase= randomAscii &gt;= &#39;a&#39; &amp;&amp; randomAscii &lt;= &#39;z&#39;;      if (isDigit|| isUppercase || isLowercase) {        randomChars[count] = (char) (randomAscii);        ++count;      }    }    return new String(randomChars);  }}//代码使用举例LogTraceIdGenerator logTraceIdGenerator = new RandomIdGenerator();</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文作为一个对于整理过的设计原则和思想的总结，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;面向对象&lt;ul&gt;
&lt;li&gt;封装、继承、抽象、多态&lt;/li&gt;
&lt;li&gt;面向对象编程 vs 面向过程编程&lt;/li&gt;
&lt;li&gt;面向对象分析、设计、编程&lt;/li&gt;
&lt;li&gt;接口 vs 抽象类&lt;/li&gt;

      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="设计原则" scheme="https://www.llchen60.com/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
      <category term="编程规范" scheme="https://www.llchen60.com/tags/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>价格心理学</title>
    <link href="https://www.llchen60.com/%E4%BB%B7%E6%A0%BC%E5%BF%83%E7%90%86%E5%AD%A6/"/>
    <id>https://www.llchen60.com/%E4%BB%B7%E6%A0%BC%E5%BF%83%E7%90%86%E5%AD%A6/</id>
    <published>2020-05-31T01:08:14.000Z</published>
    <updated>2020-06-05T03:37:44.103Z</updated>
    
    <content type="html"><![CDATA[<p>一些定价，看价的技巧。无论你是销售者还是购买者，应该都能从中得到一些对你更有利的定价策略。</p><h1 id="1-使自己的价格看起来更低"><a href="#1-使自己的价格看起来更低" class="headerlink" title="1. 使自己的价格看起来更低"></a>1. 使自己的价格看起来更低</h1><p>我们可以通过一些方式来影响在人们印象当中的产品的价格。当人们将你的产品价格和参考产品比较的时候，你可以用某些方式施加影响，来使得他们拿更低的价格来进行比较。</p><p>这样做有效的原因是我们的大脑是很懒的，我们在大脑中不会记一个物品的数字上的价格，很有可能是记录相对的高或者低</p><h4 id="1-对最左侧的数字减1"><a href="#1-对最左侧的数字减1" class="headerlink" title="1. 对最左侧的数字减1"></a>1. 对最左侧的数字减1</h4><p>通过比较转化率，我们会发现减少一分钱，即例如从$1 到$0.99，转化率就提高了1个百分点。</p><p><img src="https://i.loli.net/2020/05/31/Xr2xVAUkP7SsKM5.jpg" alt="conversion rate in Gumroad.jpg"></p><p>很多人都知道.99的魔力，但是转化率更大的转变出现在当最左侧的数字发生了改变的时候。大脑意识是有锚定效应的，即我们会认为$2.99是属于2的范畴，而$3是属于3的范畴，他们之间相差很大。同理出现在199和200之间，诸如此类。</p><h4 id="2-选择更少音节的价格"><a href="#2-选择更少音节的价格" class="headerlink" title="2. 选择更少音节的价格"></a><strong>2. 选择更少音节的价格</strong></h4><p>价格的整个读音（音节数量）也会影响最终对于价格的认知[3]。当我们需要处理更多音节的刺激的时候，我们会需要更多的意识来处理这种刺激，这同样适用于数字，当我们需要花更多的时间处理这个数字的时候，我们潜意识会认为这个数字非常大。</p><p>当包含更少的读音的时候，人们会认为价格比实际上低。</p><p>这不仅仅发生在读出价格的时候，研究表明哪怕我们看到的是写出来的价格，我们的大脑也会潜意识当中将其编码成听觉版本。[4]</p><h4 id="3-用更小的字号来展示价格"><a href="#3-用更小的字号来展示价格" class="headerlink" title="3. 用更小的字号来展示价格"></a><strong>3. 用更小的字号来展示价格</strong></h4><p>我们的大脑对于大小是有概念上的认知的。视觉大小与数字大小的交汇是很模糊的，即我们潜意识可能会认为视觉上用更小的字体也意味着数字本身是更小的。</p><p>同样，对于折扣来说，我们就应该使用尽可能大的字体来展示了。</p><p><img src="https://i.loli.net/2020/05/31/kMWAyd1LVaNsPEF.png" alt="pricing-tactic-3"></p><h4 id="4-移除价格当中的逗号"><a href="#4-移除价格当中的逗号" class="headerlink" title="4. 移除价格当中的逗号"></a><strong>4. 移除价格当中的逗号</strong></h4><p>移除逗号可以使得你的价格看起来更低！[5]</p><p>首先是视觉上，逗号使得整个数字显得更大；<br>其次是如果不加逗号，比如对于1499这个数字，会读成fourteen niety-nine; 但是如果加了逗号，那么就会读成one thousand four hundred and ninty nine. 音节从5个升到了10个。</p><h4 id="5-选择维度更小的词"><a href="#5-选择维度更小的词" class="headerlink" title="5. 选择维度更小的词"></a><strong>5. 选择维度更小的词</strong></h4><p>对于在显示的价格旁边的词，选择要谨慎。有些词是可以左右人们的设想的。举个例子, low friction vs high performance. 通过测试发现在参与者认为两个词语都同等重要的前提下，更多的人选择了带有Low Friction的。如果可以，在价格旁边选择维度更小的一些词。</p><h4 id="6-将物流和订单处理的费用分开"><a href="#6-将物流和订单处理的费用分开" class="headerlink" title="6. 将物流和订单处理的费用分开"></a><strong>6. 将物流和订单处理的费用分开</strong></h4><p>当你要在线销售产品的时候，往往需要支付物流和订单处理的费用。当将价格都分割开的时候，使得人们能够锚定在基础价格上，而不是整个价格。[6]</p><h4 id="7-提供首付金相关的选择"><a href="#7-提供首付金相关的选择" class="headerlink" title="7. 提供首付金相关的选择"></a><strong>7. 提供首付金相关的选择</strong></h4><p>一下子付1000刀和分10个月每次付100刀给人的感觉是完全不一样的。如果可能，我们通过使用月付可以很大程度上提升人们购买的欲望。他们会认为这个价格很低。</p><h4 id="8-提及每天的等值价格"><a href="#8-提及每天的等值价格" class="headerlink" title="8. 提及每天的等值价格"></a><strong>8. 提及每天的等值价格</strong></h4><p>假设我们在做一个月付的东西，30刀每月，这会显得很多。如果说每天一美元，给人感觉就会少一些了。</p><h4 id="9-关于大额的数字，要精准"><a href="#9-关于大额的数字，要精准" class="headerlink" title="9. 关于大额的数字，要精准"></a><strong>9. 关于大额的数字，要精准</strong></h4><p>比如购房的时候，$359,289和$359,000给人的感觉会很不一样，前者触发的是人们对于低价产品的认知；即足够精准，而后者会被默认为是价格很高的产品。除此以外，一个很精确的数字也会让人感觉谈价的余地相对有限；对方在很认真仔细的准备。 </p><h4 id="10-小额的价格放到左侧"><a href="#10-小额的价格放到左侧" class="headerlink" title="10. 小额的价格放到左侧"></a><strong>10. 小额的价格放到左侧</strong></h4><p>当我们设计一个布局的时候，价格应该往左侧放。这是因为在英文当中，我们将上和高质联系到了一起，低和不好的东西联系起来。譬如：</p><ul><li>go up to heaven </li><li>down to hell </li><li>thumbs up </li><li>thumbs down </li><li>get high</li><li>come down</li><li>etc.</li></ul><p>研究也证实了当好词在屏幕上方，坏词在屏幕下方的时候，我们能更快的识别出他们来。类似的概念也出现在数字上，根据研究[7]发现人们会将数字置于自己想象的一条水平方向的线上，从左到右数字依次增大。</p><p>因此小价格放到左侧，对于大家概念中的大价格，放到右侧。</p><h4 id="11-让用户看到价格的乘积-例子"><a href="#11-让用户看到价格的乘积-例子" class="headerlink" title="11. 让用户看到价格的乘积(例子)"></a><strong>11. 让用户看到价格的乘积(例子)</strong></h4><p><img src="https://i.loli.net/2020/06/03/OgXICK9tdBZHEyp.png" alt="price-multiples.png"></p><p>前两个是给了你无限添加topping的选择，从经济上来说是更好的选择，但是经过试验发现人们普遍更加喜欢后面的两个。</p><p>这是因为后面是可以计算的，即pizza的多少和toppings的数量的乘积等于价格。这种优势看起来有点荒唐，但是心理学能够给予解释。我们从小开始就在被训练一下基本的数学连接，比如熟知的九九乘法表，然后这种连接会终身影响我们，使得我们能够对其迅速反应。</p><p>也正因为这种连接，使得我们能够更加快速的处理几个不同部分的信息，并且通过数字连接建立起内容上的连接。</p><h4 id="12-正确使用取整操作"><a href="#12-正确使用取整操作" class="headerlink" title="12. 正确使用取整操作"></a><strong>12. 正确使用取整操作</strong></h4><p>取整的数字会相对容易处理很多，譬如100 vs 98.65。根据研究发现，当用户能够更快的处理分析价格的时候，他们会感觉这个价格感觉上更对。</p><p>与之相对的，消费者会需要更多的精神来处理非取整的价格，因此这种非取整的价格更适合理性消费的场景。</p><p>而对于基于情感进行的消费，使用整数价格会更容易促进销量的提升。</p><p>同样，不要使用像100，5000这样的数字，会很容易让消费者感觉这个价格虚高。</p><p>基于情感，使用整数；基于理性，可以使用带小数的价格。</p><h4 id="13-根据名字和生日调整价格"><a href="#13-根据名字和生日调整价格" class="headerlink" title="13. 根据名字和生日调整价格"></a><strong>13. 根据名字和生日调整价格</strong></h4><p>尽管略显古怪，但是确实很多研究都支持这个结论，即用户更喜欢有他们的名字同样字母的价格，亦或者是包含他们的生日的价格。[8]</p><p>心理学上的理论支持为implicit egotism – 以自我为中心的倾向。我们潜意识里会更加倾向于那些和我们相关的/ 构筑我们自我的事物。</p><h4 id="14-在最优时间展示价格"><a href="#14-在最优时间展示价格" class="headerlink" title="14. 在最优时间展示价格"></a><strong>14. 在最优时间展示价格</strong></h4><p>我们应该首先展示什么？ 你的产品或者价格？ </p><p>我们首先看到的是产品或者价格很大程度上决定了我们决定是否要去买这件产品的标准[9].</p><p>当产品被首先展示出来的时候，用户会根据产品质量，自己的喜爱程度来决定是否要购买</p><p>当价格首先被展示出来的时候，用户会根据这个产品是否值这个价格来决定是否要买。</p><p>当销售奢侈品的时候，就应该先展示产品，再阐明价格；而对于日常使用的产品来说，用户更倾向于先看到价格，再决定是否购买这件产品。</p><h4 id="15-向男士展示红颜色标注的价格"><a href="#15-向男士展示红颜色标注的价格" class="headerlink" title="15. 向男士展示红颜色标注的价格"></a>15. 向男士展示红颜色标注的价格</h4><p>研究[10]表明当价格标签颜色为红色的时候，男士更有可能买这件产品。</p><p>红色价格会成为关注的中心，很有可能变为做出评估的唯一信息。而且常常将红色价格和省钱联系起来。</p><h1 id="2-最大化参考价格"><a href="#2-最大化参考价格" class="headerlink" title="2. 最大化参考价格"></a>2. 最大化参考价格</h1><h4 id="16-使用一个高且精准的价格开始谈价-（从商家角度来看）"><a href="#16-使用一个高且精准的价格开始谈价-（从商家角度来看）" class="headerlink" title="16. 使用一个高且精准的价格开始谈价 （从商家角度来看）"></a>16. 使用一个高且精准的价格开始谈价 （从商家角度来看）</h4><p>基于锚定效应，使用一个更高的价格，往往能够使得最后商定的价格更高。我们不仅仅应该使用一个更高的价格，更应该使用一个更加精确的价格。</p><blockquote><p>If adjustment is viewed as movement along a subjective representational scale, then the resolution of this scale might also influence the amount of adjustment. X units of adjustment along a fine-resolution scale will cover less objective distance than the same number of units of adjustment along a coarse-resolution scale.</p></blockquote><h4 id="17-使用户看到更高的其他价格"><a href="#17-使用户看到更高的其他价格" class="headerlink" title="17. 使用户看到更高的其他价格"></a>17. 使用户看到更高的其他价格</h4><p>同样是通过锚定效应完成操作的，即 使人们能够看到更高的价格，那会潜意识当中也提高对你的产品的估价。</p><h4 id="18-使用户看到更高的数字"><a href="#18-使用户看到更高的数字" class="headerlink" title="18. 使用户看到更高的数字"></a>18. 使用户看到更高的数字</h4><p>依旧是潜意识，在展示价格之前，先使用户看到一些很大的数字，这已经足够来影响用户接下来对于数字相对大小的认知了。</p><p><img src="https://i.loli.net/2020/06/03/qKZ352bCYk9zPVE.png" alt="pricing-tactic-18.png"></p><h4 id="19-提高过去产品的售价"><a href="#19-提高过去产品的售价" class="headerlink" title="19. 提高过去产品的售价"></a>19. 提高过去产品的售价</h4><p>如果你正在推出一个更新版本的产品，针对行业，是可以尝试提高前一代的产品的售价的。新产品的参考价格会依托于上一代的产品，如果我们降价了的话，那新一代产品锚定的是上一代产品，会让用户有这一代产品相对比较贵的感觉。</p><h4 id="20-价格排序应该从高到低"><a href="#20-价格排序应该从高到低" class="headerlink" title="20. 价格排序应该从高到低"></a>20. 价格排序应该从高到低</h4><p>通过降序的排列，我们可以使得用户更有可能去买相对比较贵的选择。</p><p>首先，先看到的价格会成为我们的参考价格，如果初始价格比较高，用户就会生成一个相对比较高的参考价格。这样子的话，当我们降序排列，看到的新的产品往往感觉都会相对更有性价比好一些，就更容易达成交易，且平均值也会相对大一些。</p><p>还有一个原因是人们对于失去的厌恶，价格从低到高排列，失去的是价格的优势感觉，直觉反应是应该选低价的来减少损失。价格从高到低，感觉失去的是品质，直觉应该是选高品质的物品，哪怕价格高一些。中间当然有权衡。</p><h4 id="21-将价格放在大数量的右面-11"><a href="#21-将价格放在大数量的右面-11" class="headerlink" title="21. 将价格放在大数量的右面[11]"></a>21. 将价格放在大数量的右面[11]</h4><ul><li><p>前提条件</p><ul><li><p>单价计算应该是相对比较困难的</p><ul><li>当困难的时候，会更依赖于直觉去进行判断<ul><li>价格开始，注意力集中在花费</li><li>数量开始，注意力集中在潜在的好处</li></ul></li></ul></li><li><p>物品数量最好大于价格的数字</p><ul><li>锚定于数量，忽略价格</li><li>从而认为这是个很值得买的东西</li></ul></li></ul></li></ul><h1 id="3-强调参考价格之间的不同-鸿沟"><a href="#3-强调参考价格之间的不同-鸿沟" class="headerlink" title="3. 强调参考价格之间的不同/鸿沟"></a>3. 强调参考价格之间的不同/鸿沟</h1><h4 id="22-加入视觉上的售价对比"><a href="#22-加入视觉上的售价对比" class="headerlink" title="22. 加入视觉上的售价对比"></a>22. 加入视觉上的售价对比</h4><p>如果你将自己的价格和更高的其他产品价格对比，那么人们就更可能去买你的产品，因为有了对比以后会相对少一些自行去比价的动力了。</p><p>一些小技巧：</p><ul><li>如果视觉上使用不同大小，或者颜色，我们会给消费者一种很流程的体验，消费者会有将颜色的不同和价格上不同程度做通感的趋向。[12]</li><li>出了颜色和大小，视觉上的距离也会对消费者产生的对价格高低的概念产生影响，距离远会认为数字差的会更大[13]</li></ul><h4 id="23-提供一个“诱饵”的购买选择"><a href="#23-提供一个“诱饵”的购买选择" class="headerlink" title="23. 提供一个“诱饵”的购买选择"></a>23. 提供一个“诱饵”的购买选择</h4><p>举个例子：</p><ul><li>提供三个购买选择<ul><li>web only $59</li><li>print only $125 </li><li>web and print $125 </li></ul></li></ul><p>很多人肯定和我一样，刚开始看到的时候会认为第二个选择是错误的，用同等价格，可以购买网页版和纸质版，那么谁会只选择纸质版呢？ 当时经过试验发现就是这个print only的看似无用的选择，产生了锚定效应，即用户对于如何界定关于web 和 print only自己应该付多少钱的认知，通过放置print only的选择，最终选取web and print的人要多很多，整体GMS也有了很大提高。 </p><p><img src="https://i.loli.net/2020/06/05/C964yTjH2awuzqP.png" alt="psychological-pricing-table-3.png"></p><p><img src="https://i.loli.net/2020/06/05/KqY14GgLlTMkbWy.png" alt="psychological-pricing-table-4.png"></p><h1 id="4-减少付款的“心疼感”"><a href="#4-减少付款的“心疼感”" class="headerlink" title="4. 减少付款的“心疼感”"></a>4. 减少付款的“心疼感”</h1><h4 id="24-移除货币符号"><a href="#24-移除货币符号" class="headerlink" title="24. 移除货币符号"></a>24. 移除货币符号</h4><p>付款的心疼感是很容易被触发的，事实上货币符号本身就很容易触发这种情绪，让人们想花的更少。[14]</p><p>同样，需要取舍，即你放在这里的数字如果没有货币符号，是否会变得难以认清，难以明白这串数字代表价格，是需要做trade-off的。</p><h4 id="25-在用户使用前令他们付费"><a href="#25-在用户使用前令他们付费" class="headerlink" title="25. 在用户使用前令他们付费"></a>25. 在用户使用前令他们付费</h4><p>预付对链条中的所有角色都有例。对于生产方，首先可以减少资金的压力；对于消费者，预付往往会使得他们对产品更加满意，因为当先付款的时候，他们会更加专注于购买了物品以后他们获得的好处，而不是花了钱的痛感当中。如果他们已经使用了你的产品再付费，往往会更不情愿付款的。[15]</p><p>这对于那种收月度会员费的模式很有意义，如果是这种模式，那就应该在月初还没开始使用的时候先收费。当然经验也告诉我们确确实实现在大部分的商家都是这么做的。</p><p>同时不要在月底来推送你这个月总共花了多少钱之类的账单明细，这只会降低消费者的购买欲望。</p><h4 id="26-对非工具类的产品给多件折扣"><a href="#26-对非工具类的产品给多件折扣" class="headerlink" title="26. 对非工具类的产品给多件折扣"></a>26. 对非工具类的产品给多件折扣</h4><p>为了减少付费时候的痛感，可以考虑成套销售。成套来购买的时候，用户就很难给单件产品一个很清晰的定价了。而添加的产品最好是非工具类的，即使用的时候会给人带来一些愉悦的感觉的物品。在做描述的时候，也要注意着重去描述一些好玩的场景，者都会给用户带来愉悦的刺激，提高最终的付费比率。</p><h4 id="27-不要将价格昂贵和便宜的物品一起成套销售"><a href="#27-不要将价格昂贵和便宜的物品一起成套销售" class="headerlink" title="27. 不要将价格昂贵和便宜的物品一起成套销售"></a>27. 不要将价格昂贵和便宜的物品一起成套销售</h4><p>这样建议的原因是便宜的物品会改变消费者对于昂贵产品的认知，会认为其更贵，更不值钱。 </p><h4 id="28-将关注点转移到时间相关的方面"><a href="#28-将关注点转移到时间相关的方面" class="headerlink" title="28. 将关注点转移到时间相关的方面"></a>28. 将关注点转移到时间相关的方面</h4><p>当描述我们的产品的时候，尽量避免用金钱作为参考的描述。相反，使用时间概念来描述。</p><p>譬如，Mogilner，Aaker[16]做过的一个关于柠檬饮品的试验，他们做了三个强调不同属性的广告：</p><ul><li>Time: Spend a little time and enjoy C &amp; D’s lemonade</li><li>Money: Spend a little money and enjoy C &amp; D’s lemonade</li><li>Neutral: Enjoy C &amp; D’s lemonade</li></ul><p>实验结果发现时间相关的广告玩虐其他两个，相较而言，人们愿意付双倍的价格来购买柠檬汁。</p><h4 id="29-建立付费中转商"><a href="#29-建立付费中转商" class="headerlink" title="29. 建立付费中转商"></a>29. 建立付费中转商</h4><p>赌场使用代币而不是现金，礼品卡将钱提前存进去，这样做的好处实际上就是将我们把钱拿出口袋的动作发生的时间前移，和我们享用的时间分割开。这样就能够扭曲付费时候的立场，使得不会觉得那么的痛苦。</p><p>这样做行之有效的原因是因为人都是懒的，会不愿意去算各种方式的转化率的问题.</p><h4 id="30-避免直接联系到金钱的语言"><a href="#30-避免直接联系到金钱的语言" class="headerlink" title="30. 避免直接联系到金钱的语言"></a>30. 避免直接联系到金钱的语言</h4><p>the money in your account vs your credits </p><p>通过尽量避免将app内的点数和实际金钱挂钩，就会使得用户失去对于钱的某些概念。</p><p>同时，可以的话不要做1比1 的转化，太容易做这个计算了。可以搞比如说存100送10块之类的，这样的转化就会在1 - 1.1之间，对于用户来说，计算的难度上来，这样计算的人就会少很多了。</p><h4 id="31-强调你的产品的固定成本"><a href="#31-强调你的产品的固定成本" class="headerlink" title="31. 强调你的产品的固定成本"></a>31. 强调你的产品的固定成本</h4><p>消费者会在看到产品以后做出一个价格高低的判断，但是他们也同样在意价格的合理程度。即便你的价格是低的，用户仍然可能认为这个价格不合理；同样，对于相对高的价格，用户也有可能认为非常合适。这取决于以下几个因素：</p><ul><li>你如何定价的？<ul><li>基于成本的定价</li><li>基于供求的定价</li></ul></li></ul><p>用户会认为基于成本的定价更加公平，这也是你可以通过强调产品本身的成本从而给出价格很合适的认知的原因。强调你的产品的原材料非常好，或者其他很费钱的方面，这些信息会使得用户对你的产品价格有个更真切的认知。</p><h4 id="32-对于相似的产品，价格需要有一点不同"><a href="#32-对于相似的产品，价格需要有一点不同" class="headerlink" title="32. 对于相似的产品，价格需要有一点不同"></a>32. 对于相似的产品，价格需要有一点不同</h4><p>你也许经历过选择困难症，往往是选择越多，人们就越难以做出选择。一旦人们做出一个选择，他们就会失去其他选择可能带来的利益。因为对于失去的厌恶，他们就会推迟自己的决定，尤其是当更多的选择在的时候。</p><p>同样有研究者做过这样的实验，实验者询问两组参与者是否想要买一盒口香糖，每组都有以下两种选择</p><ul><li>组1： 同样价格</li><li>组2： 稍稍不同的价格 (62美分 vs 64美分)</li></ul><p><img src="https://i.loli.net/2020/06/05/2RWLMOteuDTbxpC.png" alt="price-differences.png"></p><p>实验结果发现当价格稍稍有些不同的时候，人们更有可能去买一盒口香糖。</p><p>当两个产品有同样的价格的时候，人们无法立刻区分二者的不同，那么他们只能自己主动去寻找特征上的不同。因为主动寻找，所以产品的不同会看着更加明显。</p><p>然而，当你给价格加上一点点不同的时候，你减少了搜索不同的需求。消费者可以很直接的通过价格来区分不同的产品。因为用户对于产品的不同关注的更少，两个产品直观上就会看起来更加雷斯了。这种相似性是的人们更可能去选择一个产品。</p><p><img src="https://i.loli.net/2020/06/05/6JD8M4dX2Rlfor5.png" alt="pricing-tactic-32.png"></p><h4 id="33-使用更加频繁小额的提价"><a href="#33-使用更加频繁小额的提价" class="headerlink" title="33. 使用更加频繁小额的提价"></a>33. 使用更加频繁小额的提价</h4><p>最简单的控制对于价格相对高低的概念的方法是根于刚刚能注意到的不同。比如你的价格是11.99，那么加到12.99算比较合理的，加到19.99就会很夸张了</p><h4 id="34-减小某特征-vs-提价"><a href="#34-减小某特征-vs-提价" class="headerlink" title="34. 减小某特征 vs 提价"></a>34. 减小某特征 vs 提价</h4><p>除了提价，另外可以选择的是在分量上，某个特征上的一定程度的减少。同样要遵循着小额多次的宗旨，一点点来。 </p><h1 id="5-适量使用折扣"><a href="#5-适量使用折扣" class="headerlink" title="5. 适量使用折扣"></a>5. 适量使用折扣</h1><p>如果没有合理使用，折扣是有可能伤害你的事业的。也有人小极端，认为我们永远不应该使用折扣 [17]. 值得注意的是，如果我们的折扣十分频繁，或者折扣力度太大，是会使得消费者对于产品，品牌的认知改变的。消费者可能会等待下一个折扣期才会购买产品了。</p><p>同样，折扣也会降低你的产品的参考价格，使得人们未来更少买（因为觉得你的当前价格高）</p><h4 id="35-遵循100原则"><a href="#35-遵循100原则" class="headerlink" title="35. 遵循100原则"></a>35. 遵循100原则</h4><p>当你的价格低于100的时候，使用百分比折扣，反之直接使用数字；目的是使得折扣的程度看起来更大。</p><h4 id="36-给折扣一个原因"><a href="#36-给折扣一个原因" class="headerlink" title="36. 给折扣一个原因"></a>36. 给折扣一个原因</h4><p>为了最大化折扣的有效性，我们需要解释为什么提供这样的折扣。</p><p>比如every day low pricing store 指向的是供应商给的折扣，当你提供折扣的理由的时候，你在说明他的临时性。因此人们不太会将你的折扣价和他内在隐含的实际价值做出强关联。</p><p><img src="https://i.loli.net/2020/06/05/3TSGCNQscynW6gi.png" alt="pricing-tactic-36.png"></p><h4 id="37-提供更好计算的折扣"><a href="#37-提供更好计算的折扣" class="headerlink" title="37. 提供更好计算的折扣"></a>37. 提供更好计算的折扣</h4><p>提供更好计算的折扣可以显得折扣更大的</p><h4 id="38-在月末打折"><a href="#38-在月末打折" class="headerlink" title="38. 在月末打折"></a>38. 在月末打折</h4><p>当我们总钱数少的时候，我们会更不愿意付钱出去。到了月末，很多人的钱包都会空下来，就算购买，也很可能只能买折扣的东西了。</p><h4 id="39-将你的促销价放在原价的右侧"><a href="#39-将你的促销价放在原价的右侧" class="headerlink" title="39. 将你的促销价放在原价的右侧"></a>39. 将你的促销价放在原价的右侧</h4><p>研究[18]表明当促销价放在原价的右边的时候，消费者会觉得折扣更大一些。</p><h4 id="40-只给低价商品折扣"><a href="#40-只给低价商品折扣" class="headerlink" title="40. 只给低价商品折扣"></a>40. 只给低价商品折扣</h4><p>折扣有可能有害的，尤其是当你结束一个折扣的时候，人们可能会选择竞品，或者等待下一个折扣期。</p><p>那么这种副作用会在什么时候因为什么而生效呢？ 答案在于你的品牌的定位，是高质量的还是低质量的产品，高质量商品就应该集中注意力于质量</p><h4 id="41-逐渐减小折扣的百分比"><a href="#41-逐渐减小折扣的百分比" class="headerlink" title="41. 逐渐减小折扣的百分比"></a>41. 逐渐减小折扣的百分比</h4><p>这种方式能够吸引流量，也能够保证自己的利润不受到太大的损害。</p><h4 id="42-折扣完价格的右侧数字需要小一些"><a href="#42-折扣完价格的右侧数字需要小一些" class="headerlink" title="42. 折扣完价格的右侧数字需要小一些"></a>42. 折扣完价格的右侧数字需要小一些</h4><p>当右侧的数字小，会显得整个折扣相对比较大。</p><p><img src="https://i.loli.net/2020/06/05/qU7mokILNzFGJ5M.png" alt="right-digit-effect-2.png"></p><p><img src="https://i.loli.net/2020/06/05/KNczCvMyIa2hOrf.png" alt="pricing-tactic-42.png"></p><p><img src="https://i.loli.net/2020/06/05/pfBYcn2QTrbtyJ7.png" alt="psychological-pricing-table5.png"></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://www.nickkolenda.com/psychological-pricing-strategies/" target="_blank" rel="noopener">https://www.nickkolenda.com/psychological-pricing-strategies/</a> </li><li><a href="https://blog.gumroad.com/post/64417917582/a-penny-saved-psychological-pricing" target="_blank" rel="noopener">https://blog.gumroad.com/post/64417917582/a-penny-saved-psychological-pricing</a></li><li><a href="https://www.sciencedirect.com/science/article/abs/pii/S1057740811001082" target="_blank" rel="noopener">https://www.sciencedirect.com/science/article/abs/pii/S1057740811001082</a></li><li><a href="https://www.sciencedirect.com/science/article/abs/pii/001002779290049N" target="_blank" rel="noopener">https://www.sciencedirect.com/science/article/abs/pii/001002779290049N</a></li><li><a href="https://www.sciencedirect.com/science/article/abs/pii/S1057740811001082" target="_blank" rel="noopener">https://www.sciencedirect.com/science/article/abs/pii/S1057740811001082</a></li><li><a href="https://www8.gsb.columbia.edu/sites/decisionsciences/files/files/Divide_and_Prosper.pdf" target="_blank" rel="noopener">https://www8.gsb.columbia.edu/sites/decisionsciences/files/files/Divide_and_Prosper.pdf</a></li><li><a href="http://www.dc.uba.ar/materias/incc/practicas/p1/Dehaene-ParitySNARCeffect-JEPGeneral1993.pdf" target="_blank" rel="noopener">www.dc.uba.ar/materias/incc/practicas/p1/Dehaene-ParitySNARCeffect-JEPGeneral1993.pdf</a></li><li><a href="https://journals.ama.org/doi/abs/10.1509/jm.13.0059" target="_blank" rel="noopener">https://journals.ama.org/doi/abs/10.1509/jm.13.0059</a></li><li><a href="https://journals.ama.org/doi/abs/10.1509/jmr.13.0488" target="_blank" rel="noopener">https://journals.ama.org/doi/abs/10.1509/jmr.13.0488</a></li><li><a href="http://www.dhruvgrewal.com/wp-content/uploads/2014/09/2013-JR-Color.pdf" target="_blank" rel="noopener">http://www.dhruvgrewal.com/wp-content/uploads/2014/09/2013-JR-Color.pdf</a></li><li><a href="https://vtechworks.lib.vt.edu/bitstream/handle/10919/49138/661893.pdf?sequence=1&amp;isAllowed=y" target="_blank" rel="noopener">https://vtechworks.lib.vt.edu/bitstream/handle/10919/49138/661893.pdf?sequence=1&amp;isAllowed=y</a></li><li><a href="https://production.wordpress.uconn.edu/businessmarketing/wp-content/uploads/sites/724/2014/08/size-does-matter.pdf" target="_blank" rel="noopener">https://production.wordpress.uconn.edu/businessmarketing/wp-content/uploads/sites/724/2014/08/size-does-matter.pdf</a></li><li><a href="https://www.sciencedirect.com/science/article/abs/pii/S1057740809000266" target="_blank" rel="noopener">https://www.sciencedirect.com/science/article/abs/pii/S1057740809000266</a></li><li><a href="https://www.sciencedirect.com/science/article/abs/pii/S1057740809000266" target="_blank" rel="noopener">https://www.sciencedirect.com/science/article/abs/pii/S1057740809000266</a></li><li><a href="https://www.andrew.cmu.edu/user/gl20/GeorgeLoewenstein/Papers_files/pdf/redblack.pdf" target="_blank" rel="noopener">https://www.andrew.cmu.edu/user/gl20/GeorgeLoewenstein/Papers_files/pdf/redblack.pdf</a></li><li><a href="https://www.jstor.org/stable/10.1086/597161?seq=1" target="_blank" rel="noopener">https://www.jstor.org/stable/10.1086/597161?seq=1</a></li><li><a href="https://socialtriggers.com/why-you-should-never-discount/" target="_blank" rel="noopener">https://socialtriggers.com/why-you-should-never-discount/</a></li><li><a href="https://journals.ama.org/doi/pdf/10.1509/jm.12.0052" target="_blank" rel="noopener">https://journals.ama.org/doi/pdf/10.1509/jm.12.0052</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一些定价，看价的技巧。无论你是销售者还是购买者，应该都能从中得到一些对你更有利的定价策略。&lt;/p&gt;
&lt;h1 id=&quot;1-使自己的价格看起来更低&quot;&gt;&lt;a href=&quot;#1-使自己的价格看起来更低&quot; class=&quot;headerlink&quot; title=&quot;1. 使自己的价格看起来更
      
    
    </summary>
    
    
      <category term="Notes" scheme="https://www.llchen60.com/categories/Notes/"/>
    
    
      <category term="心理学" scheme="https://www.llchen60.com/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>提高代码质量的Tips</title>
    <link href="https://www.llchen60.com/%E5%85%B3%E4%BA%8E%E6%8F%90%E9%AB%98%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E7%9A%84Tips/"/>
    <id>https://www.llchen60.com/%E5%85%B3%E4%BA%8E%E6%8F%90%E9%AB%98%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E7%9A%84Tips/</id>
    <published>2020-05-25T05:34:48.000Z</published>
    <updated>2020-05-29T00:49:33.202Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-如何重构"><a href="#1-如何重构" class="headerlink" title="1. 如何重构"></a>1. 如何重构</h1><h2 id="1-1-为什么要重构代码？"><a href="#1-1-为什么要重构代码？" class="headerlink" title="1.1 为什么要重构代码？"></a>1.1 为什么要重构代码？</h2><p>重构是一种对软件内部结构的改善，目的是在不改变软件的可见行为的情况下，使其更易理解，修改成本更低。</p><p>即 重构是指保持功能不变的前提下，利用设计思想、原则、模式和编程规范等理论来优化代码，修改设计上的不足，提高代码的质量。</p><p>如果没有维护，物体势必会往熵增加的方向去演变的。如果不做代码的维护，代码总归会往越来越混乱的方向演进，当混乱到一定程度，量变引起质变，项目的维护成本已经高过了重新开发一套新代码的成本，再去重构就会变得十分困难了。</p><h2 id="1-2-重构的对象"><a href="#1-2-重构的对象" class="headerlink" title="1.2 重构的对象"></a>1.2 重构的对象</h2><ul><li>大型重构<ul><li>对顶层代码设计的重构<ul><li>包括 <ul><li>系统</li><li>模块</li><li>代码结构</li><li>类与类之间的关系</li></ul></li><li>重构的手段<ul><li>分层</li><li>模块化</li><li>解耦</li><li>抽象可复用的组件</li></ul></li></ul></li></ul></li></ul><ul><li>小型重构<ul><li>对于代码细节的重构</li><li>针对类，函数，变量等代码级别的重构</li></ul></li></ul><h2 id="1-3-什么时候重构？"><a href="#1-3-什么时候重构？" class="headerlink" title="1.3 什么时候重构？"></a>1.3 什么时候重构？</h2><p>持续重构的概念，即没事情的时候，看看项目中有哪些写得不够好，可以优化的代码，主动去重构一下。或者在修改添加某个功能代码的时候，也可以顺手把不符合编码规范，不好的设计重构一下。</p><h2 id="1-4-如何解耦代码？"><a href="#1-4-如何解耦代码？" class="headerlink" title="1.4 如何解耦代码？"></a>1.4 如何解耦代码？</h2><ul><li><p>解耦的目的</p><ul><li>高内聚</li><li>松耦合</li></ul></li><li><p>为什么需要解耦</p><ul><li>控制代码的复杂性</li><li>使得我们可以聚焦在某一模块或类当中，不需要了解太多其他模块或类的代码</li><li>使得代码改动相对集中，引入bug的风险就减少了很多</li></ul></li><li><p>如何判断是否需要解耦</p><ul><li>在做修改的时候是否需要跨很多个包来进行改动</li><li>需要通过解耦的方式让依赖关系变得清晰，简单一些</li></ul></li><li><p>如何进行解耦</p><ul><li><p>封装与抽象</p><ul><li>有效隐藏实现的复杂</li><li>隔离实现的易变性</li><li>给依赖的模块提供稳定易用的抽象接口</li></ul></li><li><p>引入中间层</p><ul><li>引入中间层能够简化模块或类之间的依赖关系</li><li>即我们可以让开发和重构同步进行</li><li>例如需要进行接口的修改<ul><li>先引入一个中间层，包裹老的接口，提供新的接口定义</li><li>新开发的代码依赖中间层提供的新接口</li><li>将依赖老街口的代码改为调用新接口</li><li>确保所有的代码都调用新接口之后，删掉老接口</li></ul></li></ul></li><li><p>模块化</p><ul><li>对于一个大型复杂系统来说，没有人能够掌控所有细节</li><li>通过划分成不同的独立模块，让不同的人负责不同的模块</li><li>这样即便在不了解全部细节的情况下，管理者也能够协调各个模块，让整个系统有效运转起来</li><li>将每个模块都当做一个独立的library来进行开发，只提供封装了内部实现细节的接口给其他模块使用，以此来减少不同模块之间的耦合度</li></ul></li><li><p>遵循设计思想和原则</p><ul><li>单一职责原则</li><li>基于接口而非实现编程</li><li>依赖注入</li><li>多用组合少用继承</li><li>迪米特法则<ul><li>不应该有直接依赖关系的类</li></ul></li></ul></li></ul></li></ul><h1 id="2-代码的可测试性"><a href="#2-代码的可测试性" class="headerlink" title="2. 代码的可测试性"></a>2. 代码的可测试性</h1><p>做重构，如何保证你做的改动能够按照既定的想法运行，那么我们需要来写单元测试，来保证新的代码仍然能够通过，即原有的逻辑的正确性没有被破坏。</p><p>另外，单元测试的阅读实际上是快速熟悉代码的一种方式</p><p>一些常见的Anti-patterns:</p><ul><li>未决行为<ul><li>代码的输出是随机的，或者不确定的</li></ul></li><li>全局变量</li><li>静态方法</li><li>复杂继承</li><li>高耦合代码</li></ul><h1 id="3-编程规范"><a href="#3-编程规范" class="headerlink" title="3. 编程规范"></a>3. 编程规范</h1><h2 id="3-1-命名与注释"><a href="#3-1-命名与注释" class="headerlink" title="3.1 命名与注释"></a>3.1 命名与注释</h2><ol><li>在足够表达含义的情况下，命名尽量短</li></ol><p>命名时候的缩写，只对大家比较熟知的使用，减少阅读时候的障碍的感觉。</p><ol start="2"><li>利用上下文简化命名</li></ol><p>比如POJO当中，类名往往对这是个什么类做了定义了，成员变量就不用再添加类前缀了</p><ol start="3"><li>命名需要可读，可搜索</li></ol><p>英文上可读，方便发音，哪怕是第一次见到，也需要尽可能简单的能够直接读出来</p><p>另外需要遵从一些大家约定俗成的规范，即比如使用selectXXX 还是queryXXX 来表示选择，从数据库里面拿东西，一旦选定，就需要一起遵从规定了。</p><ol start="4"><li>对于接口，抽象类的命名</li></ol><ul><li><p>对于接口的命名</p><ul><li>加前缀I，比如IUserService</li><li>或者加后缀Impl, UserServiceImpl</li></ul></li><li><p>抽象类的命名</p><ul><li>加上前缀Abstract</li><li>或者不带</li></ul></li></ul><p>皆可，但是需要形式上的统一。</p><ol start="5"><li>注释</li></ol><ul><li><p>目的</p><ul><li>让代码更容易看懂</li></ul></li><li><p>写什么</p><ul><li>是什么，为什么，怎么办 三大问题</li><li>能够起到总结性和文档的作用</li><li>总结性注释也能够让整个代码更加清晰</li></ul></li><li><p>在哪里写</p><ul><li>一般来说是在类和函数上写注释</li><li>函数内部尽量通过好的命名，提炼函数，解释性的变量来提高代码的可读性</li></ul></li></ul><h2 id="3-2-代码风格"><a href="#3-2-代码风格" class="headerlink" title="3.2 代码风格"></a>3.2 代码风格</h2><ol><li>类和函数的大小</li></ol><p>软标准，只是要尽量注意，对于很大的类，最好将其分割开</p><ol start="2"><li>一行代码的长度的限制，譬如100字符或者150字符</li><li>使用空行分割单元块</li></ol><ul><li>对于比较长的函数，如果逻辑上可以分为几个独立的代码块，可以使用空行来分割各个代码块</li><li>在类的成员变量和函数之间</li><li>静态成员变量和普通成员变量之间</li><li>各个函数之间</li><li>各个成员变量之间</li></ul><ol start="4"><li>缩进风格的统一</li><li>类当中成员的排列顺序</li></ol><ul><li>首先是类的所属包名</li><li>然后罗列import引入的依赖类</li><li>类当中<ul><li>大原则<ul><li>先静态，后普通</li><li>作用域从大到小来排序</li></ul></li><li>成员变量</li><li>各种方法</li></ul></li></ul><h2 id="3-3-编程技巧"><a href="#3-3-编程技巧" class="headerlink" title="3.3 编程技巧"></a>3.3 编程技巧</h2><ol><li>将代码分割为更小的单元块</li></ol><p>大部分人阅读代码的习惯都是先看整体再看细节，因为我们要有模块化和抽象思维，善于将大块的负责逻辑提炼成类或者函数，屏蔽掉细节</p><p>通过提炼函数，通过函数名字，直接读懂这段代码是做什么用的</p><ol start="2"><li>避免函数参数过多</li></ol><ul><li>考虑函数是否职责单一，能否通过拆分多个函数的方式来减少参数</li><li>将函数的参数封装成对象</li><li>不要使用函数的参数(true/ false) 来控制逻辑，直接分成几个不同的函数会更好</li></ul><ol start="3"><li>函数的设计，职责单一</li><li>移除过深的嵌套层次</li></ol><ul><li>去掉多余的if else语句</li><li>使用continue break return等关键字，来提前退出嵌套</li><li>调整执行顺序来减少嵌套</li><li>将部分嵌套逻辑封装成函数调用，以此来减少嵌套</li></ul><ol start="5"><li>使用解释性变量</li></ol><ul><li>常量替代magic number</li><li>使用解释性变量来解释复杂表达式</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-如何重构&quot;&gt;&lt;a href=&quot;#1-如何重构&quot; class=&quot;headerlink&quot; title=&quot;1. 如何重构&quot;&gt;&lt;/a&gt;1. 如何重构&lt;/h1&gt;&lt;h2 id=&quot;1-1-为什么要重构代码？&quot;&gt;&lt;a href=&quot;#1-1-为什么要重构代码？&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
  </entry>
  
  <entry>
    <title>Enzyme + Jest Practice</title>
    <link href="https://www.llchen60.com/Enzyme-Jest-Practice/"/>
    <id>https://www.llchen60.com/Enzyme-Jest-Practice/</id>
    <published>2020-05-23T00:29:18.000Z</published>
    <updated>2020-05-23T00:29:58.284Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-How-to-use-enzyme-with-jest"><a href="#1-How-to-use-enzyme-with-jest" class="headerlink" title="1. How to use enzyme with jest"></a>1. How to use enzyme with jest</h1><h2 id="1-1-children"><a href="#1-1-children" class="headerlink" title="1.1 children()"></a>1.1 children()</h2><p>This blog mainly describe some practice on how to write tests in jest with enzyme. </p><pre><code>// This test make sure the component only have one h1 element describe(&#39;&lt;Add /&gt; rendering&#39;, () =&gt; {    it(&#39;should render one &lt;h1&gt;&#39;, () =&gt; {        let wrapper = shallow(&lt;Add /&gt;);        expect(wrapper.children(&#39;h1&#39;)).toHaveLength(1);    });});</code></pre><h2 id="1-2-snapshot"><a href="#1-2-snapshot" class="headerlink" title="1.2 snapshot"></a>1.2 snapshot</h2><pre><code>// For snapshot test, jest will help you create a directory named __snapshots__ with the autogenerated file inside with the extension `.snap`. Push snapshot into the repository and store it along with the test // it means same as test it(&#39;render correctly text component&#39;, () =&gt; {      const TextInputComponent = renderer.create(&lt;TextInput /&gt;).toJSON();    expect(TextInputComponent).toMatchSnapshot();});</code></pre><h2 id="1-3-Test-with-props-in-your-component"><a href="#1-3-Test-with-props-in-your-component" class="headerlink" title="1.3 Test with props in your component"></a>1.3 Test with props in your component</h2><pre><code>it(&#39;check month and years dropdowns displayed&#39;, () =&gt; {      const props = {            showMonthYearsDropdowns: true        },        DateInputComponent = mount(&lt;DateInput {...props} /&gt;).find(&#39;.datepicker&#39;);    expect(DateInputComponent.hasClass(&#39;react-datepicker-hide-month&#39;)).toEqual(true);});it(&#39;render date input correctly with null value&#39;, () =&gt; {      const props = {            value: null        },        DateInputComponent = mount(&lt;DateInput {...props} /&gt;);    expect((DateInputComponent).prop(&#39;value&#39;)).toEqual(null);});it(&#39;check the type of value&#39;, () =&gt; {      const props = {            value: &#39;10.03.2018&#39;        },        DateInputComponent = mount(&lt;DateInput {...props} /&gt;);    expect(DateInputComponent.prop(&#39;value&#39;)).toBeString();});</code></pre><h2 id="1-4-Test-events"><a href="#1-4-Test-events" class="headerlink" title="1.4 Test events"></a>1.4 Test events</h2><pre><code>it(&#39;check the onChange callback&#39;, () =&gt; {      const onChange = jest.fn(),        props = {            value: &#39;20.01.2018&#39;,            onChange        },        DateInputComponent = mount(&lt;DateInput {...props} /&gt;).find(&#39;input&#39;);    DateInputComponent.simulate(&#39;change&#39;, { target: {value: moment(&#39;2018-01-22&#39;)} });    expect(onChange).toHaveBeenCalledWith(&#39;22.01.2018&#39;);});it(&#39;check DatePicker popup open&#39;, () =&gt; {      const DateComponent = mount(&lt;DateInput /&gt;),        dateInput = DateComponent.find(&quot;input[type=&#39;text&#39;]&quot;);    dateInput.simulate(&#39;click&#39;);    expect(DateComponent.find(&#39;.react-datepicker&#39;)).toHaveLength(1);});</code></pre><h1 id="2-Some-tips"><a href="#2-Some-tips" class="headerlink" title="2. Some tips"></a>2. Some tips</h1><ol><li><p>One component should have only one snapshot. </p><ol><li>mainly because if one fails, most likely the others will fail too </li></ol></li><li><p>Test props. </p><ol><li>check the render od default prop values </li><li>check the custom value of the prop, set your own value and do tests </li></ol></li><li><p>Testing data types </p><ol><li>you could use <code>jest-extended</code> to test the type of data </li></ol></li><li><p>Event testing </p><ol><li>mock event -&gt; simulate it -&gt; expect event was called </li><li>mock event -&gt; simulate event with params -&gt; expect event was called with passed params </li><li>pass necessary props -&gt; render component -&gt; simulate event -&gt; expect a certain behavior on called event </li></ol></li></ol><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://blog.bitsrc.io/how-to-test-react-components-with-jest-and-enzyme-in-depth-145fcd06b90" target="_blank" rel="noopener">https://blog.bitsrc.io/how-to-test-react-components-with-jest-and-enzyme-in-depth-145fcd06b90</a> </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-How-to-use-enzyme-with-jest&quot;&gt;&lt;a href=&quot;#1-How-to-use-enzyme-with-jest&quot; class=&quot;headerlink&quot; title=&quot;1. How to use enzyme with jest&quot;&gt;&lt;/
      
    
    </summary>
    
    
      <category term="FrondEnd" scheme="https://www.llchen60.com/categories/FrondEnd/"/>
    
    
  </entry>
  
  <entry>
    <title>如何高效开Design Meetings</title>
    <link href="https://www.llchen60.com/%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E5%BC%80Design-Meetings/"/>
    <id>https://www.llchen60.com/%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E5%BC%80Design-Meetings/</id>
    <published>2020-05-21T20:33:43.000Z</published>
    <updated>2020-05-21T20:34:49.944Z</updated>
    
    <content type="html"><![CDATA[<p>能靠规范做的事情就尽量不要靠直觉，把直觉用在更需要直觉的地方吧。</p><p>工作的日常一定少不了开会的，但是你会有感觉到有一些会议效率非常高，你带着问题来开会，问题迅速被解决，每个人都对下一步很清晰，然后会议结束。但是我们也时常经历完全相反的过程，你带着问题进入，但是问题没有被解答，每个人变得更加困惑的结束会议。</p><p>问题在于，如何能够确保我们的会议是有效率的，能够解决问题的，这需要一些规则和日程上的安排，来确保其效率。</p><h1 id="1-清晰认知会议的类型"><a href="#1-清晰认知会议的类型" class="headerlink" title="1. 清晰认知会议的类型"></a>1. 清晰认知会议的类型</h1><p>在项目的设计过程当中，我们可以根据输入和输出将会议分为三个主要的类型：定义，设计与开发</p><h2 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h2><p>定义类型的会议指的是开展一个新项目，以及设定需求的过程。在这个会议当中，我们需要定义：</p><ul><li>问题是什么</li><li>用户是谁</li><li>有哪些限制</li><li>时间轴</li></ul><p>一般来说，需求定义的会议参加的人数少效果会更加理想一些，比如只带产品经理以及设计师。</p><h2 id="1-2-设计"><a href="#1-2-设计" class="headerlink" title="1.2 设计"></a>1.2 设计</h2><p>设计是个交互的过程，会需要大量的和产品，设计，技术来进行交流。可以将整个设计过程划分为以下的步骤：</p><ul><li><p>调研 (Research)</p><ul><li>看看问题和用户是否已经被定义了，花点时间去看看其他人是如何解决这个问题的（不仅限于你的公司，包括工业界）</li></ul></li><li><p>草拟 (Sketch)</p><ul><li>探索不同的选择，然后判断哪一个能够满足需求</li></ul></li><li><p>反馈 (Feedback)</p><ul><li>注意想要得到哪方面的反馈 </li><li>最好专注在某一个方向上</li></ul></li><li><p>迭代 (Refine)</p><ul><li>根据时间轴不断获取反馈，完成迭代</li></ul></li></ul><p>设计会议的关键在于需求解决哪方面的问题，我们需要聚焦于这个问题。对于不同的设计的选择，我们需要从开发者那里拿到反馈。</p><h2 id="1-3-开发"><a href="#1-3-开发" class="headerlink" title="1.3 开发"></a>1.3 开发</h2><p>当我们进入这部分的会议的时候，我们已经有了大致上的设计的思路，这个时候会更多的考虑一些edge case，还有技术上的限制。这里会有一些技术和设计方面的权衡，我们可能会需要调整我们的设计，来满足从技术角度的考量。设计和产品需要一直参与在这个过程当中，以保证哪怕细节上有调整，但是设计的初衷/理念不会被改变。</p><h1 id="2-邀请正确的人"><a href="#2-邀请正确的人" class="headerlink" title="2. 邀请正确的人"></a>2. 邀请正确的人</h1><p>我们需要很清楚这个会议是关于什么的，以及谁应该出现在这里。一个组往往可能会有3 - 10人左右，一般来说，让10个人全都出现在会议当中不是很有效率的方式，我们需要一个模型来决定谁应该出现在会议当中。 </p><p>Decide, Console, Inform模型</p><h2 id="2-1-决策"><a href="#2-1-决策" class="headerlink" title="2.1 决策"></a>2.1 决策</h2><p>决策者是可以对项目付出时间精力以及金钱的人。他们会最终决定要做什么，以及为什么要这样做。我们需要将所有的决策者带入到会议室当中，这样如果相互之间有不同意见，可以很及时的解决。并且提供下一步。</p><p>这种时候，往往相对比较小的会议更容易达成好的结果，即只带入必要的人，一般来说，是产品的带头人，设计的带头人，以及技术方面的带头人。</p><h2 id="2-2-咨询"><a href="#2-2-咨询" class="headerlink" title="2.2 咨询"></a>2.2 咨询</h2><p>这里指的是对这个领域很了解的人，他们会提出很有价值的建议，不过决定权还在决策者手中。比如几种技术方案的最终选择，就需要引入对框架，各种方法很熟悉的工程师来给出建议了。</p><h2 id="2-3-通知"><a href="#2-3-通知" class="headerlink" title="2.3 通知"></a>2.3 通知</h2><p>组里的一员，被邀请 == 被通知，lol </p><h1 id="3-按照时间安排展开会议"><a href="#3-按照时间安排展开会议" class="headerlink" title="3. 按照时间安排展开会议"></a>3. 按照时间安排展开会议</h1><p>我们需要十分清楚这个会议的目的是什么，我们最终想达到什么样的成果</p><ul><li>我们解决了什么样的问题</li><li>我们可以做出什么样的决定</li><li>下一步措施是什么</li></ul><p>一些比较好的行为，强烈推荐：</p><ul><li><p>会议前</p><ul><li>发送邮件，给出安排</li><li>给出相关的链接，使得参会人可以在参会前可以做一些准备</li></ul></li><li><p>会议开始</p><ul><li>说整个会议的安排<ul><li>比如想看看几种设计</li><li>需要基于什么什么得到反馈</li><li>下一步</li></ul></li></ul></li><li><p>会议结束</p><ul><li>总结反馈 以及下一步<ul><li>在会议还剩下5min左右的时候来做总结和下一步计划</li><li>总结获得的反馈，和决定  这样子如果我们忘记了一些东西，其他人可以给我们做补充</li><li>问下一步是什么，以及每一步的负责人</li></ul></li></ul></li><li><p>会议后</p><ul><li>发送邮件总结会议<ul><li>讨论了什么</li><li>下了什么决定</li><li>下一步工作，是什么，谁来做</li></ul></li></ul></li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://blog.prototypr.io/3-tips-to-run-effective-design-meetings-dec2ec238b56" target="_blank" rel="noopener">https://blog.prototypr.io/3-tips-to-run-effective-design-meetings-dec2ec238b56</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;能靠规范做的事情就尽量不要靠直觉，把直觉用在更需要直觉的地方吧。&lt;/p&gt;
&lt;p&gt;工作的日常一定少不了开会的，但是你会有感觉到有一些会议效率非常高，你带着问题来开会，问题迅速被解决，每个人都对下一步很清晰，然后会议结束。但是我们也时常经历完全相反的过程，你带着问题进入，但是问
      
    
    </summary>
    
    
      <category term="Notes" scheme="https://www.llchen60.com/categories/Notes/"/>
    
    
      <category term="meeting" scheme="https://www.llchen60.com/tags/meeting/"/>
    
      <category term="tips" scheme="https://www.llchen60.com/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>Enzyme -- React测试库</title>
    <link href="https://www.llchen60.com/Enzyme-React%E6%B5%8B%E8%AF%95%E5%BA%93/"/>
    <id>https://www.llchen60.com/Enzyme-React%E6%B5%8B%E8%AF%95%E5%BA%93/</id>
    <published>2020-05-18T23:06:42.000Z</published>
    <updated>2020-05-18T23:07:22.568Z</updated>
    
    <content type="html"><![CDATA[<p>这是前端用于对React的组件进行测试的一个工具类，我们可以使用这个工具来遍历，控制，以及一定程度上的模拟运行时输出。我们主要是将该工具类和Jest一起使用，写我们的react组件的单元测试们。</p><h1 id="1-Shalow-Rendering"><a href="#1-Shalow-Rendering" class="headerlink" title="1. Shalow Rendering"></a>1. Shalow Rendering</h1><p>用于以单个组件为单元来进行测试，然后确保你的测试不会依赖于子组件的状态。从Enzyme v3开始，shallow API会call React生命周期方法了，譬如<code>componentDidUpdate</code>和<code>componentDidMount</code></p><pre><code>import { shallow } from &#39;enzyme&#39;;import sinon from &#39;sinon&#39;;import Foo from &#39;./Foo&#39;;describe(&#39;&lt;MyComponent /&gt;&#39;, () =&gt; {  it(&#39;renders three &lt;Foo /&gt; components&#39;, () =&gt; {    const wrapper = shallow(&lt;MyComponent /&gt;);    expect(wrapper.find(Foo)).to.have.lengthOf(3);  });  it(&#39;renders an `.icon-star`&#39;, () =&gt; {    const wrapper = shallow(&lt;MyComponent /&gt;);    expect(wrapper.find(&#39;.icon-star&#39;)).to.have.lengthOf(1);  });  it(&#39;renders children when passed in&#39;, () =&gt; {    const wrapper = shallow((      &lt;MyComponent&gt;        &lt;div className=&quot;unique&quot; /&gt;      &lt;/MyComponent&gt;    ));    expect(wrapper.contains(&lt;div className=&quot;unique&quot; /&gt;)).to.equal(true);  });  it(&#39;simulates click events&#39;, () =&gt; {    const onButtonClick = sinon.spy();    const wrapper = shallow(&lt;Foo onButtonClick={onButtonClick} /&gt;);    wrapper.find(&#39;button&#39;).simulate(&#39;click&#39;);    expect(onButtonClick).to.have.property(&#39;callCount&#39;, 1);  });});</code></pre><p><a href="https://enzymejs.github.io/enzyme/docs/api/shallow.html" target="_blank" rel="noopener">API Reference</a></p><h1 id="2-Full-Dom-Rendering"><a href="#2-Full-Dom-Rendering" class="headerlink" title="2. Full Dom Rendering"></a>2. Full Dom Rendering</h1><p>这种测试方式在你需要和DOM API进行交互，或者需要测试在更高次位的组件的时候非常有用。</p><p>需要运行在浏览器环境当中，如果无法运行在真实的浏览器当中，那我们就需要依赖于<code>mount</code>指令，在指令之下，是调用了一个叫做jsdom的包，完全使用JavaScript实现了一个浏览器。</p><p>值得注意的是，full dom rendering是真实的将当前组件渲染到DOM树当中，这也意味着如果用的是同一棵DOM树，那么你做的改动很可能会影响其他的测试，这点是值得我们注意的。</p><pre><code>import { mount } from &#39;enzyme&#39;;import sinon from &#39;sinon&#39;;import Foo from &#39;./Foo&#39;;describe(&#39;&lt;Foo /&gt;&#39;, () =&gt; {  it(&#39;calls componentDidMount&#39;, () =&gt; {    sinon.spy(Foo.prototype, &#39;componentDidMount&#39;);    const wrapper = mount(&lt;Foo /&gt;);    expect(Foo.prototype.componentDidMount).to.have.property(&#39;callCount&#39;, 1);  });  it(&#39;allows us to set props&#39;, () =&gt; {    const wrapper = mount(&lt;Foo bar=&quot;baz&quot; /&gt;);    expect(wrapper.props().bar).to.equal(&#39;baz&#39;);    wrapper.setProps({ bar: &#39;foo&#39; });    expect(wrapper.props().bar).to.equal(&#39;foo&#39;);  });  it(&#39;simulates click events&#39;, () =&gt; {    const onButtonClick = sinon.spy();    const wrapper = mount((      &lt;Foo onButtonClick={onButtonClick} /&gt;    ));    wrapper.find(&#39;button&#39;).simulate(&#39;click&#39;);    expect(onButtonClick).to.have.property(&#39;callCount&#39;, 1);  });});</code></pre><p><a href="https://enzymejs.github.io/enzyme/docs/api/mount.html" target="_blank" rel="noopener">API Reference</a></p><h1 id="3-Static-Rendering"><a href="#3-Static-Rendering" class="headerlink" title="3. Static Rendering"></a>3. Static Rendering</h1><p>Render 使用的是Cheerio这个HTML转化库，用于从我们的React树来生成HTML，然后分析HTML的整个架构。</p><pre><code>import React from &#39;react&#39;;import { render } from &#39;enzyme&#39;;import PropTypes from &#39;prop-types&#39;;describe(&#39;&lt;Foo /&gt;&#39;, () =&gt; {  it(&#39;renders three `.foo-bar`s&#39;, () =&gt; {    const wrapper = render(&lt;Foo /&gt;);    expect(wrapper.find(&#39;.foo-bar&#39;)).to.have.lengthOf(3);  });  it(&#39;rendered the title&#39;, () =&gt; {    const wrapper = render(&lt;Foo title=&quot;unique&quot; /&gt;);    expect(wrapper.text()).to.contain(&#39;unique&#39;);  });  it(&#39;renders a div&#39;, () =&gt; {    const wrapper = render(&lt;div className=&quot;myClass&quot; /&gt;);    expect(wrapper.html()).to.contain(&#39;div&#39;);  });  it(&#39;can pass in context&#39;, () =&gt; {    function SimpleComponent(props, context) {      const { name } = context;      return &lt;div&gt;{name}&lt;/div&gt;;    }    SimpleComponent.contextTypes = {      name: PropTypes.string,    };    const context = { name: &#39;foo&#39; };    const wrapper = render(&lt;SimpleComponent /&gt;, { context });    expect(wrapper.text()).to.equal(&#39;foo&#39;);  });});</code></pre><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://enzymejs.github.io/enzyme/" target="_blank" rel="noopener">https://enzymejs.github.io/enzyme/</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是前端用于对React的组件进行测试的一个工具类，我们可以使用这个工具来遍历，控制，以及一定程度上的模拟运行时输出。我们主要是将该工具类和Jest一起使用，写我们的react组件的单元测试们。&lt;/p&gt;
&lt;h1 id=&quot;1-Shalow-Rendering&quot;&gt;&lt;a href
      
    
    </summary>
    
    
      <category term="FrontEnd" scheme="https://www.llchen60.com/categories/FrontEnd/"/>
    
    
      <category term="Enzyme" scheme="https://www.llchen60.com/tags/Enzyme/"/>
    
  </entry>
  
  <entry>
    <title>应用设计 Practice</title>
    <link href="https://www.llchen60.com/%E5%BA%94%E7%94%A8%E8%AE%BE%E8%AE%A1-Practice/"/>
    <id>https://www.llchen60.com/%E5%BA%94%E7%94%A8%E8%AE%BE%E8%AE%A1-Practice/</id>
    <published>2020-05-17T20:03:10.000Z</published>
    <updated>2020-05-20T00:12:33.088Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-thought"><a href="#1-thought" class="headerlink" title="1. thought"></a>1. thought</h1><p>实际应用设计，首先还是需要将工作进行合理分割：</p><ul><li>前期需求沟通分析<ul><li>工程师应该尽量参与到产品设计当中</li><li>寻找类似的产品，进行借鉴</li><li>将借鉴来的东西努力融合到我们自己的产品当中</li></ul></li><li>中期代码设计实现</li><li>后期系统上线维护 <h1 id="2-业务系统设计-–-积分系统"><a href="#2-业务系统设计-–-积分系统" class="headerlink" title="2. 业务系统设计 – 积分系统"></a>2. 业务系统设计 – 积分系统</h1></li></ul><h2 id="2-1-业务需求"><a href="#2-1-业务需求" class="headerlink" title="2.1 业务需求"></a>2.1 业务需求</h2><ul><li><p>功能点</p><ul><li>赚取积分<ul><li>积分赚取渠道<ul><li>订单</li><li>签到</li><li>评论</li></ul></li><li>积分兑换规则<ul><li>订单金额与积分的兑换比例</li><li>签到赠送积分数量等</li></ul></li></ul></li><li>消费积分<ul><li>积分消费渠道<ul><li>抵扣订单金额</li><li>兑换优惠券</li><li>积分换购</li><li>参与活动</li></ul></li></ul></li></ul></li><li><p>方式方法</p><ul><li>借鉴已经相对成熟的产品<ul><li>看其实现的方式方法</li></ul></li><li>通过产品线框图</li><li>user case<ul><li>模拟用户是如何使用我们的产品的</li><li>描述用户在特定的应用场景当中的一个完整的业务操作流程</li></ul></li></ul></li></ul><h2 id="2-2-系统设计"><a href="#2-2-系统设计" class="headerlink" title="2.2 系统设计"></a>2.2 系统设计</h2><h3 id="2-2-1-功能模块划分"><a href="#2-2-1-功能模块划分" class="headerlink" title="2.2.1 功能模块划分"></a>2.2.1 功能模块划分</h3><ul><li>将功能划分到不同的模块当中 <ul><li>做到模块层面的高内聚，低耦合</li></ul></li></ul><ul><li>针对上述的业务需求，我们可以采用<ul><li><ol><li>将关于积分的赚取消费的规则的管理维护放到更上层的营销系统当中，这样积分系统就只负责增删改查的数据库操作了</li></ol></li><li><ol start="2"><li>将规则分散到各个子系统当中，譬如订单系统，评论系统，签到系统，诸如此类</li></ol></li><li><ol start="3"><li>所有功能划分到积分系统当中</li></ol></li></ul></li></ul><p>值得注意的是，为了避免业务知识的耦合，让下层系统更加通用，我们不希望下层系统（被调用系统）包含太多上层系统（调用系统）的业务信息。但上层系统是可以包含下层系统的业务信息的，比如，订单系统、优惠券系统、换购商城等作为调用积分系统的上层系统，可以包含一些积分相关的业务信息。但是，反过来，积分系统中最好不要包含太多跟订单、优惠券、换购等相关的信息。</p><p>因此，1，2都是相对不错的选择，我们希望做的是让积分系统模块只包含积分的增删改查的操作，而不包含太多的业务层面的逻辑。</p><h3 id="2-2-2-模块间交互"><a href="#2-2-2-模块间交互" class="headerlink" title="2.2.2 模块间交互"></a>2.2.2 模块间交互</h3><p>定位需要和积分系统之间进行交互的系统，以及交互方式。</p><p>一般来说，系统之间的交互方式有两大类：</p><ul><li>同步接口调用</li><li>利用信息中间件异步调用</li></ul><h3 id="2-2-3-设计模块的接口、数据库、业务模型"><a href="#2-2-3-设计模块的接口、数据库、业务模型" class="headerlink" title="2.2.3 设计模块的接口、数据库、业务模型"></a>2.2.3 设计模块的接口、数据库、业务模型</h3><p>数据库和接口的设计相对来说都比较重要，一旦设计好，都不能轻易改动。尤其是当有不同的组来调用你的API的时候，让所有的组都快速迁移到新的API上是一件相对比较困难的事情了。  改动数据库表的结构，需要涉及数据的迁移和适配。</p><p>而业务模型，即业务逻辑代码，因为都是内部使用，改动的可能性比较大，对外是不可见的。</p><ul><li><p>数据库设计：</p><ul><li>id - 明细ID</li><li>user_id - 用户ID</li><li>channel_id - 赚取或消费渠道ID</li><li>event_id - 相关事件ID，例如订单ID，评论ID，优惠券换购ID等</li><li>credit - 积分 </li><li>create_time - 积分赚取或消费时间</li><li>expired_time - 积分过期时间</li></ul></li><li><p>接口设计</p><ul><li>单一职责原则 <ul><li>但是粒度太小也不好，比如一个功能的实现需要多个接口，但是每个接口如果都是RPC的一次远程调用的话，那网络上的损耗就很多，多次远程调用会影响性能的</li><li>另外还有数据一致性 - 即操作的原子性方面的考量</li><li>可以借鉴facade外观设计模式，在职责单一的细粒度接口之上，封装一层粗粒度的接口给外部使用</li></ul></li></ul></li><li><p>MVC </p><ul><li>controller负责接口暴露</li><li>service 负责核心业务逻辑</li><li>repository负责数据读写</li><li>为什么要分成MVC三层？<ul><li>代码复用</li><li>隔离变化</li><li>隔离关注点</li><li>提高代码的可测试性</li><li>能够应对系统的复杂性</li></ul></li></ul></li></ul><h1 id="3-非业务通用框架设计"><a href="#3-非业务通用框架设计" class="headerlink" title="3. 非业务通用框架设计"></a>3. 非业务通用框架设计</h1><p>假设我们要设计开发一个小框架，来获取接口调用的各种统计信息。</p><ul><li>响应时间<ul><li>max/ min/ avg/ percentile/ count/ tps </li></ul></li></ul><h2 id="3-1-需求分析"><a href="#3-1-需求分析" class="headerlink" title="3.1 需求分析"></a>3.1 需求分析</h2><p>是一个和业务无关的独立功能，我们可以将其开发成一个独立的框架或者库，集成到很多的业务系统当中。作为一个需要复用性的框架，除了功能上的需求以外，非功能性的需求也非常重要。</p><ul><li><p>功能性需求分析</p><ul><li><p>接口统计信息</p><ul><li>响应时间</li><li>接口调用次数</li></ul></li><li><p>统计信息的类型</p><ul><li>max min ave percentile tps count </li></ul></li><li><p>统计信息显示格式</p><ul><li>json</li><li>html</li><li>自定义</li></ul></li><li><p>统计信息显示终端</p><ul><li>console</li><li>email</li><li>http 页面</li><li>日志</li><li>自定义</li></ul></li><li><p>统计触发方式</p></li><li><p>统计时间区间</p></li><li><p>统计时间间隔</p></li></ul></li></ul><ul><li><p>非功能性需求分析</p><ul><li><p>易用性</p><ul><li>框架是否易集成，易拔插</li><li>跟业务代码是否为松耦合</li><li>提供的接口是否足够灵活</li></ul></li><li><p>性能</p><ul><li>不希望框架本身的代码执行效率会对业务系统有太多性能上的影响</li><li>希望框架低延迟，并且对内存的消耗不能太大</li></ul></li><li><p>扩展性</p><ul><li>在不修改或者尽量少修改代码的情况下添加新功能的能力</li></ul></li><li><p>容错性</p></li><li><p>通用性</p><ul><li>除了接口数据统计，能否将其放到其他事件上来做统计呢？ </li></ul></li></ul></li></ul><h2 id="3-2-框架设计"><a href="#3-2-框架设计" class="headerlink" title="3.2 框架设计"></a>3.2 框架设计</h2><p>可以借鉴TDD (测试驱动开发)和Prototype(最小原型)的思想，先聚焦于一个简单的应用场景，基于此来设计一个简单的原型，然后不断进行迭代。</p><p>而后是将整个框架分为多个模块，分模块进行思考：</p><ul><li>数据采集<ul><li>打点采集原始数据</li><li>记录每次接口请求的响应时间和请求时间</li><li>数据采集过程要高度容错，不能影响到接口本身的可用性</li></ul></li><li>存储<ul><li>负责将采集的原始数据保存下来，以便后面做聚合统计</li><li>数据可以存储在<ul><li>redis</li><li>mysql</li><li>hbase</li><li>日志</li><li>文件</li><li>内存</li></ul></li></ul></li><li>聚合统计<ul><li>将原始数据聚合为统计数据</li></ul></li><li>显示<ul><li>将统计数据以某种格式显示到终端当中</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-thought&quot;&gt;&lt;a href=&quot;#1-thought&quot; class=&quot;headerlink&quot; title=&quot;1. thought&quot;&gt;&lt;/a&gt;1. thought&lt;/h1&gt;&lt;p&gt;实际应用设计，首先还是需要将工作进行合理分割：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前期需
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="System Design" scheme="https://www.llchen60.com/tags/System-Design/"/>
    
  </entry>
  
  <entry>
    <title>中台(二) - 略深入些的探究</title>
    <link href="https://www.llchen60.com/%E4%B8%AD%E5%8F%B0-%E4%BA%8C-%E7%95%A5%E6%B7%B1%E5%85%A5%E4%BA%9B%E7%9A%84%E6%8E%A2%E7%A9%B6/"/>
    <id>https://www.llchen60.com/%E4%B8%AD%E5%8F%B0-%E4%BA%8C-%E7%95%A5%E6%B7%B1%E5%85%A5%E4%BA%9B%E7%9A%84%E6%8E%A2%E7%A9%B6/</id>
    <published>2020-05-16T00:38:41.000Z</published>
    <updated>2020-05-30T00:39:49.461Z</updated>
    
    <content type="html"><![CDATA[<p>中台是企业级能力复用平台，整个中台的构建，实际上是将业务数据化，将数据业务化。是需要建立业务中台和数据中台的。业务中台通过抽象，封装可复用的逻辑，提升企业的响应力；数据中台通过打通企业的数据，构建自学习服务的数据能力，让企业更加智慧。</p><h1 id="1-通用化通用能力"><a href="#1-通用化通用能力" class="headerlink" title="1. 通用化通用能力"></a>1. 通用化通用能力</h1><p>目前大部分企业实现的中台，主要是将遗留下的后台系统，比如ERP MES CRM的公共部分进行拆解复用，形成类似交易中心，用户中心，订单中心这样的微服务集合供前台调用，从而保证<strong>逻辑的一致性</strong>同时更快响应前台的变化</p><p>Reference <a href="https://www.infoq.cn/article/wCZV6X5uujxDXFP0Eub9?utm_source=rss&utm_medium=article" target="_blank" rel="noopener">1</a> 当中举了订单服务的演进过程的例子，很值得一看。当平台需要开放多渠道来完成订单的时候，保证用户有着类似的体验是很重要的一项，包括整个系统的的scalability。</p><p>在这种情况下，一个数据中台能够使得用户可以看到在各个平台各个渠道自己下的订单。从平台角度来说，有了数据中台，维护成本，发生错误以后的修改成本都会减轻很多。</p><p>略微解释下，如果是分开的系统，那么每个系统都会有自己的数据库，我们需要做数据的join操作，然后返回给前端用户需要的正确的信息。当发生了逻辑上的错误以后，我们很有可能需要在分开的几个子系统当中来做修改，很容易出错，修改的整个时间消耗也会很长。而且数据仓库在多个系统的情况下，抽取数据，再进行分析是有比较大的时延的，一般都是加一天的样子，无法看到实时的数据。</p><h1 id="2-使用中台去ERP化"><a href="#2-使用中台去ERP化" class="headerlink" title="2. 使用中台去ERP化"></a>2. 使用中台去ERP化</h1><p>ERP， 即企业资源管理系统。最最开始的时候，企业的需求是将企业的流程梳理清晰，做到资源的集约化管理，本质上来讲是为了解决流程复用，业务能力化的问题。</p><p>但是当前ERP软件存在着如下的一些问题：</p><ol><li>商业软件，响应慢<br>企业只有使用权，这就导致企业的业务发生变化的时候，需要找到原厂重新配置或者重新开发，响应比较慢</li><li>封闭架构，不开放<br>套装ERP软件是封闭架构，技术不开放，导致企业无法对其进行大的功能上的扩展，只能像打补丁一样，构建一些外挂，而且效果往往不会很好</li><li>单体架构，弹性不够<br>单体架构，很难支持持续增长的各种需求</li><li>升级 维护成本<br>套装软件升级和维护成本非常高</li></ol><p>过去人们需要ERP更多的是因为我们需要流程，需要知道具体应该如何去组织。但是在互联网化的今天，原来静态化，标准化的业务流程已经不足以支撑企业的快速响应了。因此，诉求<strong>从原来的流程化变成了需要能够快速响应前台市场的变化</strong>。</p><p>企业组织结构从流程式协作走向了平台式协作。</p><p>ERP更像是一种计划式的经济，希望每个角色都按照分配的任务来走，共同完成一个任务，但是这种共同完成会导致不同角色之间的利益相互冲突。局部利益大于整体利益。</p><p>需要的转变是 —- 要开始学习以客户为中心去动态组织资源来提供服务，将原本<strong><em>以流程为独立单元的模块拆解为以客户价值为独立单元的模块</em></strong>。</p><p>以客户价值为独立单元，如何评定绩效就是个很关键也很困难的问题，尤其是对于那些为后端赋能的业务单元，如何将其关联到直接的客户价值当中。这需要数据中台提供这方面的能力，来利用全域的数据分析，建模，通过敏感性分析等算法技术来实时计算。</p><h1 id="3-数据中台成熟度的评估维度"><a href="#3-数据中台成熟度的评估维度" class="headerlink" title="3. 数据中台成熟度的评估维度"></a>3. 数据中台成熟度的评估维度</h1><ul><li><p>数据战略</p><ul><li><p>理念</p><ul><li>究竟做数据中台是为了什么</li><li>一个组织的愿景和目标，来指导我们接下来的行动</li><li>确定组织，团队对于战略的理解是一致的</li></ul></li><li><p>行动</p><ul><li>一个管理组织<ul><li>确保战略目标能够被有效分解</li><li>能够在部门团队之间落地</li></ul></li><li>制度建设<ul><li>如何保证战略落地</li><li>如何处理冲突，不一致</li><li>如果构建决策流程</li><li>战略/行动的优化和调整机制</li></ul></li></ul></li></ul></li><li><p>数据治理</p><ul><li><p>元数据相关</p><ul><li>如何做元数据分类</li><li>技术和业务元数据的管理</li><li>维护机制</li></ul></li><li><p>数据字典相关</p></li><li><p>数据模型相关</p></li><li><p>数据质量相关</p></li><li><p>数据标准相关</p></li><li><p>数据安全相关</p></li><li><p>数据生命周期相关</p></li></ul></li><li><p>数据资产管理</p><ul><li><p>数据资产审核能力</p><ul><li>注册申请</li></ul></li><li><p>数据资产发布能力</p><ul><li>将数据提供给消费者查询使用的能力</li></ul></li><li><p>数据资产标签</p><ul><li>客户特征标签</li><li>关键业务的指标标签</li></ul></li><li><p>数据资产地图</p><ul><li>通过地图或者目录的形式，提供数据资产的查询功能</li><li>实现数据资产的可视化</li></ul></li><li><p>数据资产开放能力</p><ul><li>通过接口提供给内外部用户使用</li></ul></li><li><p>数据资产盘点能力</p></li><li><p>数据资产定价</p></li><li><p>效益评估</p></li></ul></li><li><p>数据平台和架构</p><ul><li>基准<ul><li>易用</li><li>稳定</li><li>可扩展</li><li>支持多应用的平台架构</li></ul></li><li>架构标准<ul><li>架构选择的流程<ul><li>同业调研</li><li>选型</li><li>POC</li><li>决策部门</li></ul></li><li>架构方法<ul><li>架构规划</li><li>基础架构</li><li>评估机制</li></ul></li></ul></li></ul></li><li><p>数据服务化</p><ul><li><p>数据中心以什么样的方式向外界提供服务呢？</p><ul><li><p>API调用</p></li><li><p>服务标准的确立</p><ul><li>服务目标</li><li>提供方式</li><li>流程</li><li>优先级</li></ul></li><li><p>服务监控和维护</p><ul><li>量化的评估标准</li></ul></li><li><p>数据服务的评估和优化</p></li></ul></li></ul></li><li><p>数据产品化</p><ul><li>产品<ul><li>报表分析等</li></ul></li><li>业务支撑能力<ul><li>所能支撑的业务是否能反映战略的方向或战略的执行情况，功能支撑能力是不是能被周期性评估和优化</li></ul></li><li>业务分析响应能力<ul><li>响应机制</li></ul></li><li>数据可视化能力<ul><li>是否支持业务友好的使用方式</li></ul></li><li>统一服务的能力<ul><li>是否能够将业务需求沉淀成统一的服务的能力，从而服务更多业务团队</li></ul></li></ul></li><li><p>中台运营</p><ul><li>将整个平台作为一个产品来看，是否有运营的指标和控制机制</li><li>中台管理平台<ul><li>文档</li><li>规范</li><li>流程等</li></ul></li><li>成本分析<ul><li>存储</li><li>计算</li><li>研发 <h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1></li></ul></li></ul></li></ul><ol><li><a href="https://www.infoq.cn/article/wCZV6X5uujxDXFP0Eub9?utm_source=rss&amp;utm_medium=article" target="_blank" rel="noopener">https://www.infoq.cn/article/wCZV6X5uujxDXFP0Eub9?utm_source=rss&amp;utm_medium=article</a></li><li><a href="https://insights.thoughtworks.cn/data-zhongtai-maturity-model/" target="_blank" rel="noopener">https://insights.thoughtworks.cn/data-zhongtai-maturity-model/</a> </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;中台是企业级能力复用平台，整个中台的构建，实际上是将业务数据化，将数据业务化。是需要建立业务中台和数据中台的。业务中台通过抽象，封装可复用的逻辑，提升企业的响应力；数据中台通过打通企业的数据，构建自学习服务的数据能力，让企业更加智慧。&lt;/p&gt;
&lt;h1 id=&quot;1-通用化通用
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="中台" scheme="https://www.llchen60.com/tags/%E4%B8%AD%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>Jest - JS测试框架</title>
    <link href="https://www.llchen60.com/Jest-JS%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
    <id>https://www.llchen60.com/Jest-JS%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/</id>
    <published>2020-05-14T04:31:23.000Z</published>
    <updated>2020-05-15T04:11:30.500Z</updated>
    
    <content type="html"><![CDATA[<p>JJest是一个简洁的JavaScript测试框架，我们可以将其与Babel, TS, Node, React, Angular, Vue等来共同使用</p><h1 id="1-Intro"><a href="#1-Intro" class="headerlink" title="1. Intro"></a>1. Intro</h1><p>首先jest是希望能够用很轻量的方式来进行前端测试，自己最近在做一个偏向前端的项目，希望把组里的对外页面从其他平台转移出来，通过router完成路径的转接，然后在自己的平台上，就可以更自由，更快捷的进行迭代了。</p><p>整个架构还是RPC 暴露RESTFul接口，用类似于API Gateway的系统完成Authorization Authentication的工作，前端直接调用后端的信息这样子。想要达到的最终的目标就是易于维护且易于扩展的一个前端小平台，几个基本需求，也是要做转移的原因：</p><ul><li><p>前端的埋点，希望有更多的metrics以知道用户的行为</p><ul><li>各个页面的浏览时长</li><li>跳出率</li><li>哪个步骤过滤走了最多的用户请求，诸如此类</li></ul></li><li><p>CI/ CD</p><ul><li>手动QA太容易犯错了，如果能写一部分unit tests &amp; integration tests,实现整个前端页面的可测试，那么就可以实现持续继承持续部署，会很大程度上提高可交付能力</li></ul></li><li><p>访问速度</p><ul><li>利用S3 host页面，使用CDN完成分布，会提高整体的响应速度</li></ul></li></ul><p>Jest是实现CI/CD的很不错的一个工具，on my way learning it ;) </p><h2 id="1-1-匹配器"><a href="#1-1-匹配器" class="headerlink" title="1.1 匹配器"></a>1.1 匹配器</h2><p>与Junit类似，使用expect做关键词，E.G</p><pre><code>test(&#39;two plus two is four&#39;, () =&gt; {  expect(2 + 2).toBe(4);});</code></pre><ul><li><p>toBe </p><ul><li>匹配器，内部使用的是<code>Object.is</code>来做精确相等</li></ul></li><li><p>toEqual</p><ul><li>来检查对象的值</li></ul></li><li><p>比较真实性</p><ul><li>toBeNull</li><li>toBeUndefined</li><li>toBeTruthy<ul><li>匹配任何if语句为真</li></ul></li><li>toBeFalsy <ul><li>匹配任何if语句为假 </li></ul></li></ul></li><li><p>比较数字</p><ul><li>toBeGreaterThan()</li><li>toBeGreaterThanOrEqual()</li><li>toBeLessThan()</li><li>toBeLessThanOrEqual()</li><li>toBe()</li><li>toEqual()</li></ul></li><li><p>字符串</p><ul><li>toMatch()  match一个正则表达式</li></ul></li><li><p>数组 </p><ul><li>toContain() 检查一个数组或可迭代的对象是否包含某个特定项</li></ul></li></ul><pre><code>const shoppingList = [  &#39;diapers&#39;,  &#39;kleenex&#39;,  &#39;trash bags&#39;,  &#39;paper towels&#39;,  &#39;beer&#39;,];test(&#39;the shopping list has beer on it&#39;, () =&gt; {  expect(shoppingList).toContain(&#39;beer&#39;);  expect(new Set(shoppingList)).toContain(&#39;beer&#39;);});</code></pre><h2 id="1-2-测试异步代码"><a href="#1-2-测试异步代码" class="headerlink" title="1.2 测试异步代码"></a>1.2 测试异步代码</h2><pre><code>// 对于回调函数的测试test(&#39;the data is peanut butter&#39;, done =&gt; {  function callback(data) {    try {      expect(data).toBe(&#39;peanut butter&#39;);      done();    } catch (error) {      done(error);    }  }  fetchData(callback);});// Promisestest(&#39;the data is peanut butter&#39;, () =&gt; {  return fetchData().then(data =&gt; {    expect(data).toBe(&#39;peanut butter&#39;);  });});// Resolve/ rejecttest(&#39;the data is peanut butter&#39;, () =&gt; {  return expect(fetchData()).resolves.toBe(&#39;peanut butter&#39;);});// async/ awaittest(&#39;the data is peanut butter&#39;, async () =&gt; {  const data = await fetchData();  expect(data).toBe(&#39;peanut butter&#39;);});test(&#39;the fetch fails with an error&#39;, async () =&gt; {  expect.assertions(1);  try {    await fetchData();  } catch (e) {    expect(e).toMatch(&#39;error&#39;);  }});</code></pre><h2 id="1-3-测试前后的utility方法"><a href="#1-3-测试前后的utility方法" class="headerlink" title="1.3 测试前后的utility方法"></a>1.3 测试前后的utility方法</h2><ul><li>重复设置值 </li></ul><pre><code>beforeEach(() =&gt; {});afterEach(() =&gt; {});</code></pre><ul><li><p>一次性设置 – 单个测试不会改变其值</p><p>  beforeAll(() =&gt; {</p><p>  });</p><p>  afterAll(() =&gt; {</p><p>  });</p></li><li><p>作用域 </p><ul><li>通过describe来将测试进行分组操作 </li><li>注意describe的执行顺序 <ul><li>在真正的测试开始之前执行测试文件当中的所有的describe处理程序</li><li>当describe块运行完后，Jest会按照test出现的顺序依次运行所有测试，等待每一个测试完成并整理好，然后继续往下走</li></ul></li><li>通用建议<ul><li>当测试失败的时候，首先要检查的是如果仅运行这条测试，是否仍然失败</li><li>通过将test指令改为test.only指令来实现</li></ul></li></ul></li></ul><h2 id="1-4-Mock-方法"><a href="#1-4-Mock-方法" class="headerlink" title="1.4 Mock 方法"></a>1.4 Mock 方法</h2><p>Mock函数允许我们来测试代码之间的连接，和Mockito， EasyMock其实是一个理念的，擦除函数的实际实现，专注于当前的文件的方法本身，捕获对函数的调用，实例等</p><pre><code>function forEach(items, callback) {  for (let index = 0; index &lt; items.length; index++) {    callback(items[index]);  }}const mockCallback = jest.fn(x =&gt; 42 + x);forEach([0, 1], mockCallback);// 此 mock 函数被调用了两次expect(mockCallback.mock.calls.length).toBe(2);// 第一次调用函数时的第一个参数是 0expect(mockCallback.mock.calls[0][0]).toBe(0);// 第二次调用函数时的第一个参数是 1expect(mockCallback.mock.calls[1][0]).toBe(1);// 第一次函数调用的返回值是 42expect(mockCallback.mock.results[0].value).toBe(42);</code></pre><h1 id="2-测试方法"><a href="#2-测试方法" class="headerlink" title="2. 测试方法"></a>2. 测试方法</h1><h2 id="2-1-Snapshot-测试"><a href="#2-1-Snapshot-测试" class="headerlink" title="2.1 Snapshot 测试"></a>2.1 Snapshot 测试</h2><p>给当前的UI做快照，然后和过去做过的快照进行比较，看是否有不同。</p><pre><code>import React from &#39;react&#39;;import Link from &#39;../Link.react&#39;;import renderer from &#39;react-test-renderer&#39;;it(&#39;renders correctly&#39;, () =&gt; {  const tree = renderer    .create(&lt;Link page=&quot;http://www.facebook.com&quot;&gt;Facebook&lt;/Link&gt;)    .toJSON();  expect(tree).toMatchSnapshot();});</code></pre><p>实际上是生成一个DOM树，然后来比较两颗DOM树的节点，看设置是否相同。</p><p>在每次提交的时候，会记录下当前的快照，下次提交的时候会和这次的来进行比较。</p><p>然后当我们有目的的引入了变化的时候，我们需要告诉jest 需要更新现在保存的snapshot了，这种情况下需要运行指令<code>jest --updateSnapshot</code>.</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://jestjs.io/docs/en/getting-started" target="_blank" rel="noopener">https://jestjs.io/docs/en/getting-started</a> </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JJest是一个简洁的JavaScript测试框架，我们可以将其与Babel, TS, Node, React, Angular, Vue等来共同使用&lt;/p&gt;
&lt;h1 id=&quot;1-Intro&quot;&gt;&lt;a href=&quot;#1-Intro&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="FrontEnd" scheme="https://www.llchen60.com/categories/FrontEnd/"/>
    
    
      <category term="Jest" scheme="https://www.llchen60.com/tags/Jest/"/>
    
  </entry>
  
  <entry>
    <title>好玩的网站列表</title>
    <link href="https://www.llchen60.com/%E5%A5%BD%E7%8E%A9%E7%9A%84%E7%BD%91%E7%AB%99%E5%88%97%E8%A1%A8/"/>
    <id>https://www.llchen60.com/%E5%A5%BD%E7%8E%A9%E7%9A%84%E7%BD%91%E7%AB%99%E5%88%97%E8%A1%A8/</id>
    <published>2020-05-13T04:33:52.000Z</published>
    <updated>2020-06-08T04:02:10.319Z</updated>
    
    <content type="html"><![CDATA[<p>好玩的东西，持续更新~ </p><ul><li><p>digital nomad</p><ul><li>以数字技术为生，搬到风景优美，气候温和，物价便宜的地方，做自己想做的事情，这概念有意思的</li><li><a href="https://nomadlist.com/" target="_blank" rel="noopener">https://nomadlist.com/</a> </li></ul></li><li><p>Regex 101 </p><ul><li>神一样的正则网站，可以做在线debug</li><li><a href="https://regex101.com/" target="_blank" rel="noopener">https://regex101.com/</a> </li></ul></li><li><p>中国互联网中讨论的消亡</p><ul><li><a href="https://mp.weixin.qq.com/s/a-32UpINmb_vSj17epysiA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/a-32UpINmb_vSj17epysiA</a></li></ul></li><li><p>经济机器是怎样运行的 by Ray Dalio </p><ul><li>在2020年对着现在的经济形势看，别有一番滋味 lol</li><li>tips<ul><li>不要让债务的增长速度超过收入</li><li>不要让收入的增长速度超过生产率</li><li>尽一切努力提高生产率</li></ul></li><li><a href="https://www.bilibili.com/video/av6496369/" target="_blank" rel="noopener">https://www.bilibili.com/video/av6496369/</a></li></ul></li><li><p>大国周期及储备货币变迁 by Ray Dalio</p><ul><li><a href="https://www.chainnews.com/articles/678538813470.htm" target="_blank" rel="noopener">link</a></li></ul></li><li><p>思考工具的📱</p><ul><li><a href="https://untools.co/" target="_blank" rel="noopener">link</a></li></ul></li><li><p>设计模式的讲解</p><ul><li><a href="https://refactoringguru.cn/design-patterns" target="_blank" rel="noopener">link</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;好玩的东西，持续更新~ &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;digital nomad&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以数字技术为生，搬到风景优美，气候温和，物价便宜的地方，做自己想做的事情，这概念有意思的&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://nomadlist.
      
    
    </summary>
    
    
      <category term="Notes" scheme="https://www.llchen60.com/categories/Notes/"/>
    
    
  </entry>
  
  <entry>
    <title>中台(三) - 看白话中台系列的一些总结</title>
    <link href="https://www.llchen60.com/%E4%B8%AD%E5%8F%B0-%E4%B8%89-%E7%9C%8B%E7%99%BD%E8%AF%9D%E4%B8%AD%E5%8F%B0%E7%B3%BB%E5%88%97%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/"/>
    <id>https://www.llchen60.com/%E4%B8%AD%E5%8F%B0-%E4%B8%89-%E7%9C%8B%E7%99%BD%E8%AF%9D%E4%B8%AD%E5%8F%B0%E7%B3%BB%E5%88%97%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/</id>
    <published>2020-05-12T03:36:52.000Z</published>
    <updated>2020-05-12T03:40:08.892Z</updated>
    
    <content type="html"><![CDATA[<p>前面两篇文章讲了一些关于中台的信息, <a href="https://llchen60.com/%E4%B8%AD%E5%8F%B0/" target="_blank" rel="noopener">中台1</a>,<a href="https://llchen60.com/%E4%B8%AD%E5%8F%B0-%E4%BA%8C-%E7%95%A5%E6%B7%B1%E5%85%A5%E4%BA%9B%E7%9A%84%E6%8E%A2%E7%A9%B6/" target="_blank" rel="noopener">中台2</a>。</p><ul><li><p>为什么需要平台化</p><ul><li>赋予企业用户响应力</li></ul></li><li><p>什么是中台</p><ul><li><strong>企业级能力复用平台</strong></li><li>基础的理念和架构</li><li>可以联通，支持上端的业务</li><li>需要能够将后台各式各样的资源转化为前台易于使用的能力 –&gt; 以用户为中心的持续规模化创新</li><li>Platform as a product </li><li>亚马逊大量使用微服务，关于微服务与中台，可以想象成中台是多个有平台化能力的微服务的集合，通过隐藏内部的信息和不必要的接口，对外呈现为单独一个具有平台服务能力的微服务。</li></ul></li><li><p>中台分类/ 为什么要建平台</p><ul><li>内部研发效能提升</li><li>资源整合</li><li>新零售</li><li>全周期</li><li>全渠道</li><li>开放银行</li><li>多品牌战略</li><li>全球化战略</li><li>产业互联</li><li>构建商业生态</li></ul></li><li><p>阿里的数据业务双中台</p><ul><li>业务中台将后台资源进行抽象包装整合，转化为前台友好的可重用可共享的核心能力，实现后端业务资源到前台易用能力的转化</li><li>数据中台从后台及业务中台将数据流入，完成海量数据的存储，计算，产品化包装的过程，构成企业的核心数据能力</li></ul></li><li><p>阿里技术中台</p><ul><li>将使用云或者其他基础设施的能力以及应用各种技术中间件的能力进行整合包装，过滤掉技术细节，提供简单一致，易于使用的应用技术基础设施的能力接口，助力前台和业务中台数据中台的快速建设</li></ul></li><li><p>组织中台</p><ul><li>中台建设真正困难的地方在于组织上的重构，技术架构与组织架构的匹配！！</li><li>组织中台很像企业中的内部风投和创新孵化机构，为前台组织和团队构建创新型前台应用提供类似于投资评估（项目甄别）、投资管理、投后管理（孵化与风控），真正从组织和制度上支撑前台组织和应用的快速迭代规模化创新</li></ul></li><li><p>中台建设的难点 – 需要关注组织架构的调整</p><ul><li>组织架构的调整和演进以及利益的重新分配 </li><li>战略的落地是需要靠组织架构的调整来实现的，企业的发展取决于企业正确的战略以及企业的组织结构。前者决定了后者，后者能够保证前者的落地实现</li><li>如果将中台和前台之间的关系定义成服务和被服务的关系，很容易会因为大量需求占据大量时间，短期利益和长期利益的博弈，造成很多问题</li><li>产品化思维，将中台当做一个产品，和其他组是产品之间互通的关系</li></ul></li><li><p>关于中台 - 产品化思考以后的问题</p><ul><li>愿景是什么？<ul><li>中台作为产品需要有自己的愿景定位，不一定需要满足所有前台客户的需求，这同样也意味着前台可以选择不使用中台的某些能力而选择自建。</li></ul></li><li>用户是谁？ 如何划分？<ul><li>中台作为产品需要有自己清晰的用户定位和用户划分，前台作为中台的用户不再是平等的，VIP 前台用户的需求要优于免费前台用户的诉求，通过产品上常见的用户划分来解决需求膨胀、排期、优先级和冲突问题</li></ul></li><li>解决了什么问题？<ul><li>中台作为一个产品，需要想方设法体现自身的价值，真正为前台客户解决实际问题，并关注前台用户体验，通过营销和售前等手段获取前台客户，通过清晰的用户定位和产品力吸引前台客户，让其主动选择采购中台产品</li></ul></li><li>竞争环境？ 团队构成？<ul><li>产品的建设初期，不一定启动资金直接从业务上切分，可能需要类似于天使投资的企业战略投资进行初始孵化，减少中台前期建设的业务交付压力，甚至作为企业的战略级产品，需要一些内部保护和孵化，但仍需要快速验证其价值，获取客户，实现自负盈亏</li></ul></li><li>如何获取用户？营销？售前？</li><li>如何向用户提供服务？<ul><li>产品的建设过程可以借鉴精益创业思路，需要尽快体现其商业价值，如果一定时期内无法获取相应的前台用户（前台不用），或是其他考核指标不达标，则需要进行中台建设止损，类似于创业失败</li><li>甚至在特殊情况下，允许同一类型的中台产品存在合理的内部竞争，同时对两个相似的中台产品进行孵化，使用类似于内部赛马的机制解决内部服务差异性带来的内部产品垄断和定价困难问题</li><li>中台产品为了用户留存，需要对于前台客户提供产品级 SLA，提供客户运营，客户售后服务，保持产品平滑更新，关注用户满意度，实现客户留存与转化</li></ul></li><li>如何验证价值？成本核算？ 定价机制？</li><li>如何保证服务质量？ </li><li>如何升级演进？产品运营？<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1></li></ul></li></ul><ol><li><a href="https://www.infoq.cn/profile/1084916/publish" target="_blank" rel="noopener">https://www.infoq.cn/profile/1084916/publish</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前面两篇文章讲了一些关于中台的信息, &lt;a href=&quot;https://llchen60.com/%E4%B8%AD%E5%8F%B0/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;中台1&lt;/a&gt;,&lt;a href=&quot;https://llchen60.co
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="中台" scheme="https://www.llchen60.com/tags/%E4%B8%AD%E5%8F%B0/"/>
    
  </entry>
  
</feed>
