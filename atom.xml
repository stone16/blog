<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Leilei&#39;s Blog | 磊磊的博客</title>
  
  <subtitle>Because it&#39;s there</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.llchen60.com/"/>
  <updated>2020-02-23T17:10:22.625Z</updated>
  <id>https://www.llchen60.com/</id>
  
  <author>
    <name>Leilei Chen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>设计模式概述</title>
    <link href="https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/"/>
    <id>https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/</id>
    <published>2020-02-21T22:58:10.000Z</published>
    <updated>2020-02-23T17:10:22.625Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-起源"><a href="#1-起源" class="headerlink" title="1. 起源"></a>1. 起源</h1><p>每个模式都描述了一个在我们的环境中不断出现的问题，然后描述了该问题的解决方案的核心，通过这种方式，我们可以无数次重用那些已有的成功的解决方案，无须再重复相同的工作。</p><p>软件模式(Software Patterns)是将模式的一般概念应用于软件开发领域，即软件开发的总体指导思路或参照样板。软件模式并非仅限于设计模式，还包括架构模式、分析模式和过程模式等，<strong><em>实际上，在软件开发生命周期的每一个阶段都存在着一些被认同的模式</em></strong>。</p><p>想要学习设计模式的原因，是因为感到自己的代码能力还是有点捉急，可以写出能用的代码，但很难写出好看的代码，如果每次写代码的时候都要一行一行的来构建，而没有一个组件一个组件的意识的话，那写好代码恐怕只能是天方夜谭了。我想设计模式对我来说，就是抽象，构建框架的过程，是真真切切能够在日常工作当中帮助到自己的。不仅仅在于代码质量，也在于组件化以后的开发速度，以及对于更加复杂的商业上的实际场景得以提供出更加匹配的解决方式的能力。</p><p>另外一个点是当前我的能力范畴还是仅仅在于根据需求写出代码，即停留在写业务代码的阶段，在这个阶段当中，自己并不需要具有很强的代码设计能力，理解业务就可以写出代码了。但是如果想要成长，还是需要具备写出<strong>和业务并不直接相关的更加通用的功能模块</strong>的能力的。</p><h1 id="2-软件模式的基础结构"><a href="#2-软件模式的基础结构" class="headerlink" title="2. 软件模式的基础结构"></a>2. 软件模式的基础结构</h1><ul><li>问题描述</li><li>前提条件</li><li>解法</li><li>效果</li></ul><h2 id="2-1-评价代码的一些维度"><a href="#2-1-评价代码的一些维度" class="headerlink" title="2.1 评价代码的一些维度"></a>2.1 评价代码的一些维度</h2><p>关于如何判断一段代码写的好坏，众说纷纭，每个人其实都有自己主观上的某些看法。但是在更高维度上来说，会有一些相对能达成共识的标准，是我们可以在平常写代码的时候更多的注意一下的。</p><h3 id="2-1-1-可维护性-maintainability"><a href="#2-1-1-可维护性-maintainability" class="headerlink" title="2.1.1 可维护性 maintainability"></a>2.1.1 可维护性 maintainability</h3><ul><li>在不破坏原有代码的设计，不引入新的bug的情况下，能够快速地修改或者添加代码</li><li>细拆分其实就有很多因素的协同作用了<ul><li>代码的可读性，简洁</li><li>代码分层清晰程度，模块化，高内聚低耦合</li><li>基于接口而非实现编程</li></ul></li></ul><h3 id="2-1-2-可读性-readability"><a href="#2-1-2-可读性-readability" class="headerlink" title="2.1.2 可读性 readability"></a>2.1.2 可读性 readability</h3><ul><li>命名</li><li>注释</li><li>函数的长短</li><li>模块的划分</li></ul><h3 id="2-1-3-可扩展性-extensibility"><a href="#2-1-3-可扩展性-extensibility" class="headerlink" title="2.1.3 可扩展性  extensibility"></a>2.1.3 可扩展性  extensibility</h3><p>表征的是我们的代码对未来需求变化进行应对的能力。</p><p>即代码预留了一些功能的扩展点，我们可以将新功能代码直接插入到扩展点上，而不需要因为添加一个功能而大动干戈，改动大量的原始代码。</p><h3 id="2-1-4-灵活性-flexibility"><a href="#2-1-4-灵活性-flexibility" class="headerlink" title="2.1.4 灵活性  flexibility"></a>2.1.4 灵活性  flexibility</h3><ul><li>比如预留好了扩展点给新的功能代码来使用</li><li>代码已经抽象出了很多底层可以复用的模块，类</li></ul><h3 id="2-1-5-简洁性-simplicity"><a href="#2-1-5-简洁性-simplicity" class="headerlink" title="2.1.5 简洁性   simplicity"></a>2.1.5 简洁性   simplicity</h3><p>Keep it simple, stupid. </p><h3 id="2-1-6-可复用性-reusability"><a href="#2-1-6-可复用性-reusability" class="headerlink" title="2.1.6 可复用性  reusability"></a>2.1.6 可复用性  reusability</h3><p>尽量减少重复代码的编写，复用已有的代码</p><h3 id="2-1-7-可测试性-testability"><a href="#2-1-7-可测试性-testability" class="headerlink" title="2.1.7 可测试性  testability"></a>2.1.7 可测试性  testability</h3><p>比较难写的单元测试往往意味着代码的设计是有问题的。</p><p>如果说上面的细节实在是太多，并不能一下子很快的掌握，个人感觉，去看别人的设计，别人的代码，和自己的比较，会是非常快的成长方式。除此以外，肯定还是要经过看山是山，不是山，还是山的阶段的。希望自己的代码最终能像一个故事一样，将一段逻辑讲述完整。</p><h1 id="3-设计模式"><a href="#3-设计模式" class="headerlink" title="3. 设计模式"></a>3. 设计模式</h1><blockquote><p>设计模式(Design Pattern)是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结，使用设计模式是为了可重用代码、让代码更容易被他人理解并且保证代码可靠性。</p></blockquote><p>整个设计模式系列将会分以下几个部分：</p><ol><li><p>概述</p></li><li><p>面向对象设计原则</p><ul><li>单一职责</li><li>开闭原则</li><li>里氏代换</li><li>依赖倒转</li><li>接口隔离</li><li>合成复用</li><li>迪米特</li></ul></li><li><p>创建型模式（描述如何创建对象）</p><ul><li>简单工厂模式</li><li>工厂方法模式</li><li>抽象工厂模式</li><li>单例模式</li><li>原型模式</li><li>建造者模式</li></ul></li><li><p>结构型模式（如何实现类或对象的组合）</p><ul><li>适配器模式</li><li>桥接模式</li><li>组合模式</li><li>装饰模式</li><li>外观模式</li><li>享元模式</li><li>代理模式</li></ul></li><li><p>行为型模式（类或者对象怎样交互以及怎样分配职责）（类是对一类事物的描述，抽象出来的；而对象是具体的描述。类是一群具有相同属性的对象的集合体）</p><ul><li>职责链模式</li><li>命令模式</li><li>解释器模式</li><li>迭代器模式</li><li>中介者模式</li><li>备忘录模式</li><li>观察者模式</li><li>状态模式</li><li>策略模式</li><li>模板方法模式</li><li>访问者模式</li></ul></li></ol><h1 id="4-面向对象，设计原则，设计模式，编程规范，代码重构"><a href="#4-面向对象，设计原则，设计模式，编程规范，代码重构" class="headerlink" title="4. 面向对象，设计原则，设计模式，编程规范，代码重构"></a>4. 面向对象，设计原则，设计模式，编程规范，代码重构</h1><h2 id="4-1-面向对象"><a href="#4-1-面向对象" class="headerlink" title="4.1 面向对象"></a>4.1 面向对象</h2><p>主流的编程范式有：</p><ul><li>面向过程</li><li>面向对象</li><li>函数式编程</li></ul><p>面向对象因为其具有的丰富的特性 - 封装，继承，抽象，多态。可以实现很多复杂的设计思路，是很多设计原则，设计模式的实现基础。</p><ul><li>知识点<ul><li>封装 继承 抽象 多态</li><li>面向对象与面向过程编程的区别与联系</li><li>面向对象的分析设计和编程</li><li>接口和抽象类的区别以及各自的应用场景</li><li>基于接口而非实现的编程设计思想</li><li>多用组合少用继承的设计思想</li><li>面向过程的贫血模型和面向对象的充血模型<h2 id="4-2-设计原则"><a href="#4-2-设计原则" class="headerlink" title="4.2 设计原则"></a>4.2 设计原则</h2></li></ul></li><li>设计原则<ul><li>单一职责原则</li><li>开闭原则</li><li>里氏替换原则</li><li>接口隔离原则</li><li>依赖导致原则</li><li>DRY</li><li>KISS</li><li>YAGNI</li><li>LOD</li></ul></li></ul><h2 id="4-3-设计模式"><a href="#4-3-设计模式" class="headerlink" title="4.3 设计模式"></a>4.3 设计模式</h2><ul><li>设计模式<ul><li>为了解决代码的可扩展性问题</li><li>需要掌握他们都解决了哪些问题，典型的应用场景，并且不能也不应该过度使用</li><li>创建型<ul><li>单例模式</li><li>工厂模式</li><li>建造者模式</li></ul></li><li>结构型<ul><li>代理模式</li><li>桥接模式</li><li>装饰者模式</li><li>适配器模式</li></ul></li><li>行为型<ul><li>观察者模式</li><li>模板模式</li><li>策略模式</li><li>职责链模式</li><li>迭代器模式</li><li>状态模式</li></ul></li></ul></li></ul><h2 id="4-4-编程规范"><a href="#4-4-编程规范" class="headerlink" title="4.4 编程规范"></a>4.4 编程规范</h2><p>主要为了解决代码的可读性问题，这些规范主要是记忆，熟悉，然后尽量多的去使用。书籍的话可以去看重构，代码大全，代码整洁之道这几本书。</p><h2 id="4-5-代码重构"><a href="#4-5-代码重构" class="headerlink" title="4.5 代码重构"></a>4.5 代码重构</h2><p>业务发展，规模扩大，原先的设计很可能无法支持现在的体量的应用场景，这种情况下就需要持续重构了。而是用的工具就是我们前面说的设计模式，编程规范等等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-起源&quot;&gt;&lt;a href=&quot;#1-起源&quot; class=&quot;headerlink&quot; title=&quot;1. 起源&quot;&gt;&lt;/a&gt;1. 起源&lt;/h1&gt;&lt;p&gt;每个模式都描述了一个在我们的环境中不断出现的问题，然后描述了该问题的解决方案的核心，通过这种方式，我们可以无数次重用那些
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="Design Pattern" scheme="https://www.llchen60.com/tags/Design-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>PowerMock with EasyMock toturial</title>
    <link href="https://www.llchen60.com/Powermock-with-EasyMock-toturial/"/>
    <id>https://www.llchen60.com/Powermock-with-EasyMock-toturial/</id>
    <published>2020-02-21T05:11:10.000Z</published>
    <updated>2020-02-21T05:11:57.519Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Intro-with-an-example"><a href="#1-Intro-with-an-example" class="headerlink" title="1. Intro with an example"></a>1. Intro with an example</h1><p>We often find we need to do unit tests for final class, static method, which are not supported by Easymock, Mockito currently. Under such situation, we could use Powermock to help us mock the corresponding classes. </p><p>For detail introduction about powermock, refer to <a href="https://github.com/powermock/powermock" target="_blank" rel="noopener">PowerMock Github</a></p><p>Use example as followed to show how to integrate PowerMock with EasyMock: </p><pre><code>public final class FinalClassExample {    public String static doNothingStatic() {        return &quot;test&quot;;    }}@PowerMockIgnore(&quot;javax.management.*&quot;) // only need when see warning related with jmx or mbeans@RunWith(PowerMockRunner.class)  // necessary for powermock @PrepareForTest(FinalClassExample.class)  // necessary for powermock public class FinalClassExampleTest {    private IMocksControl control;    @Before    public void init() {        // do some initialization here         control = EasyMock.createControl();    }    @Test    public void test_example() {        PowerMock.mockStatic(FinalClassExample.class);        expect(FinalClassExample.doNothingStatic()).andReturn(&quot;test&quot;);        PowerMock.replay(FinalClassExample.class);        runYourTest();        PowerMock.verify(FinalClassExample.class);        // do some assertions here    }}</code></pre><h1 id="2-Other-APIs"><a href="#2-Other-APIs" class="headerlink" title="2. Other APIs"></a>2. Other APIs</h1><ul><li>mock final classes or methods <ul><li><code>@RunWith(PowerMockRunner.class)</code></li><li><code>@PrepareForTest(ClassWithFinal.class)</code></li><li><code>PowerMock.createMock(ClassWithFinal.class);</code></li><li><code>PowerMock.replay(mockObject)</code></li><li><code>PowerMock.verify(mockObject)</code></li></ul></li><li>mock private methods <ul><li><code>@RunWith(PowerMockRunner.class)</code></li><li><code>@PrepareForTest(ClassWithPrivateMethod.class)</code></li><li><code>PowerMock.createPartialMock(ClassWithPrivateMethod.class, &quot;nameOfTheMethodToMock&quot;)</code></li><li>Use <code>PowerMock.expectPrivate(mockObject, &quot;nameOfTheMethodToMock&quot;, argument1, argument2)</code> to expect the method call to <code>nameOfTheMethodToMock</code> with arguments <code>argument1</code> and <code>argument2</code></li><li><code>PowerMock.replay(mockObject)</code></li><li><code>PowerMock.verify(mockObject)</code></li></ul></li><li>mock construction of new objects <ul><li><code>@RunWith(PowerMockRunner.class)</code></li><li><code>@PrepareForTest(ClassThatCreatesTheNewInstance.class)</code> </li><li><code>PowerMock.createMock(NewInstanceClass.class)</code></li><li><code>PowerMock.expectNew(NewInstanceClass.class).andReturn(mockObject)</code></li><li><code>PowerMock.replay(mockObject, NewInstanceClass.class)</code></li><li><code>PowerMock.verify(mockObject, NewInstanceClass.class)</code></li></ul></li><li>mock partial <ul><li><code>@RunWith(PowerMockRunner.class)</code></li><li><code>@PrepareForTest(ClassToPartiallyMock.class)</code></li><li><code>PowerMock.createPartialMock(ClassToPartiallyMock.class, &quot;nameOfTheFirstMethodToMock&quot;, &quot;nameOfTheSecondMethodToMock&quot;)</code></li><li><code>PowerMock.replay(mockObject)</code></li><li><code>PowerMock.verify(mockObject)</code></li></ul></li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://github.com/powermock/powermock" target="_blank" rel="noopener">https://github.com/powermock/powermock</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Intro-with-an-example&quot;&gt;&lt;a href=&quot;#1-Intro-with-an-example&quot; class=&quot;headerlink&quot; title=&quot;1. Intro with an example&quot;&gt;&lt;/a&gt;1. Intro with an
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
      <category term="Unit Test" scheme="https://www.llchen60.com/tags/Unit-Test/"/>
    
      <category term="PowerMock" scheme="https://www.llchen60.com/tags/PowerMock/"/>
    
  </entry>
  
  <entry>
    <title>工程师需要知道的latency 数字 </title>
    <link href="https://www.llchen60.com/%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84latency-%E6%95%B0%E5%AD%97/"/>
    <id>https://www.llchen60.com/%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84latency-%E6%95%B0%E5%AD%97/</id>
    <published>2020-02-21T05:08:38.000Z</published>
    <updated>2020-02-21T05:10:12.077Z</updated>
    
    <content type="html"><![CDATA[<p>看到一篇博客，叙述了当前内存对于数据的处理速度对于开发的影响，推而广之，找到了一些我们在做系统设计的时候需要熟知的一些数据。</p><p>首先处理器的处理速度和内存的处理速度是差距很大的，处理器的处理速度的增长速度要比内存的快很多。</p><p><img src="https://i.loli.net/2020/02/21/s8h6GTfi1PSYwpe.png" alt="处理器与内存的性能表现.png"></p><p>我们需要探究的是CPU从内存中随机提取数据以及获取连续数据的速度，这是很粗略的估计，只是希望能够有一个数量级上的感知。</p><pre><code>Latency Comparison Numbers (~2012)----------------------------------L1 cache reference                           0.5 nsBranch mispredict                            5   nsL2 cache reference                           7   ns                      14x L1 cacheMutex lock/unlock                           25   nsMain memory reference                      100   ns                      20x L2 cache, 200x L1 cacheCompress 1K bytes with Zippy             3,000   ns        3 usSend 1K bytes over 1 Gbps network       10,000   ns       10 usRead 4K randomly from SSD*             150,000   ns      150 us          ~1GB/sec SSDRead 1 MB sequentially from memory     250,000   ns      250 usRound trip within same datacenter      500,000   ns      500 usRead 1 MB sequentially from SSD*     1,000,000   ns    1,000 us    1 ms  ~1GB/sec SSD, 4X memoryDisk seek                           10,000,000   ns   10,000 us   10 ms  20x datacenter roundtripRead 1 MB sequentially from disk    20,000,000   ns   20,000 us   20 ms  80x memory, 20X SSDSend packet CA-&gt;Netherlands-&gt;CA    150,000,000   ns  150,000 us  150 ms</code></pre><p>根据2020年StackOverflow上的回答，我们可以看到Core i7 Xeon 5500 的benchmark数据如下</p><pre><code>Core i7 Xeon 5500 Series Data Source Latency (approximate)               [Pg. 22]local  L1 CACHE hit,                              ~4 cycles (   2.1 -  1.2 ns )local  L2 CACHE hit,                             ~10 cycles (   5.3 -  3.0 ns )local  L3 CACHE hit, line unshared               ~40 cycles (  21.4 - 12.0 ns )local  L3 CACHE hit, shared line in another core ~65 cycles (  34.8 - 19.5 ns )local  L3 CACHE hit, modified in another core    ~75 cycles (  40.2 - 22.5 ns )remote L3 CACHE (Ref: Fig.1 [Pg. 5])        ~100-300 cycles ( 160.7 - 30.0 ns )local  DRAM                                                   ~60 nsremote DRAM                                                  ~100 ns</code></pre><p>而现在的cache的大小，根据wikiChip上的数据，对于Core i7-8700K</p><pre><code>Memory Bandwidth: 39.74 gigabytes per secondL1 cache: 192 kilobytes (32 KB per core)L2 cache: 1.5 megabytes (256 KB per core)L3 cache: 12 megabytes  (shared; 2 MB per core)</code></pre><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://www.forrestthewoods.com/blog/memory-bandwidth-napkin-math/" target="_blank" rel="noopener">https://www.forrestthewoods.com/blog/memory-bandwidth-napkin-math/</a>?</li><li><a href="https://stackoverflow.com/questions/4087280/approximate-cost-to-access-various-caches-and-main-memory" target="_blank" rel="noopener">https://stackoverflow.com/questions/4087280/approximate-cost-to-access-various-caches-and-main-memory</a></li><li><a href="https://en.wikichip.org/wiki/intel/core_i7/i7-8700k" target="_blank" rel="noopener">https://en.wikichip.org/wiki/intel/core_i7/i7-8700k</a></li><li><a href="https://gist.github.com/jboner/2841832" target="_blank" rel="noopener">https://gist.github.com/jboner/2841832</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;看到一篇博客，叙述了当前内存对于数据的处理速度对于开发的影响，推而广之，找到了一些我们在做系统设计的时候需要熟知的一些数据。&lt;/p&gt;
&lt;p&gt;首先处理器的处理速度和内存的处理速度是差距很大的，处理器的处理速度的增长速度要比内存的快很多。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;ht
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="latency" scheme="https://www.llchen60.com/tags/latency/"/>
    
      <category term="system design" scheme="https://www.llchen60.com/tags/system-design/"/>
    
  </entry>
  
  <entry>
    <title>Java8 Date Time API </title>
    <link href="https://www.llchen60.com/Java8-Date-Time-API/"/>
    <id>https://www.llchen60.com/Java8-Date-Time-API/</id>
    <published>2020-02-20T03:08:47.000Z</published>
    <updated>2020-02-20T03:09:12.256Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-为什么需要新的Date-API"><a href="#1-为什么需要新的Date-API" class="headerlink" title="1. 为什么需要新的Date API"></a>1. 为什么需要新的Date API</h1><p>Java8 的一大更新在于终于将Date Time一致化，这解决了在Java8以前我们观察到的非常多的问题：</p><p>譬如：</p><ul><li>Java Date Time类定义在不同的地方，比如在java.util &amp; java.sql里面都有，而样式和格式转化的类都定义在java.text的包里，比较混乱</li><li>java.util.Date包括date和time类，而java.sql.Date只包含date</li><li>并没有清晰定义的类用于处理time, timestamp, formatting, parsing </li><li>所有的Date类都是可变的，并不是线程安全的</li><li>Date类不支持全球化，没有时区的支持，在java8之前，为了显示当地时间，就得使用java.util.Calendar 还有 java.util.TimeZone,整个变得比较麻烦</li></ul><h1 id="2-Java8-Date-Time-API-详解"><a href="#2-Java8-Date-Time-API-详解" class="headerlink" title="2. Java8 Date Time API 详解"></a>2. Java8 Date Time API 详解</h1><h2 id="2-1-Packages"><a href="#2-1-Packages" class="headerlink" title="2.1 Packages"></a>2.1 Packages</h2><ul><li>java.time Package <ul><li>这是新的Date Time API的基础包，一些主要的基本类都在这里面，譬如LocalDate, LocalTime, LocalDateTime, Instant, Period, Duration  </li></ul></li><li>java.time.chrono <ul><li>定义了抽象的API接口，针对于非ISO标准的calendar 系统，我们可以通过extend AbstractChronology类来创建我们自己的calendar系统</li></ul></li><li>java.time.format <ul><li>包含用来Formatting还有parsing date time对象的类</li></ul></li><li>java.time.temporal <ul><li>包含一些时间对象，比如找到月份的第一天， 最后一天之类的</li></ul></li><li>java.time.zone<ul><li>支持不同的时区 </li></ul></li></ul><h2 id="2-2-LocalDate"><a href="#2-2-LocalDate" class="headerlink" title="2.2 LocalDate"></a>2.2 LocalDate</h2><ul><li>Immutable class </li><li>默认样式为 yyyy-MM-dd</li><li>我们可以使用<code>now()</code>方法来获得当前的日期</li><li>也可以通过提供年月日来创建localDate对象</li><li>我们同时也可以传入ZoneId来得到在特定的时区的日期</li></ul><pre><code>package com.journaldev.java8.time;import java.time.LocalDate;import java.time.Month;import java.time.ZoneId;/** * LocalDate Examples * @author pankaj * */public class LocalDateExample {    public static void main(String[] args) {        //Current Date        LocalDate today = LocalDate.now();        System.out.println(&quot;Current Date=&quot;+today);        //Creating LocalDate by providing input arguments        LocalDate firstDay_2014 = LocalDate.of(2014, Month.JANUARY, 1);        System.out.println(&quot;Specific Date=&quot;+firstDay_2014);        //Try creating date by providing invalid inputs        //LocalDate feb29_2014 = LocalDate.of(2014, Month.FEBRUARY, 29);        //Exception in thread &quot;main&quot; java.time.DateTimeException:         //Invalid date &#39;February 29&#39; as &#39;2014&#39; is not a leap year        //Current date in &quot;Asia/Kolkata&quot;, you can get it from ZoneId javadoc        LocalDate todayKolkata = LocalDate.now(ZoneId.of(&quot;Asia/Kolkata&quot;));        System.out.println(&quot;Current Date in IST=&quot;+todayKolkata);        //java.time.zone.ZoneRulesException: Unknown time-zone ID: IST        //LocalDate todayIST = LocalDate.now(ZoneId.of(&quot;IST&quot;));        //Getting date from the base date i.e 01/01/1970        LocalDate dateFromBase = LocalDate.ofEpochDay(365);        System.out.println(&quot;365th day from base date= &quot;+dateFromBase);        LocalDate hundredDay2014 = LocalDate.ofYearDay(2014, 100);        System.out.println(&quot;100th day of 2014=&quot;+hundredDay2014);    }}// output Current Date=2014-04-28Specific Date=2014-01-01Current Date in IST=2014-04-29365th day from base date= 1971-01-01100th day of 2014=2014-04-10</code></pre><h2 id="2-3-LocalTime"><a href="#2-3-LocalTime" class="headerlink" title="2.3 LocalTime"></a>2.3 LocalTime</h2><ul><li>Immutable Class </li><li>表示一个可读的时间 (vs Instant 基本不可读)</li><li>默认样式为 hh:mm:ss:zz</li><li>和LocalDate基本一致的用法，可以传入参数生成实例，支持时区</li></ul><pre><code>package com.journaldev.java8.time;import java.time.LocalTime;import java.time.ZoneId;/** * LocalTime Examples * @author pankaj * */public class LocalTimeExample {    public static void main(String[] args) {        //Current Time        LocalTime time = LocalTime.now();        System.out.println(&quot;Current Time=&quot;+time);        //Creating LocalTime by providing input arguments        LocalTime specificTime = LocalTime.of(12,20,25,40);        System.out.println(&quot;Specific Time of Day=&quot;+specificTime);        //Try creating time by providing invalid inputs        //LocalTime invalidTime = LocalTime.of(25,20);        //Exception in thread &quot;main&quot; java.time.DateTimeException:         //Invalid value for HourOfDay (valid values 0 - 23): 25        //Current date in &quot;Asia/Kolkata&quot;, you can get it from ZoneId javadoc        LocalTime timeKolkata = LocalTime.now(ZoneId.of(&quot;Asia/Kolkata&quot;));        System.out.println(&quot;Current Time in IST=&quot;+timeKolkata);        //java.time.zone.ZoneRulesException: Unknown time-zone ID: IST        //LocalTime todayIST = LocalTime.now(ZoneId.of(&quot;IST&quot;));        //Getting date from the base date i.e 01/01/1970        LocalTime specificSecondTime = LocalTime.ofSecondOfDay(10000);        System.out.println(&quot;10000th second time= &quot;+specificSecondTime);    }}// Output Current Time=15:51:45.240Specific Time of Day=12:20:25.000000040Current Time in IST=04:21:45.27610000th second time= 02:46:40</code></pre><h2 id="2-4-LocalDateTime"><a href="#2-4-LocalDateTime" class="headerlink" title="2.4 LocalDateTime"></a>2.4 LocalDateTime</h2><ul><li>Immutable date-time object </li><li>represent both date and time </li><li>default format at yyyy-MM-dd-HH-mm-ss.zzz </li><li>用工厂方法来拿到LocalDate和LocalTime的input 然后来创建LocalDateTime的实例</li></ul><pre><code>package com.journaldev.java8.time;import java.time.LocalDate;import java.time.LocalDateTime;import java.time.LocalTime;import java.time.Month;import java.time.ZoneId;import java.time.ZoneOffset;public class LocalDateTimeExample {    public static void main(String[] args) {        //Current Date        LocalDateTime today = LocalDateTime.now();        System.out.println(&quot;Current DateTime=&quot;+today);        //Current Date using LocalDate and LocalTime        today = LocalDateTime.of(LocalDate.now(), LocalTime.now());        System.out.println(&quot;Current DateTime=&quot;+today);        //Creating LocalDateTime by providing input arguments        LocalDateTime specificDate = LocalDateTime.of(2014, Month.JANUARY, 1, 10, 10, 30);        System.out.println(&quot;Specific Date=&quot;+specificDate);        //Try creating date by providing invalid inputs        //LocalDateTime feb29_2014 = LocalDateTime.of(2014, Month.FEBRUARY, 28, 25,1,1);        //Exception in thread &quot;main&quot; java.time.DateTimeException:         //Invalid value for HourOfDay (valid values 0 - 23): 25        //Current date in &quot;Asia/Kolkata&quot;, you can get it from ZoneId javadoc        LocalDateTime todayKolkata = LocalDateTime.now(ZoneId.of(&quot;Asia/Kolkata&quot;));        System.out.println(&quot;Current Date in IST=&quot;+todayKolkata);        //java.time.zone.ZoneRulesException: Unknown time-zone ID: IST        //LocalDateTime todayIST = LocalDateTime.now(ZoneId.of(&quot;IST&quot;));        //Getting date from the base date i.e 01/01/1970        LocalDateTime dateFromBase = LocalDateTime.ofEpochSecond(10000, 0, ZoneOffset.UTC);        System.out.println(&quot;10000th second time from 01/01/1970= &quot;+dateFromBase);    }}// OutputCurrent DateTime=2014-04-28T16:00:49.455Current DateTime=2014-04-28T16:00:49.493Specific Date=2014-01-01T10:10:30Current Date in IST=2014-04-29T04:30:49.49310000th second time from 01/01/1970= 1970-01-01T02:46:40</code></pre><h2 id="2-5-Instant"><a href="#2-5-Instant" class="headerlink" title="2.5 Instant"></a>2.5 Instant</h2><p>是为了生成机器阅读的时间格式，它会使用unix的时间戳来存储日期和时间</p><pre><code>package com.journaldev.java8.time;import java.time.Duration;import java.time.Instant;public class InstantExample {    public static void main(String[] args) {        //Current timestamp        Instant timestamp = Instant.now();        System.out.println(&quot;Current Timestamp = &quot;+timestamp);        //Instant from timestamp        Instant specificTime = Instant.ofEpochMilli(timestamp.toEpochMilli());        System.out.println(&quot;Specific Time = &quot;+specificTime);        //Duration example        Duration thirtyDay = Duration.ofDays(30);        System.out.println(thirtyDay);    }}// Output Current Timestamp = 2014-04-28T23:20:08.489ZSpecific Time = 2014-04-28T23:20:08.489ZPT720H</code></pre><h2 id="2-6-常用API"><a href="#2-6-常用API" class="headerlink" title="2.6 常用API"></a>2.6 常用API</h2><pre><code>package com.journaldev.java8.time;import java.time.LocalDate;import java.time.LocalTime;import java.time.Period;import java.time.temporal.TemporalAdjusters;public class DateAPIUtilities {    public static void main(String[] args) {        LocalDate today = LocalDate.now();        //得到年份，看是否为闰年        System.out.println(&quot;Year &quot;+today.getYear()+&quot; is Leap Year? &quot;+today.isLeapYear());        //比较两个时间的先后        System.out.println(&quot;Today is before 01/01/2015? &quot;+today.isBefore(LocalDate.of(2015,1,1)));        //从LocalDate创建LocalDateTime        System.out.println(&quot;Current Time=&quot;+today.atTime(LocalTime.now()));        //加减时间的操作        System.out.println(&quot;10 days after today will be &quot;+today.plusDays(10));        System.out.println(&quot;3 weeks after today will be &quot;+today.plusWeeks(3));        System.out.println(&quot;20 months after today will be &quot;+today.plusMonths(20));        System.out.println(&quot;10 days before today will be &quot;+today.minusDays(10));        System.out.println(&quot;3 weeks before today will be &quot;+today.minusWeeks(3));        System.out.println(&quot;20 months before today will be &quot;+today.minusMonths(20));        //时间上的加减        System.out.println(&quot;First date of this month= &quot;+today.with(TemporalAdjusters.firstDayOfMonth()));        LocalDate lastDayOfYear = today.with(TemporalAdjusters.lastDayOfYear());        System.out.println(&quot;Last date of this year= &quot;+lastDayOfYear);        Period period = today.until(lastDayOfYear);        System.out.println(&quot;Period Format= &quot;+period);        System.out.println(&quot;Months remaining in the year= &quot;+period.getMonths());            }}Year 2014 is Leap Year? falseToday is before 01/01/2015? trueCurrent Time=2014-04-28T16:23:53.15410 days after today will be 2014-05-083 weeks after today will be 2014-05-1920 months after today will be 2015-12-2810 days before today will be 2014-04-183 weeks before today will be 2014-04-0720 months before today will be 2012-08-28First date of this month= 2014-04-01Last date of this year= 2014-12-31Period Format= P8M3DMonths remaining in the year= 8</code></pre><h2 id="2-7-时间的Parsing-和-Formatting"><a href="#2-7-时间的Parsing-和-Formatting" class="headerlink" title="2.7 时间的Parsing 和 Formatting"></a>2.7 时间的Parsing 和 Formatting</h2><pre><code>package com.journaldev.java8.time;import java.time.Instant;import java.time.LocalDate;import java.time.LocalDateTime;import java.time.format.DateTimeFormatter;public class DateParseFormatExample {    public static void main(String[] args) {        //Format examples        LocalDate date = LocalDate.now();        //default format        System.out.println(&quot;Default format of LocalDate=&quot;+date);        //使用特定的Formatter        System.out.println(date.format(DateTimeFormatter.ofPattern(&quot;d::MMM::uuuu&quot;)));        System.out.println(date.format(DateTimeFormatter.BASIC_ISO_DATE));        LocalDateTime dateTime = LocalDateTime.now();        //default format        System.out.println(&quot;Default format of LocalDateTime=&quot;+dateTime);        //specific format        System.out.println(dateTime.format(DateTimeFormatter.ofPattern(&quot;d::MMM::uuuu HH::mm::ss&quot;)));        System.out.println(dateTime.format(DateTimeFormatter.BASIC_ISO_DATE));        Instant timestamp = Instant.now();        //default format        System.out.println(&quot;Default format of Instant=&quot;+timestamp);        //Parse examples        LocalDateTime dt = LocalDateTime.parse(&quot;27::Apr::2014 21::39::48&quot;,                DateTimeFormatter.ofPattern(&quot;d::MMM::uuuu HH::mm::ss&quot;));        System.out.println(&quot;Default format after parsing = &quot;+dt);    }}// OutputDefault format of LocalDate=2014-04-2828::Apr::201420140428Default format of LocalDateTime=2014-04-28T16:25:49.34128::Apr::2014 16::25::4920140428Default format of Instant=2014-04-28T23:25:49.342ZDefault format after parsing = 2014-04-27T21:39:48</code></pre><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://www.journaldev.com/2800/java-8-date-localdate-localdatetime-instant" target="_blank" rel="noopener">https://www.journaldev.com/2800/java-8-date-localdate-localdatetime-instant</a> </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-为什么需要新的Date-API&quot;&gt;&lt;a href=&quot;#1-为什么需要新的Date-API&quot; class=&quot;headerlink&quot; title=&quot;1. 为什么需要新的Date API&quot;&gt;&lt;/a&gt;1. 为什么需要新的Date API&lt;/h1&gt;&lt;p&gt;Java8 的一
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法(17)-红黑树</title>
    <link href="https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-17-%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <id>https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-17-%E7%BA%A2%E9%BB%91%E6%A0%91/</id>
    <published>2020-02-11T04:16:00.000Z</published>
    <updated>2020-02-11T04:16:29.377Z</updated>
    
    <content type="html"><![CDATA[<p>首先对于我们前面看到的二叉查找树，在相对理想的情况下，它的时间负责度为O(logn).但是在频繁的动态更新的过程中，可能会出现树的高度远远大于log2(n)的情况，导致各项操作的效率下降.</p><p>在极端情况下，二叉查找树会退化为一个链表，时间复杂度会退化到O(n).为了解决这个复杂度退化的问题，我们需要设计一种平衡二叉查找树</p><h1 id="1-什么是平衡二叉查找树？"><a href="#1-什么是平衡二叉查找树？" class="headerlink" title="1. 什么是平衡二叉查找树？"></a>1. 什么是平衡二叉查找树？</h1><blockquote><p>平衡二叉查找树定义  二叉树中任意一个节点的左右子树的高度相差不能大于1.</p></blockquote><p>平衡二叉查找树的初衷是解决普通二叉查找树在频繁的插入\删除等动态更新的情况下，出现时间复杂度退化的问题</p><p>平衡二叉查找树中平衡的意思就是让整棵树看起来比较对称，不要出现左子树很高，右子树很矮的情况。这样就能让整棵树的高度相对来说低一些。</p><h1 id="2-如何定义一棵红黑树-Red-Black-Tree"><a href="#2-如何定义一棵红黑树-Red-Black-Tree" class="headerlink" title="2. 如何定义一棵红黑树 Red Black Tree"></a>2. 如何定义一棵红黑树 Red Black Tree</h1><p>是一种不严格的平衡二叉查找树。红黑树当中的节点，一类被标记为黑色，一类被标记为红色。</p><ul><li>根节点是黑色的</li><li>每个叶子节点都是黑色的空节点(NIL)，即叶子节点不存储数据</li><li>任何相邻的节点都不能同时为红色，即红色节点是被黑色节点分割开的</li><li>每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点</li></ul><p>二叉查找树的很多操作的性能都跟树的高度成正比，因此为了证明红黑树近似平衡，我们需要分析的问题可以转化为其高度是否能比较稳定的趋近log2(n)</p><p>AVL是高度平衡的二叉树，查找效率非常高，但是每次插入删除都要对应做调整，所以会比较复杂耗时。红黑树只是做到近似平衡，在维护平衡的成本上，要比AVL要低。</p><h1 id="3-如何实现一个红黑树"><a href="#3-如何实现一个红黑树" class="headerlink" title="3. 如何实现一个红黑树"></a>3. 如何实现一个红黑树</h1><p>红黑树的平衡过程就是<strong>根据节点排布的特征来，遇到什么样的节点排布，我们就对应的去进行调整</strong>。 </p><ul><li>重要操作<ul><li>左旋 rotate left<ul><li>将基准点的右子树绕x做逆时针旋转，是的x的右子树成为x的父亲，同时修改相关节点的引用。旋转之后，二叉查找树的特性仍然能够得到满足 </li></ul></li><li>右旋 rotate right <ul><li>将x的左子树绕x顺时针旋转，使得x的左子树成为x的父亲，同时修改相关节点的引用。旋转之后，二叉查找树的属性仍然能够满足 </li></ul></li></ul></li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://www.cnblogs.com/carpenterlee/p/5503882.html" target="_blank" rel="noopener">https://www.cnblogs.com/carpenterlee/p/5503882.html</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先对于我们前面看到的二叉查找树，在相对理想的情况下，它的时间负责度为O(logn).但是在频繁的动态更新的过程中，可能会出现树的高度远远大于log2(n)的情况，导致各项操作的效率下降.&lt;/p&gt;
&lt;p&gt;在极端情况下，二叉查找树会退化为一个链表，时间复杂度会退化到O(n).
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://www.llchen60.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="红黑树" scheme="https://www.llchen60.com/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法(16)-二叉树</title>
    <link href="https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-16-%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-16-%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2020-02-09T18:31:37.000Z</published>
    <updated>2020-02-09T18:32:28.203Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-树"><a href="#1-树" class="headerlink" title="1. 树"></a>1. 树</h1><ul><li>父节点<ul><li>上层的节点 </li></ul></li><li>兄弟节点<ul><li>父节点是同一个节点 </li></ul></li><li>叶节点<ul><li>没有子节点的节点</li></ul></li><li>高度<ul><li>节点到叶子节点的最长路径 </li></ul></li><li>深度<ul><li>根节点到这个节点所经历的边的个数 </li></ul></li><li>层<ul><li>节点的深度 + 1 </li></ul></li></ul><h1 id="2-二叉树"><a href="#2-二叉树" class="headerlink" title="2. 二叉树"></a>2. 二叉树</h1><p>每个节点最多有两个分叉的树，即最多有两个子节点</p><p><img src="https://i.loli.net/2020/02/10/r72vjaPlpfsHmuE.jpg" alt="fig1.jpg"><br>2 显示的是满二叉树，特点是叶子节点都在最底层，出了叶子节点之外，每个节点都有左右两个子节点</p><p>3 叶子节点都在最底下两层，并且出了最后一层，其他的层的节点数量都要达到最大，并且最后一层的节点都是靠左排列的，这种二叉树叫做完全二叉树。</p><h2 id="2-1-如何表示-存储一棵二叉树？"><a href="#2-1-如何表示-存储一棵二叉树？" class="headerlink" title="2.1 如何表示/ 存储一棵二叉树？"></a>2.1 如何表示/ 存储一棵二叉树？</h2><h3 id="2-1-1-基于指针或者引用的二叉链式存储法"><a href="#2-1-1-基于指针或者引用的二叉链式存储法" class="headerlink" title="2.1.1 基于指针或者引用的二叉链式存储法"></a>2.1.1 基于指针或者引用的二叉链式存储法</h3><p><img src="https://i.loli.net/2020/02/10/M1I6FkWJodTq3fX.jpg" alt="fig2.jpg"></p><p>每个节点都有三个字段，其中一个存储数据，另外两个指向左右子节点的指针。因此通过根节点，我们就可以通过左右子节点的指针将整棵树都串起来了。</p><h3 id="2-1-2-基于数组的顺序存储法"><a href="#2-1-2-基于数组的顺序存储法" class="headerlink" title="2.1.2 基于数组的顺序存储法"></a>2.1.2 基于数组的顺序存储法</h3><p><img src="https://i.loli.net/2020/02/10/P62NlH8EbY3LBXv.jpg" alt="fig3.jpg"><br>如果节点X存储在数组中下标为i的位置，下标为2<em>i的位置存储的是左子节点，下标为2</em>i + 1的位置存储的就是右子节点。下标为i/2的位置存储的就是它的父节点了。通过这种方式，我们只要知道根节点存储的位置，就可以通过下标计算，把整棵树都串起来。 不过对于一棵非完全二叉树而言，会浪费比较多的数组存储空间的。</p><h2 id="2-2-二叉树的遍历"><a href="#2-2-二叉树的遍历" class="headerlink" title="2.2 二叉树的遍历"></a>2.2 二叉树的遍历</h2><h3 id="2-2-0-递归公式"><a href="#2-2-0-递归公式" class="headerlink" title="2.2.0 递归公式"></a>2.2.0 递归公式</h3><p><img src="https://i.loli.net/2020/02/10/o1TLXDnalmgBzAQ.jpg" alt="fig4.jpg"></p><p>二叉树的遍历整体就是一个递归的过程</p><p>写递归代码的关键，就是看能不能写出一个递推公式。而递推公式的关键，就是如果要解决问题A，就假设子问题B,C都已经解决，然后再来看如何利用B，C来解决A</p><pre><code>前序遍历的递推公式：preOrder(r) = print r-&gt;preOrder(r-&gt;left)-&gt;preOrder(r-&gt;right)中序遍历的递推公式：inOrder(r) = inOrder(r-&gt;left)-&gt;print r-&gt;inOrder(r-&gt;right)后序遍历的递推公式：postOrder(r) = postOrder(r-&gt;left)-&gt;postOrder(r-&gt;right)-&gt;print r// 前序遍历void preOrder(Node* root) {  if (root == null) return;  print root // 此处为伪代码，表示打印root节点  preOrder(root-&gt;left);  preOrder(root-&gt;right);}// 中序遍历void inOrder(Node* root) {  if (root == null) return;  inOrder(root-&gt;left);  print root // 此处为伪代码，表示打印root节点  inOrder(root-&gt;right);}// 后序遍历void postOrder(Node* root) {  if (root == null) return;  postOrder(root-&gt;left);  postOrder(root-&gt;right);  print root // 此处为伪代码，表示打印root节点}</code></pre><h3 id="2-2-1-前序遍历"><a href="#2-2-1-前序遍历" class="headerlink" title="2.2.1 前序遍历"></a>2.2.1 前序遍历</h3><p>对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。</p><h3 id="2-2-2-中序遍历"><a href="#2-2-2-中序遍历" class="headerlink" title="2.2.2 中序遍历"></a>2.2.2 中序遍历</h3><p>对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树</p><h3 id="2-2-3-后序遍历"><a href="#2-2-3-后序遍历" class="headerlink" title="2.2.3 后序遍历"></a>2.2.3 后序遍历</h3><p>对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身</p><h1 id="3-二叉查找树"><a href="#3-二叉查找树" class="headerlink" title="3. 二叉查找树"></a>3. 二叉查找树</h1><p>支持动态数据集合的快速插入、删除、查找操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-树&quot;&gt;&lt;a href=&quot;#1-树&quot; class=&quot;headerlink&quot; title=&quot;1. 树&quot;&gt;&lt;/a&gt;1. 树&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;父节点&lt;ul&gt;
&lt;li&gt;上层的节点 &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;兄弟节点&lt;ul&gt;
&lt;li&gt;父节点是同
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://www.llchen60.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://www.llchen60.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法(15)-哈希算法</title>
    <link href="https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-15-%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/"/>
    <id>https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-15-%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/</id>
    <published>2020-02-09T18:30:23.000Z</published>
    <updated>2020-02-09T18:30:43.320Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-什么是哈希算法"><a href="#1-什么是哈希算法" class="headerlink" title="1. 什么是哈希算法"></a>1. 什么是哈希算法</h1><blockquote><p>将任意长度的二进制串映射为固定长度的二进制串，这个映射的规则就是哈希算法，而通过原始数据映射之后得到的二进制串就是哈希值</p></blockquote><ul><li>哈希算法的要求<ul><li>从哈希值无法反向推导出原始数据</li><li>对输入数据非常敏感，哪怕原始数据只修改一个bit，最后得到的哈希值也会大不相同</li><li>散列冲突的概率很小，对于不同的原始数据，哈希值相同的概率非常小</li><li>哈希算法的效率要足够高，针对较长文本，也能快速计算出哈希值</li></ul></li></ul><h1 id="2-哈希算法的应用"><a href="#2-哈希算法的应用" class="headerlink" title="2. 哈希算法的应用"></a>2. 哈希算法的应用</h1><h2 id="2-1-安全加密"><a href="#2-1-安全加密" class="headerlink" title="2.1 安全加密"></a>2.1 安全加密</h2><ul><li>常用de加密算法<ul><li>MD5<ul><li>MD5 Message-Digest Algorithm </li><li>MD5信息摘要算法</li></ul></li><li>SHA <ul><li>Secure Hash Algorithm 安全散列算法</li></ul></li><li>DES <ul><li>Data Encryption Standard 数据加密标准</li></ul></li><li>AES <ul><li>Advanced Encryption Standard 高级加密标准</li></ul></li></ul></li></ul><h2 id="2-2-唯一标识"><a href="#2-2-唯一标识" class="headerlink" title="2.2 唯一标识"></a>2.2 唯一标识</h2><p>图片的标识，从图片的二进制串码的前中后各取出100字节，通过哈希算法得到一个哈希字符串，用它作为图片的唯一标识。然后通过这个唯一标识来判定图片是否在图库当中，通过这种方式来减少工作量。</p><h2 id="2-3-数据校验"><a href="#2-3-数据校验" class="headerlink" title="2.3 数据校验"></a>2.3 数据校验</h2><p>BT协议的数据校验，对每个文件块取哈希值，保存在种子文件当中。当文件块下载完成之后，我们通过相同的哈希算法，对下载好的文件块逐一求哈希值，然后跟种子文件中保存的哈希值进行比对。如果不同，就说明这个文件块不完整或者被篡改了，需要再重新从其他宿主机器上下载这个文件块。</p><h2 id="2-4-散列函数"><a href="#2-4-散列函数" class="headerlink" title="2.4 散列函数"></a>2.4 散列函数</h2><p>哈希表的散列函数，关注的是在做完哈希以后，是否能够平均的分布。一组数据能否均匀散列在各个槽中。 </p><p>另外一个点是其执行速度，散列函数对执行速度的要求会比较高一些。</p><h2 id="2-5-负载均衡"><a href="#2-5-负载均衡" class="headerlink" title="2.5 负载均衡"></a>2.5 负载均衡</h2><p>分布式系统当中需要解决的问题</p><ul><li>负载均衡的算法<ul><li>轮询</li><li>随机</li><li>加权轮询</li></ul></li></ul><p>但是我们需要实现一个会话粘滞的负载均衡算法(session sticky)。即我们需要在一个客户端上，在一次会话上的所有请求都路由到同一个服务器上。</p><p>通过哈希算法，对客户端IP地址或者会话的ID计算哈希值，将取得的哈希值与服务器列表的大小进行取模运算，最终得到的值就是应该被路由到的服务器的编号。</p><h2 id="2-6-数据分片"><a href="#2-6-数据分片" class="headerlink" title="2.6 数据分片"></a>2.6 数据分片</h2><h3 id="2-6-1-如何统计关键词搜索的次数"><a href="#2-6-1-如何统计关键词搜索的次数" class="headerlink" title="2.6.1 如何统计关键词搜索的次数"></a>2.6.1 如何统计关键词搜索的次数</h3><p>假设我们有1T的日志文件，里面记录了用户的关键词，我们想快速统计出来每个关键词被搜索的次数，该怎么做呢？ </p><ol><li>数据量太大的问题</li><li>处理时间太长的问题</li></ol><p>对数据进行分片，然后多台机器进行处理。用哈希算法，将哈希值相同的搜索关键词放到同一台机器上。然后最后做汇总</p><h3 id="2-6-2-如何快速判断图片是否在图库当中"><a href="#2-6-2-如何快速判断图片是否在图库当中" class="headerlink" title="2.6.2 如何快速判断图片是否在图库当中"></a>2.6.2 如何快速判断图片是否在图库当中</h3><p>为每个图片取唯一标识，然后构建散列表，但是当图片量很大的时候，在单台机器上构建散列表是行不通的。</p><p>因为在存储的时候，我们还是需要根据哈希算法取模来进行存储，然后在进行判断的时候，也是用同样的哈希算法，然后与机器个数n求余取模。然后根据得到的值到对应的机器上去进行查找。</p><h2 id="2-7-分布式存储"><a href="#2-7-分布式存储" class="headerlink" title="2.7 分布式存储"></a>2.7 分布式存储</h2><p>分布式存储需要解决的问题是，当我们已经在各个host上按照哈希算法保存了数据以后，再增减host的时候，我们不希望还需要对原先的host里面的数据做迁移。如果说缓存当中的数据会一下子全都失效的话，那么所有数据请求都要从数据库走，直接就压垮数据库了。</p><p>因此在分布式存储当中，我们需要采用<strong><em>一致性哈希算法</em></strong></p><p>假设我们有 k 个机器，数据的哈希值的范围是[0, MAX]。我们将整个范围划分成 m 个小区间（m 远大于 k），每个机器负责 m/k 个小区间。当有新机器加入的时候，我们就将某几个小区间的数据，从原来的机器中搬移到新的机器中。这样，既不用全部重新哈希、搬移数据，也保持了各个机器上数据数量的均衡。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-什么是哈希算法&quot;&gt;&lt;a href=&quot;#1-什么是哈希算法&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是哈希算法&quot;&gt;&lt;/a&gt;1. 什么是哈希算法&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;将任意长度的二进制串映射为固定长度的二进制串，这个映射
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://www.llchen60.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="哈希算法" scheme="https://www.llchen60.com/tags/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法(14)-散列表</title>
    <link href="https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-14-%E6%95%A3%E5%88%97%E8%A1%A8/"/>
    <id>https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-14-%E6%95%A3%E5%88%97%E8%A1%A8/</id>
    <published>2020-02-09T18:21:54.000Z</published>
    <updated>2020-02-09T18:24:07.894Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Intro"><a href="#1-Intro" class="headerlink" title="1. Intro"></a>1. Intro</h1><p>散列表 - Hash Table, 又被称为哈希表或者Hash表。散列表用的是数组支持按照下标来随机访问数据的特性，因此散列表实际上是数组的一种扩展，由数组演化而来。</p><p>散列的思想就是对于key值，通过hash function，对应到table上来进行存储</p><p><img src="https://i.loli.net/2020/02/10/pnWdbkoVjUE7aTw.jpg" alt="fig1.jpg"></p><h1 id="2-散列函数"><a href="#2-散列函数" class="headerlink" title="2. 散列函数"></a>2. 散列函数</h1><p>散列函数就是实现输入到存储的对应的函数，因为最终是要存储到数组当中，故而其基本要求有：</p><ol><li>散列函数计算得到的散列值是一个非负整数</li><li>如果Key1 = Key2,那么hash(key1) == hash(key2)</li><li>如果key1 != key2, 那么hash(key1) != hash(key2)</li></ol><p>条件3 即如何应对散列冲突的问题，首先本身是必须的，而且客观是存在散列冲突的情况的，针对于散列冲突，我们一般会使用开放寻址法和链表法。</p><h1 id="3-如何解决散列冲突"><a href="#3-如何解决散列冲突" class="headerlink" title="3. 如何解决散列冲突"></a>3. 如何解决散列冲突</h1><h2 id="3-1-开放寻址法"><a href="#3-1-开放寻址法" class="headerlink" title="3.1 开放寻址法"></a>3.1 开放寻址法</h2><ul><li>核心思想<ul><li>出现了散列冲突，就重新探测一个空闲位置，将其插入</li></ul></li><li>探测方法<ul><li>线性探测</li><li>二次探测<ul><li>探测步长为二次方的增长 </li></ul></li><li>双重散列<ul><li>使用第一个散列函数进行尝试</li><li>如果计算得到的存储位置已经被占用，再用第二个散列函数，依次类推直到找到空闲的存储位置</li></ul></li></ul></li><li>装载因子<ul><li>引入装在引资的概念来表示空位的多少</li><li><code>装载因子 = 填入表中的元素个数/散列表的长度</code></li></ul></li></ul><h2 id="3-2-链表法"><a href="#3-2-链表法" class="headerlink" title="3.2 链表法"></a>3.2 链表法</h2><p><img src="https://i.loli.net/2020/02/10/VAUezcR2phPlYjT.jpg" alt="fig2.jpg"></p><p>链表法是一种更加常用的散列冲突解决办法，相比开放寻址法，它要简单很多。我们来看这个图，在散列表中，每个“桶（bucket）”或者“槽（slot）”会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中。</p><h1 id="4-工程上使用的散列表"><a href="#4-工程上使用的散列表" class="headerlink" title="4. 工程上使用的散列表"></a>4. 工程上使用的散列表</h1><p>首先我们需要思考下实际应用场景当中的散列表，虽然我们说散列表的查询效率是O(1), 实质上他的真实数据时和散列函数，装载因子，散列冲突都有关系的。如果散列函数设计的不好，或者装载因子过高，都可能导致散列冲突发生的概率升高，从而导致查询的效率下降。</p><p>因此对于在工程上使用的散列表，首先要考虑的就是需要能够应对各种异常情况，来避免散列冲突的情况下散列表性能的急剧下降，并且需要能够抵抗散列碰撞攻击。</p><h2 id="4-1-如何设计散列函数"><a href="#4-1-如何设计散列函数" class="headerlink" title="4.1 如何设计散列函数"></a>4.1 如何设计散列函数</h2><ul><li>需求<ul><li>散列函数的设计不能太复杂 <ul><li>会消耗很多计算时间</li><li>即会影响到散列表的性能</li></ul></li><li>散列函数生成的值需要尽可能随机并且均匀分布</li></ul></li><li>如何解决装载因子过大的问题<ul><li>针对散列表，当装载因子过大的时候，我们也可以进行动态扩容，重新申请一个更大的散列表，将数据搬移到这个新的散列表当中。</li><li>同时也有装载因子太小的情况下，我们可以做动态缩容的工作</li></ul></li><li>如何避免低效扩容<ul><li>所谓低效的扩容指的是如果我们在装载因子超过阈值的时候一下子进行扩容，即数据的搬运和最终的新数据的插入，那针对这一个数据，其时间复杂度变成了O(n).</li><li>为了解决这个问题，我们在需要进行扩容的时候，将扩容的操作穿插在插入操作的过程当中，分批次来完成。当装载因子触达阈值的时候，只申请新空间，但是没有将老的数据搬移到新的散列表当中。</li><li>当有新数据插入的时候，就将新数据放到新的散列表当中，并且从老的散列表当中拿一个数据放到新的散列表当中</li><li>而查询操作，为了兼顾，我们会先从新的散列表当中查找，如果没有找到，再去老的散列表当中查找</li></ul></li></ul><h2 id="4-2-如何解决冲突？"><a href="#4-2-如何解决冲突？" class="headerlink" title="4.2 如何解决冲突？"></a>4.2 如何解决冲突？</h2><h3 id="4-2-1-开放寻址法"><a href="#4-2-1-开放寻址法" class="headerlink" title="4.2.1 开放寻址法"></a>4.2.1 开放寻址法</h3><ul><li>优势<ul><li>数据都存储在数组当中，可以有效利用CPU缓存加快查询速度</li><li>序列化比较简单</li></ul></li><li>缺陷<ul><li>删除数据比较麻烦，需要特殊标记已经删除的数据</li><li>冲突代价高，导致装载因子的上限不能太大</li></ul></li></ul><blockquote><p>当数据量比较小，装载因子小的时候，适合使用开放寻址法。</p></blockquote><h3 id="4-2-2-链表法"><a href="#4-2-2-链表法" class="headerlink" title="4.2.2 链表法"></a>4.2.2 链表法</h3><ul><li>优势<ul><li>对内存的利用率相对比较高，因为链表结点可以在需要的时候再创建，不需要提前申请好</li><li>可以允许很高的装载因子</li></ul></li><li>劣势<ul><li>因为要存储指针，对于小的对象的存储，是更加耗内存的</li><li>因为结点零散分布在内存当中，不是连续的，所以对CPU缓存不友好，对执行效率会造成一定的影响</li></ul></li></ul><h2 id="4-3-Java-HashMap举例"><a href="#4-3-Java-HashMap举例" class="headerlink" title="4.3 Java HashMap举例"></a>4.3 Java HashMap举例</h2><ul><li>初始大小 - 16<ul><li>如果大概知道数据量的大小，可以修改默认，来减少动态扩容的次数</li></ul></li><li>装载因子和动态扩容<ul><li>默认 load factor 0.75 </li><li>每次扩容大小变为两倍</li></ul></li><li>散列冲突解决方法<ul><li>采用链表法</li><li>1.8以后当链表长度超过8以后，链表就会自动转化为红黑树</li></ul></li><li>散列函数</li></ul><pre><code>int hash(Object key) {    int h = key.hashCode()；    return (h ^ (h &gt;&gt;&gt; 16)) &amp; (capicity -1); //capicity表示散列表的大小} </code></pre><p><code>&amp;(capacity - 1)</code> means <code>% capacity</code></p><p>因为hashcode本身是个32位的整型值，获得其hash值以后，将高16位移到低16位，就相当于拿到了高16位和低16位的feature。用自己的高半区和低半区做异或，为的是加大低位的随机性。这样子哪怕是高位的变化也可以反映到低位当中，保证了最终进bin的随机性</p><h1 id="5-散列表实际应用"><a href="#5-散列表实际应用" class="headerlink" title="5. 散列表实际应用"></a>5. 散列表实际应用</h1><p>散列表和链表经常是共同使用的,这一部分会walk through一些常用的场景，看看是如何来共同使用的。</p><h2 id="5-1-LRU缓存淘汰算法"><a href="#5-1-LRU缓存淘汰算法" class="headerlink" title="5.1 LRU缓存淘汰算法"></a>5.1 LRU缓存淘汰算法</h2><p>最基础的LRU实现，我们可以通过链表来做.维护一个按照访问时间从大到小有序排列的链表结构，因为缓存大小有限，当缓存空间不够，需要淘汰一个数据的时候，我们就直接将链表头部的结点删除。</p><p>我们可以选择使用散列表和双向链表一起来实现LRU cache。要实现的操作有：</p><ul><li>往缓存中加入数据</li><li>从缓存中删除数据</li><li>在缓存中查找数据</li></ul><p><img src="https://i.loli.net/2020/02/10/LIB2nkbZYudrq37.jpg" alt="fig3.jpg"></p><p>如图所示，我们相当于在维护两条链表，一条是在哈希表的每个entry上的链，在这上面的链是为了解决哈希冲突的；另外一个点，我们在使用的是维护LRU cache的链表。</p><p>链表当中的每个结点保存了：</p><ul><li>prev</li><li>next</li><li>data</li><li>hnext<ul><li>散列表上碰撞问题的解决的 </li></ul></li></ul><h2 id="5-2-Java-LinkedHashMap"><a href="#5-2-Java-LinkedHashMap" class="headerlink" title="5.2 Java LinkedHashMap"></a>5.2 Java LinkedHashMap</h2><p>LinkedHashMap能够实现按照数据的插入顺序来进行打印，是因为他也是通过散列表和链表组合在一起的方式实现的。它支持按照插入顺序遍历数据，还支持按照访问顺序来遍历数据</p><pre><code>// 10是初始大小，0.75是装载因子，true是表示按照访问时间排序HashMap&lt;Integer, Integer&gt; m = new LinkedHashMap&lt;&gt;(10, 0.75f, true);m.put(3, 11);m.put(1, 12);m.put(5, 23);m.put(2, 22);m.put(3, 26);m.get(5);for (Map.Entry e : m.entrySet()) {  System.out.println(e.getKey());}// print out: 1, 2, 3, 5</code></pre><p><img src="https://i.loli.net/2020/02/10/wxy1tumrZO3DXQz.jpg" alt="fig4.jpg"></p><p><img src="https://i.loli.net/2020/02/10/9phoBuRSI5gsJC4.jpg" alt="fig5.jpg"></p><p><img src="https://i.loli.net/2020/02/10/3KGVI15LDp4PSAZ.jpg" alt="fig6.jpg"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Intro&quot;&gt;&lt;a href=&quot;#1-Intro&quot; class=&quot;headerlink&quot; title=&quot;1. Intro&quot;&gt;&lt;/a&gt;1. Intro&lt;/h1&gt;&lt;p&gt;散列表 - Hash Table, 又被称为哈希表或者Hash表。散列表用的是数组支持按照下标来
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://www.llchen60.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="散列表" scheme="https://www.llchen60.com/tags/%E6%95%A3%E5%88%97%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法(13)-跳表</title>
    <link href="https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-13-%E8%B7%B3%E8%A1%A8/"/>
    <id>https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-13-%E8%B7%B3%E8%A1%A8/</id>
    <published>2020-02-09T18:11:25.000Z</published>
    <updated>2020-02-09T18:12:09.716Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h1><ul><li>跳表<ul><li>动态数据结构</li><li>可以支持快速的插入，删除，查找操作</li><li>写起来也不会很复杂</li></ul></li></ul><p>Redis当中的有序集合就是用跳表来实现的。</p><h1 id="2-如何理解跳表"><a href="#2-如何理解跳表" class="headerlink" title="2. 如何理解跳表"></a>2. 如何理解跳表</h1><p>对于一个单链表来说，即便链表当中存储的数据是有序的，如果我们想要从中查找某个数据，也只能从头到尾遍历链表，这样查找效率就会非常低，时间复杂度比较高，O(n)</p><p>为了解决这个问题，我们可以对链表建立一级索引，每几个结点就提取一个结点到上一级当中，抽出来的那一级我们就可以将其叫做索引或者索引层了。</p><p>通过增加索引的层级，来加快寻找节点的速度，这就是跳表 – 链表加上多级索引的结构</p><ul><li>时间复杂度非常理想 O(logn)</li><li>但是相对来说会更需要内存一些  空间复杂度为O(n)</li></ul><h1 id="3-高效的动态插入和删除操作"><a href="#3-高效的动态插入和删除操作" class="headerlink" title="3. 高效的动态插入和删除操作"></a>3. 高效的动态插入和删除操作</h1><p>其动态的插入和删除操作的时间复杂度为O(logn)</p><p><img src="https://i.loli.net/2020/02/10/f4vdSyzCEs2KWFY.jpg" alt="fig1.jpg"></p><p>删除操作，还是需要拿到删除节点的前驱节点，然后通过指针操作完成删除。</p><h2 id="4-跳表索引动态更新"><a href="#4-跳表索引动态更新" class="headerlink" title="4. 跳表索引动态更新"></a>4. 跳表索引动态更新</h2><p><img src="https://i.loli.net/2020/02/10/J5QxpXFgAeTCa2j.jpg" alt="fig2.jpg"></p><p>跳表是需要不断更新的，因为当我们不断向跳表里面插入数据的时候，如果我们不更新索引，就有可能出现两个索引节点之间数据非常多的情况。极端情况下，跳表就会退化成单链表。</p><ul><li>我们需要某种方式来维护索引与原始链表大小之间的平衡<ul><li>跳表是通过随机函数来维护平衡性的</li><li>当我们往跳表里面插入数据的时候，可以选择同时将这个数据插入到部分索引层当中。</li><li>根据随机函数来决定这个结点插入到哪几级索引当中。</li></ul></li></ul><p><img src="https://i.loli.net/2020/02/10/64FQnKPZ8uWlTCb.jpg" alt="fig3.jpg"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-概念&quot;&gt;&lt;a href=&quot;#1-概念&quot; class=&quot;headerlink&quot; title=&quot;1. 概念&quot;&gt;&lt;/a&gt;1. 概念&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;跳表&lt;ul&gt;
&lt;li&gt;动态数据结构&lt;/li&gt;
&lt;li&gt;可以支持快速的插入，删除，查找操作&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://www.llchen60.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="跳表" scheme="https://www.llchen60.com/tags/%E8%B7%B3%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法(12)-二分查找</title>
    <link href="https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-12-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <id>https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-12-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</id>
    <published>2020-02-09T18:07:07.000Z</published>
    <updated>2020-02-09T18:07:27.910Z</updated>
    
    <content type="html"><![CDATA[<p>二分查找是一种针对于有序数据集合的查找算法，也叫折半查找算法。类似分治的思想，每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为0. 查找速度为O(logn)</p><p>思考题：1000万个整数数据，每个数据8字节，</p><h1 id="1-二分查找的基本实现"><a href="#1-二分查找的基本实现" class="headerlink" title="1. 二分查找的基本实现"></a>1. 二分查找的基本实现</h1><pre><code>public int bsearch(int[] a, int n, int value) {// 定基准点  int low = 0;  int high = n - 1;// 停止条件  while (low &lt;= high) {    // 定二分点    int mid = (low + high) / 2;    if (a[mid] == value) {      return mid;    } else if (a[mid] &lt; value) {     // 保证是活循环..       low = mid + 1;    } else {      high = mid - 1;    }  }  return -1;}// 二分查找的递归实现public int bsearch(int[] a, int n, int val) {  return bsearchInternally(a, 0, n - 1, val);}private int bsearchInternally(int[] a, int low, int high, int value) {  if (low &gt; high) return -1;  int mid =  low + ((high - low) &gt;&gt; 1);  if (a[mid] == value) {    return mid;  } else if (a[mid] &lt; value) {    return bsearchInternally(a, mid+1, high, value);  } else {    return bsearchInternally(a, low, mid-1, value);  }}</code></pre><ul><li>循环退出条件<ul><li>low &lt;= high </li></ul></li><li>mid取值<ul><li>mid = low + (high - low)/2</li><li>因为如果值太大的话，会溢出的</li></ul></li><li>low high的更新<ul><li>low = mid + 1</li><li>high = mid - 1 </li></ul></li></ul><h1 id="2-二分查找的应用场景局限性"><a href="#2-二分查找的应用场景局限性" class="headerlink" title="2. 二分查找的应用场景局限性"></a>2. 二分查找的应用场景局限性</h1><ul><li>二分查找以来的是顺序表结构  – 数组<ul><li>因为二分查找需要按照下标来随机访问元素</li></ul></li><li>针对的是有序数据 – 静态数据集<ul><li>更适用在插入，删除不频繁，一次排序多次查找的场景当中</li><li>针对动态变化的数据集合，二分查找就不再适用了</li></ul></li><li>数据量太小不需要适用二分查找</li><li>如果数据之间的比较非常耗时，我们需要尽力减少比较的次数，那么二分查找就是很好的方式了</li></ul><h1 id="3-二分查找的实际应用与变体"><a href="#3-二分查找的实际应用与变体" class="headerlink" title="3. 二分查找的实际应用与变体"></a>3. 二分查找的实际应用与变体</h1><h2 id="3-1-查找第一个值等于给定值的元素"><a href="#3-1-查找第一个值等于给定值的元素" class="headerlink" title="3.1 查找第一个值等于给定值的元素"></a>3.1 查找第一个值等于给定值的元素</h2><pre><code>public int bsearch(int[] a, int n, int value) {  int low = 0;  int high = n - 1;  while (low &lt;= high) {    int mid =  low + ((high - low) &gt;&gt; 1);    if (a[mid] &gt; value) {      high = mid - 1;    } else if (a[mid] &lt; value) {      low = mid + 1;    } else {      // 注意这里的判断，中止条件时mid为0 或者左一个的值和现在的值不相等       if ((mid == 0) || (a[mid - 1] != value)) return mid;      else high = mid - 1;    }  }  return -1;}</code></pre><ul><li>写二分相关的算法要注意的点有<ul><li>终止条件</li><li>区间上下界的更新方法</li><li>返回值的选择</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;二分查找是一种针对于有序数据集合的查找算法，也叫折半查找算法。类似分治的思想，每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为0. 查找速度为O(logn)&lt;/p&gt;
&lt;p&gt;思考题：1000万个整数数据，每个数据8字节，&lt;
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://www.llchen60.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="二分查找" scheme="https://www.llchen60.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法(11)-应用场景下的排序函数</title>
    <link href="https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-11-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E6%8E%92%E5%BA%8F%E5%87%BD%E6%95%B0/"/>
    <id>https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-11-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E6%8E%92%E5%BA%8F%E5%87%BD%E6%95%B0/</id>
    <published>2020-02-09T18:00:04.000Z</published>
    <updated>2020-02-09T18:00:58.516Z</updated>
    
    <content type="html"><![CDATA[<p>在日常开发当中，无论我们使用的语言是什么，他们几乎都会提供排序算法，本篇博文将尝试着对其进行分析，看看如何实现一个通用的，高性能的排序算法。</p><p>首先看看我们的现有排序算法库，看看我们的选择空间在哪里： </p><p><img src="https://i.loli.net/2020/02/10/2ga9UPTNkOcb8wr.jpg" alt="fig1.jpg"></p><p>如果对于小规模数据排序，可以选择O(n^2); 但是对于大规模的数据，时间复杂度为O(nlogn)的算法会高效很多。因此为了兼顾任意规模数据的排序，一般都会首选时间复杂度为O(nlogn)的排序算法来实现排序函数。</p><p>一般来说会选用堆排序或者快速排序来做。</p><p>因为在实际情况下内存的占用情况是非常关键的参数了，所以我们需要看待选算法的空间复杂度，最好是原地的，即不占用更多的空间。像归并排序，时间复杂度很合适但是空间复杂度为O(n)，那就完全不是一个好选择了</p><p>快速排序想要优化的话，主要的点在于要选准分区点，好的分区点是希望其两个分区数据的数量是差不多的才可以。我们可以随机取值，也可以多取几个随机点，然后求平均。</p><p>还有一点需要注意的是在实际情况当中, O(n^2)有可能会比O(nlogn)要快的，因为小规模数据集的时候首先常量就不能忽略掉了。在这种情况下，可能插入排序反而会更快。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在日常开发当中，无论我们使用的语言是什么，他们几乎都会提供排序算法，本篇博文将尝试着对其进行分析，看看如何实现一个通用的，高性能的排序算法。&lt;/p&gt;
&lt;p&gt;首先看看我们的现有排序算法库，看看我们的选择空间在哪里： &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.lo
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://www.llchen60.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序" scheme="https://www.llchen60.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法(10)-排序(桶排序 计数排序 基数排序)</title>
    <link href="https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-10-%E6%8E%92%E5%BA%8F-%E6%A1%B6%E6%8E%92%E5%BA%8F-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    <id>https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-10-%E6%8E%92%E5%BA%8F-%E6%A1%B6%E6%8E%92%E5%BA%8F-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/</id>
    <published>2020-02-09T17:55:16.000Z</published>
    <updated>2020-02-09T17:55:34.808Z</updated>
    
    <content type="html"><![CDATA[<p>上述三种排序方法的时间复杂度均为线性，因此将其称为线性排序(Linear sort).之所以能做先线性的时间复杂度，是因为他们都不是基于比较的排序算法，并不涉及到元素之间的比较操作。</p><h1 id="1-桶排序-Bucket-Sort"><a href="#1-桶排序-Bucket-Sort" class="headerlink" title="1. 桶排序 Bucket Sort"></a>1. 桶排序 Bucket Sort</h1><ul><li>核心思想<ul><li>将排序的数据分到几个有序的桶当中，每个桶的数据再单独进行排序。桶内排完序之后，再将每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。</li></ul></li><li>分析<ul><li>如果要排序的数据为 n个，将其均匀分到m个桶当中，每个桶就有 k=n/m个元素。每个桶内部使用快排，时间复杂度为O(k*logk)</li><li>m个桶的时间复杂度就为O(n*log(n/m)) </li><li>当m的数量非常接近n的时候，那么log(n/m)就是一个非常小的常量，这时候桶排序的时间复杂度就接近O(n)了</li></ul></li><li>优劣势<ul><li>对数据本身要求比较苛刻</li><li>需要足够均匀，否则桶内排序就不是常量级的复杂度了</li></ul></li><li>桶排序  适合在外部排序当中<ul><li>指数据存储在外部磁盘当中，数据量比较大，内存有限，无法将数据全部加载到内存当中 </li><li>顺序进行划分，挨个顺次放到内存当中</li></ul></li></ul><h1 id="2-计数排序-Counting-Sort"><a href="#2-计数排序-Counting-Sort" class="headerlink" title="2. 计数排序 Counting Sort"></a>2. 计数排序 Counting Sort</h1><p>类似于桶排序，但是每个桶里面存储的只是个数</p><pre><code>// 计数排序，a是数组，n是数组大小。假设数组中存储的都是非负整数。public void countingSort(int[] a, int n) {  if (n &lt;= 1) return;  // 查找数组中数据的范围  int max = a[0];  for (int i = 1; i &lt; n; ++i) {    if (max &lt; a[i]) {      max = a[i];    }  }  int[] c = new int[max + 1]; // 申请一个计数数组c，下标大小[0,max]  for (int i = 0; i &lt;= max; ++i) {    c[i] = 0;  }  // 计算每个元素的个数，放入c中  for (int i = 0; i &lt; n; ++i) {    c[a[i]]++;  }  // 依次累加  for (int i = 1; i &lt;= max; ++i) {    c[i] = c[i-1] + c[i];  }  // 临时数组r，存储排序之后的结果  int[] r = new int[n];  // 计算排序的关键步骤，有点难理解  for (int i = n - 1; i &gt;= 0; --i) {    int index = c[a[i]]-1;    r[index] = a[i];    c[a[i]]--;  }  // 将结果拷贝给a数组  for (int i = 0; i &lt; n; ++i) {    a[i] = r[i];  }}</code></pre><h1 id="3-基数排序-Radix-Sort"><a href="#3-基数排序-Radix-Sort" class="headerlink" title="3. 基数排序 Radix Sort"></a>3. 基数排序 Radix Sort</h1><p>排10万个手机号码，从小到大来排序？ </p><p>按照位来排，需要选用稳定性的算法来做。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上述三种排序方法的时间复杂度均为线性，因此将其称为线性排序(Linear sort).之所以能做先线性的时间复杂度，是因为他们都不是基于比较的排序算法，并不涉及到元素之间的比较操作。&lt;/p&gt;
&lt;h1 id=&quot;1-桶排序-Bucket-Sort&quot;&gt;&lt;a href=&quot;#1-桶排
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://www.llchen60.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序" scheme="https://www.llchen60.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法(9)-排序(归并 快排)</title>
    <link href="https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-9-%E6%8E%92%E5%BA%8F-%E5%BD%92%E5%B9%B6-%E5%BF%AB%E6%8E%92/"/>
    <id>https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-9-%E6%8E%92%E5%BA%8F-%E5%BD%92%E5%B9%B6-%E5%BF%AB%E6%8E%92/</id>
    <published>2020-02-09T17:51:41.000Z</published>
    <updated>2020-02-09T17:55:54.841Z</updated>
    
    <content type="html"><![CDATA[<p>这节主要讲归并排序和快速排序，二者其实都用了分治的思想，可以借鉴这个思想，来解决诸如“如何在O(n)的时间复杂度内查找一个无序数组中的第k大元素”这样的问题。</p><h1 id="1-归并排序"><a href="#1-归并排序" class="headerlink" title="1. 归并排序"></a>1. 归并排序</h1><p><img src="https://i.loli.net/2020/02/10/fVpOLyXAhjn2cKW.jpg" alt="fig1.jpg"></p><ul><li><p>归并排序</p><ul><li>分治思想</li><li>分治是一种解决问题的处理思想，递归是一种编程技巧</li><li>和递归的三要素很类似，先分析得出递推公式，然后找到终止条件，再将递推公式翻译成递归代码。</li></ul></li><li><p>注意是分成了分开和合并两个过程的，在合并的过程当中，需要遍历两个有序子集，相互比较大小，然后放置在另外一个空间当中</p></li></ul><pre><code>递推公式：merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1…r))终止条件：p &gt;= r 不用再继续分解// 归并排序算法, A 是数组，n 表示数组大小merge_sort(A, n) {  merge_sort_c(A, 0, n-1)}// 递归调用函数merge_sort_c(A, p, r) {  // 递归终止条件  if p &gt;= r  then return  // 取 p 到 r 之间的中间位置 q  q = (p+r) / 2  // 分治递归  merge_sort_c(A, p, q)  merge_sort_c(A, q+1, r)  // 将 A[p...q] 和 A[q+1...r] 合并为 A[p...r]  merge(A[p...r], A[p...q], A[q+1...r])}</code></pre><ul><li>稳定排序</li><li>时间复杂度为O(nlog(n))</li><li>需要借助额外空间，不是原地排序算法  空间复杂度 O(n) 每次搞完就会直接释放掉了</li></ul><h1 id="2-快速排序"><a href="#2-快速排序" class="headerlink" title="2. 快速排序"></a>2. 快速排序</h1><p><img src="https://i.loli.net/2020/02/10/J6wH1nKPtv9qIAm.jpg" alt="fig2.jpg"></p><ul><li>快排的思想<ul><li>如果要排序数组中下标从p到r之间的一组数据，我们选择p到r之间的任意一个数据作为pivot(分区点) </li><li>我们遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间。经过这一步骤之后，数组 p 到 r 之间的数据就被分成了三个部分，前面 p 到 q-1 之间都是小于 pivot 的，中间是 pivot，后面的 q+1 到 r 之间是大于 pivot 的。</li><li>快速排序是一种不稳定的排序方法，因为要实现swap</li></ul></li></ul><pre><code>递推公式：quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1, r)终止条件：p &gt;= r// 快速排序，A 是数组，n 表示数组的大小quick_sort(A, n) {  quick_sort_c(A, 0, n-1)}// 快速排序递归函数，p,r 为下标quick_sort_c(A, p, r) {  if p &gt;= r then return  q = partition(A, p, r) // 获取分区点  quick_sort_c(A, p, q-1)  quick_sort_c(A, q+1, r)}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这节主要讲归并排序和快速排序，二者其实都用了分治的思想，可以借鉴这个思想，来解决诸如“如何在O(n)的时间复杂度内查找一个无序数组中的第k大元素”这样的问题。&lt;/p&gt;
&lt;h1 id=&quot;1-归并排序&quot;&gt;&lt;a href=&quot;#1-归并排序&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://www.llchen60.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序" scheme="https://www.llchen60.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法(8)-排序(冒泡 插入 选择)</title>
    <link href="https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-8-%E6%8E%92%E5%BA%8F-%E5%86%92%E6%B3%A1-%E6%8F%92%E5%85%A5-%E9%80%89%E6%8B%A9/"/>
    <id>https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-8-%E6%8E%92%E5%BA%8F-%E5%86%92%E6%B3%A1-%E6%8F%92%E5%85%A5-%E9%80%89%E6%8B%A9/</id>
    <published>2020-02-09T17:49:00.000Z</published>
    <updated>2020-02-09T17:50:06.364Z</updated>
    
    <content type="html"><![CDATA[<ul><li>这里介绍三大类型的排序<ul><li>冒泡，插入，选择  O(n^2)</li><li>快排，归并 O(nlogn)</li><li>桶，计数，基数</li></ul></li></ul><h1 id="1-如何分析一个排序算法？"><a href="#1-如何分析一个排序算法？" class="headerlink" title="1. 如何分析一个排序算法？"></a>1. 如何分析一个排序算法？</h1><h2 id="1-1-执行效率"><a href="#1-1-执行效率" class="headerlink" title="1.1 执行效率"></a>1.1 执行效率</h2><ul><li>最好情况，最坏情况，平均情况时间复杂度<ul><li>要知道针对于数据集的特征，需要采取哪一种排序算法 </li></ul></li><li>时间复杂度的系数，常数，低阶<ul><li>实际开发过程中，面对规模比较小的数据，我们可能需要将系数，常数，低阶都考虑进去才可以的 </li></ul></li><li>比较次数和交换次数<ul><li>对于基于比较的排序算法，会涉及到元素大小的比较以及元素的交换或者移动，因此当我们在分析排序算法的执行效率的时候，应该把比较次数和交换次数也考虑进去 </li></ul></li></ul><h2 id="1-2-排序算法的内存消耗"><a href="#1-2-排序算法的内存消耗" class="headerlink" title="1.2 排序算法的内存消耗"></a>1.2 排序算法的内存消耗</h2><p>内存消耗可以用空间复杂度来衡量，来看算法究竟消耗了多少内存空间</p><h2 id="1-3-排序算法的稳定性"><a href="#1-3-排序算法的稳定性" class="headerlink" title="1.3 排序算法的稳定性"></a>1.3 排序算法的稳定性</h2><p>如果待排序的序列中存在值相等的元素，经过排序以后，相等元素之间原有的先后顺序不变</p><p>稳定性很重要，表现在要对几个影响因素来按照步骤进行排序的情况。</p><h1 id="2-算法分析"><a href="#2-算法分析" class="headerlink" title="2. 算法分析"></a>2. 算法分析</h1><h2 id="2-1-冒泡排序"><a href="#2-1-冒泡排序" class="headerlink" title="2.1 冒泡排序"></a>2.1 冒泡排序</h2><ul><li>操作相邻的两个数据<ul><li>每次冒泡都会对相邻的两个元素进行比较，</li><li>看是否满足大小关系要求</li><li>如果不满足就让它倆互换，一次冒泡至少会让一个元素移动到它应该在的位置，重复n次，就完成了n个数据的排序工作</li></ul></li></ul><p><img src="https://i.loli.net/2020/02/10/zUxOmSFQJLiyGMD.jpg" alt="fig1.jpg"></p><p><img src="https://i.loli.net/2020/02/10/o8L1DHgENfb2su7.jpg" alt="fig2.jpg"></p><pre><code>// 冒泡排序，a 表示数组，n 表示数组大小public void bubbleSort(int[] a, int n) {  if (n &lt;= 1) return; for (int i = 0; i &lt; n; ++i) {    // 提前退出冒泡循环的标志位，如果没有冒泡，说明已经有序了，不用再进行下去了    boolean flag = false;    // -i是因为在进行第i轮次的时候，最末尾的是已经排好了的i个数    for (int j = 0; j &lt; n - i - 1; ++j) {      if (a[j] &gt; a[j+1]) { // 交换        int tmp = a[j];        a[j] = a[j+1];        a[j+1] = tmp;        flag = true;  // 表示有数据交换            }    }    if (!flag) break;  // 没有数据交换，提前退出  }}</code></pre><ul><li>冒泡排序是原地排序算法，空间复杂度为O(1)</li><li>冒泡排序是稳定的排序算法</li><li>时间复杂度<ul><li>最好情况 O(n)</li><li>最坏情况 O(n^2)</li></ul></li></ul><h2 id="2-2-插入排序"><a href="#2-2-插入排序" class="headerlink" title="2.2 插入排序"></a>2.2 插入排序</h2><p>对于一个有序的数组来说，我们往里面添加一个新的数据，就是要遍历数组，找到数据应该插入的位置并将其插入即可。</p><p><img src="https://i.loli.net/2020/02/10/GIRQpFxgunetcr7.jpg" alt="fig3.jpg"></p><ul><li>将数组中的数据分为两个区间，已排序空间和未排序空间</li><li>初始已排序空间有一个元素，即数组的第一个元素</li><li>插入算法的核心思想是取未排序区间当中的元素，在已排序空间中找到合适的插入位置将其插入，并保证已排序空间的数据一致都是有序的</li><li>重复这个过程直到未排序空间中的元素为空</li></ul><p><img src="https://i.loli.net/2020/02/10/r9yq3FfdKginlQI.jpg" alt="fig4.jpg"></p><pre><code>// 插入排序，a 表示数组，n 表示数组大小public void insertionSort(int[] a, int n) {  if (n &lt;= 1) return;  for (int i = 1; i &lt; n; ++i) {    int value = a[i];    int j = i - 1;    // 查找插入的位置    for (; j &gt;= 0; --j) {      if (a[j] &gt; value) {        a[j+1] = a[j];  // 数据移动      } else {        break;      }    }    // 这里注意循环当中j--了，所以这里是a[j+1]    a[j+1] = value; // 插入数据  }}</code></pre><ul><li>原地排序算法，空间复杂度为O(1)</li><li>稳定的排序算法</li><li>时间复杂度<ul><li>最好情况O(n)</li><li>最坏情况O(n^2)</li></ul></li></ul><h2 id="2-3-选择排序"><a href="#2-3-选择排序" class="headerlink" title="2.3 选择排序"></a>2.3 选择排序</h2><p>同样是分成已排序空间和未排序空间，但是选择排序每次都会从未排序空间当中找到最小的元素，将其放到已排序区间的末尾</p><p><img src="https://i.loli.net/2020/02/10/uZH8xBFPs247nCr.jpg" alt="fig5.jpg"></p><ul><li><p>原地排序算法</p></li><li><p>不稳定的，因为每次都要找剩余的未排序的元素当中的最小值，并和前面的元素交换位置</p><p>  public int[] selectSort(int arr[], int n) {</p><pre><code>for (int i = 0; i &lt; n; i++) {  int index = min(i+1, n);   swap(arr[index], arr[i]);}</code></pre></li></ul><pre><code>  return arr;}</code></pre><h1 id="3-冒泡-插入-选择排序的比较"><a href="#3-冒泡-插入-选择排序的比较" class="headerlink" title="3. 冒泡 插入 选择排序的比较"></a>3. 冒泡 插入 选择排序的比较</h1><p>三者的平均时间复杂度均为O(n^2)。但是实际上还是有不同的，冒泡不如插入优秀，因为在循环当中，冒泡有三个操作，而插入只有一个。在实际情况当中，插入会比冒泡快不少。而选择排序的问题是因为它的逻辑是在未选择的数列里面选择最小的，放到已排序的末端，这里是一定会有一个swap发生的，这导致排序不稳定，即对于有相同值的，排列顺序可能会发生变化。这会在实际应用中造成问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;这里介绍三大类型的排序&lt;ul&gt;
&lt;li&gt;冒泡，插入，选择  O(n^2)&lt;/li&gt;
&lt;li&gt;快排，归并 O(nlogn)&lt;/li&gt;
&lt;li&gt;桶，计数，基数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;1-如何分析一个排序算法？&quot;&gt;&lt;a href
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://www.llchen60.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序" scheme="https://www.llchen60.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法(7)-递归</title>
    <link href="https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-7-%E9%80%92%E5%BD%92/"/>
    <id>https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-7-%E9%80%92%E5%BD%92/</id>
    <published>2020-02-09T17:47:26.000Z</published>
    <updated>2020-02-09T17:47:45.905Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-如何理解递归"><a href="#1-如何理解递归" class="headerlink" title="1.如何理解递归"></a>1.如何理解递归</h1><ul><li>递<ul><li>去的过程 </li></ul></li><li>归<ul><li>回来的过程</li></ul></li></ul><p>给我的感觉是先努力去溯源，拿到源数据以后就相当于多了一个信息，然后再依托多了一个的信息，来解决问题。</p><pre><code>f(n) = f(n-1) + 1 </code></pre><h1 id="2-递归的条件"><a href="#2-递归的条件" class="headerlink" title="2. 递归的条件"></a>2. 递归的条件</h1><ul><li>一个问题的解可以分解为几个子问题的解<ul><li>子问题指数据规模更小的解</li></ul></li><li>这个问题与分解之后的子问题，除了数据规模的不同，求解思路完全一样</li><li>存在递归终止条件</li></ul><h1 id="3-如何写递归代码"><a href="#3-如何写递归代码" class="headerlink" title="3. 如何写递归代码"></a>3. 如何写递归代码</h1><ul><li>写出递归公式</li><li>找到终止条件</li></ul><p>E.G </p><p>n个台阶，每次可以跨过1个或者2个，问一共多少种走法？ </p><ul><li>可以划分为子问题，即一共的走法等于我先走一步，剩下的n-1共同的走法和先走两步，剩下的n-1共同的走法的和。就有了一个递归公式：</li></ul><pre><code>f(n) = f(n-1) + f(n-2)</code></pre><p>终止条件，看最后几个corner case，只有一个台阶，只有两个台阶，然后用3，4来验证一下。</p><blockquote><p>写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲出终止条件，最终将递推公式和终止条件翻译成代码</p></blockquote><p>不要人为加大难度，遇到递归，抽象成一个递推公式，不再一层层的想其调用关系，不要试图用人脑去分解递归的步骤</p><p>分解子问题的时候，当我们将其分解成几个子问题B C D以后，我们要做的是在假设子问题 BCD都已经解决的前提下，思考如何解决问题A。这样子我们就可以思考问题A和子问题B,C,D两层之间的关系就可以了，不需要再一层一层往下思考更深的子问题之间的关系了。屏蔽掉递归的实现细节，我们理解起来就会容易很多了</p><h1 id="4-警惕堆栈溢出"><a href="#4-警惕堆栈溢出" class="headerlink" title="4. 警惕堆栈溢出"></a>4. 警惕堆栈溢出</h1><ul><li>递归容易堆栈溢出</li><li>函数调用会使用栈来保存临时变量，每调用一个函数，都会将临时变量封装为栈帧压入内存栈当中。等函数执行完成返回时，才出栈。</li><li>系统栈或者虚拟机栈空间都不大，如果递归层很多的话，那么就会有堆栈溢出的风险。</li><li>可以在代码中限制递归调用的最大深度来解决这个问题</li></ul><p>递归好处是表达能力强，很容易去理顺其想要表达的内容；坏处是空间复杂度会比较高，因为每次递归的时候都需要在内存栈中保存一次现场数据，所以在分析递归代码空间复杂度的时候，是需要额外考虑这部分的开销的。</p><h1 id="5-重复计算问题"><a href="#5-重复计算问题" class="headerlink" title="5. 重复计算问题"></a>5. 重复计算问题</h1><p>子步骤会被计算了很多很多遍，为了避免这种重复计算，可以使用一些数据结构来保存已经求解过得f(k)。当递归调用到f(k)的时候，先看下是否已经求解过了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-如何理解递归&quot;&gt;&lt;a href=&quot;#1-如何理解递归&quot; class=&quot;headerlink&quot; title=&quot;1.如何理解递归&quot;&gt;&lt;/a&gt;1.如何理解递归&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;递&lt;ul&gt;
&lt;li&gt;去的过程 &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;归&lt;u
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://www.llchen60.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="递归" scheme="https://www.llchen60.com/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法(6)-队列</title>
    <link href="https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-6-%E9%98%9F%E5%88%97/"/>
    <id>https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-6-%E9%98%9F%E5%88%97/</id>
    <published>2020-02-09T17:45:37.000Z</published>
    <updated>2020-02-09T17:45:58.480Z</updated>
    
    <content type="html"><![CDATA[<p>CPU资源有限，任务的处理速度和线程个数并不是线性正相关的。相反的，过多的线程会导致CPU频繁切换，处理性能下降。因此，线程池的大小一般都是综合考虑要处理任务的特点和硬件环境，来事先设置的。</p><p>当我们向固定大小的线程池中请求一个线程的时候，如果线程池中没有空闲资源，如何处理这个请求呢？ —–&gt; 队列</p><p>操作受限的线性表。</p><h1 id="1-理解队列"><a href="#1-理解队列" class="headerlink" title="1. 理解队列"></a>1. 理解队列</h1><ul><li>基本操作<ul><li>入队 enqueue()   入栈 push()</li><li>出队 dequeue()   出栈 pop()</li></ul></li><li>操作受限的线性表数据结构</li><li>带有一些特性的队列<ul><li>循环队列</li><li>阻塞队列</li><li>并发队列</li><li>顺序队列 - 数组实现</li><li>链式队列 - 链式队列</li></ul></li></ul><p>在很多偏底层系统，框架，中间件的开发当中，起到关键性作用。比如高性能disruptor,Linux环形缓存，都用到了循环并发队列; Java Concurrent并发包利用ArrayBlockingQueue来实现公平锁。</p><pre><code>// 用数组实现的队列public class ArrayQueue {  // 数组：items，数组大小：n  private String[] items;  private int n = 0;  // head 表示队头下标，tail 表示队尾下标  private int head = 0;  private int tail = 0;  // 申请一个大小为 capacity 的数组  public ArrayQueue(int capacity) {    items = new String[capacity];    n = capacity;  }  // 入队  public boolean enqueue(String item) {    // 如果 tail == n 表示队列已经满了    if (tail == n) return false;    items[tail] = item;    ++tail;    return true;  }  // 出队  public String dequeue() {    // 如果 head == tail 表示队列为空    if (head == tail) return null;    // 为了让其他语言的同学看的更加明确，把 -- 操作放到单独一行来写了    String ret = items[head];    ++head;    return ret;  }}</code></pre><h1 id="2-基于链表的队列实现方法"><a href="#2-基于链表的队列实现方法" class="headerlink" title="2. 基于链表的队列实现方法"></a>2. 基于链表的队列实现方法</h1><ul><li>两个指针<ul><li>head指针 - 指向第一个结点</li><li>tail指针 - 指向最后一个结点</li></ul></li></ul><h1 id="3-循环队列"><a href="#3-循环队列" class="headerlink" title="3. 循环队列"></a>3. 循环队列</h1><p>用数组实现的队列，在tail = n的时候，会有数据搬移操作。这样入队性能就会受到影响。循环队列的可以解决这个问题。</p><ul><li>如何确认队空和队满<ul><li>队空 head == tail</li><li>队满 (tail+1)%n = head</li></ul></li></ul><pre><code>public class CircularQueue {  // 数组：items，数组大小：n  private String[] items;  private int n = 0;  // head 表示队头下标，tail 表示队尾下标  private int head = 0;  private int tail = 0;  // 申请一个大小为 capacity 的数组  public CircularQueue(int capacity) {    items = new String[capacity];    n = capacity;  }  // 入队  public boolean enqueue(String item) {    // 队列满了    if ((tail + 1) % n == head) return false;    items[tail] = item;    tail = (tail + 1) % n;    return true;  }  // 出队  public String dequeue() {    // 如果 head == tail 表示队列为空    if (head == tail) return null;    String ret = items[head];    head = (head + 1) % n;    return ret;  }}</code></pre><h1 id="4-阻塞队列和并发队列"><a href="#4-阻塞队列和并发队列" class="headerlink" title="4. 阻塞队列和并发队列"></a>4. 阻塞队列和并发队列</h1><ul><li>阻塞队列<ul><li>在队列基础上增加了阻塞操作</li><li>队列为空的时候，从队头取数据会被阻塞</li><li>如果队列已经满了，那么插入数据的操作会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回</li><li>生产者 消费者模型  相当于</li><li>基于阻塞队列，我们可以通过协调生产者和消费者的个数来提高数据的处理效率</li><li>我们可以通过配置多几个的消费者，来应对一个生产者</li></ul></li><li>并发队列<ul><li>实现方法<ul><li>在enquue()和dequeue()方法上加锁</li><li>基于CAS原子操作</li></ul></li></ul></li></ul><h1 id="5-对比基于数组和基于链表实现的队列"><a href="#5-对比基于数组和基于链表实现的队列" class="headerlink" title="5. 对比基于数组和基于链表实现的队列"></a>5. 对比基于数组和基于链表实现的队列</h1><ul><li>基于链表的实现方式<ul><li>可以实现一个支持无限排队的无界队列</li><li>可能会导致过多的请求排队等待</li><li>请求处理的响应时间会长很多</li><li>因此对于响应时间比较敏感的系统来说，基于链表实现的无限排队的线程池就不是很合适了</li></ul></li><li>基于数组实现的有界队列<ul><li>队列大小是有限的</li><li>超过一定数量以后，请求就会被拒绝</li><li>队列的大小设置就会是个trade off了</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CPU资源有限，任务的处理速度和线程个数并不是线性正相关的。相反的，过多的线程会导致CPU频繁切换，处理性能下降。因此，线程池的大小一般都是综合考虑要处理任务的特点和硬件环境，来事先设置的。&lt;/p&gt;
&lt;p&gt;当我们向固定大小的线程池中请求一个线程的时候，如果线程池中没有空闲资
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://www.llchen60.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="队列" scheme="https://www.llchen60.com/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法(5)-栈</title>
    <link href="https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-5-%E6%A0%88/"/>
    <id>https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-5-%E6%A0%88/</id>
    <published>2020-02-09T17:44:43.000Z</published>
    <updated>2020-02-09T17:45:06.181Z</updated>
    
    <content type="html"><![CDATA[<p>大家都常用Chrome浏览器，你会发现在你做后退或者前进按钮时，浏览器的加载速度非常快，这里实际上是用的栈这个数据结构来进行处理的。</p><h1 id="1-对栈的理解"><a href="#1-对栈的理解" class="headerlink" title="1. 对栈的理解"></a>1. 对栈的理解</h1><ul><li>先进后出</li><li>操作受限的线性表，只允许在一端插入和删除数据</li><li>实质上栈的功能一定是可以被数组（顺序栈）或者链表（链式栈）来替代的，因为有拿第一个和最后一个的接口，或者说方式</li><li>用栈的好处是操作上的简单，更不容易出错一些</li><li>功能操作受限的线性表，栈可以通过数组或者链表来进行实现</li></ul><h1 id="2-支持动态扩容的顺序栈"><a href="#2-支持动态扩容的顺序栈" class="headerlink" title="2. 支持动态扩容的顺序栈"></a>2. 支持动态扩容的顺序栈</h1><ul><li>动态扩容 - load factor</li><li>顺序栈 - 数组</li></ul><p><img src="fig1.jpg" alt="fig1.jpg"></p><ul><li>注意动态扩容的顺序栈，出栈过程依然可以实现O(1)的时间复杂度，但是在入栈过程当中，如果空间不够了的话，那就需要实现整体的迁移，时间复杂度就变成了O(n)</li></ul><pre><code>// 基于数组实现的顺序栈public class ArrayStack {  private String[] items;  // 数组  private int count;       // 栈中元素个数  private int n;           //栈的大小  // 初始化数组，申请一个大小为n的数组空间  public ArrayStack(int n) {    this.items = new String[n];    this.n = n;    this.count = 0;  }  // 入栈操作  public boolean push(String item) {    // 数组空间不够了，直接返回false，入栈失败。    if (count == n) return false;    // 将item放到下标为count的位置，并且count加一    items[count] = item;    ++count;    return true;  }  // 出栈操作  public String pop() {    // 栈为空，则直接返回null    if (count == 0) return null;    // 返回下标为count-1的数组元素，并且栈中元素个数count减一    String tmp = items[count-1];    --count;    return tmp;  }}</code></pre><h1 id="3-栈的应用"><a href="#3-栈的应用" class="headerlink" title="3. 栈的应用"></a>3. 栈的应用</h1><ul><li>函数调用栈<ul><li>操作系统给每个线程分配一块独立的内存空间，这块内存被组织成栈这种结构，用来存储函数调用时的临时变量</li></ul></li><li>表达式求值<ul><li>计算机会用两个栈来实现</li><li>一个用来保存操作数</li><li>一个用来保存运算符<br>实际上，编译器就是通过两个栈来实现的。其中一个保存操作数的栈，另一个是保存运算符的栈。我们从左向右遍历表达式，当遇到数字，我们就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较。如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取 2 个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。<br><img src="fig2.jpg" alt="fig2.jpg"></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;大家都常用Chrome浏览器，你会发现在你做后退或者前进按钮时，浏览器的加载速度非常快，这里实际上是用的栈这个数据结构来进行处理的。&lt;/p&gt;
&lt;h1 id=&quot;1-对栈的理解&quot;&gt;&lt;a href=&quot;#1-对栈的理解&quot; class=&quot;headerlink&quot; title=&quot;1. 对
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://www.llchen60.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="栈" scheme="https://www.llchen60.com/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法(4)-链表</title>
    <link href="https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-4-%E9%93%BE%E8%A1%A8/"/>
    <id>https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-4-%E9%93%BE%E8%A1%A8/</id>
    <published>2020-02-09T06:48:48.000Z</published>
    <updated>2020-02-09T06:49:54.512Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-链表结构"><a href="#1-链表结构" class="headerlink" title="1. 链表结构"></a>1. 链表结构</h1><ul><li><p>数组需要一块连续的内存空间来存储，对内存的要求比较高</p></li><li><p>链表，通过指针将一组<strong>零散的内存块</strong>串联起来使用</p></li><li><p>链表经典应用场景 - LRU缓存淘汰算法</p><ul><li>缓存是一种提高数据读取性能的技术<ul><li>CPU缓存</li><li>数据库缓存</li><li>浏览器缓存</li></ul></li></ul></li></ul><h2 id="1-1-单链表"><a href="#1-1-单链表" class="headerlink" title="1.1 单链表"></a>1.1 单链表</h2><p><img src="https://i.loli.net/2020/02/09/Q9fFlx6ap5B47Mj.jpg" alt="fig1.jpg"></p><ul><li><p>每个链表的节点 </p><ul><li>存储的数据</li><li>记录链的下一个结点的地址(后继指针next)</li></ul></li><li><p>头结点用来记录链表的<strong>基地址</strong></p></li><li><p>尾结点的指针指向一个<strong>空地址NULL</strong></p></li><li><p>插入和删除结点都非常快 O(1)</p></li><li><p>随机访问其中一个元素，比如按照顺序选第n个就是O(n)的复杂度</p></li></ul><p><img src="https://i.loli.net/2020/02/09/h6maNKWveQnfgGP.jpg" alt="fig2.jpg"></p><h2 id="1-2-双向链表"><a href="#1-2-双向链表" class="headerlink" title="1.2 双向链表"></a>1.2 双向链表</h2><p><img src="https://i.loli.net/2020/02/09/rYhNQ1Zwp5klgVn.jpg" alt="fig4.jpg"></p><ul><li>双向链表支持两个方向，每个节点不止有一个后继指针next指向后面的结点，还有一个前驱指针prev指向前面的结点。</li><li>双向链表可以支持O(1) 的时间复杂度的情况下找到前驱结点，这样就使得双向链表在某些情况下的插入、删除等操作都要比单链表简单高效。</li><li>其实就是无论单链表还是双向链表，在删除的时候都需要找到前驱结点，而单链表在这里想要找到前驱结点的话就得从头开始去找，时间复杂度还是O(n)，而双向链表就可以实现很快的找到对应的前驱节点了。</li><li>因为有prev next两个指针，它黄海军更占用内存的空间</li><li>Java的LinkedHashMap就是用双向链表来实现的</li><li>用空间换时间的设计思想<ul><li>当内存空间充足的时候，如果我们更追求代码的执行速度，那么我们就可以选择空间复杂度相对较高，但时间复杂度相对很低的算法或者数据结构。 </li></ul></li><li>对于有序链表来说，双向链表的按值查询效率也要比单链表高。因为我们可以通过记录上次查找的位置p，每次查询的时候，根据要查找的值和p的大小关系决定是往前还是往后来查找。</li></ul><h2 id="1-3-循环链表"><a href="#1-3-循环链表" class="headerlink" title="1.3 循环链表"></a>1.3 循环链表</h2><p><img src="https://i.loli.net/2020/02/09/BLOXWHUgpeJoQGh.jpg" alt="fig3.jpg"></p><ul><li>循环链表的尾结点指针是指向链表的头结点，像一个环一样首尾相连</li><li>当要处理的数据具有<strong>环形结构特点</strong>时，就特别适合采用循环链表。</li></ul><h1 id="2-链表数组性能对比"><a href="#2-链表数组性能对比" class="headerlink" title="2.链表数组性能对比"></a>2.链表数组性能对比</h1><table><thead><tr><th>时间复杂度</th><th>数组</th><th>链表</th></tr></thead><tbody><tr><td>插入删除</td><td>O(n)</td><td>O(1)</td></tr><tr><td>随机访问</td><td>O(1)</td><td>O(n)</td></tr></tbody></table><p>但是在实际应用开发当中，不能仅仅利用复杂度分析就决定使用哪个数据结构来存储数据。</p><p>数组简单易用，在实现上使用的是连续的内存空间，可以借助CPU的缓存机制，预读数组中的数据，所以访问效率更高。而链表因为不是连续内存存储，所以没办法有效预读。</p><p>数组大小固定，增大如果要做扩容拷贝是非常费时间的。链表本身没有大小的限制，天然支持动态扩容。</p><p>而且，如果代码对于内存的使用很苛刻，那数组会更加合适。因为链表中的每个结点都要消耗额外的存储空间去存储指针，所以内存的消耗会翻倍。而且，对链表进行频繁的插入，删除操作还会导致频繁的内存申请和释放，容易造成内存碎片。Java中就会导致频繁的garbage collection. </p><h1 id="3-写链表代码的技巧"><a href="#3-写链表代码的技巧" class="headerlink" title="3. 写链表代码的技巧"></a>3. 写链表代码的技巧</h1><h2 id="3-1-理解指针或者引用的含义"><a href="#3-1-理解指针或者引用的含义" class="headerlink" title="3.1 理解指针或者引用的含义"></a>3.1 理解指针或者引用的含义</h2><p>指针，是在像C语言这样的语言当中来使用的；对于Java这种面向对象的语言，是用引用来达成存储所指对象的内存地址的目的。</p><p>将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就可以找到这个变量了。</p><pre><code>// p结点的next指针里面存储了q结点的内存地址p-&gt;next = q// p 结点的next指针存储了p结点的下下个结点的内存地址p-&gt;next = p-&gt;next-&gt;next</code></pre><h2 id="3-2-警惕指针丢失和内存泄露"><a href="#3-2-警惕指针丢失和内存泄露" class="headerlink" title="3.2 警惕指针丢失和内存泄露"></a>3.2 警惕指针丢失和内存泄露</h2><p><img src="https://i.loli.net/2020/02/09/ASXEJ4ZYzf6lmrH.jpg" alt="fig5.jpg"></p><pre><code>x-&gt;next = p-&gt;next;  // 将 x 的结点的 next 指针指向 b 结点；p-&gt;next = x;  // 将 p 的 next 指针指向 x 结点；</code></pre><p>两行代码的顺序很重要，你需要先将p的next的地址赋给x的next的地址，然后再来改p的next，改变p的next指针</p><h2 id="3-3-利用哨兵"><a href="#3-3-利用哨兵" class="headerlink" title="3.3 利用哨兵"></a>3.3 利用哨兵</h2><p>对于链表当中的第一个结点和最后一个结点，其实现插入删除的逻辑和其他结点是不一样的。</p><p>利用哨兵结点可以简化整个实现，让针对于第一个结点和最后一个结点的处理和其他结点的处理方式一致。</p><p><img src="https://i.loli.net/2020/02/09/A43BtwNSuvhMy7n.jpg" alt="fig6.jpg"></p><h2 id="3-4-边界条件的思考与判定"><a href="#3-4-边界条件的思考与判定" class="headerlink" title="3.4 边界条件的思考与判定"></a>3.4 边界条件的思考与判定</h2><ul><li>链表为空</li><li>链表只包含一个结点</li><li>链表只包含两个结点</li><li>代码逻辑在处理头结点和尾结点的时候</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-链表结构&quot;&gt;&lt;a href=&quot;#1-链表结构&quot; class=&quot;headerlink&quot; title=&quot;1. 链表结构&quot;&gt;&lt;/a&gt;1. 链表结构&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;数组需要一块连续的内存空间来存储，对内存的要求比较高&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://www.llchen60.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LinkedList" scheme="https://www.llchen60.com/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法(3)-数组</title>
    <link href="https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-3-%E6%95%B0%E7%BB%84/"/>
    <id>https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-3-%E6%95%B0%E7%BB%84/</id>
    <published>2020-02-09T06:46:35.000Z</published>
    <updated>2020-02-09T06:46:53.794Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-什么是数组"><a href="#1-什么是数组" class="headerlink" title="1. 什么是数组"></a>1. 什么是数组</h1><ul><li>是一种<strong>线性表</strong>数据结构，用一组<strong>连续的内存空间</strong>，来存储一组具有<strong>相同类型</strong>的数据</li><li>线性表<ul><li>数据排成了线性的结构</li><li>每个线性表上的数据只有前后两个方向</li><li>除了数组，链表、队列、栈等也是线性表结构</li></ul></li><li>非线性表<ul><li>比如说二叉树，堆，图等  他们的数据之间不是简单的前后关系了 </li></ul></li><li>连续内存空间与相同类型的数据<ul><li>正因为有这个特征其才可以进行随机访问</li><li>但是这也导致了想要在数组当中删除，插入一个数据，为了保证连续性，就需要做大量的数据搬移工作</li><li>数组非常适合根据下标来进行访问</li></ul></li><li>线性表 - 数组<ul><li>表中的数据只有前后两个方向</li><li>数组，链表，队列，栈都是线性表结构</li></ul></li><li>非线性表<ul><li>二叉树，堆，图</li><li>数据之间并不是简单的前后关系</li></ul></li></ul><h1 id="2-数组的插入，删除，随机访问"><a href="#2-数组的插入，删除，随机访问" class="headerlink" title="2. 数组的插入，删除，随机访问"></a>2. 数组的插入，删除，随机访问</h1><ul><li>插入，删除<ul><li>在k位置做操作，那么对于k位置之后的k - n都是需要做移位的 </li></ul></li><li>删除的优化<ul><li>避免每次删除都直接的搬移数据</li><li>先记录下已经删除的数据</li><li>每次删除操作并不是真正搬移数据，只是记录数据已经被删除了</li><li>当数组没有更多空间存储了以后，再触发执行一次真正的删除操作</li><li>通过这种方式大大减少了删除操作导致的数据搬移</li><li>—–&gt; JVM标记清除垃圾回收算法</li></ul></li></ul><h1 id="3-数组的访问越界问题"><a href="#3-数组的访问越界问题" class="headerlink" title="3. 数组的访问越界问题"></a>3. 数组的访问越界问题</h1><pre><code>int main(int argc, char* argv[]){    int i = 0;    int arr[3] = {0};    for(; i&lt;=3; i++){        arr[i] = 0;        printf(&quot;hello world\n&quot;);    }    return 0;}</code></pre><p>当i=3的时候，访问越界。在C语言当中，只要不是访问受限的内存，内存空间都是可以自由访问的。a[3]会被定位到某块不属于数组的内存地址上，而这个地址正好是存储变量i的内存地址，那么arr[3] = 0 就相当于 i=0，因此会导致代码无限循环。</p><p>对这里的无限循环的解释：函数体内的局部变量存在栈上，且是连续压栈。在Linux进程的内存布局中，栈区在高地址空间，从高向低增长。变量i和arr在相邻地址，且i比arr的地址大，所以arr越界正好访问到i。当然，前提是i和arr元素同类型，否则那段代码仍是未决行为。</p><p>数组越界是一种未决行为，并没有规定数组访问越界时编译器应该如何处理。因为，访问数组的本质就是访问一段连续内存，只要数组通过偏移计算得到的内存地址是可用的，那么程序就可能不会报任何错误。</p><p>Java做了封装，会判断出数组越界的行为，并throw exception。</p><h1 id="4-容器-vs-数组"><a href="#4-容器-vs-数组" class="headerlink" title="4. 容器 vs 数组"></a>4. 容器 vs 数组</h1><p>容器，譬如Java中的ArrayList，最大优势是可以将许多数组操作细节封装起来。另外，其支持动态扩容。动态扩容很耗时的，因为牵扯到内存申请，还有整体的数据搬移。因此如果能确定需要村塾的数据的大小，最好<strong>在创建Arraylist的时候事先指定好</strong></p><ul><li>使用数组的情况<ul><li>ArrayList 无法存储基本类型，需要封装，autoBoxing, unboxing本身是有一定的性能消耗的，如果特别关注性能，那么我们就需要用数组</li><li>如果数组大小已知，并且对数据的操作很简单。不需要使用ArrayList所提供的大部分的方法，那么我们可以直接使用数组</li><li>多维数组的表示会更为直观一些</li></ul></li></ul><h1 id="5-为什么数组要从0开始编号？"><a href="#5-为什么数组要从0开始编号？" class="headerlink" title="5. 为什么数组要从0开始编号？"></a>5. 为什么数组要从0开始编号？</h1><p>因为下标最确切的定义是偏移，offset。要算a[k]的内存地址的公式为：</p><pre><code>a[k]_address = base_address + k * type_size</code></pre><p>如果我们从1开始计数，那么我们计算位置的公式就会变成：</p><pre><code>a[k]_address = base_address + (k-1)*type_size</code></pre><p>这样每次访问都会多一次减法运算！！！对于CPU来说，就是多了一次减法指令。从0开始就是为了提高效率，当然这个效率的提升其实很小，也有一大部分是历史原因了，即不同语言的迁移之间的学习成本。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-什么是数组&quot;&gt;&lt;a href=&quot;#1-什么是数组&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是数组&quot;&gt;&lt;/a&gt;1. 什么是数组&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;是一种&lt;strong&gt;线性表&lt;/strong&gt;数据结构，用一组&lt;strong&gt;连续的
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://www.llchen60.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Array" scheme="https://www.llchen60.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法(2)-复杂度分析</title>
    <link href="https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-2-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"/>
    <id>https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-2-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/</id>
    <published>2020-02-09T06:41:40.000Z</published>
    <updated>2020-02-09T06:42:03.983Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-为什么需要复杂度分析？"><a href="#1-为什么需要复杂度分析？" class="headerlink" title="1. 为什么需要复杂度分析？"></a>1. 为什么需要复杂度分析？</h1><p>通过统计和监控得到的算法执行时间的占用的内存的大小的方法称为事后统计法，这种方法有其局限性：</p><ul><li>测试结果非常依赖于测试环境</li><li>测试结果受数据规模的影响很大, 而且会和数据集本身的数据质量有关</li><li>—-&gt; 因此我们需要一个不用具体的测试数据来测试，就可以粗略估计算法的执行效率的方法</li></ul><h1 id="2-大O复杂度表示法"><a href="#2-大O复杂度表示法" class="headerlink" title="2. 大O复杂度表示法"></a>2. 大O复杂度表示法</h1><ul><li>假定每行代码执行时间都一样</li><li>并不表示具体的代码执行时间，而是表示执行时间随着数据规模增大的变化趋势，因此也叫做渐进时间复杂度。</li></ul><h1 id="3-如何分析代码的时间复杂度"><a href="#3-如何分析代码的时间复杂度" class="headerlink" title="3. 如何分析代码的时间复杂度"></a>3. 如何分析代码的时间复杂度</h1><ul><li>只关注循环执行次数最多的一段代码</li><li>加法原则：总复杂度等于量级最大的那段代码的复杂度</li><li>乘法法则： 嵌套代码的复杂度等于签到内外层代码复杂度的乘积</li></ul><h1 id="4-复杂度量级"><a href="#4-复杂度量级" class="headerlink" title="4. 复杂度量级"></a>4. 复杂度量级</h1><ul><li>常量阶 O(1)</li><li>对数阶 O(logn)</li><li>线性阶 O(n)<ul><li>O (m+n) 当我们不知道几个变量的大小的时候 </li></ul></li><li>线性对数阶 O(nlogn)</li><li>平方阶 O(n^2)<ul><li>O (m*n) 乘法关系，不知道参量之间的相对大小 </li></ul></li><li>k次方阶 O(n^k)</li><li>指数阶 O(2^n)</li><li>阶乘阶 O(n!)</li></ul><h1 id="5-空间复杂度分析"><a href="#5-空间复杂度分析" class="headerlink" title="5. 空间复杂度分析"></a>5. 空间复杂度分析</h1><p>空间复杂度的全程是渐进空间复杂度，表示算法的存储空间与数据规模之间的增长关系。</p><p>大O时间复杂度，并不具体表示代码真正的执行时间，而是表示代码执行时间随着数据规模的增大的变化趋势。因此也叫做渐进时间复杂度，(asymptotic time complexity)</p><pre><code>T(n) = O(f(n))</code></pre><p>T(n) - 代码的执行时间<br>n - 数据规模的大小<br>f(n) - 每行代码执行的次数总和<br>O - 表示左右成正比</p><h2 id="5-1-Tips"><a href="#5-1-Tips" class="headerlink" title="5.1 Tips"></a>5.1 Tips</h2><ul><li>只关注循环执行次数最多的一段代码</li><li>总复杂度等于量级最大的那段代码的复杂度</li><li>嵌套代码的复杂度为嵌套内外代码复杂度的乘积</li></ul><h1 id="6-复杂度的分析"><a href="#6-复杂度的分析" class="headerlink" title="6. 复杂度的分析"></a>6. 复杂度的分析</h1><h2 id="6-1-时间复杂度分析"><a href="#6-1-时间复杂度分析" class="headerlink" title="6.1 时间复杂度分析"></a>6.1 时间复杂度分析</h2><h3 id="6-1-1-多项式量级"><a href="#6-1-1-多项式量级" class="headerlink" title="6.1.1 多项式量级"></a>6.1.1 多项式量级</h3><ul><li>O(1) <ul><li>常量级的代码，我们将其时间复杂度都记作O(1)</li></ul></li><li>O(logn)</li></ul><pre><code> i=1; while (i &lt;= n)  {   i = i * 2; }</code></pre><ul><li>O(nlogn)</li><li>O(m+n)</li><li>O(m*n)</li></ul><h3 id="6-1-2-非多项式量级"><a href="#6-1-2-非多项式量级" class="headerlink" title="6.1.2 非多项式量级"></a>6.1.2 非多项式量级</h3><p>非常低效，会随着n的增长急剧增长，因此我们应当尽量不选择有如下时间复杂度的算法</p><ul><li>O(2^n) </li><li>O(n!)</li></ul><h2 id="6-2-空间复杂度分析"><a href="#6-2-空间复杂度分析" class="headerlink" title="6.2 空间复杂度分析"></a>6.2 空间复杂度分析</h2><p>渐进空间复杂度，表示算法的存储空间和数据规模之间的增长关系。</p><p>一般来说在O(1), O(n), O(n^2)这几个可能性上面</p><h1 id="7-浅析最好、最坏、平均、均摊时间复杂度"><a href="#7-浅析最好、最坏、平均、均摊时间复杂度" class="headerlink" title="7. 浅析最好、最坏、平均、均摊时间复杂度"></a>7. 浅析最好、最坏、平均、均摊时间复杂度</h1><pre><code>// n 表示数组 array 的长度int find(int[] array, int n, int x) {  int i = 0;  int pos = -1;  for (; i &lt; n; ++i) {    if (array[i] == x) {       pos = i;       break;    }  }  return pos;}</code></pre><h2 id="7-1-最好情况时间复杂度-best-case-time-complexity"><a href="#7-1-最好情况时间复杂度-best-case-time-complexity" class="headerlink" title="7.1 最好情况时间复杂度(best case time complexity)"></a>7.1 最好情况时间复杂度(best case time complexity)</h2><p>上面这段代码，最好情况是O(1)</p><h2 id="7-2-最坏情况时间复杂度-worst-case-time-complexity"><a href="#7-2-最坏情况时间复杂度-worst-case-time-complexity" class="headerlink" title="7.2 最坏情况时间复杂度(worst case time complexity)"></a>7.2 最坏情况时间复杂度(worst case time complexity)</h2><p>上面这段代码，最坏情况是O(n)</p><h2 id="7-3-平均情况时间复杂度-average-case-time-complexity"><a href="#7-3-平均情况时间复杂度-average-case-time-complexity" class="headerlink" title="7.3 平均情况时间复杂度(average case time complexity)"></a>7.3 平均情况时间复杂度(average case time complexity)</h2><p>需要算上发生的概率</p><p>上述例子当中，因为要查找变量x在数组当中的位置，一共有n+1种情况，在数组的0 - n-1位置中和不在数组当中。将每种情况下，需要遍历的元素个数累加起来，再除以n+1,就可以得到需要遍历的元素个数的平均值了 </p><p>即</p><pre><code>(1+2+3+ ... + n + n) / (n+1) = n(n+3)/(2(n+1))</code></pre><p>故平均复杂度还是O(n)</p><p>然而还要考虑每种情况下 发生的概率实质上是不同的，需要将这个算上</p><h2 id="7-4-均摊时间复杂度-amortized-time-complexity"><a href="#7-4-均摊时间复杂度-amortized-time-complexity" class="headerlink" title="7.4 均摊时间复杂度(amortized time complexity)"></a>7.4 均摊时间复杂度(amortized time complexity)</h2><p>不是遍历case，而是有轮回的，因此算一个轮回里的时间就可以得出平均复杂度了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-为什么需要复杂度分析？&quot;&gt;&lt;a href=&quot;#1-为什么需要复杂度分析？&quot; class=&quot;headerlink&quot; title=&quot;1. 为什么需要复杂度分析？&quot;&gt;&lt;/a&gt;1. 为什么需要复杂度分析？&lt;/h1&gt;&lt;p&gt;通过统计和监控得到的算法执行时间的占用的内存的大
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://www.llchen60.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="复杂度分析" scheme="https://www.llchen60.com/tags/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
</feed>
