<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Leilei&#39;s Blog | 磊磊的博客</title>
  
  <subtitle>Because it&#39;s there</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.llchen60.com/"/>
  <updated>2020-03-04T04:22:54.643Z</updated>
  <id>https://www.llchen60.com/</id>
  
  <author>
    <name>Leilei Chen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>组合 vs 继承</title>
    <link href="https://www.llchen60.com/%E7%BB%84%E5%90%88-vs-%E7%BB%A7%E6%89%BF/"/>
    <id>https://www.llchen60.com/%E7%BB%84%E5%90%88-vs-%E7%BB%A7%E6%89%BF/</id>
    <published>2020-03-04T04:21:56.000Z</published>
    <updated>2020-03-04T04:22:54.643Z</updated>
    
    <content type="html"><![CDATA[<p>组合还有继承都是面向对象的很重要的特性，但是有一条非常重要的设计原则说 – 组合优于继承，想在这篇博文当中分析一下为什么认为组合优于继承，以及什么情况下我们仍然应该使用继承。</p><p>继承可以表示类之间的is-a的关系，可以一定程度上解决代码复用性的问题，但是继承层次过深，也会影响到代码的可维护性。</p><h1 id="1-继承的劣势"><a href="#1-继承的劣势" class="headerlink" title="1. 继承的劣势"></a>1. 继承的劣势</h1><p>譬如 我们现在要实现一个关于哺乳动物的类，我们首先需要将哺乳动物定义为一个抽象的类</p><pre><code>public class Mammal {    public void breathWithLung() {    }}</code></pre><p>此时我们就可以实例化Monkey，Whale等一系列哺乳动物了。但是对于哺乳动物来说，他的属，科，目门类很多，海陆空都有，假设我们按照他们的行为来进行分类的话。可以分成会飞的，会游的，还有会跑的。所以就可以写如下的代码：</p><pre><code>public class flyableMammal extends Mammal {    public void fly() {    }}public class underwaterMammal extends Mammal {    public void swim() {    }}public class onLandMammal extends Mammal {    public void run() {    }}</code></pre><p>这个时候我们已经有两层的继承了，而后我们可以实例化一些哺乳动物，譬如鲸鱼，海豚，狮子等等来创建真的对象。然后问题来了，我们现在想探究会飞的动物当中，夜行的类目，那就意味着我们需要再创建一个新的层级来进行研究了。</p><p>长此以往，整个层级就会变得很深。而深度的层级意味着每当我们想真真切切去研究到底这个类做了什么的时候，我们需要去他的父类，去他的父类的父类，追本溯源，一个一个看其中定义的属性和方法，才能完全理解他做了什么。</p><p>这样子来做，首先造成了代码的可读性变得非常差，而对于类本身而言，破坏了其封装特性，将父类的实现细节暴露给了子类。在这种情况下，一旦父类代码修改，就会影响所有子类的逻辑。</p><h1 id="2-组合的优势"><a href="#2-组合的优势" class="headerlink" title="2. 组合的优势"></a>2. 组合的优势</h1><p>对于上述的场景，我们完全可以用组合的方式来实现。通过设立多个功能接口，来表示当前类的属性，譬如flyable, runnable, swimmable, etc. 通过这种方式，我们让concrete class直接implements对应的接口，并override写出自己的实现。这样子就能够解决这个问题了。</p><p>除了使用接口之外，我们也可以使用委托的方式，即仍然定于对应的接口，但是还定义了实现了接口方法的实现类，在实际使用的时候，调用实现类的方法直接使用，例子如下</p><pre><code>public interface Flyable {  void fly()；}public class FlyAbility implements Flyable {  @Override  public void fly() { //... }}//省略Tweetable/TweetAbility/EggLayable/EggLayAbilitypublic class Ostrich implements Tweetable, EggLayable {//鸵鸟  private TweetAbility tweetAbility = new TweetAbility(); //组合  private EggLayAbility eggLayAbility = new EggLayAbility(); //组合  //... 省略其他属性和方法...  @Override  public void tweet() {    tweetAbility.tweet(); // 委托  }  @Override  public void layEgg() {    eggLayAbility.layEgg(); // 委托  }}</code></pre><h1 id="3-如何判断该使用继承还是组合？"><a href="#3-如何判断该使用继承还是组合？" class="headerlink" title="3. 如何判断该使用继承还是组合？"></a>3. 如何判断该使用继承还是组合？</h1><p>组合也并不完美，组合需要对类做更细度的拆分，要定义更多的类和接口，因此在实际开发的过程当中，我们还是要根据具体的情况，来具体选择该使用继承还是组合。</p><p>如果类之间的继承结构稳定 – 不会轻易改变，继承关系比较浅 – 譬如两层到三层的继承关系，那么我们可以直接使用继承。反之，对于系统不够稳定，继承层次会很深，且关系复杂的，我们就应该尽量使用组合来替代继承了。</p><p>或者当我们想要使用多态的特性的时候，我们就需要使用继承了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;组合还有继承都是面向对象的很重要的特性，但是有一条非常重要的设计原则说 – 组合优于继承，想在这篇博文当中分析一下为什么认为组合优于继承，以及什么情况下我们仍然应该使用继承。&lt;/p&gt;
&lt;p&gt;继承可以表示类之间的is-a的关系，可以一定程度上解决代码复用性的问题，但是继承层次
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
      <category term="Composition" scheme="https://www.llchen60.com/tags/Composition/"/>
    
      <category term="Inheritance" scheme="https://www.llchen60.com/tags/Inheritance/"/>
    
  </entry>
  
  <entry>
    <title>Java 理解多态</title>
    <link href="https://www.llchen60.com/Java-%E7%90%86%E8%A7%A3%E5%A4%9A%E6%80%81/"/>
    <id>https://www.llchen60.com/Java-%E7%90%86%E8%A7%A3%E5%A4%9A%E6%80%81/</id>
    <published>2020-02-29T16:34:38.000Z</published>
    <updated>2020-02-29T16:35:36.929Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-什么是多态？"><a href="#1-什么是多态？" class="headerlink" title="1. 什么是多态？"></a>1. 什么是多态？</h1><p>多态目的是为了分离做什么和怎么做，从而实现接口和实现的分离。通过多态，可以改善代码的组织结构和可读性，最重要的是能够创建可扩展的程序。</p><p>有继承关系的类，子类重写父类的方法，然后父类的引用指向子类。通过这种方式，就可以对于父类的声明指向子类的实际对象，</p><h1 id="2-为什么需要多态？"><a href="#2-为什么需要多态？" class="headerlink" title="2. 为什么需要多态？"></a>2. 为什么需要多态？</h1><p>多态的好处很多，令代码可扩展，解耦接口与实现，让代码对于改动封闭，对于扩展开放, etc. 如果直接从代码的角度来看，我们可以比较直观的看到他的优势</p><pre><code>public class Animal {    public void move() {        System.out.println(&quot;Animal move&quot;);    }}public class Cat extends Animal {    @Override    public void move() {        System.out.println(&quot;cat climb&quot;);    }}public calss Dog entends Animal {    @Override    public void move() {        System.out.println(&quot;dog run&quot;);    }}public static void main(String [] args) {    Animal animal = new Cat();    animal.move();    // output: cat climb}</code></pre><p>通过这种方式可以实现接口与实现的解耦。</p><h1 id="3-多态和继承的关系"><a href="#3-多态和继承的关系" class="headerlink" title="3. 多态和继承的关系"></a>3. 多态和继承的关系</h1><p>继承指在子类当中使用父类的数据和方法</p><p>多态指在子类当中改变父类的行为。</p><h1 id="4-构造器内部的多态方法的行为"><a href="#4-构造器内部的多态方法的行为" class="headerlink" title="4. 构造器内部的多态方法的行为"></a>4. 构造器内部的多态方法的行为</h1><p>如果在一个构造器的内部调用正在构造的对象的某个动态绑定的方法，会出现一些不可知的错误。</p><p>因为构造器内部的动态绑定意味着要用到方法被覆盖以后的定义，而这意味着被覆盖的方法在对象被完全构造之前就会被调用了，</p><pre><code>class Graph {    void draw() {        print(&quot;Graph draw()&quot;);    }    Graph() {        print(&quot;Graph() before draw()&quot;);        draw();        print(&quot;Graph() after draw()&quot;);    }}class RoundGraph extends Graph {    private int radius = 1;    RoundGraph(int r) {        radius = r;        print(&quot;RoundGraph.RoundGraph(), radius = &quot; + radius);    }    void draw() {        print(&quot;RoundGraph.draw(), radius = &quot; + radius);    }}public class PolyConstructors {    public static void main(String[] args) {        new RoundGraph(5);    }}// All output Graph() before draw()RoundGraph.draw(), radius = 0Graph() after draw()ROundGraph,RoundGraph(), radius = 5</code></pre><p>有这样的输出的原因是当我们实例化R欧尼的Graph的时候，会调用基类的构造器，在Graph类的构造器当中调用了draw()方法，这个时候动态绑定，是要去调用RoundGraph类的draw方法的，但是这个时候还在构建Graph 的实例，RoundGraph还没有构建好，所以就出现了返回的Radius刚开始值为0的问题了</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li>Thinking in Java Ch.8 </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-什么是多态？&quot;&gt;&lt;a href=&quot;#1-什么是多态？&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是多态？&quot;&gt;&lt;/a&gt;1. 什么是多态？&lt;/h1&gt;&lt;p&gt;多态目的是为了分离做什么和怎么做，从而实现接口和实现的分离。通过多态，可以改善代码的组织
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
      <category term="Polymorphism" scheme="https://www.llchen60.com/tags/Polymorphism/"/>
    
  </entry>
  
  <entry>
    <title>理解面向对象</title>
    <link href="https://www.llchen60.com/%E7%90%86%E8%A7%A3%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>https://www.llchen60.com/%E7%90%86%E8%A7%A3%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</id>
    <published>2020-02-25T05:20:52.000Z</published>
    <updated>2020-03-04T01:43:08.660Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博文主要想说面向对象的几大特性：封装，抽象，继承，多态，以及我们究竟如何去使用。</p><h1 id="1-面向对象概述"><a href="#1-面向对象概述" class="headerlink" title="1. 面向对象概述"></a>1. 面向对象概述</h1><h2 id="1-1-面向对象编程"><a href="#1-1-面向对象编程" class="headerlink" title="1.1 面向对象编程"></a>1.1 面向对象编程</h2><p>一种编程范式/风格，以类或对象作为组织代码的基本单元，并将封装，抽象，继承，多态四个特性作为代码设计和实现的基石。</p><p>整个编程的过程：</p><ul><li>Object Oriented Analysis</li><li>Object Oriented Design</li><li>Object Oriented Programming </li></ul><h2 id="1-2-面向对象编程的四大特征"><a href="#1-2-面向对象编程的四大特征" class="headerlink" title="1.2 面向对象编程的四大特征"></a>1.2 面向对象编程的四大特征</h2><h3 id="1-2-1-封装-Encapsulation"><a href="#1-2-1-封装-Encapsulation" class="headerlink" title="1.2.1 封装 Encapsulation"></a>1.2.1 封装 Encapsulation</h3><pre><code>public class Wallet {  private String id;  private long createTime;  private BigDecimal balance;  private long balanceLastModifiedTime;  // ...省略其他属性...  public Wallet() {     this.id = IdGenerator.getInstance().generate();     this.createTime = System.currentTimeMillis();     this.balance = BigDecimal.ZERO;     this.balanceLastModifiedTime = System.currentTimeMillis();  }  // 注意：下面对get方法做了代码折叠，是为了减少代码所占文章的篇幅  public String getId() { return this.id; }  public long getCreateTime() { return this.createTime; }  public BigDecimal getBalance() { return this.balance; }  public long getBalanceLastModifiedTime() { return this.balanceLastModifiedTime;  }  public void increaseBalance(BigDecimal increasedAmount) {    if (increasedAmount.compareTo(BigDecimal.ZERO) &lt; 0) {      throw new InvalidAmountException(&quot;...&quot;);    }    this.balance.add(increasedAmount);    this.balanceLastModifiedTime = System.currentTimeMillis();  }  public void decreaseBalance(BigDecimal decreasedAmount) {    if (decreasedAmount.compareTo(BigDecimal.ZERO) &lt; 0) {      throw new InvalidAmountException(&quot;...&quot;);    }    if (decreasedAmount.compareTo(this.balance) &gt; 0) {      throw new InsufficientAmountException(&quot;...&quot;);    }    this.balance.subtract(decreasedAmount);    this.balanceLastModifiedTime = System.currentTimeMillis();  }}</code></pre><p>虚拟钱包，对于自身变量，用private来标注，然后通过对应的getter，setter方法允许外界来访问一部分变量，允许进行一定的修改。</p><p>没有封装则意味着不可控，即任何代码都可以被任何人访问，修改的代码可以遍布在包的任何角落，会影响代码的可读性，以及可维护性。只暴露出有限多的接口，供外界来使用。</p><p>总结： 封装是为了隐藏信息，保护数据</p><h3 id="1-2-2-继承-Inheritance"><a href="#1-2-2-继承-Inheritance" class="headerlink" title="1.2.2 继承 Inheritance"></a>1.2.2 继承 Inheritance</h3><p>用来表述is a的关系，java支持单继承。</p><p>继承最大的好处就是代码复用，比如两个子类的共同代码抽取到父类当中，然后父类来共同使用。</p><p>但是过度使用的话会容易导致层级数量太多，反而降低代码的可读性。</p><h3 id="1-2-3-多态-Polymorphism"><a href="#1-2-3-多态-Polymorphism" class="headerlink" title="1.2.3 多态 Polymorphism"></a>1.2.3 多态 Polymorphism</h3><ul><li>继承加方法重写实现</li></ul><pre><code>public class DynamicArray {  private static final int DEFAULT_CAPACITY = 10;  protected int size = 0;  protected int capacity = DEFAULT_CAPACITY;  protected Integer[] elements = new Integer[DEFAULT_CAPACITY];  public int size() { return this.size; }  public Integer get(int index) { return elements[index];}  //...省略n多方法...  public void add(Integer e) {    ensureCapacity();    elements[size++] = e;  }  protected void ensureCapacity() {    //...如果数组满了就扩容...代码省略...  }}public class SortedDynamicArray extends DynamicArray {  @Override  public void add(Integer e) {    ensureCapacity();    int i;    for (i = size-1; i&gt;=0; --i) { //保证数组中的数据有序      if (elements[i] &gt; e) {        elements[i+1] = elements[i];      } else {        break;      }    }    elements[i+1] = e;    ++size;  }}public class Example {  public static void test(DynamicArray dynamicArray) {    dynamicArray.add(5);    dynamicArray.add(1);    dynamicArray.add(3);    for (int i = 0; i &lt; dynamicArray.size(); ++i) {      System.out.println(dynamicArray.get(i));    }  }  public static void main(String args[]) {    DynamicArray dynamicArray = new SortedDynamicArray();    test(dynamicArray); // 打印结果：1、3、5  }}</code></pre><ul><li>利用接口类实现多态特性</li></ul><pre><code>public interface Iterator {  String hasNext();  String next();  String remove();}public class Array implements Iterator {  private String[] data;  public String hasNext() { ... }  public String next() { ... }  public String remove() { ... }  //...省略其他方法...}public class LinkedList implements Iterator {  private LinkedListNode head;  public String hasNext() { ... }  public String next() { ... }  public String remove() { ... }  //...省略其他方法... }public class Demo {  private static void print(Iterator iterator) {    while (iterator.hasNext()) {      System.out.println(iterator.next());    }  }  public static void main(String[] args) {    Iterator arrayIterator = new Array();    print(arrayIterator);    Iterator linkedListIterator = new LinkedList();    print(linkedListIterator);  }}</code></pre><p>多态可以很大程度上提高代码的可扩展性和复用性</p><h3 id="1-2-4-抽象-Abstraction"><a href="#1-2-4-抽象-Abstraction" class="headerlink" title="1.2.4 抽象 Abstraction"></a>1.2.4 抽象 Abstraction</h3><p>抽象，主要是为了隐藏方法的具体实现，让调用者只需要关心方法提供了哪些功能，并不需要知道这些方法具体是如何实现的。</p><pre><code>public interface IPictureStorage {  void savePicture(Picture picture);  Image getPicture(String pictureId);  void deletePicture(String pictureId);  void modifyMetaInfo(String pictureId, PictureMetaInfo metaInfo);}public class PictureStorage implements IPictureStorage {  // ...省略其他属性...  @Override  public void savePicture(Picture picture) { ... }  @Override  public Image getPicture(String pictureId) { ... }  @Override  public void deletePicture(String pictureId) { ... }  @Override  public void modifyMetaInfo(String pictureId, PictureMetaInfo metaInfo) { ... }}</code></pre><p>使用接口或者abstract class，然后调用者就只需要知道需要传入什么参数，传出什么参数，就可以试用了。</p><h1 id="2-面向对象-vs-面向过程"><a href="#2-面向对象-vs-面向过程" class="headerlink" title="2. 面向对象 vs 面向过程"></a>2. 面向对象 vs 面向过程</h1><p>需要对这两个概念有更深的理解，很多时候，我们是在用面向对象的语言写面向过程的代码，对于到底什么是面向对象，如何写真的面向对象的代码，我们还是有很多无法确定的地方。</p><p>面向过程的编程是一种编程范式，以过程(方法，函数，操作)作为组织代码的基本单元，以数据(可以理解为成员变量，属性)与方法相分离为最主要的特点。面向过程风格是一种流程化的编程风格，通过拼接一组顺序执行的方法来操作数据完成一项功能。</p><h2 id="2-1-面向对象编程的优势"><a href="#2-1-面向对象编程的优势" class="headerlink" title="2.1 面向对象编程的优势"></a>2.1 面向对象编程的优势</h2><h3 id="2-1-1-更能够应对大规模复杂程序的开发"><a href="#2-1-1-更能够应对大规模复杂程序的开发" class="headerlink" title="2.1.1 更能够应对大规模复杂程序的开发"></a>2.1.1 更能够应对大规模复杂程序的开发</h3><p>因为对于面向过程的编程风格来说，整个程序的处理流程会偏向于线性，流程化，但是实际应用场景中，关系错综复杂，会很难将程序拆解为一组顺序执行的方法。而面向对象的方式就可以比较好的解决这个问题了。</p><h3 id="2-1-2-更易复用，扩展和维护"><a href="#2-1-2-更易复用，扩展和维护" class="headerlink" title="2.1.2 更易复用，扩展和维护"></a>2.1.2 更易复用，扩展和维护</h3><p>面向对象通过类这种组织方式能够将数据和方法绑定在一起，通过访问权限控制，只允许外部调用者通过类暴露的有限方法访问数据，而不会像面向过程编程那样，数据可以被任意方法的随意修改</p><p>我们通过使用多态的特性，可以在需要修改一个功能实现的时候，通过实现一个新的子类的方式，在子类当中重写原来的功能逻辑，用子类替代父类。 —- 对修改关闭，对扩展开放。</p><h2 id="2-2-Warning-Bad-Smell-看似面向对象的面向过程的代码"><a href="#2-2-Warning-Bad-Smell-看似面向对象的面向过程的代码" class="headerlink" title="2.2 Warning/ Bad Smell - 看似面向对象的面向过程的代码"></a>2.2 Warning/ Bad Smell - 看似面向对象的面向过程的代码</h2><p>首先值得注意的是，这里提及的都是我们需要注意的地方，但并不是说我们完全不能这样子写。譬如util class，很多时候我们是需要的，因为确实可以不带数据的，只在input，output传递所有信息就够了。</p><h3 id="2-2-1-getter-setter方法的问题"><a href="#2-2-1-getter-setter方法的问题" class="headerlink" title="2.2.1 getter setter方法的问题"></a>2.2.1 getter setter方法的问题</h3><p>当我们习惯性的给所有的属性都加上getter， setter方法的时候，其实是破坏了Java的封装的特性的，我们使用private 标注属性，再适当的设置setter，getter方法是因为我们不想将对于代码/数据的控制权交给他人，而疯狂的getter，setter方法会让Java的封装优势荡然无存，只是从原来的直接访问属性变成通过getter，setter方法来访问。没有起到任何保障安全的作用。</p><p>注意如果是集合容器的话，要防范集合内部的数据被修改的危险。另外，setter方法的使用需要谨慎些，只有在必需的时候再用。</p><h3 id="2-2-2-全局变量和全局方法"><a href="#2-2-2-全局变量和全局方法" class="headerlink" title="2.2.2 全局变量和全局方法"></a>2.2.2 全局变量和全局方法</h3><p>常见的全局变量有：</p><ul><li>单例类对象</li><li>静态成员变量</li><li>常量</li></ul><p>常见的全局方法有：</p><ul><li>静态方法</li></ul><p>Constants类往往会越加越大，而且会很难维护。而且如果我们开发的其他项目需要复用这些constants，哪怕我们只使用一个，那么最终也会不得不将整个文件加载进去，没有必要，而且会变得非常的慢。我们可以将Constants类拆分为功能更加单一的多个类，或者直接将这些常量定义到对应的class当中。这也是个很好的选择。</p><h2 id="3-1-什么是接口？-什么是抽象类？"><a href="#3-1-什么是接口？-什么是抽象类？" class="headerlink" title="3.1 什么是接口？ 什么是抽象类？"></a>3.1 什么是接口？ 什么是抽象类？</h2><h3 id="3-1-1-抽象类定义"><a href="#3-1-1-抽象类定义" class="headerlink" title="3.1.1 抽象类定义"></a>3.1.1 抽象类定义</h3><p>下面是一个模板设计的实例，Logger被用来记录日志，FileLogger和MessageQueueLogger继承Logger，分别实现两种不同的日志记录方式</p><pre><code>// 抽象类public abstract class Logger {  private String name;  private boolean enabled;  private Level minPermittedLevel;  public Logger(String name, boolean enabled, Level minPermittedLevel) {    this.name = name;    this.enabled = enabled;    this.minPermittedLevel = minPermittedLevel;  }  public void log(Level level, String message) {    boolean loggable = enabled &amp;&amp; (minPermittedLevel.intValue() &lt;= level.intValue());    if (!loggable) return;    doLog(level, message);  }  protected abstract void doLog(Level level, String message);}// 抽象类的子类：输出日志到文件public class FileLogger extends Logger {  private Writer fileWriter;  public FileLogger(String name, boolean enabled,    Level minPermittedLevel, String filepath) {    super(name, enabled, minPermittedLevel);    this.fileWriter = new FileWriter(filepath);   }  @Override  public void doLog(Level level, String mesage) {    // 格式化level和message,输出到日志文件    fileWriter.write(...);  }}// 抽象类的子类: 输出日志到消息中间件(比如kafka)public class MessageQueueLogger extends Logger {  private MessageQueueClient msgQueueClient;  public MessageQueueLogger(String name, boolean enabled,    Level minPermittedLevel, MessageQueueClient msgQueueClient) {    super(name, enabled, minPermittedLevel);    this.msgQueueClient = msgQueueClient;  }  @Override  protected void doLog(Level level, String mesage) {    // 格式化level和message,输出到消息中间件    msgQueueClient.send(...);  }}</code></pre><p>抽象类的特性：</p><ul><li>抽象类不允许被实例化，只能被继承  </li><li>抽象类可以包含属性与方法，方法可以包含代码实现，也可以不包含，设计成抽象方法</li><li>子类继承抽象类，必须实现抽象类当中的所有抽象方法</li></ul><h3 id="3-1-2-接口定义"><a href="#3-1-2-接口定义" class="headerlink" title="3.1.2 接口定义"></a>3.1.2 接口定义</h3><pre><code>// 接口public interface Filter {  void doFilter(RpcRequest req) throws RpcException;}// 接口实现类：鉴权过滤器public class AuthencationFilter implements Filter {  @Override  public void doFilter(RpcRequest req) throws RpcException {    //...鉴权逻辑..  }}// 接口实现类：限流过滤器public class RateLimitFilter implements Filter {  @Override  public void doFilter(RpcRequest req) throws RpcException {    //...限流逻辑...  }}// 过滤器使用demopublic class Application {  // filters.add(new AuthencationFilter());  // filters.add(new RateLimitFilter());  private List&lt;Filter&gt; filters = new ArrayList&lt;&gt;();  public void handleRpcRequest(RpcRequest req) {    try {      for (Filter filter : fitlers) {        filter.doFilter(req);      }    } catch(RpcException e) {      // ...处理过滤结果...    }    // ...省略其他处理逻辑...  }}</code></pre><p>使用interface关键字实现一个Filter接口，AuthencationFilter和RatelimiterFilter分别实现对于RPC请求的鉴权和限流的过滤功能。</p><ul><li>接口不能包含属性</li><li>接口只能声明方法，方法不能包含代码实现</li><li>类实现接口的时候，必须实现接口当中声明的所有方法</li></ul><p>抽象类和继承类似，其实表征的是一种is-a的关系；而接口表征的是一种has-a的关系/ 协议，表示具有某些功能 </p><h2 id="3-2-区别-都能解决什么样的编程问题？"><a href="#3-2-区别-都能解决什么样的编程问题？" class="headerlink" title="3.2 区别/ 都能解决什么样的编程问题？"></a>3.2 区别/ 都能解决什么样的编程问题？</h2><h3 id="3-2-1-抽象类-存在的意义"><a href="#3-2-1-抽象类-存在的意义" class="headerlink" title="3.2.1 抽象类 存在的意义"></a>3.2.1 抽象类 存在的意义</h3><p>抽象类不能实例化，只能被继承。主要是用来解决代码复用的问题的。多个子类可以继承抽象类当中定义的属性和方法，避免在子类当中，重复编写相同的代码。</p><p>为什么必须是抽象类来做代码复用呢？ </p><ul><li>因为可以利用多态来做了</li><li>减少父类代码被错误的直接使用的风险</li><li>也可以增加代码的可读性</li></ul><h3 id="3-2-2-接口的存在意义"><a href="#3-2-2-接口的存在意义" class="headerlink" title="3.2.2 接口的存在意义"></a>3.2.2 接口的存在意义</h3><p>接口更侧重于解耦，接口是对行为的一种抽象，相当于一组协议或者契约。这样调用者只需要关注抽象的接口，不需要了解具体的实现</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://github.com/gdhucoder/Algorithms4/blob/master/designpattern/pic/umlcheatsheet.jpg" target="_blank" rel="noopener">https://github.com/gdhucoder/Algorithms4/blob/master/designpattern/pic/umlcheatsheet.jpg</a> </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这篇博文主要想说面向对象的几大特性：封装，抽象，继承，多态，以及我们究竟如何去使用。&lt;/p&gt;
&lt;h1 id=&quot;1-面向对象概述&quot;&gt;&lt;a href=&quot;#1-面向对象概述&quot; class=&quot;headerlink&quot; title=&quot;1. 面向对象概述&quot;&gt;&lt;/a&gt;1. 面向对象概述&lt;/
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="OOP" scheme="https://www.llchen60.com/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>设计模式概述</title>
    <link href="https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/"/>
    <id>https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/</id>
    <published>2020-02-21T22:58:10.000Z</published>
    <updated>2020-02-23T17:10:22.625Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-起源"><a href="#1-起源" class="headerlink" title="1. 起源"></a>1. 起源</h1><p>每个模式都描述了一个在我们的环境中不断出现的问题，然后描述了该问题的解决方案的核心，通过这种方式，我们可以无数次重用那些已有的成功的解决方案，无须再重复相同的工作。</p><p>软件模式(Software Patterns)是将模式的一般概念应用于软件开发领域，即软件开发的总体指导思路或参照样板。软件模式并非仅限于设计模式，还包括架构模式、分析模式和过程模式等，<strong><em>实际上，在软件开发生命周期的每一个阶段都存在着一些被认同的模式</em></strong>。</p><p>想要学习设计模式的原因，是因为感到自己的代码能力还是有点捉急，可以写出能用的代码，但很难写出好看的代码，如果每次写代码的时候都要一行一行的来构建，而没有一个组件一个组件的意识的话，那写好代码恐怕只能是天方夜谭了。我想设计模式对我来说，就是抽象，构建框架的过程，是真真切切能够在日常工作当中帮助到自己的。不仅仅在于代码质量，也在于组件化以后的开发速度，以及对于更加复杂的商业上的实际场景得以提供出更加匹配的解决方式的能力。</p><p>另外一个点是当前我的能力范畴还是仅仅在于根据需求写出代码，即停留在写业务代码的阶段，在这个阶段当中，自己并不需要具有很强的代码设计能力，理解业务就可以写出代码了。但是如果想要成长，还是需要具备写出<strong>和业务并不直接相关的更加通用的功能模块</strong>的能力的。</p><h1 id="2-软件模式的基础结构"><a href="#2-软件模式的基础结构" class="headerlink" title="2. 软件模式的基础结构"></a>2. 软件模式的基础结构</h1><ul><li>问题描述</li><li>前提条件</li><li>解法</li><li>效果</li></ul><h2 id="2-1-评价代码的一些维度"><a href="#2-1-评价代码的一些维度" class="headerlink" title="2.1 评价代码的一些维度"></a>2.1 评价代码的一些维度</h2><p>关于如何判断一段代码写的好坏，众说纷纭，每个人其实都有自己主观上的某些看法。但是在更高维度上来说，会有一些相对能达成共识的标准，是我们可以在平常写代码的时候更多的注意一下的。</p><h3 id="2-1-1-可维护性-maintainability"><a href="#2-1-1-可维护性-maintainability" class="headerlink" title="2.1.1 可维护性 maintainability"></a>2.1.1 可维护性 maintainability</h3><ul><li>在不破坏原有代码的设计，不引入新的bug的情况下，能够快速地修改或者添加代码</li><li>细拆分其实就有很多因素的协同作用了<ul><li>代码的可读性，简洁</li><li>代码分层清晰程度，模块化，高内聚低耦合</li><li>基于接口而非实现编程</li></ul></li></ul><h3 id="2-1-2-可读性-readability"><a href="#2-1-2-可读性-readability" class="headerlink" title="2.1.2 可读性 readability"></a>2.1.2 可读性 readability</h3><ul><li>命名</li><li>注释</li><li>函数的长短</li><li>模块的划分</li></ul><h3 id="2-1-3-可扩展性-extensibility"><a href="#2-1-3-可扩展性-extensibility" class="headerlink" title="2.1.3 可扩展性  extensibility"></a>2.1.3 可扩展性  extensibility</h3><p>表征的是我们的代码对未来需求变化进行应对的能力。</p><p>即代码预留了一些功能的扩展点，我们可以将新功能代码直接插入到扩展点上，而不需要因为添加一个功能而大动干戈，改动大量的原始代码。</p><h3 id="2-1-4-灵活性-flexibility"><a href="#2-1-4-灵活性-flexibility" class="headerlink" title="2.1.4 灵活性  flexibility"></a>2.1.4 灵活性  flexibility</h3><ul><li>比如预留好了扩展点给新的功能代码来使用</li><li>代码已经抽象出了很多底层可以复用的模块，类</li></ul><h3 id="2-1-5-简洁性-simplicity"><a href="#2-1-5-简洁性-simplicity" class="headerlink" title="2.1.5 简洁性   simplicity"></a>2.1.5 简洁性   simplicity</h3><p>Keep it simple, stupid. </p><h3 id="2-1-6-可复用性-reusability"><a href="#2-1-6-可复用性-reusability" class="headerlink" title="2.1.6 可复用性  reusability"></a>2.1.6 可复用性  reusability</h3><p>尽量减少重复代码的编写，复用已有的代码</p><h3 id="2-1-7-可测试性-testability"><a href="#2-1-7-可测试性-testability" class="headerlink" title="2.1.7 可测试性  testability"></a>2.1.7 可测试性  testability</h3><p>比较难写的单元测试往往意味着代码的设计是有问题的。</p><p>如果说上面的细节实在是太多，并不能一下子很快的掌握，个人感觉，去看别人的设计，别人的代码，和自己的比较，会是非常快的成长方式。除此以外，肯定还是要经过看山是山，不是山，还是山的阶段的。希望自己的代码最终能像一个故事一样，将一段逻辑讲述完整。</p><h1 id="3-设计模式"><a href="#3-设计模式" class="headerlink" title="3. 设计模式"></a>3. 设计模式</h1><blockquote><p>设计模式(Design Pattern)是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结，使用设计模式是为了可重用代码、让代码更容易被他人理解并且保证代码可靠性。</p></blockquote><p>整个设计模式系列将会分以下几个部分：</p><ol><li><p>概述</p></li><li><p>面向对象设计原则</p><ul><li>单一职责</li><li>开闭原则</li><li>里氏代换</li><li>依赖倒转</li><li>接口隔离</li><li>合成复用</li><li>迪米特</li></ul></li><li><p>创建型模式（描述如何创建对象）</p><ul><li>简单工厂模式</li><li>工厂方法模式</li><li>抽象工厂模式</li><li>单例模式</li><li>原型模式</li><li>建造者模式</li></ul></li><li><p>结构型模式（如何实现类或对象的组合）</p><ul><li>适配器模式</li><li>桥接模式</li><li>组合模式</li><li>装饰模式</li><li>外观模式</li><li>享元模式</li><li>代理模式</li></ul></li><li><p>行为型模式（类或者对象怎样交互以及怎样分配职责）（类是对一类事物的描述，抽象出来的；而对象是具体的描述。类是一群具有相同属性的对象的集合体）</p><ul><li>职责链模式</li><li>命令模式</li><li>解释器模式</li><li>迭代器模式</li><li>中介者模式</li><li>备忘录模式</li><li>观察者模式</li><li>状态模式</li><li>策略模式</li><li>模板方法模式</li><li>访问者模式</li></ul></li></ol><h1 id="4-面向对象，设计原则，设计模式，编程规范，代码重构"><a href="#4-面向对象，设计原则，设计模式，编程规范，代码重构" class="headerlink" title="4. 面向对象，设计原则，设计模式，编程规范，代码重构"></a>4. 面向对象，设计原则，设计模式，编程规范，代码重构</h1><h2 id="4-1-面向对象"><a href="#4-1-面向对象" class="headerlink" title="4.1 面向对象"></a>4.1 面向对象</h2><p>主流的编程范式有：</p><ul><li>面向过程</li><li>面向对象</li><li>函数式编程</li></ul><p>面向对象因为其具有的丰富的特性 - 封装，继承，抽象，多态。可以实现很多复杂的设计思路，是很多设计原则，设计模式的实现基础。</p><ul><li>知识点<ul><li>封装 继承 抽象 多态</li><li>面向对象与面向过程编程的区别与联系</li><li>面向对象的分析设计和编程</li><li>接口和抽象类的区别以及各自的应用场景</li><li>基于接口而非实现的编程设计思想</li><li>多用组合少用继承的设计思想</li><li>面向过程的贫血模型和面向对象的充血模型<h2 id="4-2-设计原则"><a href="#4-2-设计原则" class="headerlink" title="4.2 设计原则"></a>4.2 设计原则</h2></li></ul></li><li>设计原则<ul><li>单一职责原则</li><li>开闭原则</li><li>里氏替换原则</li><li>接口隔离原则</li><li>依赖导致原则</li><li>DRY</li><li>KISS</li><li>YAGNI</li><li>LOD</li></ul></li></ul><h2 id="4-3-设计模式"><a href="#4-3-设计模式" class="headerlink" title="4.3 设计模式"></a>4.3 设计模式</h2><ul><li>设计模式<ul><li>为了解决代码的可扩展性问题</li><li>需要掌握他们都解决了哪些问题，典型的应用场景，并且不能也不应该过度使用</li><li>创建型<ul><li>单例模式</li><li>工厂模式</li><li>建造者模式</li></ul></li><li>结构型<ul><li>代理模式</li><li>桥接模式</li><li>装饰者模式</li><li>适配器模式</li></ul></li><li>行为型<ul><li>观察者模式</li><li>模板模式</li><li>策略模式</li><li>职责链模式</li><li>迭代器模式</li><li>状态模式</li></ul></li></ul></li></ul><h2 id="4-4-编程规范"><a href="#4-4-编程规范" class="headerlink" title="4.4 编程规范"></a>4.4 编程规范</h2><p>主要为了解决代码的可读性问题，这些规范主要是记忆，熟悉，然后尽量多的去使用。书籍的话可以去看重构，代码大全，代码整洁之道这几本书。</p><h2 id="4-5-代码重构"><a href="#4-5-代码重构" class="headerlink" title="4.5 代码重构"></a>4.5 代码重构</h2><p>业务发展，规模扩大，原先的设计很可能无法支持现在的体量的应用场景，这种情况下就需要持续重构了。而是用的工具就是我们前面说的设计模式，编程规范等等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-起源&quot;&gt;&lt;a href=&quot;#1-起源&quot; class=&quot;headerlink&quot; title=&quot;1. 起源&quot;&gt;&lt;/a&gt;1. 起源&lt;/h1&gt;&lt;p&gt;每个模式都描述了一个在我们的环境中不断出现的问题，然后描述了该问题的解决方案的核心，通过这种方式，我们可以无数次重用那些
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="Design Pattern" scheme="https://www.llchen60.com/tags/Design-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>PowerMock with EasyMock toturial</title>
    <link href="https://www.llchen60.com/Powermock-with-EasyMock-toturial/"/>
    <id>https://www.llchen60.com/Powermock-with-EasyMock-toturial/</id>
    <published>2020-02-21T05:11:10.000Z</published>
    <updated>2020-02-21T05:11:57.519Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Intro-with-an-example"><a href="#1-Intro-with-an-example" class="headerlink" title="1. Intro with an example"></a>1. Intro with an example</h1><p>We often find we need to do unit tests for final class, static method, which are not supported by Easymock, Mockito currently. Under such situation, we could use Powermock to help us mock the corresponding classes. </p><p>For detail introduction about powermock, refer to <a href="https://github.com/powermock/powermock" target="_blank" rel="noopener">PowerMock Github</a></p><p>Use example as followed to show how to integrate PowerMock with EasyMock: </p><pre><code>public final class FinalClassExample {    public String static doNothingStatic() {        return &quot;test&quot;;    }}@PowerMockIgnore(&quot;javax.management.*&quot;) // only need when see warning related with jmx or mbeans@RunWith(PowerMockRunner.class)  // necessary for powermock @PrepareForTest(FinalClassExample.class)  // necessary for powermock public class FinalClassExampleTest {    private IMocksControl control;    @Before    public void init() {        // do some initialization here         control = EasyMock.createControl();    }    @Test    public void test_example() {        PowerMock.mockStatic(FinalClassExample.class);        expect(FinalClassExample.doNothingStatic()).andReturn(&quot;test&quot;);        PowerMock.replay(FinalClassExample.class);        runYourTest();        PowerMock.verify(FinalClassExample.class);        // do some assertions here    }}</code></pre><h1 id="2-Other-APIs"><a href="#2-Other-APIs" class="headerlink" title="2. Other APIs"></a>2. Other APIs</h1><ul><li>mock final classes or methods <ul><li><code>@RunWith(PowerMockRunner.class)</code></li><li><code>@PrepareForTest(ClassWithFinal.class)</code></li><li><code>PowerMock.createMock(ClassWithFinal.class);</code></li><li><code>PowerMock.replay(mockObject)</code></li><li><code>PowerMock.verify(mockObject)</code></li></ul></li><li>mock private methods <ul><li><code>@RunWith(PowerMockRunner.class)</code></li><li><code>@PrepareForTest(ClassWithPrivateMethod.class)</code></li><li><code>PowerMock.createPartialMock(ClassWithPrivateMethod.class, &quot;nameOfTheMethodToMock&quot;)</code></li><li>Use <code>PowerMock.expectPrivate(mockObject, &quot;nameOfTheMethodToMock&quot;, argument1, argument2)</code> to expect the method call to <code>nameOfTheMethodToMock</code> with arguments <code>argument1</code> and <code>argument2</code></li><li><code>PowerMock.replay(mockObject)</code></li><li><code>PowerMock.verify(mockObject)</code></li></ul></li><li>mock construction of new objects <ul><li><code>@RunWith(PowerMockRunner.class)</code></li><li><code>@PrepareForTest(ClassThatCreatesTheNewInstance.class)</code> </li><li><code>PowerMock.createMock(NewInstanceClass.class)</code></li><li><code>PowerMock.expectNew(NewInstanceClass.class).andReturn(mockObject)</code></li><li><code>PowerMock.replay(mockObject, NewInstanceClass.class)</code></li><li><code>PowerMock.verify(mockObject, NewInstanceClass.class)</code></li></ul></li><li>mock partial <ul><li><code>@RunWith(PowerMockRunner.class)</code></li><li><code>@PrepareForTest(ClassToPartiallyMock.class)</code></li><li><code>PowerMock.createPartialMock(ClassToPartiallyMock.class, &quot;nameOfTheFirstMethodToMock&quot;, &quot;nameOfTheSecondMethodToMock&quot;)</code></li><li><code>PowerMock.replay(mockObject)</code></li><li><code>PowerMock.verify(mockObject)</code></li></ul></li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://github.com/powermock/powermock" target="_blank" rel="noopener">https://github.com/powermock/powermock</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Intro-with-an-example&quot;&gt;&lt;a href=&quot;#1-Intro-with-an-example&quot; class=&quot;headerlink&quot; title=&quot;1. Intro with an example&quot;&gt;&lt;/a&gt;1. Intro with an
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
      <category term="Unit Test" scheme="https://www.llchen60.com/tags/Unit-Test/"/>
    
      <category term="PowerMock" scheme="https://www.llchen60.com/tags/PowerMock/"/>
    
  </entry>
  
  <entry>
    <title>工程师需要知道的latency 数字 </title>
    <link href="https://www.llchen60.com/%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84latency-%E6%95%B0%E5%AD%97/"/>
    <id>https://www.llchen60.com/%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84latency-%E6%95%B0%E5%AD%97/</id>
    <published>2020-02-21T05:08:38.000Z</published>
    <updated>2020-02-21T05:10:12.077Z</updated>
    
    <content type="html"><![CDATA[<p>看到一篇博客，叙述了当前内存对于数据的处理速度对于开发的影响，推而广之，找到了一些我们在做系统设计的时候需要熟知的一些数据。</p><p>首先处理器的处理速度和内存的处理速度是差距很大的，处理器的处理速度的增长速度要比内存的快很多。</p><p><img src="https://i.loli.net/2020/02/21/s8h6GTfi1PSYwpe.png" alt="处理器与内存的性能表现.png"></p><p>我们需要探究的是CPU从内存中随机提取数据以及获取连续数据的速度，这是很粗略的估计，只是希望能够有一个数量级上的感知。</p><pre><code>Latency Comparison Numbers (~2012)----------------------------------L1 cache reference                           0.5 nsBranch mispredict                            5   nsL2 cache reference                           7   ns                      14x L1 cacheMutex lock/unlock                           25   nsMain memory reference                      100   ns                      20x L2 cache, 200x L1 cacheCompress 1K bytes with Zippy             3,000   ns        3 usSend 1K bytes over 1 Gbps network       10,000   ns       10 usRead 4K randomly from SSD*             150,000   ns      150 us          ~1GB/sec SSDRead 1 MB sequentially from memory     250,000   ns      250 usRound trip within same datacenter      500,000   ns      500 usRead 1 MB sequentially from SSD*     1,000,000   ns    1,000 us    1 ms  ~1GB/sec SSD, 4X memoryDisk seek                           10,000,000   ns   10,000 us   10 ms  20x datacenter roundtripRead 1 MB sequentially from disk    20,000,000   ns   20,000 us   20 ms  80x memory, 20X SSDSend packet CA-&gt;Netherlands-&gt;CA    150,000,000   ns  150,000 us  150 ms</code></pre><p>根据2020年StackOverflow上的回答，我们可以看到Core i7 Xeon 5500 的benchmark数据如下</p><pre><code>Core i7 Xeon 5500 Series Data Source Latency (approximate)               [Pg. 22]local  L1 CACHE hit,                              ~4 cycles (   2.1 -  1.2 ns )local  L2 CACHE hit,                             ~10 cycles (   5.3 -  3.0 ns )local  L3 CACHE hit, line unshared               ~40 cycles (  21.4 - 12.0 ns )local  L3 CACHE hit, shared line in another core ~65 cycles (  34.8 - 19.5 ns )local  L3 CACHE hit, modified in another core    ~75 cycles (  40.2 - 22.5 ns )remote L3 CACHE (Ref: Fig.1 [Pg. 5])        ~100-300 cycles ( 160.7 - 30.0 ns )local  DRAM                                                   ~60 nsremote DRAM                                                  ~100 ns</code></pre><p>而现在的cache的大小，根据wikiChip上的数据，对于Core i7-8700K</p><pre><code>Memory Bandwidth: 39.74 gigabytes per secondL1 cache: 192 kilobytes (32 KB per core)L2 cache: 1.5 megabytes (256 KB per core)L3 cache: 12 megabytes  (shared; 2 MB per core)</code></pre><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://www.forrestthewoods.com/blog/memory-bandwidth-napkin-math/" target="_blank" rel="noopener">https://www.forrestthewoods.com/blog/memory-bandwidth-napkin-math/</a>?</li><li><a href="https://stackoverflow.com/questions/4087280/approximate-cost-to-access-various-caches-and-main-memory" target="_blank" rel="noopener">https://stackoverflow.com/questions/4087280/approximate-cost-to-access-various-caches-and-main-memory</a></li><li><a href="https://en.wikichip.org/wiki/intel/core_i7/i7-8700k" target="_blank" rel="noopener">https://en.wikichip.org/wiki/intel/core_i7/i7-8700k</a></li><li><a href="https://gist.github.com/jboner/2841832" target="_blank" rel="noopener">https://gist.github.com/jboner/2841832</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;看到一篇博客，叙述了当前内存对于数据的处理速度对于开发的影响，推而广之，找到了一些我们在做系统设计的时候需要熟知的一些数据。&lt;/p&gt;
&lt;p&gt;首先处理器的处理速度和内存的处理速度是差距很大的，处理器的处理速度的增长速度要比内存的快很多。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;ht
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="latency" scheme="https://www.llchen60.com/tags/latency/"/>
    
      <category term="system design" scheme="https://www.llchen60.com/tags/system-design/"/>
    
  </entry>
  
  <entry>
    <title>Java8 Date Time API </title>
    <link href="https://www.llchen60.com/Java8-Date-Time-API/"/>
    <id>https://www.llchen60.com/Java8-Date-Time-API/</id>
    <published>2020-02-20T03:08:47.000Z</published>
    <updated>2020-02-20T03:09:12.256Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-为什么需要新的Date-API"><a href="#1-为什么需要新的Date-API" class="headerlink" title="1. 为什么需要新的Date API"></a>1. 为什么需要新的Date API</h1><p>Java8 的一大更新在于终于将Date Time一致化，这解决了在Java8以前我们观察到的非常多的问题：</p><p>譬如：</p><ul><li>Java Date Time类定义在不同的地方，比如在java.util &amp; java.sql里面都有，而样式和格式转化的类都定义在java.text的包里，比较混乱</li><li>java.util.Date包括date和time类，而java.sql.Date只包含date</li><li>并没有清晰定义的类用于处理time, timestamp, formatting, parsing </li><li>所有的Date类都是可变的，并不是线程安全的</li><li>Date类不支持全球化，没有时区的支持，在java8之前，为了显示当地时间，就得使用java.util.Calendar 还有 java.util.TimeZone,整个变得比较麻烦</li></ul><h1 id="2-Java8-Date-Time-API-详解"><a href="#2-Java8-Date-Time-API-详解" class="headerlink" title="2. Java8 Date Time API 详解"></a>2. Java8 Date Time API 详解</h1><h2 id="2-1-Packages"><a href="#2-1-Packages" class="headerlink" title="2.1 Packages"></a>2.1 Packages</h2><ul><li>java.time Package <ul><li>这是新的Date Time API的基础包，一些主要的基本类都在这里面，譬如LocalDate, LocalTime, LocalDateTime, Instant, Period, Duration  </li></ul></li><li>java.time.chrono <ul><li>定义了抽象的API接口，针对于非ISO标准的calendar 系统，我们可以通过extend AbstractChronology类来创建我们自己的calendar系统</li></ul></li><li>java.time.format <ul><li>包含用来Formatting还有parsing date time对象的类</li></ul></li><li>java.time.temporal <ul><li>包含一些时间对象，比如找到月份的第一天， 最后一天之类的</li></ul></li><li>java.time.zone<ul><li>支持不同的时区 </li></ul></li></ul><h2 id="2-2-LocalDate"><a href="#2-2-LocalDate" class="headerlink" title="2.2 LocalDate"></a>2.2 LocalDate</h2><ul><li>Immutable class </li><li>默认样式为 yyyy-MM-dd</li><li>我们可以使用<code>now()</code>方法来获得当前的日期</li><li>也可以通过提供年月日来创建localDate对象</li><li>我们同时也可以传入ZoneId来得到在特定的时区的日期</li></ul><pre><code>package com.journaldev.java8.time;import java.time.LocalDate;import java.time.Month;import java.time.ZoneId;/** * LocalDate Examples * @author pankaj * */public class LocalDateExample {    public static void main(String[] args) {        //Current Date        LocalDate today = LocalDate.now();        System.out.println(&quot;Current Date=&quot;+today);        //Creating LocalDate by providing input arguments        LocalDate firstDay_2014 = LocalDate.of(2014, Month.JANUARY, 1);        System.out.println(&quot;Specific Date=&quot;+firstDay_2014);        //Try creating date by providing invalid inputs        //LocalDate feb29_2014 = LocalDate.of(2014, Month.FEBRUARY, 29);        //Exception in thread &quot;main&quot; java.time.DateTimeException:         //Invalid date &#39;February 29&#39; as &#39;2014&#39; is not a leap year        //Current date in &quot;Asia/Kolkata&quot;, you can get it from ZoneId javadoc        LocalDate todayKolkata = LocalDate.now(ZoneId.of(&quot;Asia/Kolkata&quot;));        System.out.println(&quot;Current Date in IST=&quot;+todayKolkata);        //java.time.zone.ZoneRulesException: Unknown time-zone ID: IST        //LocalDate todayIST = LocalDate.now(ZoneId.of(&quot;IST&quot;));        //Getting date from the base date i.e 01/01/1970        LocalDate dateFromBase = LocalDate.ofEpochDay(365);        System.out.println(&quot;365th day from base date= &quot;+dateFromBase);        LocalDate hundredDay2014 = LocalDate.ofYearDay(2014, 100);        System.out.println(&quot;100th day of 2014=&quot;+hundredDay2014);    }}// output Current Date=2014-04-28Specific Date=2014-01-01Current Date in IST=2014-04-29365th day from base date= 1971-01-01100th day of 2014=2014-04-10</code></pre><h2 id="2-3-LocalTime"><a href="#2-3-LocalTime" class="headerlink" title="2.3 LocalTime"></a>2.3 LocalTime</h2><ul><li>Immutable Class </li><li>表示一个可读的时间 (vs Instant 基本不可读)</li><li>默认样式为 hh:mm:ss:zz</li><li>和LocalDate基本一致的用法，可以传入参数生成实例，支持时区</li></ul><pre><code>package com.journaldev.java8.time;import java.time.LocalTime;import java.time.ZoneId;/** * LocalTime Examples * @author pankaj * */public class LocalTimeExample {    public static void main(String[] args) {        //Current Time        LocalTime time = LocalTime.now();        System.out.println(&quot;Current Time=&quot;+time);        //Creating LocalTime by providing input arguments        LocalTime specificTime = LocalTime.of(12,20,25,40);        System.out.println(&quot;Specific Time of Day=&quot;+specificTime);        //Try creating time by providing invalid inputs        //LocalTime invalidTime = LocalTime.of(25,20);        //Exception in thread &quot;main&quot; java.time.DateTimeException:         //Invalid value for HourOfDay (valid values 0 - 23): 25        //Current date in &quot;Asia/Kolkata&quot;, you can get it from ZoneId javadoc        LocalTime timeKolkata = LocalTime.now(ZoneId.of(&quot;Asia/Kolkata&quot;));        System.out.println(&quot;Current Time in IST=&quot;+timeKolkata);        //java.time.zone.ZoneRulesException: Unknown time-zone ID: IST        //LocalTime todayIST = LocalTime.now(ZoneId.of(&quot;IST&quot;));        //Getting date from the base date i.e 01/01/1970        LocalTime specificSecondTime = LocalTime.ofSecondOfDay(10000);        System.out.println(&quot;10000th second time= &quot;+specificSecondTime);    }}// Output Current Time=15:51:45.240Specific Time of Day=12:20:25.000000040Current Time in IST=04:21:45.27610000th second time= 02:46:40</code></pre><h2 id="2-4-LocalDateTime"><a href="#2-4-LocalDateTime" class="headerlink" title="2.4 LocalDateTime"></a>2.4 LocalDateTime</h2><ul><li>Immutable date-time object </li><li>represent both date and time </li><li>default format at yyyy-MM-dd-HH-mm-ss.zzz </li><li>用工厂方法来拿到LocalDate和LocalTime的input 然后来创建LocalDateTime的实例</li></ul><pre><code>package com.journaldev.java8.time;import java.time.LocalDate;import java.time.LocalDateTime;import java.time.LocalTime;import java.time.Month;import java.time.ZoneId;import java.time.ZoneOffset;public class LocalDateTimeExample {    public static void main(String[] args) {        //Current Date        LocalDateTime today = LocalDateTime.now();        System.out.println(&quot;Current DateTime=&quot;+today);        //Current Date using LocalDate and LocalTime        today = LocalDateTime.of(LocalDate.now(), LocalTime.now());        System.out.println(&quot;Current DateTime=&quot;+today);        //Creating LocalDateTime by providing input arguments        LocalDateTime specificDate = LocalDateTime.of(2014, Month.JANUARY, 1, 10, 10, 30);        System.out.println(&quot;Specific Date=&quot;+specificDate);        //Try creating date by providing invalid inputs        //LocalDateTime feb29_2014 = LocalDateTime.of(2014, Month.FEBRUARY, 28, 25,1,1);        //Exception in thread &quot;main&quot; java.time.DateTimeException:         //Invalid value for HourOfDay (valid values 0 - 23): 25        //Current date in &quot;Asia/Kolkata&quot;, you can get it from ZoneId javadoc        LocalDateTime todayKolkata = LocalDateTime.now(ZoneId.of(&quot;Asia/Kolkata&quot;));        System.out.println(&quot;Current Date in IST=&quot;+todayKolkata);        //java.time.zone.ZoneRulesException: Unknown time-zone ID: IST        //LocalDateTime todayIST = LocalDateTime.now(ZoneId.of(&quot;IST&quot;));        //Getting date from the base date i.e 01/01/1970        LocalDateTime dateFromBase = LocalDateTime.ofEpochSecond(10000, 0, ZoneOffset.UTC);        System.out.println(&quot;10000th second time from 01/01/1970= &quot;+dateFromBase);    }}// OutputCurrent DateTime=2014-04-28T16:00:49.455Current DateTime=2014-04-28T16:00:49.493Specific Date=2014-01-01T10:10:30Current Date in IST=2014-04-29T04:30:49.49310000th second time from 01/01/1970= 1970-01-01T02:46:40</code></pre><h2 id="2-5-Instant"><a href="#2-5-Instant" class="headerlink" title="2.5 Instant"></a>2.5 Instant</h2><p>是为了生成机器阅读的时间格式，它会使用unix的时间戳来存储日期和时间</p><pre><code>package com.journaldev.java8.time;import java.time.Duration;import java.time.Instant;public class InstantExample {    public static void main(String[] args) {        //Current timestamp        Instant timestamp = Instant.now();        System.out.println(&quot;Current Timestamp = &quot;+timestamp);        //Instant from timestamp        Instant specificTime = Instant.ofEpochMilli(timestamp.toEpochMilli());        System.out.println(&quot;Specific Time = &quot;+specificTime);        //Duration example        Duration thirtyDay = Duration.ofDays(30);        System.out.println(thirtyDay);    }}// Output Current Timestamp = 2014-04-28T23:20:08.489ZSpecific Time = 2014-04-28T23:20:08.489ZPT720H</code></pre><h2 id="2-6-常用API"><a href="#2-6-常用API" class="headerlink" title="2.6 常用API"></a>2.6 常用API</h2><pre><code>package com.journaldev.java8.time;import java.time.LocalDate;import java.time.LocalTime;import java.time.Period;import java.time.temporal.TemporalAdjusters;public class DateAPIUtilities {    public static void main(String[] args) {        LocalDate today = LocalDate.now();        //得到年份，看是否为闰年        System.out.println(&quot;Year &quot;+today.getYear()+&quot; is Leap Year? &quot;+today.isLeapYear());        //比较两个时间的先后        System.out.println(&quot;Today is before 01/01/2015? &quot;+today.isBefore(LocalDate.of(2015,1,1)));        //从LocalDate创建LocalDateTime        System.out.println(&quot;Current Time=&quot;+today.atTime(LocalTime.now()));        //加减时间的操作        System.out.println(&quot;10 days after today will be &quot;+today.plusDays(10));        System.out.println(&quot;3 weeks after today will be &quot;+today.plusWeeks(3));        System.out.println(&quot;20 months after today will be &quot;+today.plusMonths(20));        System.out.println(&quot;10 days before today will be &quot;+today.minusDays(10));        System.out.println(&quot;3 weeks before today will be &quot;+today.minusWeeks(3));        System.out.println(&quot;20 months before today will be &quot;+today.minusMonths(20));        //时间上的加减        System.out.println(&quot;First date of this month= &quot;+today.with(TemporalAdjusters.firstDayOfMonth()));        LocalDate lastDayOfYear = today.with(TemporalAdjusters.lastDayOfYear());        System.out.println(&quot;Last date of this year= &quot;+lastDayOfYear);        Period period = today.until(lastDayOfYear);        System.out.println(&quot;Period Format= &quot;+period);        System.out.println(&quot;Months remaining in the year= &quot;+period.getMonths());            }}Year 2014 is Leap Year? falseToday is before 01/01/2015? trueCurrent Time=2014-04-28T16:23:53.15410 days after today will be 2014-05-083 weeks after today will be 2014-05-1920 months after today will be 2015-12-2810 days before today will be 2014-04-183 weeks before today will be 2014-04-0720 months before today will be 2012-08-28First date of this month= 2014-04-01Last date of this year= 2014-12-31Period Format= P8M3DMonths remaining in the year= 8</code></pre><h2 id="2-7-时间的Parsing-和-Formatting"><a href="#2-7-时间的Parsing-和-Formatting" class="headerlink" title="2.7 时间的Parsing 和 Formatting"></a>2.7 时间的Parsing 和 Formatting</h2><pre><code>package com.journaldev.java8.time;import java.time.Instant;import java.time.LocalDate;import java.time.LocalDateTime;import java.time.format.DateTimeFormatter;public class DateParseFormatExample {    public static void main(String[] args) {        //Format examples        LocalDate date = LocalDate.now();        //default format        System.out.println(&quot;Default format of LocalDate=&quot;+date);        //使用特定的Formatter        System.out.println(date.format(DateTimeFormatter.ofPattern(&quot;d::MMM::uuuu&quot;)));        System.out.println(date.format(DateTimeFormatter.BASIC_ISO_DATE));        LocalDateTime dateTime = LocalDateTime.now();        //default format        System.out.println(&quot;Default format of LocalDateTime=&quot;+dateTime);        //specific format        System.out.println(dateTime.format(DateTimeFormatter.ofPattern(&quot;d::MMM::uuuu HH::mm::ss&quot;)));        System.out.println(dateTime.format(DateTimeFormatter.BASIC_ISO_DATE));        Instant timestamp = Instant.now();        //default format        System.out.println(&quot;Default format of Instant=&quot;+timestamp);        //Parse examples        LocalDateTime dt = LocalDateTime.parse(&quot;27::Apr::2014 21::39::48&quot;,                DateTimeFormatter.ofPattern(&quot;d::MMM::uuuu HH::mm::ss&quot;));        System.out.println(&quot;Default format after parsing = &quot;+dt);    }}// OutputDefault format of LocalDate=2014-04-2828::Apr::201420140428Default format of LocalDateTime=2014-04-28T16:25:49.34128::Apr::2014 16::25::4920140428Default format of Instant=2014-04-28T23:25:49.342ZDefault format after parsing = 2014-04-27T21:39:48</code></pre><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://www.journaldev.com/2800/java-8-date-localdate-localdatetime-instant" target="_blank" rel="noopener">https://www.journaldev.com/2800/java-8-date-localdate-localdatetime-instant</a> </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-为什么需要新的Date-API&quot;&gt;&lt;a href=&quot;#1-为什么需要新的Date-API&quot; class=&quot;headerlink&quot; title=&quot;1. 为什么需要新的Date API&quot;&gt;&lt;/a&gt;1. 为什么需要新的Date API&lt;/h1&gt;&lt;p&gt;Java8 的一
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法(17)-红黑树</title>
    <link href="https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-17-%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <id>https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-17-%E7%BA%A2%E9%BB%91%E6%A0%91/</id>
    <published>2020-02-11T04:16:00.000Z</published>
    <updated>2020-02-11T04:16:29.377Z</updated>
    
    <content type="html"><![CDATA[<p>首先对于我们前面看到的二叉查找树，在相对理想的情况下，它的时间负责度为O(logn).但是在频繁的动态更新的过程中，可能会出现树的高度远远大于log2(n)的情况，导致各项操作的效率下降.</p><p>在极端情况下，二叉查找树会退化为一个链表，时间复杂度会退化到O(n).为了解决这个复杂度退化的问题，我们需要设计一种平衡二叉查找树</p><h1 id="1-什么是平衡二叉查找树？"><a href="#1-什么是平衡二叉查找树？" class="headerlink" title="1. 什么是平衡二叉查找树？"></a>1. 什么是平衡二叉查找树？</h1><blockquote><p>平衡二叉查找树定义  二叉树中任意一个节点的左右子树的高度相差不能大于1.</p></blockquote><p>平衡二叉查找树的初衷是解决普通二叉查找树在频繁的插入\删除等动态更新的情况下，出现时间复杂度退化的问题</p><p>平衡二叉查找树中平衡的意思就是让整棵树看起来比较对称，不要出现左子树很高，右子树很矮的情况。这样就能让整棵树的高度相对来说低一些。</p><h1 id="2-如何定义一棵红黑树-Red-Black-Tree"><a href="#2-如何定义一棵红黑树-Red-Black-Tree" class="headerlink" title="2. 如何定义一棵红黑树 Red Black Tree"></a>2. 如何定义一棵红黑树 Red Black Tree</h1><p>是一种不严格的平衡二叉查找树。红黑树当中的节点，一类被标记为黑色，一类被标记为红色。</p><ul><li>根节点是黑色的</li><li>每个叶子节点都是黑色的空节点(NIL)，即叶子节点不存储数据</li><li>任何相邻的节点都不能同时为红色，即红色节点是被黑色节点分割开的</li><li>每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点</li></ul><p>二叉查找树的很多操作的性能都跟树的高度成正比，因此为了证明红黑树近似平衡，我们需要分析的问题可以转化为其高度是否能比较稳定的趋近log2(n)</p><p>AVL是高度平衡的二叉树，查找效率非常高，但是每次插入删除都要对应做调整，所以会比较复杂耗时。红黑树只是做到近似平衡，在维护平衡的成本上，要比AVL要低。</p><h1 id="3-如何实现一个红黑树"><a href="#3-如何实现一个红黑树" class="headerlink" title="3. 如何实现一个红黑树"></a>3. 如何实现一个红黑树</h1><p>红黑树的平衡过程就是<strong>根据节点排布的特征来，遇到什么样的节点排布，我们就对应的去进行调整</strong>。 </p><ul><li>重要操作<ul><li>左旋 rotate left<ul><li>将基准点的右子树绕x做逆时针旋转，是的x的右子树成为x的父亲，同时修改相关节点的引用。旋转之后，二叉查找树的特性仍然能够得到满足 </li></ul></li><li>右旋 rotate right <ul><li>将x的左子树绕x顺时针旋转，使得x的左子树成为x的父亲，同时修改相关节点的引用。旋转之后，二叉查找树的属性仍然能够满足 </li></ul></li></ul></li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://www.cnblogs.com/carpenterlee/p/5503882.html" target="_blank" rel="noopener">https://www.cnblogs.com/carpenterlee/p/5503882.html</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先对于我们前面看到的二叉查找树，在相对理想的情况下，它的时间负责度为O(logn).但是在频繁的动态更新的过程中，可能会出现树的高度远远大于log2(n)的情况，导致各项操作的效率下降.&lt;/p&gt;
&lt;p&gt;在极端情况下，二叉查找树会退化为一个链表，时间复杂度会退化到O(n).
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://www.llchen60.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="红黑树" scheme="https://www.llchen60.com/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法(16)-二叉树</title>
    <link href="https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-16-%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-16-%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2020-02-09T18:31:37.000Z</published>
    <updated>2020-02-09T18:32:28.203Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-树"><a href="#1-树" class="headerlink" title="1. 树"></a>1. 树</h1><ul><li>父节点<ul><li>上层的节点 </li></ul></li><li>兄弟节点<ul><li>父节点是同一个节点 </li></ul></li><li>叶节点<ul><li>没有子节点的节点</li></ul></li><li>高度<ul><li>节点到叶子节点的最长路径 </li></ul></li><li>深度<ul><li>根节点到这个节点所经历的边的个数 </li></ul></li><li>层<ul><li>节点的深度 + 1 </li></ul></li></ul><h1 id="2-二叉树"><a href="#2-二叉树" class="headerlink" title="2. 二叉树"></a>2. 二叉树</h1><p>每个节点最多有两个分叉的树，即最多有两个子节点</p><p><img src="https://i.loli.net/2020/02/10/r72vjaPlpfsHmuE.jpg" alt="fig1.jpg"><br>2 显示的是满二叉树，特点是叶子节点都在最底层，出了叶子节点之外，每个节点都有左右两个子节点</p><p>3 叶子节点都在最底下两层，并且出了最后一层，其他的层的节点数量都要达到最大，并且最后一层的节点都是靠左排列的，这种二叉树叫做完全二叉树。</p><h2 id="2-1-如何表示-存储一棵二叉树？"><a href="#2-1-如何表示-存储一棵二叉树？" class="headerlink" title="2.1 如何表示/ 存储一棵二叉树？"></a>2.1 如何表示/ 存储一棵二叉树？</h2><h3 id="2-1-1-基于指针或者引用的二叉链式存储法"><a href="#2-1-1-基于指针或者引用的二叉链式存储法" class="headerlink" title="2.1.1 基于指针或者引用的二叉链式存储法"></a>2.1.1 基于指针或者引用的二叉链式存储法</h3><p><img src="https://i.loli.net/2020/02/10/M1I6FkWJodTq3fX.jpg" alt="fig2.jpg"></p><p>每个节点都有三个字段，其中一个存储数据，另外两个指向左右子节点的指针。因此通过根节点，我们就可以通过左右子节点的指针将整棵树都串起来了。</p><h3 id="2-1-2-基于数组的顺序存储法"><a href="#2-1-2-基于数组的顺序存储法" class="headerlink" title="2.1.2 基于数组的顺序存储法"></a>2.1.2 基于数组的顺序存储法</h3><p><img src="https://i.loli.net/2020/02/10/P62NlH8EbY3LBXv.jpg" alt="fig3.jpg"><br>如果节点X存储在数组中下标为i的位置，下标为2<em>i的位置存储的是左子节点，下标为2</em>i + 1的位置存储的就是右子节点。下标为i/2的位置存储的就是它的父节点了。通过这种方式，我们只要知道根节点存储的位置，就可以通过下标计算，把整棵树都串起来。 不过对于一棵非完全二叉树而言，会浪费比较多的数组存储空间的。</p><h2 id="2-2-二叉树的遍历"><a href="#2-2-二叉树的遍历" class="headerlink" title="2.2 二叉树的遍历"></a>2.2 二叉树的遍历</h2><h3 id="2-2-0-递归公式"><a href="#2-2-0-递归公式" class="headerlink" title="2.2.0 递归公式"></a>2.2.0 递归公式</h3><p><img src="https://i.loli.net/2020/02/10/o1TLXDnalmgBzAQ.jpg" alt="fig4.jpg"></p><p>二叉树的遍历整体就是一个递归的过程</p><p>写递归代码的关键，就是看能不能写出一个递推公式。而递推公式的关键，就是如果要解决问题A，就假设子问题B,C都已经解决，然后再来看如何利用B，C来解决A</p><pre><code>前序遍历的递推公式：preOrder(r) = print r-&gt;preOrder(r-&gt;left)-&gt;preOrder(r-&gt;right)中序遍历的递推公式：inOrder(r) = inOrder(r-&gt;left)-&gt;print r-&gt;inOrder(r-&gt;right)后序遍历的递推公式：postOrder(r) = postOrder(r-&gt;left)-&gt;postOrder(r-&gt;right)-&gt;print r// 前序遍历void preOrder(Node* root) {  if (root == null) return;  print root // 此处为伪代码，表示打印root节点  preOrder(root-&gt;left);  preOrder(root-&gt;right);}// 中序遍历void inOrder(Node* root) {  if (root == null) return;  inOrder(root-&gt;left);  print root // 此处为伪代码，表示打印root节点  inOrder(root-&gt;right);}// 后序遍历void postOrder(Node* root) {  if (root == null) return;  postOrder(root-&gt;left);  postOrder(root-&gt;right);  print root // 此处为伪代码，表示打印root节点}</code></pre><h3 id="2-2-1-前序遍历"><a href="#2-2-1-前序遍历" class="headerlink" title="2.2.1 前序遍历"></a>2.2.1 前序遍历</h3><p>对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。</p><h3 id="2-2-2-中序遍历"><a href="#2-2-2-中序遍历" class="headerlink" title="2.2.2 中序遍历"></a>2.2.2 中序遍历</h3><p>对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树</p><h3 id="2-2-3-后序遍历"><a href="#2-2-3-后序遍历" class="headerlink" title="2.2.3 后序遍历"></a>2.2.3 后序遍历</h3><p>对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身</p><h1 id="3-二叉查找树"><a href="#3-二叉查找树" class="headerlink" title="3. 二叉查找树"></a>3. 二叉查找树</h1><p>支持动态数据集合的快速插入、删除、查找操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-树&quot;&gt;&lt;a href=&quot;#1-树&quot; class=&quot;headerlink&quot; title=&quot;1. 树&quot;&gt;&lt;/a&gt;1. 树&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;父节点&lt;ul&gt;
&lt;li&gt;上层的节点 &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;兄弟节点&lt;ul&gt;
&lt;li&gt;父节点是同
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://www.llchen60.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://www.llchen60.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法(15)-哈希算法</title>
    <link href="https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-15-%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/"/>
    <id>https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-15-%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/</id>
    <published>2020-02-09T18:30:23.000Z</published>
    <updated>2020-02-09T18:30:43.320Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-什么是哈希算法"><a href="#1-什么是哈希算法" class="headerlink" title="1. 什么是哈希算法"></a>1. 什么是哈希算法</h1><blockquote><p>将任意长度的二进制串映射为固定长度的二进制串，这个映射的规则就是哈希算法，而通过原始数据映射之后得到的二进制串就是哈希值</p></blockquote><ul><li>哈希算法的要求<ul><li>从哈希值无法反向推导出原始数据</li><li>对输入数据非常敏感，哪怕原始数据只修改一个bit，最后得到的哈希值也会大不相同</li><li>散列冲突的概率很小，对于不同的原始数据，哈希值相同的概率非常小</li><li>哈希算法的效率要足够高，针对较长文本，也能快速计算出哈希值</li></ul></li></ul><h1 id="2-哈希算法的应用"><a href="#2-哈希算法的应用" class="headerlink" title="2. 哈希算法的应用"></a>2. 哈希算法的应用</h1><h2 id="2-1-安全加密"><a href="#2-1-安全加密" class="headerlink" title="2.1 安全加密"></a>2.1 安全加密</h2><ul><li>常用de加密算法<ul><li>MD5<ul><li>MD5 Message-Digest Algorithm </li><li>MD5信息摘要算法</li></ul></li><li>SHA <ul><li>Secure Hash Algorithm 安全散列算法</li></ul></li><li>DES <ul><li>Data Encryption Standard 数据加密标准</li></ul></li><li>AES <ul><li>Advanced Encryption Standard 高级加密标准</li></ul></li></ul></li></ul><h2 id="2-2-唯一标识"><a href="#2-2-唯一标识" class="headerlink" title="2.2 唯一标识"></a>2.2 唯一标识</h2><p>图片的标识，从图片的二进制串码的前中后各取出100字节，通过哈希算法得到一个哈希字符串，用它作为图片的唯一标识。然后通过这个唯一标识来判定图片是否在图库当中，通过这种方式来减少工作量。</p><h2 id="2-3-数据校验"><a href="#2-3-数据校验" class="headerlink" title="2.3 数据校验"></a>2.3 数据校验</h2><p>BT协议的数据校验，对每个文件块取哈希值，保存在种子文件当中。当文件块下载完成之后，我们通过相同的哈希算法，对下载好的文件块逐一求哈希值，然后跟种子文件中保存的哈希值进行比对。如果不同，就说明这个文件块不完整或者被篡改了，需要再重新从其他宿主机器上下载这个文件块。</p><h2 id="2-4-散列函数"><a href="#2-4-散列函数" class="headerlink" title="2.4 散列函数"></a>2.4 散列函数</h2><p>哈希表的散列函数，关注的是在做完哈希以后，是否能够平均的分布。一组数据能否均匀散列在各个槽中。 </p><p>另外一个点是其执行速度，散列函数对执行速度的要求会比较高一些。</p><h2 id="2-5-负载均衡"><a href="#2-5-负载均衡" class="headerlink" title="2.5 负载均衡"></a>2.5 负载均衡</h2><p>分布式系统当中需要解决的问题</p><ul><li>负载均衡的算法<ul><li>轮询</li><li>随机</li><li>加权轮询</li></ul></li></ul><p>但是我们需要实现一个会话粘滞的负载均衡算法(session sticky)。即我们需要在一个客户端上，在一次会话上的所有请求都路由到同一个服务器上。</p><p>通过哈希算法，对客户端IP地址或者会话的ID计算哈希值，将取得的哈希值与服务器列表的大小进行取模运算，最终得到的值就是应该被路由到的服务器的编号。</p><h2 id="2-6-数据分片"><a href="#2-6-数据分片" class="headerlink" title="2.6 数据分片"></a>2.6 数据分片</h2><h3 id="2-6-1-如何统计关键词搜索的次数"><a href="#2-6-1-如何统计关键词搜索的次数" class="headerlink" title="2.6.1 如何统计关键词搜索的次数"></a>2.6.1 如何统计关键词搜索的次数</h3><p>假设我们有1T的日志文件，里面记录了用户的关键词，我们想快速统计出来每个关键词被搜索的次数，该怎么做呢？ </p><ol><li>数据量太大的问题</li><li>处理时间太长的问题</li></ol><p>对数据进行分片，然后多台机器进行处理。用哈希算法，将哈希值相同的搜索关键词放到同一台机器上。然后最后做汇总</p><h3 id="2-6-2-如何快速判断图片是否在图库当中"><a href="#2-6-2-如何快速判断图片是否在图库当中" class="headerlink" title="2.6.2 如何快速判断图片是否在图库当中"></a>2.6.2 如何快速判断图片是否在图库当中</h3><p>为每个图片取唯一标识，然后构建散列表，但是当图片量很大的时候，在单台机器上构建散列表是行不通的。</p><p>因为在存储的时候，我们还是需要根据哈希算法取模来进行存储，然后在进行判断的时候，也是用同样的哈希算法，然后与机器个数n求余取模。然后根据得到的值到对应的机器上去进行查找。</p><h2 id="2-7-分布式存储"><a href="#2-7-分布式存储" class="headerlink" title="2.7 分布式存储"></a>2.7 分布式存储</h2><p>分布式存储需要解决的问题是，当我们已经在各个host上按照哈希算法保存了数据以后，再增减host的时候，我们不希望还需要对原先的host里面的数据做迁移。如果说缓存当中的数据会一下子全都失效的话，那么所有数据请求都要从数据库走，直接就压垮数据库了。</p><p>因此在分布式存储当中，我们需要采用<strong><em>一致性哈希算法</em></strong></p><p>假设我们有 k 个机器，数据的哈希值的范围是[0, MAX]。我们将整个范围划分成 m 个小区间（m 远大于 k），每个机器负责 m/k 个小区间。当有新机器加入的时候，我们就将某几个小区间的数据，从原来的机器中搬移到新的机器中。这样，既不用全部重新哈希、搬移数据，也保持了各个机器上数据数量的均衡。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-什么是哈希算法&quot;&gt;&lt;a href=&quot;#1-什么是哈希算法&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是哈希算法&quot;&gt;&lt;/a&gt;1. 什么是哈希算法&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;将任意长度的二进制串映射为固定长度的二进制串，这个映射
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://www.llchen60.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="哈希算法" scheme="https://www.llchen60.com/tags/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法(14)-散列表</title>
    <link href="https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-14-%E6%95%A3%E5%88%97%E8%A1%A8/"/>
    <id>https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-14-%E6%95%A3%E5%88%97%E8%A1%A8/</id>
    <published>2020-02-09T18:21:54.000Z</published>
    <updated>2020-02-09T18:24:07.894Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Intro"><a href="#1-Intro" class="headerlink" title="1. Intro"></a>1. Intro</h1><p>散列表 - Hash Table, 又被称为哈希表或者Hash表。散列表用的是数组支持按照下标来随机访问数据的特性，因此散列表实际上是数组的一种扩展，由数组演化而来。</p><p>散列的思想就是对于key值，通过hash function，对应到table上来进行存储</p><p><img src="https://i.loli.net/2020/02/10/pnWdbkoVjUE7aTw.jpg" alt="fig1.jpg"></p><h1 id="2-散列函数"><a href="#2-散列函数" class="headerlink" title="2. 散列函数"></a>2. 散列函数</h1><p>散列函数就是实现输入到存储的对应的函数，因为最终是要存储到数组当中，故而其基本要求有：</p><ol><li>散列函数计算得到的散列值是一个非负整数</li><li>如果Key1 = Key2,那么hash(key1) == hash(key2)</li><li>如果key1 != key2, 那么hash(key1) != hash(key2)</li></ol><p>条件3 即如何应对散列冲突的问题，首先本身是必须的，而且客观是存在散列冲突的情况的，针对于散列冲突，我们一般会使用开放寻址法和链表法。</p><h1 id="3-如何解决散列冲突"><a href="#3-如何解决散列冲突" class="headerlink" title="3. 如何解决散列冲突"></a>3. 如何解决散列冲突</h1><h2 id="3-1-开放寻址法"><a href="#3-1-开放寻址法" class="headerlink" title="3.1 开放寻址法"></a>3.1 开放寻址法</h2><ul><li>核心思想<ul><li>出现了散列冲突，就重新探测一个空闲位置，将其插入</li></ul></li><li>探测方法<ul><li>线性探测</li><li>二次探测<ul><li>探测步长为二次方的增长 </li></ul></li><li>双重散列<ul><li>使用第一个散列函数进行尝试</li><li>如果计算得到的存储位置已经被占用，再用第二个散列函数，依次类推直到找到空闲的存储位置</li></ul></li></ul></li><li>装载因子<ul><li>引入装在引资的概念来表示空位的多少</li><li><code>装载因子 = 填入表中的元素个数/散列表的长度</code></li></ul></li></ul><h2 id="3-2-链表法"><a href="#3-2-链表法" class="headerlink" title="3.2 链表法"></a>3.2 链表法</h2><p><img src="https://i.loli.net/2020/02/10/VAUezcR2phPlYjT.jpg" alt="fig2.jpg"></p><p>链表法是一种更加常用的散列冲突解决办法，相比开放寻址法，它要简单很多。我们来看这个图，在散列表中，每个“桶（bucket）”或者“槽（slot）”会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中。</p><h1 id="4-工程上使用的散列表"><a href="#4-工程上使用的散列表" class="headerlink" title="4. 工程上使用的散列表"></a>4. 工程上使用的散列表</h1><p>首先我们需要思考下实际应用场景当中的散列表，虽然我们说散列表的查询效率是O(1), 实质上他的真实数据时和散列函数，装载因子，散列冲突都有关系的。如果散列函数设计的不好，或者装载因子过高，都可能导致散列冲突发生的概率升高，从而导致查询的效率下降。</p><p>因此对于在工程上使用的散列表，首先要考虑的就是需要能够应对各种异常情况，来避免散列冲突的情况下散列表性能的急剧下降，并且需要能够抵抗散列碰撞攻击。</p><h2 id="4-1-如何设计散列函数"><a href="#4-1-如何设计散列函数" class="headerlink" title="4.1 如何设计散列函数"></a>4.1 如何设计散列函数</h2><ul><li>需求<ul><li>散列函数的设计不能太复杂 <ul><li>会消耗很多计算时间</li><li>即会影响到散列表的性能</li></ul></li><li>散列函数生成的值需要尽可能随机并且均匀分布</li></ul></li><li>如何解决装载因子过大的问题<ul><li>针对散列表，当装载因子过大的时候，我们也可以进行动态扩容，重新申请一个更大的散列表，将数据搬移到这个新的散列表当中。</li><li>同时也有装载因子太小的情况下，我们可以做动态缩容的工作</li></ul></li><li>如何避免低效扩容<ul><li>所谓低效的扩容指的是如果我们在装载因子超过阈值的时候一下子进行扩容，即数据的搬运和最终的新数据的插入，那针对这一个数据，其时间复杂度变成了O(n).</li><li>为了解决这个问题，我们在需要进行扩容的时候，将扩容的操作穿插在插入操作的过程当中，分批次来完成。当装载因子触达阈值的时候，只申请新空间，但是没有将老的数据搬移到新的散列表当中。</li><li>当有新数据插入的时候，就将新数据放到新的散列表当中，并且从老的散列表当中拿一个数据放到新的散列表当中</li><li>而查询操作，为了兼顾，我们会先从新的散列表当中查找，如果没有找到，再去老的散列表当中查找</li></ul></li></ul><h2 id="4-2-如何解决冲突？"><a href="#4-2-如何解决冲突？" class="headerlink" title="4.2 如何解决冲突？"></a>4.2 如何解决冲突？</h2><h3 id="4-2-1-开放寻址法"><a href="#4-2-1-开放寻址法" class="headerlink" title="4.2.1 开放寻址法"></a>4.2.1 开放寻址法</h3><ul><li>优势<ul><li>数据都存储在数组当中，可以有效利用CPU缓存加快查询速度</li><li>序列化比较简单</li></ul></li><li>缺陷<ul><li>删除数据比较麻烦，需要特殊标记已经删除的数据</li><li>冲突代价高，导致装载因子的上限不能太大</li></ul></li></ul><blockquote><p>当数据量比较小，装载因子小的时候，适合使用开放寻址法。</p></blockquote><h3 id="4-2-2-链表法"><a href="#4-2-2-链表法" class="headerlink" title="4.2.2 链表法"></a>4.2.2 链表法</h3><ul><li>优势<ul><li>对内存的利用率相对比较高，因为链表结点可以在需要的时候再创建，不需要提前申请好</li><li>可以允许很高的装载因子</li></ul></li><li>劣势<ul><li>因为要存储指针，对于小的对象的存储，是更加耗内存的</li><li>因为结点零散分布在内存当中，不是连续的，所以对CPU缓存不友好，对执行效率会造成一定的影响</li></ul></li></ul><h2 id="4-3-Java-HashMap举例"><a href="#4-3-Java-HashMap举例" class="headerlink" title="4.3 Java HashMap举例"></a>4.3 Java HashMap举例</h2><ul><li>初始大小 - 16<ul><li>如果大概知道数据量的大小，可以修改默认，来减少动态扩容的次数</li></ul></li><li>装载因子和动态扩容<ul><li>默认 load factor 0.75 </li><li>每次扩容大小变为两倍</li></ul></li><li>散列冲突解决方法<ul><li>采用链表法</li><li>1.8以后当链表长度超过8以后，链表就会自动转化为红黑树</li></ul></li><li>散列函数</li></ul><pre><code>int hash(Object key) {    int h = key.hashCode()；    return (h ^ (h &gt;&gt;&gt; 16)) &amp; (capicity -1); //capicity表示散列表的大小} </code></pre><p><code>&amp;(capacity - 1)</code> means <code>% capacity</code></p><p>因为hashcode本身是个32位的整型值，获得其hash值以后，将高16位移到低16位，就相当于拿到了高16位和低16位的feature。用自己的高半区和低半区做异或，为的是加大低位的随机性。这样子哪怕是高位的变化也可以反映到低位当中，保证了最终进bin的随机性</p><h1 id="5-散列表实际应用"><a href="#5-散列表实际应用" class="headerlink" title="5. 散列表实际应用"></a>5. 散列表实际应用</h1><p>散列表和链表经常是共同使用的,这一部分会walk through一些常用的场景，看看是如何来共同使用的。</p><h2 id="5-1-LRU缓存淘汰算法"><a href="#5-1-LRU缓存淘汰算法" class="headerlink" title="5.1 LRU缓存淘汰算法"></a>5.1 LRU缓存淘汰算法</h2><p>最基础的LRU实现，我们可以通过链表来做.维护一个按照访问时间从大到小有序排列的链表结构，因为缓存大小有限，当缓存空间不够，需要淘汰一个数据的时候，我们就直接将链表头部的结点删除。</p><p>我们可以选择使用散列表和双向链表一起来实现LRU cache。要实现的操作有：</p><ul><li>往缓存中加入数据</li><li>从缓存中删除数据</li><li>在缓存中查找数据</li></ul><p><img src="https://i.loli.net/2020/02/10/LIB2nkbZYudrq37.jpg" alt="fig3.jpg"></p><p>如图所示，我们相当于在维护两条链表，一条是在哈希表的每个entry上的链，在这上面的链是为了解决哈希冲突的；另外一个点，我们在使用的是维护LRU cache的链表。</p><p>链表当中的每个结点保存了：</p><ul><li>prev</li><li>next</li><li>data</li><li>hnext<ul><li>散列表上碰撞问题的解决的 </li></ul></li></ul><h2 id="5-2-Java-LinkedHashMap"><a href="#5-2-Java-LinkedHashMap" class="headerlink" title="5.2 Java LinkedHashMap"></a>5.2 Java LinkedHashMap</h2><p>LinkedHashMap能够实现按照数据的插入顺序来进行打印，是因为他也是通过散列表和链表组合在一起的方式实现的。它支持按照插入顺序遍历数据，还支持按照访问顺序来遍历数据</p><pre><code>// 10是初始大小，0.75是装载因子，true是表示按照访问时间排序HashMap&lt;Integer, Integer&gt; m = new LinkedHashMap&lt;&gt;(10, 0.75f, true);m.put(3, 11);m.put(1, 12);m.put(5, 23);m.put(2, 22);m.put(3, 26);m.get(5);for (Map.Entry e : m.entrySet()) {  System.out.println(e.getKey());}// print out: 1, 2, 3, 5</code></pre><p><img src="https://i.loli.net/2020/02/10/wxy1tumrZO3DXQz.jpg" alt="fig4.jpg"></p><p><img src="https://i.loli.net/2020/02/10/9phoBuRSI5gsJC4.jpg" alt="fig5.jpg"></p><p><img src="https://i.loli.net/2020/02/10/3KGVI15LDp4PSAZ.jpg" alt="fig6.jpg"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Intro&quot;&gt;&lt;a href=&quot;#1-Intro&quot; class=&quot;headerlink&quot; title=&quot;1. Intro&quot;&gt;&lt;/a&gt;1. Intro&lt;/h1&gt;&lt;p&gt;散列表 - Hash Table, 又被称为哈希表或者Hash表。散列表用的是数组支持按照下标来
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://www.llchen60.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="散列表" scheme="https://www.llchen60.com/tags/%E6%95%A3%E5%88%97%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法(13)-跳表</title>
    <link href="https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-13-%E8%B7%B3%E8%A1%A8/"/>
    <id>https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-13-%E8%B7%B3%E8%A1%A8/</id>
    <published>2020-02-09T18:11:25.000Z</published>
    <updated>2020-02-09T18:12:09.716Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h1><ul><li>跳表<ul><li>动态数据结构</li><li>可以支持快速的插入，删除，查找操作</li><li>写起来也不会很复杂</li></ul></li></ul><p>Redis当中的有序集合就是用跳表来实现的。</p><h1 id="2-如何理解跳表"><a href="#2-如何理解跳表" class="headerlink" title="2. 如何理解跳表"></a>2. 如何理解跳表</h1><p>对于一个单链表来说，即便链表当中存储的数据是有序的，如果我们想要从中查找某个数据，也只能从头到尾遍历链表，这样查找效率就会非常低，时间复杂度比较高，O(n)</p><p>为了解决这个问题，我们可以对链表建立一级索引，每几个结点就提取一个结点到上一级当中，抽出来的那一级我们就可以将其叫做索引或者索引层了。</p><p>通过增加索引的层级，来加快寻找节点的速度，这就是跳表 – 链表加上多级索引的结构</p><ul><li>时间复杂度非常理想 O(logn)</li><li>但是相对来说会更需要内存一些  空间复杂度为O(n)</li></ul><h1 id="3-高效的动态插入和删除操作"><a href="#3-高效的动态插入和删除操作" class="headerlink" title="3. 高效的动态插入和删除操作"></a>3. 高效的动态插入和删除操作</h1><p>其动态的插入和删除操作的时间复杂度为O(logn)</p><p><img src="https://i.loli.net/2020/02/10/f4vdSyzCEs2KWFY.jpg" alt="fig1.jpg"></p><p>删除操作，还是需要拿到删除节点的前驱节点，然后通过指针操作完成删除。</p><h2 id="4-跳表索引动态更新"><a href="#4-跳表索引动态更新" class="headerlink" title="4. 跳表索引动态更新"></a>4. 跳表索引动态更新</h2><p><img src="https://i.loli.net/2020/02/10/J5QxpXFgAeTCa2j.jpg" alt="fig2.jpg"></p><p>跳表是需要不断更新的，因为当我们不断向跳表里面插入数据的时候，如果我们不更新索引，就有可能出现两个索引节点之间数据非常多的情况。极端情况下，跳表就会退化成单链表。</p><ul><li>我们需要某种方式来维护索引与原始链表大小之间的平衡<ul><li>跳表是通过随机函数来维护平衡性的</li><li>当我们往跳表里面插入数据的时候，可以选择同时将这个数据插入到部分索引层当中。</li><li>根据随机函数来决定这个结点插入到哪几级索引当中。</li></ul></li></ul><p><img src="https://i.loli.net/2020/02/10/64FQnKPZ8uWlTCb.jpg" alt="fig3.jpg"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-概念&quot;&gt;&lt;a href=&quot;#1-概念&quot; class=&quot;headerlink&quot; title=&quot;1. 概念&quot;&gt;&lt;/a&gt;1. 概念&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;跳表&lt;ul&gt;
&lt;li&gt;动态数据结构&lt;/li&gt;
&lt;li&gt;可以支持快速的插入，删除，查找操作&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://www.llchen60.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="跳表" scheme="https://www.llchen60.com/tags/%E8%B7%B3%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法(12)-二分查找</title>
    <link href="https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-12-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <id>https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-12-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</id>
    <published>2020-02-09T18:07:07.000Z</published>
    <updated>2020-02-09T18:07:27.910Z</updated>
    
    <content type="html"><![CDATA[<p>二分查找是一种针对于有序数据集合的查找算法，也叫折半查找算法。类似分治的思想，每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为0. 查找速度为O(logn)</p><p>思考题：1000万个整数数据，每个数据8字节，</p><h1 id="1-二分查找的基本实现"><a href="#1-二分查找的基本实现" class="headerlink" title="1. 二分查找的基本实现"></a>1. 二分查找的基本实现</h1><pre><code>public int bsearch(int[] a, int n, int value) {// 定基准点  int low = 0;  int high = n - 1;// 停止条件  while (low &lt;= high) {    // 定二分点    int mid = (low + high) / 2;    if (a[mid] == value) {      return mid;    } else if (a[mid] &lt; value) {     // 保证是活循环..       low = mid + 1;    } else {      high = mid - 1;    }  }  return -1;}// 二分查找的递归实现public int bsearch(int[] a, int n, int val) {  return bsearchInternally(a, 0, n - 1, val);}private int bsearchInternally(int[] a, int low, int high, int value) {  if (low &gt; high) return -1;  int mid =  low + ((high - low) &gt;&gt; 1);  if (a[mid] == value) {    return mid;  } else if (a[mid] &lt; value) {    return bsearchInternally(a, mid+1, high, value);  } else {    return bsearchInternally(a, low, mid-1, value);  }}</code></pre><ul><li>循环退出条件<ul><li>low &lt;= high </li></ul></li><li>mid取值<ul><li>mid = low + (high - low)/2</li><li>因为如果值太大的话，会溢出的</li></ul></li><li>low high的更新<ul><li>low = mid + 1</li><li>high = mid - 1 </li></ul></li></ul><h1 id="2-二分查找的应用场景局限性"><a href="#2-二分查找的应用场景局限性" class="headerlink" title="2. 二分查找的应用场景局限性"></a>2. 二分查找的应用场景局限性</h1><ul><li>二分查找以来的是顺序表结构  – 数组<ul><li>因为二分查找需要按照下标来随机访问元素</li></ul></li><li>针对的是有序数据 – 静态数据集<ul><li>更适用在插入，删除不频繁，一次排序多次查找的场景当中</li><li>针对动态变化的数据集合，二分查找就不再适用了</li></ul></li><li>数据量太小不需要适用二分查找</li><li>如果数据之间的比较非常耗时，我们需要尽力减少比较的次数，那么二分查找就是很好的方式了</li></ul><h1 id="3-二分查找的实际应用与变体"><a href="#3-二分查找的实际应用与变体" class="headerlink" title="3. 二分查找的实际应用与变体"></a>3. 二分查找的实际应用与变体</h1><h2 id="3-1-查找第一个值等于给定值的元素"><a href="#3-1-查找第一个值等于给定值的元素" class="headerlink" title="3.1 查找第一个值等于给定值的元素"></a>3.1 查找第一个值等于给定值的元素</h2><pre><code>public int bsearch(int[] a, int n, int value) {  int low = 0;  int high = n - 1;  while (low &lt;= high) {    int mid =  low + ((high - low) &gt;&gt; 1);    if (a[mid] &gt; value) {      high = mid - 1;    } else if (a[mid] &lt; value) {      low = mid + 1;    } else {      // 注意这里的判断，中止条件时mid为0 或者左一个的值和现在的值不相等       if ((mid == 0) || (a[mid - 1] != value)) return mid;      else high = mid - 1;    }  }  return -1;}</code></pre><ul><li>写二分相关的算法要注意的点有<ul><li>终止条件</li><li>区间上下界的更新方法</li><li>返回值的选择</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;二分查找是一种针对于有序数据集合的查找算法，也叫折半查找算法。类似分治的思想，每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为0. 查找速度为O(logn)&lt;/p&gt;
&lt;p&gt;思考题：1000万个整数数据，每个数据8字节，&lt;
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://www.llchen60.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="二分查找" scheme="https://www.llchen60.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法(11)-应用场景下的排序函数</title>
    <link href="https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-11-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E6%8E%92%E5%BA%8F%E5%87%BD%E6%95%B0/"/>
    <id>https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-11-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E6%8E%92%E5%BA%8F%E5%87%BD%E6%95%B0/</id>
    <published>2020-02-09T18:00:04.000Z</published>
    <updated>2020-02-09T18:00:58.516Z</updated>
    
    <content type="html"><![CDATA[<p>在日常开发当中，无论我们使用的语言是什么，他们几乎都会提供排序算法，本篇博文将尝试着对其进行分析，看看如何实现一个通用的，高性能的排序算法。</p><p>首先看看我们的现有排序算法库，看看我们的选择空间在哪里： </p><p><img src="https://i.loli.net/2020/02/10/2ga9UPTNkOcb8wr.jpg" alt="fig1.jpg"></p><p>如果对于小规模数据排序，可以选择O(n^2); 但是对于大规模的数据，时间复杂度为O(nlogn)的算法会高效很多。因此为了兼顾任意规模数据的排序，一般都会首选时间复杂度为O(nlogn)的排序算法来实现排序函数。</p><p>一般来说会选用堆排序或者快速排序来做。</p><p>因为在实际情况下内存的占用情况是非常关键的参数了，所以我们需要看待选算法的空间复杂度，最好是原地的，即不占用更多的空间。像归并排序，时间复杂度很合适但是空间复杂度为O(n)，那就完全不是一个好选择了</p><p>快速排序想要优化的话，主要的点在于要选准分区点，好的分区点是希望其两个分区数据的数量是差不多的才可以。我们可以随机取值，也可以多取几个随机点，然后求平均。</p><p>还有一点需要注意的是在实际情况当中, O(n^2)有可能会比O(nlogn)要快的，因为小规模数据集的时候首先常量就不能忽略掉了。在这种情况下，可能插入排序反而会更快。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在日常开发当中，无论我们使用的语言是什么，他们几乎都会提供排序算法，本篇博文将尝试着对其进行分析，看看如何实现一个通用的，高性能的排序算法。&lt;/p&gt;
&lt;p&gt;首先看看我们的现有排序算法库，看看我们的选择空间在哪里： &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.lo
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://www.llchen60.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序" scheme="https://www.llchen60.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法(10)-排序(桶排序 计数排序 基数排序)</title>
    <link href="https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-10-%E6%8E%92%E5%BA%8F-%E6%A1%B6%E6%8E%92%E5%BA%8F-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    <id>https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-10-%E6%8E%92%E5%BA%8F-%E6%A1%B6%E6%8E%92%E5%BA%8F-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/</id>
    <published>2020-02-09T17:55:16.000Z</published>
    <updated>2020-02-09T17:55:34.808Z</updated>
    
    <content type="html"><![CDATA[<p>上述三种排序方法的时间复杂度均为线性，因此将其称为线性排序(Linear sort).之所以能做先线性的时间复杂度，是因为他们都不是基于比较的排序算法，并不涉及到元素之间的比较操作。</p><h1 id="1-桶排序-Bucket-Sort"><a href="#1-桶排序-Bucket-Sort" class="headerlink" title="1. 桶排序 Bucket Sort"></a>1. 桶排序 Bucket Sort</h1><ul><li>核心思想<ul><li>将排序的数据分到几个有序的桶当中，每个桶的数据再单独进行排序。桶内排完序之后，再将每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。</li></ul></li><li>分析<ul><li>如果要排序的数据为 n个，将其均匀分到m个桶当中，每个桶就有 k=n/m个元素。每个桶内部使用快排，时间复杂度为O(k*logk)</li><li>m个桶的时间复杂度就为O(n*log(n/m)) </li><li>当m的数量非常接近n的时候，那么log(n/m)就是一个非常小的常量，这时候桶排序的时间复杂度就接近O(n)了</li></ul></li><li>优劣势<ul><li>对数据本身要求比较苛刻</li><li>需要足够均匀，否则桶内排序就不是常量级的复杂度了</li></ul></li><li>桶排序  适合在外部排序当中<ul><li>指数据存储在外部磁盘当中，数据量比较大，内存有限，无法将数据全部加载到内存当中 </li><li>顺序进行划分，挨个顺次放到内存当中</li></ul></li></ul><h1 id="2-计数排序-Counting-Sort"><a href="#2-计数排序-Counting-Sort" class="headerlink" title="2. 计数排序 Counting Sort"></a>2. 计数排序 Counting Sort</h1><p>类似于桶排序，但是每个桶里面存储的只是个数</p><pre><code>// 计数排序，a是数组，n是数组大小。假设数组中存储的都是非负整数。public void countingSort(int[] a, int n) {  if (n &lt;= 1) return;  // 查找数组中数据的范围  int max = a[0];  for (int i = 1; i &lt; n; ++i) {    if (max &lt; a[i]) {      max = a[i];    }  }  int[] c = new int[max + 1]; // 申请一个计数数组c，下标大小[0,max]  for (int i = 0; i &lt;= max; ++i) {    c[i] = 0;  }  // 计算每个元素的个数，放入c中  for (int i = 0; i &lt; n; ++i) {    c[a[i]]++;  }  // 依次累加  for (int i = 1; i &lt;= max; ++i) {    c[i] = c[i-1] + c[i];  }  // 临时数组r，存储排序之后的结果  int[] r = new int[n];  // 计算排序的关键步骤，有点难理解  for (int i = n - 1; i &gt;= 0; --i) {    int index = c[a[i]]-1;    r[index] = a[i];    c[a[i]]--;  }  // 将结果拷贝给a数组  for (int i = 0; i &lt; n; ++i) {    a[i] = r[i];  }}</code></pre><h1 id="3-基数排序-Radix-Sort"><a href="#3-基数排序-Radix-Sort" class="headerlink" title="3. 基数排序 Radix Sort"></a>3. 基数排序 Radix Sort</h1><p>排10万个手机号码，从小到大来排序？ </p><p>按照位来排，需要选用稳定性的算法来做。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上述三种排序方法的时间复杂度均为线性，因此将其称为线性排序(Linear sort).之所以能做先线性的时间复杂度，是因为他们都不是基于比较的排序算法，并不涉及到元素之间的比较操作。&lt;/p&gt;
&lt;h1 id=&quot;1-桶排序-Bucket-Sort&quot;&gt;&lt;a href=&quot;#1-桶排
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://www.llchen60.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序" scheme="https://www.llchen60.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法(9)-排序(归并 快排)</title>
    <link href="https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-9-%E6%8E%92%E5%BA%8F-%E5%BD%92%E5%B9%B6-%E5%BF%AB%E6%8E%92/"/>
    <id>https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-9-%E6%8E%92%E5%BA%8F-%E5%BD%92%E5%B9%B6-%E5%BF%AB%E6%8E%92/</id>
    <published>2020-02-09T17:51:41.000Z</published>
    <updated>2020-02-09T17:55:54.841Z</updated>
    
    <content type="html"><![CDATA[<p>这节主要讲归并排序和快速排序，二者其实都用了分治的思想，可以借鉴这个思想，来解决诸如“如何在O(n)的时间复杂度内查找一个无序数组中的第k大元素”这样的问题。</p><h1 id="1-归并排序"><a href="#1-归并排序" class="headerlink" title="1. 归并排序"></a>1. 归并排序</h1><p><img src="https://i.loli.net/2020/02/10/fVpOLyXAhjn2cKW.jpg" alt="fig1.jpg"></p><ul><li><p>归并排序</p><ul><li>分治思想</li><li>分治是一种解决问题的处理思想，递归是一种编程技巧</li><li>和递归的三要素很类似，先分析得出递推公式，然后找到终止条件，再将递推公式翻译成递归代码。</li></ul></li><li><p>注意是分成了分开和合并两个过程的，在合并的过程当中，需要遍历两个有序子集，相互比较大小，然后放置在另外一个空间当中</p></li></ul><pre><code>递推公式：merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1…r))终止条件：p &gt;= r 不用再继续分解// 归并排序算法, A 是数组，n 表示数组大小merge_sort(A, n) {  merge_sort_c(A, 0, n-1)}// 递归调用函数merge_sort_c(A, p, r) {  // 递归终止条件  if p &gt;= r  then return  // 取 p 到 r 之间的中间位置 q  q = (p+r) / 2  // 分治递归  merge_sort_c(A, p, q)  merge_sort_c(A, q+1, r)  // 将 A[p...q] 和 A[q+1...r] 合并为 A[p...r]  merge(A[p...r], A[p...q], A[q+1...r])}</code></pre><ul><li>稳定排序</li><li>时间复杂度为O(nlog(n))</li><li>需要借助额外空间，不是原地排序算法  空间复杂度 O(n) 每次搞完就会直接释放掉了</li></ul><h1 id="2-快速排序"><a href="#2-快速排序" class="headerlink" title="2. 快速排序"></a>2. 快速排序</h1><p><img src="https://i.loli.net/2020/02/10/J6wH1nKPtv9qIAm.jpg" alt="fig2.jpg"></p><ul><li>快排的思想<ul><li>如果要排序数组中下标从p到r之间的一组数据，我们选择p到r之间的任意一个数据作为pivot(分区点) </li><li>我们遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间。经过这一步骤之后，数组 p 到 r 之间的数据就被分成了三个部分，前面 p 到 q-1 之间都是小于 pivot 的，中间是 pivot，后面的 q+1 到 r 之间是大于 pivot 的。</li><li>快速排序是一种不稳定的排序方法，因为要实现swap</li></ul></li></ul><pre><code>递推公式：quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1, r)终止条件：p &gt;= r// 快速排序，A 是数组，n 表示数组的大小quick_sort(A, n) {  quick_sort_c(A, 0, n-1)}// 快速排序递归函数，p,r 为下标quick_sort_c(A, p, r) {  if p &gt;= r then return  q = partition(A, p, r) // 获取分区点  quick_sort_c(A, p, q-1)  quick_sort_c(A, q+1, r)}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这节主要讲归并排序和快速排序，二者其实都用了分治的思想，可以借鉴这个思想，来解决诸如“如何在O(n)的时间复杂度内查找一个无序数组中的第k大元素”这样的问题。&lt;/p&gt;
&lt;h1 id=&quot;1-归并排序&quot;&gt;&lt;a href=&quot;#1-归并排序&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://www.llchen60.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序" scheme="https://www.llchen60.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法(8)-排序(冒泡 插入 选择)</title>
    <link href="https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-8-%E6%8E%92%E5%BA%8F-%E5%86%92%E6%B3%A1-%E6%8F%92%E5%85%A5-%E9%80%89%E6%8B%A9/"/>
    <id>https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-8-%E6%8E%92%E5%BA%8F-%E5%86%92%E6%B3%A1-%E6%8F%92%E5%85%A5-%E9%80%89%E6%8B%A9/</id>
    <published>2020-02-09T17:49:00.000Z</published>
    <updated>2020-02-09T17:50:06.364Z</updated>
    
    <content type="html"><![CDATA[<ul><li>这里介绍三大类型的排序<ul><li>冒泡，插入，选择  O(n^2)</li><li>快排，归并 O(nlogn)</li><li>桶，计数，基数</li></ul></li></ul><h1 id="1-如何分析一个排序算法？"><a href="#1-如何分析一个排序算法？" class="headerlink" title="1. 如何分析一个排序算法？"></a>1. 如何分析一个排序算法？</h1><h2 id="1-1-执行效率"><a href="#1-1-执行效率" class="headerlink" title="1.1 执行效率"></a>1.1 执行效率</h2><ul><li>最好情况，最坏情况，平均情况时间复杂度<ul><li>要知道针对于数据集的特征，需要采取哪一种排序算法 </li></ul></li><li>时间复杂度的系数，常数，低阶<ul><li>实际开发过程中，面对规模比较小的数据，我们可能需要将系数，常数，低阶都考虑进去才可以的 </li></ul></li><li>比较次数和交换次数<ul><li>对于基于比较的排序算法，会涉及到元素大小的比较以及元素的交换或者移动，因此当我们在分析排序算法的执行效率的时候，应该把比较次数和交换次数也考虑进去 </li></ul></li></ul><h2 id="1-2-排序算法的内存消耗"><a href="#1-2-排序算法的内存消耗" class="headerlink" title="1.2 排序算法的内存消耗"></a>1.2 排序算法的内存消耗</h2><p>内存消耗可以用空间复杂度来衡量，来看算法究竟消耗了多少内存空间</p><h2 id="1-3-排序算法的稳定性"><a href="#1-3-排序算法的稳定性" class="headerlink" title="1.3 排序算法的稳定性"></a>1.3 排序算法的稳定性</h2><p>如果待排序的序列中存在值相等的元素，经过排序以后，相等元素之间原有的先后顺序不变</p><p>稳定性很重要，表现在要对几个影响因素来按照步骤进行排序的情况。</p><h1 id="2-算法分析"><a href="#2-算法分析" class="headerlink" title="2. 算法分析"></a>2. 算法分析</h1><h2 id="2-1-冒泡排序"><a href="#2-1-冒泡排序" class="headerlink" title="2.1 冒泡排序"></a>2.1 冒泡排序</h2><ul><li>操作相邻的两个数据<ul><li>每次冒泡都会对相邻的两个元素进行比较，</li><li>看是否满足大小关系要求</li><li>如果不满足就让它倆互换，一次冒泡至少会让一个元素移动到它应该在的位置，重复n次，就完成了n个数据的排序工作</li></ul></li></ul><p><img src="https://i.loli.net/2020/02/10/zUxOmSFQJLiyGMD.jpg" alt="fig1.jpg"></p><p><img src="https://i.loli.net/2020/02/10/o8L1DHgENfb2su7.jpg" alt="fig2.jpg"></p><pre><code>// 冒泡排序，a 表示数组，n 表示数组大小public void bubbleSort(int[] a, int n) {  if (n &lt;= 1) return; for (int i = 0; i &lt; n; ++i) {    // 提前退出冒泡循环的标志位，如果没有冒泡，说明已经有序了，不用再进行下去了    boolean flag = false;    // -i是因为在进行第i轮次的时候，最末尾的是已经排好了的i个数    for (int j = 0; j &lt; n - i - 1; ++j) {      if (a[j] &gt; a[j+1]) { // 交换        int tmp = a[j];        a[j] = a[j+1];        a[j+1] = tmp;        flag = true;  // 表示有数据交换            }    }    if (!flag) break;  // 没有数据交换，提前退出  }}</code></pre><ul><li>冒泡排序是原地排序算法，空间复杂度为O(1)</li><li>冒泡排序是稳定的排序算法</li><li>时间复杂度<ul><li>最好情况 O(n)</li><li>最坏情况 O(n^2)</li></ul></li></ul><h2 id="2-2-插入排序"><a href="#2-2-插入排序" class="headerlink" title="2.2 插入排序"></a>2.2 插入排序</h2><p>对于一个有序的数组来说，我们往里面添加一个新的数据，就是要遍历数组，找到数据应该插入的位置并将其插入即可。</p><p><img src="https://i.loli.net/2020/02/10/GIRQpFxgunetcr7.jpg" alt="fig3.jpg"></p><ul><li>将数组中的数据分为两个区间，已排序空间和未排序空间</li><li>初始已排序空间有一个元素，即数组的第一个元素</li><li>插入算法的核心思想是取未排序区间当中的元素，在已排序空间中找到合适的插入位置将其插入，并保证已排序空间的数据一致都是有序的</li><li>重复这个过程直到未排序空间中的元素为空</li></ul><p><img src="https://i.loli.net/2020/02/10/r9yq3FfdKginlQI.jpg" alt="fig4.jpg"></p><pre><code>// 插入排序，a 表示数组，n 表示数组大小public void insertionSort(int[] a, int n) {  if (n &lt;= 1) return;  for (int i = 1; i &lt; n; ++i) {    int value = a[i];    int j = i - 1;    // 查找插入的位置    for (; j &gt;= 0; --j) {      if (a[j] &gt; value) {        a[j+1] = a[j];  // 数据移动      } else {        break;      }    }    // 这里注意循环当中j--了，所以这里是a[j+1]    a[j+1] = value; // 插入数据  }}</code></pre><ul><li>原地排序算法，空间复杂度为O(1)</li><li>稳定的排序算法</li><li>时间复杂度<ul><li>最好情况O(n)</li><li>最坏情况O(n^2)</li></ul></li></ul><h2 id="2-3-选择排序"><a href="#2-3-选择排序" class="headerlink" title="2.3 选择排序"></a>2.3 选择排序</h2><p>同样是分成已排序空间和未排序空间，但是选择排序每次都会从未排序空间当中找到最小的元素，将其放到已排序区间的末尾</p><p><img src="https://i.loli.net/2020/02/10/uZH8xBFPs247nCr.jpg" alt="fig5.jpg"></p><ul><li><p>原地排序算法</p></li><li><p>不稳定的，因为每次都要找剩余的未排序的元素当中的最小值，并和前面的元素交换位置</p><p>  public int[] selectSort(int arr[], int n) {</p><pre><code>for (int i = 0; i &lt; n; i++) {  int index = min(i+1, n);   swap(arr[index], arr[i]);}</code></pre></li></ul><pre><code>  return arr;}</code></pre><h1 id="3-冒泡-插入-选择排序的比较"><a href="#3-冒泡-插入-选择排序的比较" class="headerlink" title="3. 冒泡 插入 选择排序的比较"></a>3. 冒泡 插入 选择排序的比较</h1><p>三者的平均时间复杂度均为O(n^2)。但是实际上还是有不同的，冒泡不如插入优秀，因为在循环当中，冒泡有三个操作，而插入只有一个。在实际情况当中，插入会比冒泡快不少。而选择排序的问题是因为它的逻辑是在未选择的数列里面选择最小的，放到已排序的末端，这里是一定会有一个swap发生的，这导致排序不稳定，即对于有相同值的，排列顺序可能会发生变化。这会在实际应用中造成问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;这里介绍三大类型的排序&lt;ul&gt;
&lt;li&gt;冒泡，插入，选择  O(n^2)&lt;/li&gt;
&lt;li&gt;快排，归并 O(nlogn)&lt;/li&gt;
&lt;li&gt;桶，计数，基数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;1-如何分析一个排序算法？&quot;&gt;&lt;a href
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://www.llchen60.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序" scheme="https://www.llchen60.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法(7)-递归</title>
    <link href="https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-7-%E9%80%92%E5%BD%92/"/>
    <id>https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-7-%E9%80%92%E5%BD%92/</id>
    <published>2020-02-09T17:47:26.000Z</published>
    <updated>2020-02-09T17:47:45.905Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-如何理解递归"><a href="#1-如何理解递归" class="headerlink" title="1.如何理解递归"></a>1.如何理解递归</h1><ul><li>递<ul><li>去的过程 </li></ul></li><li>归<ul><li>回来的过程</li></ul></li></ul><p>给我的感觉是先努力去溯源，拿到源数据以后就相当于多了一个信息，然后再依托多了一个的信息，来解决问题。</p><pre><code>f(n) = f(n-1) + 1 </code></pre><h1 id="2-递归的条件"><a href="#2-递归的条件" class="headerlink" title="2. 递归的条件"></a>2. 递归的条件</h1><ul><li>一个问题的解可以分解为几个子问题的解<ul><li>子问题指数据规模更小的解</li></ul></li><li>这个问题与分解之后的子问题，除了数据规模的不同，求解思路完全一样</li><li>存在递归终止条件</li></ul><h1 id="3-如何写递归代码"><a href="#3-如何写递归代码" class="headerlink" title="3. 如何写递归代码"></a>3. 如何写递归代码</h1><ul><li>写出递归公式</li><li>找到终止条件</li></ul><p>E.G </p><p>n个台阶，每次可以跨过1个或者2个，问一共多少种走法？ </p><ul><li>可以划分为子问题，即一共的走法等于我先走一步，剩下的n-1共同的走法和先走两步，剩下的n-1共同的走法的和。就有了一个递归公式：</li></ul><pre><code>f(n) = f(n-1) + f(n-2)</code></pre><p>终止条件，看最后几个corner case，只有一个台阶，只有两个台阶，然后用3，4来验证一下。</p><blockquote><p>写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲出终止条件，最终将递推公式和终止条件翻译成代码</p></blockquote><p>不要人为加大难度，遇到递归，抽象成一个递推公式，不再一层层的想其调用关系，不要试图用人脑去分解递归的步骤</p><p>分解子问题的时候，当我们将其分解成几个子问题B C D以后，我们要做的是在假设子问题 BCD都已经解决的前提下，思考如何解决问题A。这样子我们就可以思考问题A和子问题B,C,D两层之间的关系就可以了，不需要再一层一层往下思考更深的子问题之间的关系了。屏蔽掉递归的实现细节，我们理解起来就会容易很多了</p><h1 id="4-警惕堆栈溢出"><a href="#4-警惕堆栈溢出" class="headerlink" title="4. 警惕堆栈溢出"></a>4. 警惕堆栈溢出</h1><ul><li>递归容易堆栈溢出</li><li>函数调用会使用栈来保存临时变量，每调用一个函数，都会将临时变量封装为栈帧压入内存栈当中。等函数执行完成返回时，才出栈。</li><li>系统栈或者虚拟机栈空间都不大，如果递归层很多的话，那么就会有堆栈溢出的风险。</li><li>可以在代码中限制递归调用的最大深度来解决这个问题</li></ul><p>递归好处是表达能力强，很容易去理顺其想要表达的内容；坏处是空间复杂度会比较高，因为每次递归的时候都需要在内存栈中保存一次现场数据，所以在分析递归代码空间复杂度的时候，是需要额外考虑这部分的开销的。</p><h1 id="5-重复计算问题"><a href="#5-重复计算问题" class="headerlink" title="5. 重复计算问题"></a>5. 重复计算问题</h1><p>子步骤会被计算了很多很多遍，为了避免这种重复计算，可以使用一些数据结构来保存已经求解过得f(k)。当递归调用到f(k)的时候，先看下是否已经求解过了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-如何理解递归&quot;&gt;&lt;a href=&quot;#1-如何理解递归&quot; class=&quot;headerlink&quot; title=&quot;1.如何理解递归&quot;&gt;&lt;/a&gt;1.如何理解递归&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;递&lt;ul&gt;
&lt;li&gt;去的过程 &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;归&lt;u
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://www.llchen60.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="递归" scheme="https://www.llchen60.com/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法(6)-队列</title>
    <link href="https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-6-%E9%98%9F%E5%88%97/"/>
    <id>https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-6-%E9%98%9F%E5%88%97/</id>
    <published>2020-02-09T17:45:37.000Z</published>
    <updated>2020-02-09T17:45:58.480Z</updated>
    
    <content type="html"><![CDATA[<p>CPU资源有限，任务的处理速度和线程个数并不是线性正相关的。相反的，过多的线程会导致CPU频繁切换，处理性能下降。因此，线程池的大小一般都是综合考虑要处理任务的特点和硬件环境，来事先设置的。</p><p>当我们向固定大小的线程池中请求一个线程的时候，如果线程池中没有空闲资源，如何处理这个请求呢？ —–&gt; 队列</p><p>操作受限的线性表。</p><h1 id="1-理解队列"><a href="#1-理解队列" class="headerlink" title="1. 理解队列"></a>1. 理解队列</h1><ul><li>基本操作<ul><li>入队 enqueue()   入栈 push()</li><li>出队 dequeue()   出栈 pop()</li></ul></li><li>操作受限的线性表数据结构</li><li>带有一些特性的队列<ul><li>循环队列</li><li>阻塞队列</li><li>并发队列</li><li>顺序队列 - 数组实现</li><li>链式队列 - 链式队列</li></ul></li></ul><p>在很多偏底层系统，框架，中间件的开发当中，起到关键性作用。比如高性能disruptor,Linux环形缓存，都用到了循环并发队列; Java Concurrent并发包利用ArrayBlockingQueue来实现公平锁。</p><pre><code>// 用数组实现的队列public class ArrayQueue {  // 数组：items，数组大小：n  private String[] items;  private int n = 0;  // head 表示队头下标，tail 表示队尾下标  private int head = 0;  private int tail = 0;  // 申请一个大小为 capacity 的数组  public ArrayQueue(int capacity) {    items = new String[capacity];    n = capacity;  }  // 入队  public boolean enqueue(String item) {    // 如果 tail == n 表示队列已经满了    if (tail == n) return false;    items[tail] = item;    ++tail;    return true;  }  // 出队  public String dequeue() {    // 如果 head == tail 表示队列为空    if (head == tail) return null;    // 为了让其他语言的同学看的更加明确，把 -- 操作放到单独一行来写了    String ret = items[head];    ++head;    return ret;  }}</code></pre><h1 id="2-基于链表的队列实现方法"><a href="#2-基于链表的队列实现方法" class="headerlink" title="2. 基于链表的队列实现方法"></a>2. 基于链表的队列实现方法</h1><ul><li>两个指针<ul><li>head指针 - 指向第一个结点</li><li>tail指针 - 指向最后一个结点</li></ul></li></ul><h1 id="3-循环队列"><a href="#3-循环队列" class="headerlink" title="3. 循环队列"></a>3. 循环队列</h1><p>用数组实现的队列，在tail = n的时候，会有数据搬移操作。这样入队性能就会受到影响。循环队列的可以解决这个问题。</p><ul><li>如何确认队空和队满<ul><li>队空 head == tail</li><li>队满 (tail+1)%n = head</li></ul></li></ul><pre><code>public class CircularQueue {  // 数组：items，数组大小：n  private String[] items;  private int n = 0;  // head 表示队头下标，tail 表示队尾下标  private int head = 0;  private int tail = 0;  // 申请一个大小为 capacity 的数组  public CircularQueue(int capacity) {    items = new String[capacity];    n = capacity;  }  // 入队  public boolean enqueue(String item) {    // 队列满了    if ((tail + 1) % n == head) return false;    items[tail] = item;    tail = (tail + 1) % n;    return true;  }  // 出队  public String dequeue() {    // 如果 head == tail 表示队列为空    if (head == tail) return null;    String ret = items[head];    head = (head + 1) % n;    return ret;  }}</code></pre><h1 id="4-阻塞队列和并发队列"><a href="#4-阻塞队列和并发队列" class="headerlink" title="4. 阻塞队列和并发队列"></a>4. 阻塞队列和并发队列</h1><ul><li>阻塞队列<ul><li>在队列基础上增加了阻塞操作</li><li>队列为空的时候，从队头取数据会被阻塞</li><li>如果队列已经满了，那么插入数据的操作会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回</li><li>生产者 消费者模型  相当于</li><li>基于阻塞队列，我们可以通过协调生产者和消费者的个数来提高数据的处理效率</li><li>我们可以通过配置多几个的消费者，来应对一个生产者</li></ul></li><li>并发队列<ul><li>实现方法<ul><li>在enquue()和dequeue()方法上加锁</li><li>基于CAS原子操作</li></ul></li></ul></li></ul><h1 id="5-对比基于数组和基于链表实现的队列"><a href="#5-对比基于数组和基于链表实现的队列" class="headerlink" title="5. 对比基于数组和基于链表实现的队列"></a>5. 对比基于数组和基于链表实现的队列</h1><ul><li>基于链表的实现方式<ul><li>可以实现一个支持无限排队的无界队列</li><li>可能会导致过多的请求排队等待</li><li>请求处理的响应时间会长很多</li><li>因此对于响应时间比较敏感的系统来说，基于链表实现的无限排队的线程池就不是很合适了</li></ul></li><li>基于数组实现的有界队列<ul><li>队列大小是有限的</li><li>超过一定数量以后，请求就会被拒绝</li><li>队列的大小设置就会是个trade off了</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CPU资源有限，任务的处理速度和线程个数并不是线性正相关的。相反的，过多的线程会导致CPU频繁切换，处理性能下降。因此，线程池的大小一般都是综合考虑要处理任务的特点和硬件环境，来事先设置的。&lt;/p&gt;
&lt;p&gt;当我们向固定大小的线程池中请求一个线程的时候，如果线程池中没有空闲资
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://www.llchen60.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="队列" scheme="https://www.llchen60.com/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法(5)-栈</title>
    <link href="https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-5-%E6%A0%88/"/>
    <id>https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-5-%E6%A0%88/</id>
    <published>2020-02-09T17:44:43.000Z</published>
    <updated>2020-02-09T17:45:06.181Z</updated>
    
    <content type="html"><![CDATA[<p>大家都常用Chrome浏览器，你会发现在你做后退或者前进按钮时，浏览器的加载速度非常快，这里实际上是用的栈这个数据结构来进行处理的。</p><h1 id="1-对栈的理解"><a href="#1-对栈的理解" class="headerlink" title="1. 对栈的理解"></a>1. 对栈的理解</h1><ul><li>先进后出</li><li>操作受限的线性表，只允许在一端插入和删除数据</li><li>实质上栈的功能一定是可以被数组（顺序栈）或者链表（链式栈）来替代的，因为有拿第一个和最后一个的接口，或者说方式</li><li>用栈的好处是操作上的简单，更不容易出错一些</li><li>功能操作受限的线性表，栈可以通过数组或者链表来进行实现</li></ul><h1 id="2-支持动态扩容的顺序栈"><a href="#2-支持动态扩容的顺序栈" class="headerlink" title="2. 支持动态扩容的顺序栈"></a>2. 支持动态扩容的顺序栈</h1><ul><li>动态扩容 - load factor</li><li>顺序栈 - 数组</li></ul><p><img src="fig1.jpg" alt="fig1.jpg"></p><ul><li>注意动态扩容的顺序栈，出栈过程依然可以实现O(1)的时间复杂度，但是在入栈过程当中，如果空间不够了的话，那就需要实现整体的迁移，时间复杂度就变成了O(n)</li></ul><pre><code>// 基于数组实现的顺序栈public class ArrayStack {  private String[] items;  // 数组  private int count;       // 栈中元素个数  private int n;           //栈的大小  // 初始化数组，申请一个大小为n的数组空间  public ArrayStack(int n) {    this.items = new String[n];    this.n = n;    this.count = 0;  }  // 入栈操作  public boolean push(String item) {    // 数组空间不够了，直接返回false，入栈失败。    if (count == n) return false;    // 将item放到下标为count的位置，并且count加一    items[count] = item;    ++count;    return true;  }  // 出栈操作  public String pop() {    // 栈为空，则直接返回null    if (count == 0) return null;    // 返回下标为count-1的数组元素，并且栈中元素个数count减一    String tmp = items[count-1];    --count;    return tmp;  }}</code></pre><h1 id="3-栈的应用"><a href="#3-栈的应用" class="headerlink" title="3. 栈的应用"></a>3. 栈的应用</h1><ul><li>函数调用栈<ul><li>操作系统给每个线程分配一块独立的内存空间，这块内存被组织成栈这种结构，用来存储函数调用时的临时变量</li></ul></li><li>表达式求值<ul><li>计算机会用两个栈来实现</li><li>一个用来保存操作数</li><li>一个用来保存运算符<br>实际上，编译器就是通过两个栈来实现的。其中一个保存操作数的栈，另一个是保存运算符的栈。我们从左向右遍历表达式，当遇到数字，我们就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较。如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取 2 个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。<br><img src="fig2.jpg" alt="fig2.jpg"></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;大家都常用Chrome浏览器，你会发现在你做后退或者前进按钮时，浏览器的加载速度非常快，这里实际上是用的栈这个数据结构来进行处理的。&lt;/p&gt;
&lt;h1 id=&quot;1-对栈的理解&quot;&gt;&lt;a href=&quot;#1-对栈的理解&quot; class=&quot;headerlink&quot; title=&quot;1. 对
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://www.llchen60.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="栈" scheme="https://www.llchen60.com/tags/%E6%A0%88/"/>
    
  </entry>
  
</feed>
