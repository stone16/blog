<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Leilei&#39;s Blog | 磊磊的博客</title>
  
  <subtitle>Because it&#39;s there</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.llchen60.com/"/>
  <updated>2020-02-09T06:46:53.794Z</updated>
  <id>https://www.llchen60.com/</id>
  
  <author>
    <name>Leilei Chen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构与算法(3)-数组</title>
    <link href="https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-3-%E6%95%B0%E7%BB%84/"/>
    <id>https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-3-%E6%95%B0%E7%BB%84/</id>
    <published>2020-02-09T06:46:35.000Z</published>
    <updated>2020-02-09T06:46:53.794Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-什么是数组"><a href="#1-什么是数组" class="headerlink" title="1. 什么是数组"></a>1. 什么是数组</h1><ul><li>是一种<strong>线性表</strong>数据结构，用一组<strong>连续的内存空间</strong>，来存储一组具有<strong>相同类型</strong>的数据</li><li>线性表<ul><li>数据排成了线性的结构</li><li>每个线性表上的数据只有前后两个方向</li><li>除了数组，链表、队列、栈等也是线性表结构</li></ul></li><li>非线性表<ul><li>比如说二叉树，堆，图等  他们的数据之间不是简单的前后关系了 </li></ul></li><li>连续内存空间与相同类型的数据<ul><li>正因为有这个特征其才可以进行随机访问</li><li>但是这也导致了想要在数组当中删除，插入一个数据，为了保证连续性，就需要做大量的数据搬移工作</li><li>数组非常适合根据下标来进行访问</li></ul></li><li>线性表 - 数组<ul><li>表中的数据只有前后两个方向</li><li>数组，链表，队列，栈都是线性表结构</li></ul></li><li>非线性表<ul><li>二叉树，堆，图</li><li>数据之间并不是简单的前后关系</li></ul></li></ul><h1 id="2-数组的插入，删除，随机访问"><a href="#2-数组的插入，删除，随机访问" class="headerlink" title="2. 数组的插入，删除，随机访问"></a>2. 数组的插入，删除，随机访问</h1><ul><li>插入，删除<ul><li>在k位置做操作，那么对于k位置之后的k - n都是需要做移位的 </li></ul></li><li>删除的优化<ul><li>避免每次删除都直接的搬移数据</li><li>先记录下已经删除的数据</li><li>每次删除操作并不是真正搬移数据，只是记录数据已经被删除了</li><li>当数组没有更多空间存储了以后，再触发执行一次真正的删除操作</li><li>通过这种方式大大减少了删除操作导致的数据搬移</li><li>—–&gt; JVM标记清除垃圾回收算法</li></ul></li></ul><h1 id="3-数组的访问越界问题"><a href="#3-数组的访问越界问题" class="headerlink" title="3. 数组的访问越界问题"></a>3. 数组的访问越界问题</h1><pre><code>int main(int argc, char* argv[]){    int i = 0;    int arr[3] = {0};    for(; i&lt;=3; i++){        arr[i] = 0;        printf(&quot;hello world\n&quot;);    }    return 0;}</code></pre><p>当i=3的时候，访问越界。在C语言当中，只要不是访问受限的内存，内存空间都是可以自由访问的。a[3]会被定位到某块不属于数组的内存地址上，而这个地址正好是存储变量i的内存地址，那么arr[3] = 0 就相当于 i=0，因此会导致代码无限循环。</p><p>对这里的无限循环的解释：函数体内的局部变量存在栈上，且是连续压栈。在Linux进程的内存布局中，栈区在高地址空间，从高向低增长。变量i和arr在相邻地址，且i比arr的地址大，所以arr越界正好访问到i。当然，前提是i和arr元素同类型，否则那段代码仍是未决行为。</p><p>数组越界是一种未决行为，并没有规定数组访问越界时编译器应该如何处理。因为，访问数组的本质就是访问一段连续内存，只要数组通过偏移计算得到的内存地址是可用的，那么程序就可能不会报任何错误。</p><p>Java做了封装，会判断出数组越界的行为，并throw exception。</p><h1 id="4-容器-vs-数组"><a href="#4-容器-vs-数组" class="headerlink" title="4. 容器 vs 数组"></a>4. 容器 vs 数组</h1><p>容器，譬如Java中的ArrayList，最大优势是可以将许多数组操作细节封装起来。另外，其支持动态扩容。动态扩容很耗时的，因为牵扯到内存申请，还有整体的数据搬移。因此如果能确定需要村塾的数据的大小，最好<strong>在创建Arraylist的时候事先指定好</strong></p><ul><li>使用数组的情况<ul><li>ArrayList 无法存储基本类型，需要封装，autoBoxing, unboxing本身是有一定的性能消耗的，如果特别关注性能，那么我们就需要用数组</li><li>如果数组大小已知，并且对数据的操作很简单。不需要使用ArrayList所提供的大部分的方法，那么我们可以直接使用数组</li><li>多维数组的表示会更为直观一些</li></ul></li></ul><h1 id="5-为什么数组要从0开始编号？"><a href="#5-为什么数组要从0开始编号？" class="headerlink" title="5. 为什么数组要从0开始编号？"></a>5. 为什么数组要从0开始编号？</h1><p>因为下标最确切的定义是偏移，offset。要算a[k]的内存地址的公式为：</p><pre><code>a[k]_address = base_address + k * type_size</code></pre><p>如果我们从1开始计数，那么我们计算位置的公式就会变成：</p><pre><code>a[k]_address = base_address + (k-1)*type_size</code></pre><p>这样每次访问都会多一次减法运算！！！对于CPU来说，就是多了一次减法指令。从0开始就是为了提高效率，当然这个效率的提升其实很小，也有一大部分是历史原因了，即不同语言的迁移之间的学习成本。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-什么是数组&quot;&gt;&lt;a href=&quot;#1-什么是数组&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是数组&quot;&gt;&lt;/a&gt;1. 什么是数组&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;是一种&lt;strong&gt;线性表&lt;/strong&gt;数据结构，用一组&lt;strong&gt;连续的
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://www.llchen60.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Array" scheme="https://www.llchen60.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法(2)-复杂度分析</title>
    <link href="https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-2-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"/>
    <id>https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-2-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/</id>
    <published>2020-02-09T06:41:40.000Z</published>
    <updated>2020-02-09T06:42:03.983Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-为什么需要复杂度分析？"><a href="#1-为什么需要复杂度分析？" class="headerlink" title="1. 为什么需要复杂度分析？"></a>1. 为什么需要复杂度分析？</h1><p>通过统计和监控得到的算法执行时间的占用的内存的大小的方法称为事后统计法，这种方法有其局限性：</p><ul><li>测试结果非常依赖于测试环境</li><li>测试结果受数据规模的影响很大, 而且会和数据集本身的数据质量有关</li><li>—-&gt; 因此我们需要一个不用具体的测试数据来测试，就可以粗略估计算法的执行效率的方法</li></ul><h1 id="2-大O复杂度表示法"><a href="#2-大O复杂度表示法" class="headerlink" title="2. 大O复杂度表示法"></a>2. 大O复杂度表示法</h1><ul><li>假定每行代码执行时间都一样</li><li>并不表示具体的代码执行时间，而是表示执行时间随着数据规模增大的变化趋势，因此也叫做渐进时间复杂度。</li></ul><h1 id="3-如何分析代码的时间复杂度"><a href="#3-如何分析代码的时间复杂度" class="headerlink" title="3. 如何分析代码的时间复杂度"></a>3. 如何分析代码的时间复杂度</h1><ul><li>只关注循环执行次数最多的一段代码</li><li>加法原则：总复杂度等于量级最大的那段代码的复杂度</li><li>乘法法则： 嵌套代码的复杂度等于签到内外层代码复杂度的乘积</li></ul><h1 id="4-复杂度量级"><a href="#4-复杂度量级" class="headerlink" title="4. 复杂度量级"></a>4. 复杂度量级</h1><ul><li>常量阶 O(1)</li><li>对数阶 O(logn)</li><li>线性阶 O(n)<ul><li>O (m+n) 当我们不知道几个变量的大小的时候 </li></ul></li><li>线性对数阶 O(nlogn)</li><li>平方阶 O(n^2)<ul><li>O (m*n) 乘法关系，不知道参量之间的相对大小 </li></ul></li><li>k次方阶 O(n^k)</li><li>指数阶 O(2^n)</li><li>阶乘阶 O(n!)</li></ul><h1 id="5-空间复杂度分析"><a href="#5-空间复杂度分析" class="headerlink" title="5. 空间复杂度分析"></a>5. 空间复杂度分析</h1><p>空间复杂度的全程是渐进空间复杂度，表示算法的存储空间与数据规模之间的增长关系。</p><p>大O时间复杂度，并不具体表示代码真正的执行时间，而是表示代码执行时间随着数据规模的增大的变化趋势。因此也叫做渐进时间复杂度，(asymptotic time complexity)</p><pre><code>T(n) = O(f(n))</code></pre><p>T(n) - 代码的执行时间<br>n - 数据规模的大小<br>f(n) - 每行代码执行的次数总和<br>O - 表示左右成正比</p><h2 id="5-1-Tips"><a href="#5-1-Tips" class="headerlink" title="5.1 Tips"></a>5.1 Tips</h2><ul><li>只关注循环执行次数最多的一段代码</li><li>总复杂度等于量级最大的那段代码的复杂度</li><li>嵌套代码的复杂度为嵌套内外代码复杂度的乘积</li></ul><h1 id="6-复杂度的分析"><a href="#6-复杂度的分析" class="headerlink" title="6. 复杂度的分析"></a>6. 复杂度的分析</h1><h2 id="6-1-时间复杂度分析"><a href="#6-1-时间复杂度分析" class="headerlink" title="6.1 时间复杂度分析"></a>6.1 时间复杂度分析</h2><h3 id="6-1-1-多项式量级"><a href="#6-1-1-多项式量级" class="headerlink" title="6.1.1 多项式量级"></a>6.1.1 多项式量级</h3><ul><li>O(1) <ul><li>常量级的代码，我们将其时间复杂度都记作O(1)</li></ul></li><li>O(logn)</li></ul><pre><code> i=1; while (i &lt;= n)  {   i = i * 2; }</code></pre><ul><li>O(nlogn)</li><li>O(m+n)</li><li>O(m*n)</li></ul><h3 id="6-1-2-非多项式量级"><a href="#6-1-2-非多项式量级" class="headerlink" title="6.1.2 非多项式量级"></a>6.1.2 非多项式量级</h3><p>非常低效，会随着n的增长急剧增长，因此我们应当尽量不选择有如下时间复杂度的算法</p><ul><li>O(2^n) </li><li>O(n!)</li></ul><h2 id="6-2-空间复杂度分析"><a href="#6-2-空间复杂度分析" class="headerlink" title="6.2 空间复杂度分析"></a>6.2 空间复杂度分析</h2><p>渐进空间复杂度，表示算法的存储空间和数据规模之间的增长关系。</p><p>一般来说在O(1), O(n), O(n^2)这几个可能性上面</p><h1 id="7-浅析最好、最坏、平均、均摊时间复杂度"><a href="#7-浅析最好、最坏、平均、均摊时间复杂度" class="headerlink" title="7. 浅析最好、最坏、平均、均摊时间复杂度"></a>7. 浅析最好、最坏、平均、均摊时间复杂度</h1><pre><code>// n 表示数组 array 的长度int find(int[] array, int n, int x) {  int i = 0;  int pos = -1;  for (; i &lt; n; ++i) {    if (array[i] == x) {       pos = i;       break;    }  }  return pos;}</code></pre><h2 id="7-1-最好情况时间复杂度-best-case-time-complexity"><a href="#7-1-最好情况时间复杂度-best-case-time-complexity" class="headerlink" title="7.1 最好情况时间复杂度(best case time complexity)"></a>7.1 最好情况时间复杂度(best case time complexity)</h2><p>上面这段代码，最好情况是O(1)</p><h2 id="7-2-最坏情况时间复杂度-worst-case-time-complexity"><a href="#7-2-最坏情况时间复杂度-worst-case-time-complexity" class="headerlink" title="7.2 最坏情况时间复杂度(worst case time complexity)"></a>7.2 最坏情况时间复杂度(worst case time complexity)</h2><p>上面这段代码，最坏情况是O(n)</p><h2 id="7-3-平均情况时间复杂度-average-case-time-complexity"><a href="#7-3-平均情况时间复杂度-average-case-time-complexity" class="headerlink" title="7.3 平均情况时间复杂度(average case time complexity)"></a>7.3 平均情况时间复杂度(average case time complexity)</h2><p>需要算上发生的概率</p><p>上述例子当中，因为要查找变量x在数组当中的位置，一共有n+1种情况，在数组的0 - n-1位置中和不在数组当中。将每种情况下，需要遍历的元素个数累加起来，再除以n+1,就可以得到需要遍历的元素个数的平均值了 </p><p>即</p><pre><code>(1+2+3+ ... + n + n) / (n+1) = n(n+3)/(2(n+1))</code></pre><p>故平均复杂度还是O(n)</p><p>然而还要考虑每种情况下 发生的概率实质上是不同的，需要将这个算上</p><h2 id="7-4-均摊时间复杂度-amortized-time-complexity"><a href="#7-4-均摊时间复杂度-amortized-time-complexity" class="headerlink" title="7.4 均摊时间复杂度(amortized time complexity)"></a>7.4 均摊时间复杂度(amortized time complexity)</h2><p>不是遍历case，而是有轮回的，因此算一个轮回里的时间就可以得出平均复杂度了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-为什么需要复杂度分析？&quot;&gt;&lt;a href=&quot;#1-为什么需要复杂度分析？&quot; class=&quot;headerlink&quot; title=&quot;1. 为什么需要复杂度分析？&quot;&gt;&lt;/a&gt;1. 为什么需要复杂度分析？&lt;/h1&gt;&lt;p&gt;通过统计和监控得到的算法执行时间的占用的内存的大
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://www.llchen60.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="复杂度分析" scheme="https://www.llchen60.com/tags/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法(1)-概述</title>
    <link href="https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-1-%E6%A6%82%E8%BF%B0/"/>
    <id>https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-1-%E6%A6%82%E8%BF%B0/</id>
    <published>2020-02-09T06:39:44.000Z</published>
    <updated>2020-02-09T06:40:41.488Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-为什么要学习数据结构与算法？"><a href="#1-为什么要学习数据结构与算法？" class="headerlink" title="1. 为什么要学习数据结构与算法？"></a>1. 为什么要学习数据结构与算法？</h1><p>入职已经快1年的时间了，自己在这一年中确实有很多收获，涨了很多架构上的知识，对于工程上的代码流程有了更深一步的了解。不过愈发感觉到数据结构与算法的重要性，因为在服务出现bug的时候，除了业务逻辑上的问题，剩下的大部分都是数据结构操作上的一些问题，比如常见的Index out of bound，诸如此类。</p><p>我想与其说数据结构与算法是进入大厂的敲门砖，不如说二者是一个优秀工程师和一个CRUD 男孩的分水岭。很多时候，对于基础的理解决定了你的上限，要知道底层的知识是相通的，我们看到的很多现在的新兴技术，实际上底子上还是用的那些十年前，二十年前的理念。学习数据结构与算法，可以算得上是想要去掌握一把屠龙刀。无论遇到什么，庖丁解牛一般。</p><p>在工业界，讲道理对于业务工程师来说，大部分时间都在使用封装好的接口，类库，并翻译业务逻辑，很少需要自己实现数据结构和算法。但是，不用自己实现不代表不需要去了解。</p><p>依旧需要知道这背后的原理；需要懂得分析时间、空间的复杂度；需要能够分辨出几个相似的数据结构的不同；调用了某个函数之后，需要知道如何评估代码的性能和资源的消耗。</p><p>学习数据结构与算法，是为了让自己有能够成长起来的油/ 源。</p><h1 id="2-如何学习？"><a href="#2-如何学习？" class="headerlink" title="2. 如何学习？"></a>2. 如何学习？</h1><p>首先，数据结构与算法的关系是：数据结构为算法服务，而算法要作用在特定的数据结构之上。</p><p>数据结构是静态的，是组织数据的一种方式。我们需要在其基础上操作、构建算法，孤立存在的数据结构是没用的。</p><ul><li>复杂度分析<ul><li>数据结构与算法是解决如何更省，更快的存储和处理数据的问题</li><li>复杂度分析就是对应的考量效率和资源消耗的方法</li></ul></li></ul><p><img src="https://i.loli.net/2020/02/09/LTqyj9aMOQsXw8U.jpg" alt="fig1.png"></p><ul><li>数据结构算法树状图<ul><li>复杂度分析<ul><li>空间复杂度</li><li>时间复杂度<ul><li>最好</li><li>最坏</li><li>平均</li><li>均摊</li></ul></li></ul></li><li>基本算法思想<ul><li>贪心</li><li>分治</li><li>动态规划</li><li>回溯</li><li>枚举</li></ul></li><li>排序<ul><li>O(n^2)<ul><li>冒泡排序</li><li>插入排序</li><li>选择排序</li><li>希尔排序</li></ul></li><li>O(nlogn)<ul><li>归并排序</li><li>快速排序</li><li>堆排序</li></ul></li><li>O(n)<ul><li>计数排序</li><li>基数排序</li><li>桶排序</li></ul></li></ul></li><li>搜索<ul><li>深度优先搜索</li><li>广度优先搜索</li><li>A启发式搜索</li></ul></li><li>查找<ul><li>线性表查找</li><li>树结构查找</li><li>散列表查找</li></ul></li><li>字符串匹配<ul><li>朴素</li><li>KMP</li><li>Robin-Karp</li><li>Boyer-Moore</li><li>AC自动机</li><li>Trie</li><li>后缀数组</li></ul></li><li>图<ul><li>存储<ul><li>邻接矩阵</li><li>邻接表</li></ul></li><li>拓扑排序</li><li>最短路径</li><li>关键路径</li><li>最小生成树</li><li>二分图</li><li>最大流</li></ul></li><li>树<ul><li>二叉树<ul><li>平衡二叉树</li><li>二叉查找树</li><li>平衡二叉查找树<ul><li>AVL树</li><li>红黑树</li></ul></li><li>完全二叉树</li><li>满二叉树</li></ul></li><li>多路查找树<ul><li>B 树</li><li>B+ 树</li><li>2-3 树</li><li>2-3-4 树</li></ul></li><li>堆<ul><li>小顶堆</li><li>大顶堆</li><li>优先级队列</li><li>斐波那契堆</li><li>二项堆</li></ul></li><li>其他<ul><li>梨形数组</li><li>线段树</li></ul></li></ul></li><li>散列表<ul><li>散列函数</li><li>冲突解决<ul><li>链表法</li><li>开放寻址</li><li>其他</li></ul></li><li>动态扩容</li><li>位图</li></ul></li><li>线性表<ul><li>数组</li><li>链表<ul><li>单链表</li><li>双向链表</li><li>循环链表</li><li>双向循环链表</li><li>静态链表</li></ul></li><li>栈<ul><li>顺序栈</li><li>链式栈</li></ul></li><li>队列<ul><li>普通队列</li><li>双端队列</li><li>阻塞队列</li><li>并发队列</li><li>阻塞并发队列</li></ul></li></ul></li></ul></li></ul><h2 id="2-1-最常用的基础总结"><a href="#2-1-最常用的基础总结" class="headerlink" title="2.1 最常用的基础总结"></a>2.1 最常用的基础总结</h2><ul><li>数据结构<ul><li>数组</li><li>链表</li><li>栈</li><li>队列</li><li>散列表</li><li>二叉树</li><li>堆</li><li>跳表</li><li>图</li><li>Trie树</li></ul></li><li>算法<ul><li>递归</li><li>排序</li><li>二分查找</li><li>搜索</li><li>哈希算法</li><li>贪心算法</li><li>分治算法</li><li>回溯算法</li><li>动态规划</li><li>字符串匹配算法</li></ul></li></ul><p>对于数据结构和算法，要学习的是：</p><ul><li>其自身来历</li><li>特点</li><li>适合解决的问题</li><li>实际的应用场景</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-为什么要学习数据结构与算法？&quot;&gt;&lt;a href=&quot;#1-为什么要学习数据结构与算法？&quot; class=&quot;headerlink&quot; title=&quot;1. 为什么要学习数据结构与算法？&quot;&gt;&lt;/a&gt;1. 为什么要学习数据结构与算法？&lt;/h1&gt;&lt;p&gt;入职已经快1年的时间了，
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://www.llchen60.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>后端开发实践-项目模板</title>
    <link href="https://www.llchen60.com/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5-%E9%A1%B9%E7%9B%AE%E6%A8%A1%E6%9D%BF/"/>
    <id>https://www.llchen60.com/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5-%E9%A1%B9%E7%9B%AE%E6%A8%A1%E6%9D%BF/</id>
    <published>2020-02-09T06:26:51.000Z</published>
    <updated>2020-02-09T06:27:26.585Z</updated>
    
    <content type="html"><![CDATA[<p>整理出一套公共性的项目模板，旨在尽量多地包含日常开发所需，减少开发者的重复性工作以及提供一些最佳实践。</p><h1 id="1-从写好README开始"><a href="#1-从写好README开始" class="headerlink" title="1. 从写好README开始"></a>1. 从写好README开始</h1><p>一个好的README给人以项目概览，可以使新人快速上手项目，并降低沟通成本，建议包括：</p><ul><li>项目简介<ul><li>一两句话描述该项目实现的业务功能</li></ul></li><li>技术选型<ul><li>项目的技术栈，包括语言，框架，中间件等</li></ul></li><li>本地构建<ul><li>列出本地开发过程中所用到的工具命令</li></ul></li><li>领域模型<ul><li>核心的领域概念，针对于当前系统所在的领域</li></ul></li><li>测试策略<ul><li>自动化测试如何分类</li></ul></li><li>技术架构<ul><li>技术架构图</li></ul></li><li>部署架构<ul><li>部署架构图</li></ul></li><li>外部依赖<ul><li>项目运行时所以来的外部集成方</li></ul></li><li>环境信息<ul><li>各个环境的访问方式，数据库连接</li></ul></li><li>编码实践<ul><li>统一的编码实践，比如异常处理原则，分页封装等</li></ul></li><li>FAQ<ul><li>开发过程中常见问题的解答</li></ul></li></ul><p>注意保持README的持续更新，一些重要的架构决定可以通过示例代码的形式记录在代码块当中，新开发者可以通过直接阅读这些示例代码快速了解项目的通用实践方式以及架构选择</p><h1 id="2-一键式本地构建"><a href="#2-一键式本地构建" class="headerlink" title="2. 一键式本地构建"></a>2. 一键式本地构建</h1><p>写一个必需的script，自动化完成本地构建的过程</p><ul><li><code>run.sh</code> 进行本地调试或者必要的手动测试</li><li><code>local-build.sh</code>，完成本地构建</li></ul><h1 id="3-日志处理"><a href="#3-日志处理" class="headerlink" title="3. 日志处理"></a>3. 日志处理</h1><ul><li>在日志中加入请求标识，便于链路追踪。在处理一个请求的过程中有时会输出多条日志，如果每条日志都共享统一的请求ID，那么在日志追踪时会更加方便。此时，可以使用Logback原生提供的MDC(Mapped Diagnostic Context)功能，创建一个RequestIdMdcFilter</li></ul><pre><code>    protected void doFilterInternal(HttpServletRequest request,                                HttpServletResponse response,                                FilterChain filterChain)        throws ServletException, IOException {    //request id in header may come from Gateway, eg. Nginx    String headerRequestId = request.getHeader(HEADER_X_REQUEST_ID);    MDC.put(REQUEST_ID, isNullOrEmpty(headerRequestId) ? newUuid() : headerRequestId);    try {        filterChain.doFilter(request, response);    } finally {        clearMdc();    }}</code></pre><ul><li>集中式日志管理，在多节点部署的场景下，各个节点的日志是分散的，为此可以引入诸如ELK之类的工具将日志统一输出到ElasticSearch中。</li></ul><pre><code>&lt;appender name=&quot;REDIS&quot; class=&quot;com.cwbase.logback.RedisAppender&quot;&gt;&lt;tags&gt;ecommerce-order-backend-${ACTIVE_PROFILE}&lt;/tags&gt;&lt;host&gt;elk.yourdomain.com&lt;/host&gt;&lt;port&gt;6379&lt;/port&gt;&lt;password&gt;whatever&lt;/password&gt;&lt;key&gt;ecommerce-ordder-log&lt;/key&gt;&lt;mdc&gt;true&lt;/mdc&gt;&lt;type&gt;redis&lt;/type&gt;&lt;/appender&gt;</code></pre><h1 id="4-异常处理"><a href="#4-异常处理" class="headerlink" title="4. 异常处理"></a>4. 异常处理</h1><p>在设计异常处理的框架的时候，需要考虑到： </p><ul><li>向客户端提供格式统一的异常返回</li><li>异常信息中应该包含足够多的上下文信息，最好是结构化的数据以便于客户端解析</li><li>不同类型的异常应该包含唯一标识，以便客户端精确识别</li></ul><p>异常处理有两种处理形式，一种是层级式，即每种具体的异常都对应了一个异常类，这些类最终继承自某个父异常；另外一种是单一式，即整个程序中只有一个异常类，再以一个字段来区分不同的异常场景。层级式异常的好处能够显化异常的含义，但是如果设计不好可能会导致程序中大量的异常类。</p><p>使用层级式异常的范例：</p><pre><code>public abstract class AppException extends RuntimeException {    private final ErrorCode code;    private final Map&lt;String, Object&gt; data = newHashMap();}</code></pre><p>这里，ErrorCode枚举中包含了异常的唯一标识、HTTP状态码以及错误信息；而data字段表示各个异常的上下文信息。</p><pre><code>public class OrderNotFoundException extends AppException {    public OrderNotFoundException(OrderId orderId) {        super(ErrorCode.ORDER_NOT_FOUND, ImmutableMap.of(&quot;orderId&quot;, orderId.toString()));    }}</code></pre><p>在返回给客户端的时候，通过一个ErrorDetail类来统一异常格式：</p><pre><code>public final class ErrorDetail {    private final ErrorCode code;    private final int status;    private final String message;    private final String path;    private final Instant timestamp;    private final Map&lt;String, Object&gt; data = newHashMap();}</code></pre><p>最终返回给客户端的数据为：</p><pre><code>{  requestId: &quot;d008ef46bb4f4cf19c9081ad50df33bd&quot;,  error: {    code: &quot;ORDER_NOT_FOUND&quot;,    status: 404,    message: &quot;没有找到订单&quot;,    path: &quot;/order&quot;,    timestamp: 1555031270087,    data: {      orderId: &quot;123456789&quot;    }  }}</code></pre><h1 id="5-统一代码风格"><a href="#5-统一代码风格" class="headerlink" title="5. 统一代码风格"></a>5. 统一代码风格</h1><p>除了Checkstyle以外，项目中有些通用的公共编码实践方式也需要进行统一。</p><ul><li>客户端的请求数据类统一使用相同后缀，比如Command</li><li>返回给客户端的数据统一使用相同后缀，比如Represetation</li><li>统一对请求处理的流程框架，比如采用传统的3层架构或者DDD战术模式</li><li>提供一致的异常返回（请参考“异常处理”小节）</li><li>提供统一的分页结构类</li><li>明确测试分类以及统一的测试基础类（请参考“自动化测试分类”小节）<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1></li></ul><p><a href="https://insights.thoughtworks.cn/backend-development-iteration0/" target="_blank" rel="noopener">https://insights.thoughtworks.cn/backend-development-iteration0/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;整理出一套公共性的项目模板，旨在尽量多地包含日常开发所需，减少开发者的重复性工作以及提供一些最佳实践。&lt;/p&gt;
&lt;h1 id=&quot;1-从写好README开始&quot;&gt;&lt;a href=&quot;#1-从写好README开始&quot; class=&quot;headerlink&quot; title=&quot;1. 从写好R
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="项目模板" scheme="https://www.llchen60.com/tags/%E9%A1%B9%E7%9B%AE%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>XML与JSON的比较</title>
    <link href="https://www.llchen60.com/XML%E4%B8%8EJSON%E7%9A%84%E6%AF%94%E8%BE%83/"/>
    <id>https://www.llchen60.com/XML%E4%B8%8EJSON%E7%9A%84%E6%AF%94%E8%BE%83/</id>
    <published>2020-02-09T06:25:58.000Z</published>
    <updated>2020-02-09T06:26:25.494Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-JSON"><a href="#1-JSON" class="headerlink" title="1. JSON"></a>1. JSON</h1><p>JSON - JavaScript Object Notation, an open standard file format uses human-readable text to transmit data objects consisting of attribute–value pairs and array data types (or any other serializable value). It is a very common data format used for asynchronous browser–server communication, including as a replacement for XML in some AJAX-style systems.</p><p>The official Internet media type for JSON is <strong>application/json</strong>. </p><h1 id="2-XML"><a href="#2-XML" class="headerlink" title="2. XML"></a>2. XML</h1><p>JSON is promoted as a <strong>low-overhead alternative</strong> to XML as both of these formats have widespread support for creation, reading, and decoding in the real-world situations where they are commonly used.</p><p>XML has been used to <strong>describe structured data and to serialize objects</strong>. Various XML-based protocols exist to represent the same kind of data structures as JSON for the same kind of data interchange purposes. Data can be encoded in XML in several ways. The most expansive form <strong>using tag pairs results</strong> in a much larger representation than JSON, but if data is stored in attributes and ‘short tag’ form where the closing tag is replaced with ‘/&gt;’, the representation is often about the same size as JSON or just a little larger. If the data is compressed <strong>using an algorithm like gzip</strong>, there is little difference because compression is good at saving space when a pattern is repeated.</p><p>XML also has the concept of <strong>++schema++</strong>. <strong>This permits strong typing, user-defined types, predefined tags, and formal structure, allowing for formal validation of an XML stream in a portable way</strong>. Similarly, there is an IETF draft proposal for a schema system for JSON.[44]</p><p>XML supports comments, but JSON does not</p><h1 id="3-Differences"><a href="#3-Differences" class="headerlink" title="3. Differences"></a>3. Differences</h1><h1 id="3-1-XML-is-a-markup-language-whereas-JSON-is-a-way-of-representing-objects"><a href="#3-1-XML-is-a-markup-language-whereas-JSON-is-a-way-of-representing-objects" class="headerlink" title="3.1 XML is a markup language whereas JSON is a way of representing objects"></a>3.1 XML is a markup language whereas JSON is a way of representing objects</h1><p>A markup language is a way of adding extra information to free-flowing plain text </p><pre><code>&lt;Document&gt;    &lt;Paragraph Align=&quot;Center&quot;&gt;        Here &lt;Bold&gt;is&lt;/Bold&gt; some text.    &lt;/Paragraph&gt;&lt;/Document&gt;</code></pre><p>An object notation like JSON is not as flexible. But this is usually a good thing. When you’re representing objects, you simply don’t need the extra flexibility. To represent the above example in JSON, you’d actually have to solve some problems manually that XML solves for you.</p><pre><code>{    &quot;Paragraphs&quot;: [        {            &quot;align&quot;: &quot;center&quot;,            &quot;content&quot;: [                &quot;Here &quot;, {                    &quot;style&quot; : &quot;bold&quot;,                    &quot;content&quot;: [ &quot;is&quot; ]                },                &quot; some text.&quot;            ]        }    ]}</code></pre><p>JSON is better suited if you have typical a hierarchy of objects and you want to represent them in a stream. </p><pre><code>{    &quot;firstName&quot;: &quot;Homer&quot;,    &quot;lastName&quot;: &quot;Simpson&quot;,    &quot;relatives&quot;: [ &quot;Grandpa&quot;, &quot;Marge&quot;, &quot;The Boy&quot;, &quot;Lisa&quot;, &quot;I think that&#39;s all of them&quot; ]} </code></pre><p>Below is same expression in xml</p><pre><code>&lt;Person&gt;    &lt;FirstName&gt;Homer&lt;/FirstName&gt;    &lt;LastName&gt;Simpsons&lt;/LastName&gt;    &lt;Relatives&gt;        &lt;Relative&gt;Grandpa&lt;/Relative&gt;        &lt;Relative&gt;Marge&lt;/Relative&gt;        &lt;Relative&gt;The Boy&lt;/Relative&gt;        &lt;Relative&gt;Lisa&lt;/Relative&gt;        &lt;Relative&gt;I think that&#39;s all of them&lt;/Relative&gt;    &lt;/Relatives&gt;&lt;/Person&gt;</code></pre><h2 id="3-2-JSON-has-defined-ways-of-distinguishing-records"><a href="#3-2-JSON-has-defined-ways-of-distinguishing-records" class="headerlink" title="3.2 JSON has defined ways of distinguishing records"></a>3.2 JSON has defined ways of distinguishing records</h2><p>You can differenciate records directly in JSON. List and normal record have different expression; wheareas in XML, they look all same. </p><p>We need to use an external schema or extra user defined attributes in XML to express different expressions, or some limitations on it. While in JSON, it’s self describing by default. </p><p>-&gt; JSON should be the first choise for object notation, where XML should spot at document markup. </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-JSON&quot;&gt;&lt;a href=&quot;#1-JSON&quot; class=&quot;headerlink&quot; title=&quot;1. JSON&quot;&gt;&lt;/a&gt;1. JSON&lt;/h1&gt;&lt;p&gt;JSON - JavaScript Object Notation, an open standard 
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/tags/BackEnd/"/>
    
  </entry>
  
  <entry>
    <title>System.gc() and Runtime.gc()</title>
    <link href="https://www.llchen60.com/System-gc-and-Runtime-gc/"/>
    <id>https://www.llchen60.com/System-gc-and-Runtime-gc/</id>
    <published>2020-02-09T06:10:53.000Z</published>
    <updated>2020-02-09T06:11:17.904Z</updated>
    
    <content type="html"><![CDATA[<p>首先在Java中垃圾回收算法是首先遍历所有在堆中的非垃圾的对象，然后推断出那些一段时间内没有被访问的对象一定是垃圾了。call gc()方法不是强制垃圾回收发生的，相反的，它只是在建议JVM现在是不错的做垃圾回收的时间。</p><p>system.gc()是用来运行垃圾收集器的。call这个方法就意味着Java虚拟机正在努力去回收没有被使用的对象，使得他们现在占用的内存可以进行快速地再利用。整个垃圾回收在Java中是自动进行的。</p><p>system.gc()是个静态方法，但是手动调用它很有可能会让整个系统运行更慢的，一般为了加快整体的运行，会使用<code>-XX:+DisableExplicitGC</code>这条指令，这样子JVM就不会在你手动唤醒gc的时候直接call这个方法了。</p><p>runtime.gc()和system.gc()并没有什么区别，实质上system.gc()内部就call了runtime.gc()。 唯一的不同在于System.gc()是类的方法然而runtime.gc()是实例方法。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="http://net-informations.com/java/cjava/gc.htm" target="_blank" rel="noopener">http://net-informations.com/java/cjava/gc.htm</a> </li><li><a href="https://docs.oracle.com/javase/7/docs/api/java/lang/System.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/7/docs/api/java/lang/System.html</a> </li><li><a href="https://www.geeksforgeeks.org/garbage-collection-java/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/garbage-collection-java/</a> </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先在Java中垃圾回收算法是首先遍历所有在堆中的非垃圾的对象，然后推断出那些一段时间内没有被访问的对象一定是垃圾了。call gc()方法不是强制垃圾回收发生的，相反的，它只是在建议JVM现在是不错的做垃圾回收的时间。&lt;/p&gt;
&lt;p&gt;system.gc()是用来运行垃圾收
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Ruby Totorial</title>
    <link href="https://www.llchen60.com/Ruby-Totorial/"/>
    <id>https://www.llchen60.com/Ruby-Totorial/</id>
    <published>2020-02-09T05:22:07.000Z</published>
    <updated>2020-02-09T05:22:33.775Z</updated>
    
    <content type="html"><![CDATA[<p>Met circumstances where need Ruby knowledge to resolve problems, thus need to do a quick touch on Ruby, at least know how to read ruby code. </p><p>Leran by doing, or we say, learn by satisfying current needs. </p><h1 id="1-Basics"><a href="#1-Basics" class="headerlink" title="1. Basics"></a>1. Basics</h1><ul><li>features <ul><li>object-oriented </li><li>server side scripting language </li><li>can be used to write common gateway interface(CGI) scripts</li></ul></li></ul><h2 id="1-1-Syntax-of-Ruby"><a href="#1-1-Syntax-of-Ruby" class="headerlink" title="1.1 Syntax of Ruby"></a>1.1 Syntax of Ruby</h2><ul><li>whitespace <ul><li>ignored in ruby code, except when they appear in strings. </li></ul></li><li>end of line<ul><li>you could use <ul><li>semicolons </li><li>newline characters as the ending of a statement </li></ul></li></ul></li><li>Ruby Identifiers<ul><li>case sensitive </li></ul></li><li>comments<ul><li><code>#</code></li><li><code>=begin</code> at beginning, <code>=end</code> at the end</li></ul></li></ul><pre><code>// Declares code to be called before the program run BEGIN {    code}// Declares code to be called at the end of the program END {    code}</code></pre><ul><li>classes and objects <ul><li>features<ul><li>data encapsulation </li><li>data abstraction </li><li>polymorphism</li><li>inheritance </li></ul></li></ul></li></ul><pre><code>// Class exampleClass Vehicle {   Number no_of_wheels   Number horsepower   Characters type_of_tank   Number Capacity   Function speeding {   }   Function driving {   }   Function halting {   }}</code></pre><h2 id="1-2-Class-and-Objects"><a href="#1-2-Class-and-Objects" class="headerlink" title="1.2 Class and Objects"></a>1.2 Class and Objects</h2><ul><li>Define a class in Ruby </li></ul><pre><code>// A class always starts with keyword class, followed by the name of the class. // Terminate a class by using the keyword end. class Customerend</code></pre><ul><li>Variables in a Ruby Class <ul><li>local variables <ul><li>defined in a method</li><li>begin with a lowercase letter or _. </li></ul></li><li>instance variables <ul><li>available across methods for any particular instance or object </li><li>instance variables change from object to object </li><li><code>@</code></li></ul></li><li>class variables <ul><li>available across different objects </li><li>belongs to the class and is a characteristic of a class </li><li><code>@@</code></li></ul></li><li>global variables <ul><li>Class variables are not available across classes, while global variables are.  </li><li><code>$</code></li></ul></li></ul></li></ul><pre><code>// Determine the number of objects that are being ccreated class Customer   @@no_of_customers = 0end</code></pre><ul><li>creating objects with <code>new</code> method<ul><li><code>object1 = Customer.new</code></li><li>object1 is object name</li><li>Customer is class</li><li>To instantiate a new object, you need to use class name followed by dot and new(keyword)</li></ul></li><li>custom method to create ruby objects (similar to constructor concept in Java)<ul><li>pass parameters to method new </li><li>when you plan to declare new method with parameters, you need to declare the method <strong>initialize</strong> at the time of the class creation </li></ul></li></ul><pre><code>class Customer   @@no_of_customers = 0   def initialize(id, name, addr)      @cust_id = id      @cust_name = name      @cust_addr = addr   endend// To create objects cust1 = Customer.new(&quot;1&quot;, &quot;John&quot;, &quot;Wisdom Apartments, Ludhiya&quot;)</code></pre><ul><li>member functions in class <ul><li>each method in a class starts with the keyword <code>def</code> followed by the method name </li></ul></li></ul><pre><code>class Sample    def function        statement 1        statement 2    endend// A full example #!/usr/bin/rubyclass Sample   def hello      puts &quot;Hello Ruby!&quot;   endend# Now using above class to create objectsobject = Sample. newobject.hello</code></pre><h2 id="1-3-Variables"><a href="#1-3-Variables" class="headerlink" title="1.3 Variables"></a>1.3 Variables</h2><ul><li>Global Variables <ul><li>begin with $ </li><li>uninitialized global variables have the value <code>nil</code> </li></ul></li></ul><pre><code>#!/usr/bin/ruby$global_variable = 10class Class1   def print_global      # In ruby, you can use HashTag to access any variables value       puts &quot;Global variable in Class1 is #$global_variable&quot;   endendclass Class2   def print_global      puts &quot;Global variable in Class2 is #$global_variable&quot;   endendclass1obj = Class1.newclass1obj.print_globalclass2obj = Class2.newclass2obj.print_global</code></pre><ul><li>Instance Variables <ul><li>begin with <code>@</code></li></ul></li></ul><pre><code>#!/usr/bin/rubyclass Customer   def initialize(id, name, addr)      @cust_id = id      @cust_name = name      @cust_addr = addr   end   def display_details()      puts &quot;Customer id #@cust_id&quot;      puts &quot;Customer name #@cust_name&quot;      puts &quot;Customer address #@cust_addr&quot;   endend# Create Objectscust1 = Customer.new(&quot;1&quot;, &quot;John&quot;, &quot;Wisdom Apartments, Ludhiya&quot;)cust2 = Customer.new(&quot;2&quot;, &quot;Poul&quot;, &quot;New Empire road, Khandala&quot;)# Call Methodscust1.display_details()cust2.display_details()</code></pre><ul><li>Class Variables <ul><li>begin with @@</li><li>must be initialized before they can be used in method definitions </li></ul></li></ul><pre><code>#!/usr/bin/rubyclass Customer   @@no_of_customers = 0   def initialize(id, name, addr)      @cust_id = id      @cust_name = name      @cust_addr = addr   end   def display_details()      puts &quot;Customer id #@cust_id&quot;      puts &quot;Customer name #@cust_name&quot;      puts &quot;Customer address #@cust_addr&quot;   end   def total_no_of_customers()      @@no_of_customers += 1      puts &quot;Total number of customers: #@@no_of_customers&quot;   endend# Create Objectscust1 = Customer.new(&quot;1&quot;, &quot;John&quot;, &quot;Wisdom Apartments, Ludhiya&quot;)cust2 = Customer.new(&quot;2&quot;, &quot;Poul&quot;, &quot;New Empire road, Khandala&quot;)# Call Methodscust1.total_no_of_customers()cust2.total_no_of_customers()</code></pre><ul><li><p>Local variables </p><ul><li>begin with a lowercase letter or <code>_</code></li><li>scope<ul><li>class</li><li>module</li><li>def</li><li>do to the corresponding end</li><li>block’s opening brace to its close brace </li></ul></li></ul></li><li><p>Constants</p><ul><li>Begin with an <strong>uppercase</strong> letter  </li><li>defined within a class or module </li></ul></li><li><p>Pseudo-variables </p><ul><li><p>self </p></li><li><p>true</p></li><li><p>false</p></li><li><p>nil </p><ul><li>Value representing undefined </li></ul></li><li><p><code>_FILE_</code></p><ul><li>the name of the current source file </li></ul></li><li><p><code>_LINE_</code></p><ul><li>the current line number in the source file <h2 id="1-4-Arrays"><a href="#1-4-Arrays" class="headerlink" title="1.4 Arrays"></a>1.4 Arrays</h2>Array are created by placing a comma-separated series of object references between the square brackets.</li></ul><p>#!/usr/bin/ruby</p><p>ary = [  “fred”, 10, 3.14, “This is a string”, “last element”, ]<br>ary.each do |i|<br> puts i<br>end</p></li></ul></li></ul><h2 id="1-5-Hashes"><a href="#1-5-Hashes" class="headerlink" title="1.5 Hashes"></a>1.5 Hashes</h2><p>Hash is created by placing a list of key/value pairs between braces, with either a comma or the sequence =&gt; between the key and the value. A trailing comma is ignored.</p><pre><code>#!/usr/bin/rubyhsh = colors = { &quot;red&quot; =&gt; 0xf00, &quot;green&quot; =&gt; 0x0f0, &quot;blue&quot; =&gt; 0x00f }hsh.each do |key, value|   print key, &quot; is &quot;, value, &quot;\n&quot;end</code></pre><h2 id="1-6-Ranges"><a href="#1-6-Ranges" class="headerlink" title="1.6 Ranges"></a>1.6 Ranges</h2><p>A Range represents an interval which is a set of values with a start and an end. Ranges may be constructed using the s..e and s…e literals, or with Range.new.</p><pre><code>#!/usr/bin/ruby(10..15).each do |n|    print n, &#39; &#39; end</code></pre><h2 id="1-7-Operators"><a href="#1-7-Operators" class="headerlink" title="1.7 Operators"></a>1.7 Operators</h2><ul><li><code>&lt;=&gt;</code><ul><li>ruturn 0 if first operand equals second</li><li>1 if first greater than second</li><li>-1 if first less than second </li></ul></li><li><code>.eql?</code><ul><li>true if the receiver and argument have both the same type and equal values</li></ul></li><li><code>equal?</code><ul><li>true if the receiver and argument have the same object id </li></ul></li><li><code>..</code><ul><li>1..10 creates a range from 1 to 10 inclusive</li></ul></li><li><code>...</code><ul><li>1…10 creates a range from 1 to 9  </li></ul></li><li>defined? operators<ul><li>takes the form of a method call to determine whether or not the passed expression is defined</li><li>returns a description string of the expression, or nil if the expression isn’t defined </li></ul></li><li>dot operators<ul><li></li></ul></li><li>double colon <code>::</code> operators<ul><li>You call a module method by preceding its name with the module’s name and a period, and you reference a constant using the module name and two colons. </li><li><code>::</code> us a unary operator that allows constants, instance methods and class methods defined within a class or module to be accessed from anywhere outside the class or module </li><li>*<em>Classes and methods are considered to be constants too *</em></li></ul></li></ul><h2 id="1-8-Conditions"><a href="#1-8-Conditions" class="headerlink" title="1.8 Conditions"></a>1.8 Conditions</h2><pre><code>// if else condition checkif condition    code..elsif condition2    codeelse     codeend// case #!/usr/bin/ruby$age =  5case $agewhen 0 .. 2   puts &quot;baby&quot;when 3 .. 6   puts &quot;little child&quot;when 7 .. 12   puts &quot;child&quot;when 13 .. 18   puts &quot;youth&quot;else   puts &quot;adult&quot;end</code></pre><h2 id="1-9-Loops"><a href="#1-9-Loops" class="headerlink" title="1.9 Loops"></a>1.9 Loops</h2><pre><code>while condition do     codeend</code></pre><p>Executes code while conditional is true </p><pre><code>$i = 0$num = 5begin     puts(&quot;123&quot;)    $i += 1end while $i &lt; $num // for loopfor i in 0..5    puts &quot;Value of local variable is #{i}&quot;end// subtitute way of for loop(expression).each do |variable|     codeend// E.G (0..5).each do |i|    puts &quot;Value of local variable is #{i}&quot;end </code></pre><ul><li><code>next</code><ul><li>jump to the next iteration of the most internal loop </li></ul></li><li><code>redo</code><ul><li>restarts this iteration of the most internal loop, without checking loop condition  </li></ul></li><li><code>retry</code></li><li><code>break</code><ul><li>terminate the most internal loop  </li></ul></li></ul><h2 id="1-10-Methods"><a href="#1-10-Methods" class="headerlink" title="1.10 Methods"></a>1.10 Methods</h2><ul><li><p>used to bundle one or more repeatable statements into a single unit </p></li><li><p>method name should begin with a lowercase lettter </p></li><li><p>method should be defined before calling them </p></li><li><p>call the method by direcly type in the method name <code>method_name</code></p></li><li><p>with parameters <code>method_name 25, 30</code></p></li><li><p>Ruby will return the value of lat statement by default </p></li><li><p>or use the return statement </p></li><li><p>method defined in the class definition are marked as <strong>public</strong> by default </p></li><li><p>a block is always invoked from a function with the same name as that of the block </p><p>  def method_name (var1, var2)</p><pre><code>  expr</code></pre><p>  end </p></li><li><p>variable number of parameters </p><ul><li><code>def sample (*test)</code>   </li></ul></li></ul><h2 id="1-11-Blocks"><a href="#1-11-Blocks" class="headerlink" title="1.11 Blocks"></a>1.11 Blocks</h2><ul><li>definition <ul><li>consists of chunks of code</li><li>assign a name to a block </li><li>code in the block is always enclosed within braces <code>{}</code> or <code>()</code></li><li>a block is always invoked from a function with the same name as that of the block</li><li>invoke a block by using the <code>yield</code> statement </li></ul></li><li>if the last argument of a method is preceded by &amp;, then you can pass a block to this method and this block will be assigned to the last parameter. </li></ul><pre><code>#!/usr/bin/rubydef test(&amp;block)   block.callendtest { puts &quot;Hello World!&quot;}</code></pre><h2 id="1-12-Modules-and-Mixins"><a href="#1-12-Modules-and-Mixins" class="headerlink" title="1.12 Modules and Mixins"></a>1.12 Modules and Mixins</h2><ul><li>Module<ul><li>way of grouping together methods, classes, and constants </li><li>provides namespace and prevent name clashes<ul><li>a sandbox  </li></ul></li><li>implement mixin facility </li></ul></li></ul><pre><code>// syntaxmodule Identifier    statement1    statement2end</code></pre><ul><li>call a module method by precedint its name with the module’s name and a period </li><li>reference a constant using the module name and two colons </li></ul><pre><code>#!/usr/bin/ruby# Module defined in trig.rb filemodule Trig   PI = 3.141592654   def Trig.sin(x)   # ..   end   def Trig.cos(x)   # ..   endend</code></pre><ul><li><p><code>require</code></p><ul><li>similar to import, include</li><li>if a third program wants to use any defined module, it can simply load the module files using the Ruby<code>require</code> statement </li></ul></li><li><p>mixin </p><ul><li>multiple inheratance </li></ul></li></ul><pre><code>module A   def a1   end   def a2   endendmodule B   def b1   end   def b2   endendclass Sampleinclude Ainclude B   def s1   endendsamp = Sample.newsamp.a1samp.a2samp.b1samp.b2samp.s1</code></pre><p>In this way, samp could call method defined in Module A and Module B</p><h2 id="1-13-Strings"><a href="#1-13-Strings" class="headerlink" title="1.13 Strings"></a>1.13 Strings</h2><ul><li>holds and manipulates an arbitrary sequence of one or more bytes</li></ul><h2 id="1-14-Array"><a href="#1-14-Array" class="headerlink" title="1.14 Array"></a>1.14 Array</h2><ul><li>ordered, integer indexed collections of any object</li><li>each element in an array is associated with and referred to by an index </li><li>creating arrays<ul><li><code>Array.new</code> </li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Met circumstances where need Ruby knowledge to resolve problems, thus need to do a quick touch on Ruby, at least know how to read ruby co
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Ruby" scheme="https://www.llchen60.com/tags/Ruby/"/>
    
  </entry>
  
  <entry>
    <title>PATH and LD_LIBRARY_PATH</title>
    <link href="https://www.llchen60.com/PATH-and-LD-LIBRARY-PATH/"/>
    <id>https://www.llchen60.com/PATH-and-LD-LIBRARY-PATH/</id>
    <published>2020-02-09T05:19:09.000Z</published>
    <updated>2020-02-09T05:20:52.375Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-What-is-LD-LIBRARY-PATH"><a href="#1-What-is-LD-LIBRARY-PATH" class="headerlink" title="1. What is LD_LIBRARY_PATH?"></a>1. What is LD_LIBRARY_PATH?</h1><p>LD_LIBRARY_PATH is a variable in linux to provide a list of additional directories in which to search for dynamically linkable libraries. </p><p>Consulted at time of execution , not consulted at link time </p><h1 id="2-PATH"><a href="#2-PATH" class="headerlink" title="2. PATH"></a>2. PATH</h1><p>PATH environment variable specifies the search paths for commands</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-What-is-LD-LIBRARY-PATH&quot;&gt;&lt;a href=&quot;#1-What-is-LD-LIBRARY-PATH&quot; class=&quot;headerlink&quot; title=&quot;1. What is LD_LIBRARY_PATH?&quot;&gt;&lt;/a&gt;1. What i
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.llchen60.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.llchen60.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Lombok</title>
    <link href="https://www.llchen60.com/Lombok/"/>
    <id>https://www.llchen60.com/Lombok/</id>
    <published>2020-02-09T05:17:23.000Z</published>
    <updated>2020-02-09T06:25:23.186Z</updated>
    
    <content type="html"><![CDATA[<p>Merely want to list all annotations here, and do some analysis. Lombok is a great tool to relieve java programmer from writing duplicate code. </p><h1 id="1-EqualsAndHashCode"><a href="#1-EqualsAndHashCode" class="headerlink" title="1. @EqualsAndHashCode"></a>1. @EqualsAndHashCode</h1><p>Generates hashCode and equals implementations from the fields of your object. </p><h2 id="1-1-What’s-hashCode-equals-use-for"><a href="#1-1-What’s-hashCode-equals-use-for" class="headerlink" title="1.1 What’s hashCode/ equals use for?"></a>1.1 What’s hashCode/ equals use for?</h2><p>Equals compare pass-in objects’ attributes, to see if they are the same. It compares all the field values to make judgement. </p><p>== compares whether two object references point to the same object</p><p>Use hashcode() method to optimize performance when comparing objects. <strong><em>Execute hashcode() returns a unique ID for each object in your program, which makes the task of comparing the whole state of the object much easier.</em></strong> </p><p>First run hashcode() method to judge if two objects are same, then run equals() method. </p><p>See <a href="https://www.javaworld.com/article/3305792/learn-java/java-challengers-4-comparing-java-objects-with-equals-and-hashcode.html" target="_blank" rel="noopener">Comparing Java objects with <code>equals()</code> and <code>hashcode()</code></a></p><h2 id="1-2-Implementation"><a href="#1-2-Implementation" class="headerlink" title="1.2 Implementation"></a>1.2 Implementation</h2><ol><li>By default, it uses all non-static and non-transient fields</li><li>Do modification by set <code>@EqualsAndHashCode.Include</code> or <code>@EqualsAndHashCode.Exclude</code></li></ol><h3 id="1-3-1-Apply-to-a-class-that-extends-another"><a href="#1-3-1-Apply-to-a-class-that-extends-another" class="headerlink" title="1.3.1 Apply to a class that extends another"></a>1.3.1 Apply to a class that extends another</h3><p>Normally, auto-generating an equals and hashCode method for such classes is a bad idea, as the superclass also defines fields, which also need equals/hashCode code but this code will not be generated. By setting callSuper to true, you can include the equals and hashCode methods of your superclass in the generated methods. For hashCode, the result of super.hashCode() is included in the hash algorithm, and forequals, the generated method will return false if the super implementation thinks it is not equal to the passed in object.  You can safely call your superclass equals if it, too, has a lombok-generated equals method.</p><p><code>callSuper</code>, set it to ture when you don’t extend anything is a compile time error. </p><pre><code> import lombok.EqualsAndHashCode;@EqualsAndHashCodepublic class EqualsAndHashCodeExample {  private transient int transientVar = 10;  private String name;  private double score;  @EqualsAndHashCode.Exclude private Shape shape = new Square(5, 10);  private String[] tags;  @EqualsAndHashCode.Exclude private int id;  public String getName() {    return this.name;  }  @EqualsAndHashCode(callSuper=true)  public static class Square extends Shape {    private final int width, height;    public Square(int width, int height) {      this.width = width;      this.height = height;    }  }}</code></pre><h1 id="2-NonNull"><a href="#2-NonNull" class="headerlink" title="2. @NonNull"></a>2. @NonNull</h1><p>Use this annotation on the parameter of a mothod or constructor to have lombok generate a null-check statement. </p><p>And a @NonNull on a primitive parameter results in a warning. </p><pre><code> import lombok.NonNull;public class NonNullExample extends Something {  private String name;  public NonNullExample(@NonNull Person person) {    super(&quot;Hello&quot;);    this.name = person.getName();  }}</code></pre><h1 id="3-Cleanup"><a href="#3-Cleanup" class="headerlink" title="3. @Cleanup"></a>3. @Cleanup</h1><p>It’s an antomatic resource management: call your close() methods safely with no hassle!</p><p>You can use @Cleanup to <strong><em>ensure a given resource is automatically cleaned up before the code execution path exits your current scope</em></strong>. </p><p>For example, you can use it like： </p><pre><code>@Cleanup InputStream in = new FileInputStream(&quot;some/file&quot;);</code></pre><p>As a result, at the end of the scope you are in, <code>in.close()</code> is called. The call is guaranteed to run by way of a try/ finally construct. </p><p>If the type of object you’d like to cleanup does not have a close method, you can specify the name of this method like:</p><pre><code>@Cleanup(&quot;dispose&quot;) org.eclipse.swt.widgets.CoolBar bar = new CoolBar(parent, 0); </code></pre><p>Notice: there should be no variables in the cleanup method. </p><pre><code> import lombok.Cleanup;import java.io.*;public class CleanupExample {  public static void main(String[] args) throws IOException {    @Cleanup InputStream in = new FileInputStream(args[0]);    @Cleanup OutputStream out = new FileOutputStream(args[1]);    byte[] b = new byte[10000];    while (true) {      int r = in.read(b);      if (r == -1) break;      out.write(b, 0, r);    }  }}</code></pre><h1 id="4-Getter-Setter"><a href="#4-Getter-Setter" class="headerlink" title="4. @Getter/ @Setter"></a>4. @Getter/ @Setter</h1><p>Annotate any field with Getter and Setter to let lombok generate the default getter/ setter automatically. </p><p>The generated getter/setter method will be public unless you explicitly specify an AccessLevel, as shown in the example below. Legal access levels are PUBLIC, PROTECTED, PACKAGE, and PRIVATE.</p><p>Also we can put the annotation on a class, in this way, it’s as if you annotate all the non-static fields in the class with annotation. </p><pre><code> import lombok.AccessLevel;import lombok.Getter;import lombok.Setter;public class GetterSetterExample {  /**   * Age of the person. Water is wet.   *    * @param age New value for this person&#39;s age. Sky is blue.   * @return The current value of this person&#39;s age. Circles are round.   */  @Getter @Setter private int age = 10;  /**   * Name of the person.   * -- SETTER --   * Changes the name of this person.   *    * @param name The new value.   */  @Setter(AccessLevel.PROTECTED) private String name;  @Override public String toString() {    return String.format(&quot;%s (age: %d)&quot;, name, age);  }}</code></pre><h1 id="5-ToString"><a href="#5-ToString" class="headerlink" title="5. @ToString"></a>5. @ToString</h1><p>No need to start a debugger to see your fields, lombok can generate a toString for you. </p><p>Any <strong><em>class</em></strong> can be annotated with @ToString to let lombok generate an implementation of the toString() method. </p><p>We can set: </p><ul><li><p>includeFieldNames </p><ul><li>Add some clarity to the output </li></ul></li><li><p>@ToString.Exclude </p></li><li><p>@ToString(onlyExplicitlyIncluded = true)</p><ul><li>specify exactly which fields you wish to be used  </li><li>then marking each field you want to include with <code>@ToString.Include</code></li></ul></li><li><p>Can also include non static methods that take no argument  -&gt; use <code>@ToString.Include</code></p><p>  import lombok.ToString;</p><p>  @ToString<br>  public class ToStringExample {</p><pre><code>private static final int STATIC_VAR = 10;private String name;private Shape shape = new Square(5, 10);private String[] tags;@ToString.Exclude private int id;public String getName() {  return this.name;}@ToString(callSuper=true, includeFieldNames=true)public static class Square extends Shape {  private final int width, height;  public Square(int width, int height) {    this.width = width;    this.height = height;  }}</code></pre><p>  }</p></li></ul><h1 id="6-NoArgsConstructor-RequiredArgsConstructor-AllArgsConstructor"><a href="#6-NoArgsConstructor-RequiredArgsConstructor-AllArgsConstructor" class="headerlink" title="6. @NoArgsConstructor, @RequiredArgsConstructor, @AllArgsConstructor"></a>6. @NoArgsConstructor, @RequiredArgsConstructor, @AllArgsConstructor</h1><p>Constructors: </p><ul><li>Generates constructors that take no arguments</li><li>Generates constructors that take one argument per final/ non-null field </li><li>Generates constructors that take one argument for every field</li></ul><h2 id="6-1-NoArgsConstructor"><a href="#6-1-NoArgsConstructor" class="headerlink" title="6.1 @NoArgsConstructor"></a>6.1 @NoArgsConstructor</h2><p>@NoArgsConstructor will generate a constructor with no parameters. </p><p>If it’s not possible(because of final fields), a compiler error will result, unless we use <code>@NoArgsConstructor(force = true)</code>. Then all final fields are initialized with 0/ false/ null </p><h2 id="6-2-RequiredArgsConstructor"><a href="#6-2-RequiredArgsConstructor" class="headerlink" title="6.2 @RequiredArgsConstructor"></a>6.2 @RequiredArgsConstructor</h2><p>@RequiredArgsConstructor  generates a constructor with 1 parameter for each field that requires special handling.  All <strong>non-initialized final fields</strong> get a parameter, as well as any fields that are marked as <strong>@NonNull</strong> that aren’t initialized where they are declared. For those fields marked with @NonNull, an explicit null check is also generated. The constructor will throw a NullPointerException if any of the parameters intended for the fields marked with @NonNull contain null. The order of the parameters match the order in which the fields appear in your class.</p><h2 id="6-3-AllArgsConstructor"><a href="#6-3-AllArgsConstructor" class="headerlink" title="6.3 @AllArgsConstructor"></a>6.3 @AllArgsConstructor</h2><p>@AllArgsConstructor generates a constructor with 1 parameter for each field in your class. Fields marked with @NonNull result in null checks on those parameters.</p><h1 id="7-Data"><a href="#7-Data" class="headerlink" title="7. @Data"></a>7. @Data</h1><p>All togerther: a shortcut for: </p><ul><li>@ToString,</li><li>@EqualsAndHashCode</li><li>@Getter on all fields</li><li>@Setter on all non-final fields</li><li>@RequiredArgsConstructor </li></ul><p>@Data generates all the boilerplate that is normally associated with simple POJOs (Plain Old Java Objects) and beans: getters for all fields, setters for all non-final fields, and appropriate toString, equals and hashCode implementations that involve the fields of the class, and a constructor that initializes all final fields, as well as all non-final fields with no initializer that have been marked with @NonNull, in order to ensure the field is never null.</p><p>All generated getters and setters will be public</p><p>All fields marked as transient will not be considered for hashCode and equals. All static fields will be skipped entirely. </p><pre><code> import lombok.AccessLevel;import lombok.Setter;import lombok.Data;import lombok.ToString;@Data public class DataExample {  private final String name;  @Setter(AccessLevel.PACKAGE) private int age;  private double score;  private String[] tags;  @ToString(includeFieldNames=true)  @Data(staticConstructor=&quot;of&quot;)  public static class Exercise&lt;T&gt; {    private final String name;    private final T value;  }}</code></pre><h1 id="8-Value"><a href="#8-Value" class="headerlink" title="8. @Value"></a>8. @Value</h1><p>@Value is the immutable variant of @Data. All fields are made private and final by default. setters are not generated at all. </p><p>The class itself is also made final by default, becuase immutability is not something that can be forced onto a sunclass.</p><p>Actually, @Value equals to <code>final @ToString @EqualsAndHashCode @AllArgsConstructor @FieldDefaults(makeFinal = true, level = AccessLevel.PRIVATE) @Getter</code></p><pre><code>import lombok.AccessLevel;import lombok.experimental.NonFinal;import lombok.experimental.Value;import lombok.experimental.Wither;import lombok.ToString;@Value public class ValueExample {  String name;  @Wither(AccessLevel.PACKAGE) @NonFinal int age;  double score;  protected String[] tags;  @ToString(includeFieldNames=true)  @Value(staticConstructor=&quot;of&quot;)  public static class Exercise&lt;T&gt; {    String name;    T value;  }}</code></pre><h1 id="9-Builder"><a href="#9-Builder" class="headerlink" title="9. @Builder"></a>9. @Builder</h1><p>The @Builder annotation produces complex builder APIs for your classes.</p><p>@Builder lets you automatically produce the code required to have your class be instantiable with code such as:<br>Person.builder().name(“Adam Savage”).city(“San Francisco”).job(“Mythbusters”).job(“Unchained Reaction”).build();</p><h1 id="10-Getter-lazy-true"><a href="#10-Getter-lazy-true" class="headerlink" title="10. @Getter(lazy = true)"></a>10. @Getter(lazy = true)</h1><p>You can let lombok generate a getter which will calculate a value once, the first time this getter is called, and cache it from then on. This can be useful if calculating the value takes a lot of CPU, or the value takes a lot of memory. To use this feature, create a private final variable, initialize it with the expression that’s expensive to run, and annotate your field with @Getter(lazy=true)</p><pre><code> import lombok.Getter;public class GetterLazyExample {  @Getter(lazy=true) private final double[] cached = expensive();  private double[] expensive() {    double[] result = new double[1000000];    for (int i = 0; i &lt; result.length; i++) {      result[i] = Math.asin(i);    }    return result;  }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Merely want to list all annotations here, and do some analysis. Lombok is a great tool to relieve java programmer from writing duplicate 
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
      <category term="Annotation" scheme="https://www.llchen60.com/tags/Annotation/"/>
    
      <category term="Lombok" scheme="https://www.llchen60.com/tags/Lombok/"/>
    
  </entry>
  
  <entry>
    <title>JSP Tutorial</title>
    <link href="https://www.llchen60.com/JSP-Tutorial/"/>
    <id>https://www.llchen60.com/JSP-Tutorial/</id>
    <published>2020-02-09T05:16:31.000Z</published>
    <updated>2020-02-09T05:16:49.160Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h1><h2 id="1-1-Intro"><a href="#1-1-Intro" class="headerlink" title="1.1 Intro"></a>1.1 Intro</h2><ul><li>JavaServer Pages <ul><li>develop webpages that support dynamic content </li><li>collect input from users through webpage forms</li><li>present records from a database or another source </li><li>creates webpage dynamically </li></ul></li></ul><h2 id="1-2-Architecture"><a href="#1-2-Architecture" class="headerlink" title="1.2 Architecture"></a>1.2 Architecture</h2><ul><li><p>JSP engine</p><ul><li>a container to process JSP pages  </li><li>responsible for intercepting requests for JSP pages </li></ul></li><li><p>JSP processing </p><ul><li>browser sends an HTTP request to the web server </li><li>web server recognizes that the HTTP request is for a JSP page and forwards it to a JSP engine. <ul><li>Finish by using the URL or JSP page which ends with .jsp instead of .html </li></ul></li><li>JSP engine loads the JSP page from disk and converts it into a servlet content. </li><li>JSP engine compiles the servlet into an executable class and forwards the original request to a servlet engine</li><li>A part of the web server called the servlet engine loads the Servlet class and executes it. During execution, the servlet produces an output in HTML format. The output is furthur passed on to the web server by the servlet engine inside an HTTP response.</li><li>The web server forwards the HTTP response to your browser in terms of static HTML content !!! Return static html directly </li><li>the web browser handles the dynamically generated HTML page inside the HTTP response exactly as if it were a static page </li></ul></li></ul><h2 id="1-3-Lifecycle"><a href="#1-3-Lifecycle" class="headerlink" title="1.3 Lifecycle"></a>1.3 Lifecycle</h2><p>A JSP life cycle is defined as the process from its creation till the destruction, Similar to a servlet life cycle with an additional step which is required to compile a JSP into servlet.</p><ul><li>compilation<ul><li>when a browser asks for a JSP, the JSP engine first checks to see whether it needs to compile the page </li><li>If the page has never been compiled, or if the JSP has been modified since it was last compiled, the JSP engine compiles the page</li><li>compile involves:<ul><li>parsing the JSP</li><li>turning the JSP into a servlet </li><li>compile the servlet </li></ul></li></ul></li><li>initialization<ul><li>invokes the jspInit() method before servicing any requests  </li></ul></li><li>execution<ul><li>represents all interactions with requests until the JSP is destroyed </li><li>Whenever a browser requests a JSP and the page has been loaded and initialized, the JSP engine invokes the _jspService() method in the JSP</li><li><code>void _jspService(HttpServletRequest request, HttpServletResponse response) {// Service handling code...}</code></li></ul></li><li>cleanup <ul><li>represents when a JSP is being removed from use by a container </li><li>The jspDestroy() method is the JSP equivalent of the destroy method for servlets. </li></ul></li></ul><h1 id="2-Syntax-Operations"><a href="#2-Syntax-Operations" class="headerlink" title="2. Syntax/ Operations"></a>2. Syntax/ Operations</h1><h2 id="2-1-Elements-of-JSP"><a href="#2-1-Elements-of-JSP" class="headerlink" title="2.1 Elements of JSP"></a>2.1 Elements of JSP</h2><h3 id="2-1-1-Scriptlet"><a href="#2-1-1-Scriptlet" class="headerlink" title="2.1.1 Scriptlet"></a>2.1.1 Scriptlet</h3><p>A scriptlet can contain any number of JAVA language statements, variable or method declarations, or expressions that are valid in the page scripting language. </p><p><code>&lt;%code fragment%&gt;</code></p><p>XML equivalent as follows: </p><pre><code>&lt;jsp:scriptlet&gt;   code fragment&lt;/jsp:scriptlet&gt;</code></pre><p>Any text, HTML tags, or JSP elements you write must be outside the scriptlet. </p><h3 id="2-1-2-JSP-Declarations"><a href="#2-1-2-JSP-Declarations" class="headerlink" title="2.1.2 JSP Declarations"></a>2.1.2 JSP Declarations</h3><p>A declaration declares one or more variables or methods that you can use in Java code later in the JSP file. You must declare the variable or method before you use it in the JSP file.</p><pre><code>&lt;%! declaration; [ declaration; ]+ ... %&gt;</code></pre><p>We can also write the XML equivalent of the above syntax as follows: </p><pre><code>&lt;jsp:declaration&gt;   code fragment&lt;/jsp:declaration&gt;</code></pre><h3 id="2-1-3-JSP-Expression"><a href="#2-1-3-JSP-Expression" class="headerlink" title="2.1.3 JSP Expression"></a>2.1.3 JSP Expression</h3><ul><li>Contains a scripting language expression that is evaluated, converted to a String, and inserted where the expression appears in the JSP file. </li><li>The expression element can contain any expression that is valid according to the Java Language Specification but you cannot use a semicolon to end an expression.</li></ul><pre><code>&lt;%= expression %&gt;&lt;jsp:expression&gt;    expression&lt;/jsp:expression&gt;</code></pre><h3 id="2-1-4-JSP-Comments"><a href="#2-1-4-JSP-Comments" class="headerlink" title="2.1.4 JSP Comments"></a>2.1.4 JSP Comments</h3><p>JSP comments marks text or statements that the JSP container should ignore. A JSP comment is useful when you want to hide or comment out. </p><p>&lt;%– This is JSP comment –%&gt;</p><h3 id="2-1-5-JSP-Directives"><a href="#2-1-5-JSP-Directives" class="headerlink" title="2.1.5 JSP Directives"></a>2.1.5 JSP Directives</h3><ul><li>A JSP directive affects the overall structure of the servlet class. </li></ul><pre><code>&lt;%@ directive attribute=&quot;value&quot; %&gt;</code></pre><ul><li><code>&lt;%@ page. attribute=.. %&gt;</code><ul><li>Defines page dependent attributes<ul><li>scripting language</li><li>error page</li><li>buffering requirements </li></ul></li><li>instructions to the current page </li><li>attributes list <ul><li>buffer </li><li>autoFlush </li><li>contentType</li><li>errorPage</li><li>isErrorPage</li><li>extends</li><li>import</li><li>info </li><li>isThreadSafe</li><li>language</li><li>session </li><li>isELignored </li><li>isScriptingEnabled</li></ul></li></ul></li><li><code>&lt;%@ include ... %&gt;</code><ul><li>include a file during the translation phase  </li><li>tells the container to merge the content of other external files with the current JSP during the translation phase.</li></ul></li><li><code>&lt;%@ taglib ... %&gt;</code><ul><li>declares a tag library, containing custom actions, used in the page  </li></ul></li></ul><h3 id="2-1-6-JSP-Actions"><a href="#2-1-6-JSP-Actions" class="headerlink" title="2.1.6 JSP Actions"></a>2.1.6 JSP Actions</h3><p>JSP actions use contructs in XML syntax to control the behavior of the servlet engine</p><p>You can dynamically insert a file, reuse javaBeans components, forward the user to another page, or generate HTML for the java plugin </p><pre><code>&lt;jsp:action_name  attribute=&quot;value&gt;</code></pre><ul><li>jsp:include </li><li>jsp:useBean </li><li>jsp:setProperty</li><li>jsp:forward <ul><li>forward the requester to a new page </li></ul></li><li>jsp:plugin<ul><li>generates browser-specific code that makes an OBJECT or EMBED tag for the java plugin</li></ul></li><li>jsp:element <ul><li>defines XML elements dynamically </li></ul></li><li>jsp:attribute <ul><li>defines dynamically defined XML element’s attribute</li></ul></li><li>jsp:body<ul><li>Defines dynamically-defined XML element’s body.</li></ul></li><li>jsp:text <ul><li>write template text in JSP pages and documents </li></ul></li></ul><h2 id="2-2-JSP-Implicit-Objects"><a href="#2-2-JSP-Implicit-Objects" class="headerlink" title="2.2 JSP Implicit Objects"></a>2.2 JSP Implicit Objects</h2><p>JSP supports some automatically defined variables</p><ul><li>request <ul><li>HttpServletRequest object </li></ul></li><li>response <ul><li>HttpServletResponse object </li></ul></li><li>out <ul><li>send output  to the client </li></ul></li><li>session <ul><li>HttpSession object associated with the request </li></ul></li><li>application <ul><li>The servletContext object associated with the application context </li></ul></li><li>config <ul><li>servletConfig object associated with the page </li></ul></li><li>pageContext<ul><li>This encapsulates use of server-specific features like higher performance JspWriters.</li></ul></li><li>page<ul><li>This is simply a synonym for this, and is used to call the methods defined by the translated servlet class.</li></ul></li><li>exception <ul><li>The Exception object allows the exception data to be accessed by designated JSP. </li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Introduction&quot;&gt;&lt;a href=&quot;#1-Introduction&quot; class=&quot;headerlink&quot; title=&quot;1. Introduction&quot;&gt;&lt;/a&gt;1. Introduction&lt;/h1&gt;&lt;h2 id=&quot;1-1-Intro&quot;&gt;&lt;a h
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
      <category term="JSP" scheme="https://www.llchen60.com/tags/JSP/"/>
    
  </entry>
  
  <entry>
    <title>JMX - Tutorials</title>
    <link href="https://www.llchen60.com/JMX-Tutorials/"/>
    <id>https://www.llchen60.com/JMX-Tutorials/</id>
    <published>2020-02-09T05:15:44.000Z</published>
    <updated>2020-02-09T05:16:07.815Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h1><ul><li>JMX - Java Management extensions<ul><li>export standard metrics and custom metrics using MBeans to a monitoring system </li><li>understand how your application is performing <ul><li>memory </li><li>cpu</li><li>threads </li><li>API calls in a REST endpoint</li></ul></li></ul></li></ul><h1 id="2-Why-need-this"><a href="#2-Why-need-this" class="headerlink" title="2. Why need this?"></a>2. Why need this?</h1><ul><li>Large scale java applications <ul><li>gather performance information <ul><li>number of users connected </li></ul></li></ul></li><li>could provide a monitoring interface </li><li>any class that exports data to JMX is called a Managed Bean(MBean). These MBeans publish their metrics to a MBean Server provided by the Java platform. </li></ul><h1 id="3-Components"><a href="#3-Components" class="headerlink" title="3. Components"></a>3. Components</h1><h2 id="3-1-MBean"><a href="#3-1-MBean" class="headerlink" title="3.1 MBean"></a>3.1 MBean</h2><ul><li>Objects with methods that return information and export the information via the MBeanServer</li><li>Mainly have 4 types <ul><li>Standard MBean <ul><li>create an interface with getter  </li></ul></li><li>Dynamic MBean <ul><li>implements getters and setters to retrieve or modify the metric that can be auto discovered by implementing the javax.management.DynamicMBean interface </li></ul></li><li>Model MBean<ul><li>Generic, dynamic in runtime to instrument the resources  </li></ul></li><li>Open MBean<ul><li>Using a predefined set of java classes</li></ul></li></ul></li></ul><h1 id="4-Example"><a href="#4-Example" class="headerlink" title="4. Example"></a>4. Example</h1><pre><code>// Create an interface that the MBeanServer will retrieve information public interface SystemStatusMBean {   Integer getNumberOfSecondsRunning();   String getProgramName();   Long getNumberOfUnixSecondsRunning();   Boolean getSwitchStatus();}</code></pre><p>Actual Implementation </p><pre><code>    public class SystemStatus implements SystemStatusMBean {   private Integer numberOfSecondsRunning;   private String programName;   private Long numberOfUnixSecondsRunning;   private Boolean switchStatus;   private Thread backgroundThread;   public SystemStatus(String programName) {       // First we initialize all the metrics       this.backgroundThread = new Thread();       this.programName = programName;       this.numberOfSecondsRunning = 0;       this.numberOfUnixSecondsRunning = System.currentTimeMillis() / 1000L;       this.switchStatus = false;       // We will use a background thread to update the metrics       this.backgroundThread = new Thread(() -&gt; {           try {               while (true) {                   // Every second we update the metrics                   numberOfSecondsRunning += 1;                   numberOfUnixSecondsRunning += 1;                   switchStatus = !switchStatus;                   Thread.sleep(1000L);               }           } catch (Exception e) {               e.printStackTrace();           }       });       this.backgroundThread.setName(&quot;backgroundThread&quot;);       this.backgroundThread.start();   }</code></pre><h1 id="5-Operations-and-attributes"><a href="#5-Operations-and-attributes" class="headerlink" title="5. Operations and attributes"></a>5. Operations and attributes</h1><p>Class properties exported through MBeans are called attributes, and methods exported through MBeans are called operations.</p><ul><li>TotalCompilationTime <ul><li>Total time spent doing in JIT compilation  </li></ul></li><li>Garbage Collector - CollectionCount <ul><li>Number of garbage collection events fired since the JVM launch</li></ul></li><li>Garbage Collector - CollectionTime </li><li>FreePyhsicalMemorySize </li><li>CommitedVirtualMemorySize<ul><li>The amount of memory that is guaranteed to be available for use by JVM  </li></ul></li><li>ProcessCpuTime <ul><li>Time CPU has spent running the process  </li></ul></li><li>PeakThreadCount <ul><li>maximum number of threads being executed at the same time since the JVM was started or the peak was reset  </li></ul></li><li>ThreadCount <ul><li>the number of threads running at the current moment </li></ul></li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://sysdig.com/blog/jmx-monitoring-custom-metrics/" target="_blank" rel="noopener">https://sysdig.com/blog/jmx-monitoring-custom-metrics/</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Introduction&quot;&gt;&lt;a href=&quot;#1-Introduction&quot; class=&quot;headerlink&quot; title=&quot;1. Introduction&quot;&gt;&lt;/a&gt;1. Introduction&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;JMX - Java Man
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
      <category term="JMX" scheme="https://www.llchen60.com/tags/JMX/"/>
    
  </entry>
  
  <entry>
    <title>Java是如何工作的</title>
    <link href="https://www.llchen60.com/Java%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/"/>
    <id>https://www.llchen60.com/Java%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/</id>
    <published>2020-02-09T05:14:12.000Z</published>
    <updated>2020-02-09T05:14:29.247Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-编程语言是如何工作的"><a href="#1-编程语言是如何工作的" class="headerlink" title="1. 编程语言是如何工作的"></a>1. 编程语言是如何工作的</h1><p>我们可以把编程语言按照与底层实现的接近程度来划分层次，更加高层次的编程语言会让我们写起来更像自然语言一些，比如Java, C++。而低层次的语言，更贴近机器语言，即在描述底层是如何实现的。</p><p>对于大部分编程语言来说，工作的整个过程是从编译 - 链接 - 执行。就是从源代码开始，编译器会运行源代码，将其转化为贴近机器语言的状态，我们将其称为<code>Object</code> 文件。一系列的<code>Object</code>文件可以被链接起来，并创建一个可执行文件。操作系统可以加载这个可执行文件到内存中，并运行程序。</p><p>还有一部分语言是解释性的，比如Lisp, Schema。他会针对每一个高层次的语句来做低层次的翻译，然后顺序执行他们。这个过程相当于我遇到一个语句，翻译成计算机能看懂的语言以后，再看下一句…</p><h1 id="2-Java是如何工作的"><a href="#2-Java是如何工作的" class="headerlink" title="2. Java是如何工作的"></a>2. Java是如何工作的</h1><p>Java是个平台独立的语言，那他是怎么做到的呢？</p><p>首先我们要理解一下什么叫做平台独立？</p><blockquote><p>对于很多编程语言来说，编译器会生成可以在特定计算机上执行的代码。比如你在windows机器上编译一段c++代码，那么生成的可执行文件可以在任何其他的windows电脑上运行，但无法在Mac或者Linux机器上运行。</p></blockquote><p>对于早期的语言来说，设计者需要针对每一个平台专门设计一个编译器。而作为一个程序员，如果你想自己的代码在多个平台上都可以工作，你也需要针对性的做很多修改。</p><p>Java重新组织了编译-链接-执行这个循环，它将和平台相关的代码给抽象出来，和其他代码分开。这样子，编译的时候不会生成一个Object文件，反之，会生成字节码文件，这个字节码文件是平台独立的，即它可以在任何平台运行。那么刚才说的和平台相关的代码放到哪里了呢？为了执行字节码，我们需要唤醒java解释器。每个平台都会有自己的解释器，来解决和平台相关的问题。</p><p>对于其他语言来说，执行的过程是 编译，链接然后执行。对于Java来说，更应该说是编译然后链接，执行。</p><h1 id="3-Compile-vs-Runtime"><a href="#3-Compile-vs-Runtime" class="headerlink" title="3. Compile vs Runtime"></a>3. Compile vs Runtime</h1><p>整个代码的lifecycle,程序员先写源码，通过源码定义了程序是比如和工作的。这些源码必须要编译成机器码(java里面等效为字节码)，然后变成可执行文件。这个编译的过程称之为compile time.</p><p>一个编译过的文件是可以打开并且运行的，当一个应用正在运行的时候，我们就叫他处在runtime当中。</p><p>compile error一般是在编译的过程中由编译器报的错，告诉我们哪一行出了什么问题。运行时候的错误就叫做runtime error，这往往是一些逻辑错误，系统崩溃，流量过大等原因造成的。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="http://www.cs.cmu.edu/~jcarroll/15-100-s05/supps/basics/history.html" target="_blank" rel="noopener">CMU Class Notes</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-编程语言是如何工作的&quot;&gt;&lt;a href=&quot;#1-编程语言是如何工作的&quot; class=&quot;headerlink&quot; title=&quot;1. 编程语言是如何工作的&quot;&gt;&lt;/a&gt;1. 编程语言是如何工作的&lt;/h1&gt;&lt;p&gt;我们可以把编程语言按照与底层实现的接近程度来划分层次，更
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java Unit Test - Junit5</title>
    <link href="https://www.llchen60.com/Java-Unit-Test-Junit5/"/>
    <id>https://www.llchen60.com/Java-Unit-Test-Junit5/</id>
    <published>2020-02-09T05:12:58.000Z</published>
    <updated>2020-02-09T05:13:43.504Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Writing-Tests"><a href="#1-Writing-Tests" class="headerlink" title="1. Writing Tests"></a>1. Writing Tests</h1><p>JUnit5 = Junit Platform + Junit Jupiter + Junit Vintage </p><p>First test cases: </p><pre><code>import static org.junit.jupiter.api.Assertions.assertEquals;import example.util.Calculator;import org.junit.jupiter.api.Test;class MyFirstJUnitJupiterTests {    private final Calculator calculator = new Calculator();    @Test    void addition() {        assertEquals(2, calculator.add(1, 1));    }}</code></pre><h2 id="1-1-Annotations"><a href="#1-1-Annotations" class="headerlink" title="1.1 Annotations"></a>1.1 Annotations</h2><ul><li>@Test <ul><li>Denotes that a method is a test method. This annotation does not declare any attributes</li></ul></li><li>@ParameterizedTest <ul><li>Denote a method is a parameterized test </li><li>Make it possible to run a test multiple times with different arguments </li><li>Must declare at least one source that will provide the arguments for each invocation and then consume the arguments in teh test method </li></ul></li><li>@RepeatedTest <ul><li>denotes a method is a test template for a repeated test </li><li>Provides ability to repeat a test a specific number of times by annotating a method with <code>@RepeatedTest</code> and specify the total number of repetitions desired. </li></ul></li><li>@TestFactory <ul><li>denotes a method is a test factory for dynamic tests</li><li>dynamic test generated at runtime by a factory method that is annotated with @TestFactory </li><li>a factory for test case </li></ul></li><li>@TestTemplate<ul><li>denotes that a method is a template for test cases designed to be invoked multiple times depending on the number of invocation contexts returned by the registered providers. </li></ul></li><li>@TestMethodOrder <ul><li>Configure the test method execution order </li></ul></li><li>@TestInstance<ul><li>Used to configure the test instance lifecycle for the annotated test class.  </li></ul></li><li>@DisplayName<ul><li>Declares a custom display name for the test class or test method.</li></ul></li><li>@BeforeEach<ul><li>Denotes that the annotated method should be executed before each @Test, @RepeatedTest, @ParameterizedTest, or @TestFactory method in the current class; analogous to JUnit 4’s @Before. </li></ul></li><li>@AfterEach <ul><li>Denotes that the annotated method should be executed after each @Test, @RepeatedTest, @ParameterizedTest, or @TestFactory method in the current class; analogous to JUnit 4’s @After</li></ul></li><li>@BeforeAll <ul><li>Denotes that the annotated method should be executed before all @Test, @RepeatedTest, @ParameterizedTest, and @TestFactory methods in the current class; analogous to JUnit 4’s @BeforeClass. Such methods are inherited (unless they are hidden or overridden) and must be static (unless the “per-class” test instance lifecycle is used).</li></ul></li><li>@AfterAll <ul><li>Denotes that the annotated method should be executed after all @Test, @RepeatedTest, @ParameterizedTest, and @TestFactory methods in the current class; analogous to JUnit 4’s @AfterClass. Such methods are inherited (unless they are hidden or overridden) and must be static</li></ul></li><li>@Nested <ul><li>Denotes that the annotated class is a non-static nested test class. @BeforeAll and @AfterAll methods cannot be used directly in a @Nested test class unless the “per-class” test instance lifecycle is used.</li></ul></li><li>@Tag<ul><li>Used to declare tags for filtering tests, either at the class or method level; analogous to test groups in TestNG or Categories in JUnit 4. Such annotations are inherited at the class level but not at the method level.</li></ul></li><li>@Disabled <ul><li>Used to disable a test class or test method; analogous to JUnit 4’s @Ignore. Such annotations are not inherited.</li></ul></li><li>@ExtendWith<ul><li>Used to register extensions declaratively </li></ul></li><li>@RegisterExtension<ul><li>Used to register extensions programmatically via fields.</li></ul></li><li>@TempDir<ul><li>Used to supply a temporary directory via field injection or parameter injection in a lifecycle method or test method </li></ul></li></ul><h2 id="1-2-Test-classes-and-methods"><a href="#1-2-Test-classes-and-methods" class="headerlink" title="1.2 Test classes and methods"></a>1.2 Test classes and methods</h2><ul><li>Test classes must not be abstract and mush have a single constructor</li><li>Test method: any instance method that is directly annotated or meta-annotated with @Test, @RepeatedTest, @ParameterizedTest, @TestFactory, or @TestTemplate</li><li>Lifecycle Method: any method that is directly annotated or meta-annotated with @BeforeAll, @AfterAll, @BeforeEach, or @AfterEach</li></ul><p>A standard unit test class: </p><pre><code>import static org.junit.jupiter.api.Assertions.fail;import static org.junit.jupiter.api.Assumptions.assumeTrue;import org.junit.jupiter.api.AfterAll;import org.junit.jupiter.api.AfterEach;import org.junit.jupiter.api.BeforeAll;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Disabled;import org.junit.jupiter.api.Test;class StandardTests {    @BeforeAll    static void initAll() {    }    @BeforeEach    void init() {    }    @Test    void succeedingTest() {    }    @Test    void failingTest() {        fail(&quot;a failing test&quot;);    }    @Test    @Disabled(&quot;for demonstration purposes&quot;)    void skippedTest() {        // not executed    }    @Test    void abortedTest() {        assumeTrue(&quot;abc&quot;.contains(&quot;Z&quot;));        fail(&quot;test should have been aborted&quot;);    }    @AfterEach    void tearDown() {    }    @AfterAll    static void tearDownAll() {    }}</code></pre><h2 id="1-3-Assertions"><a href="#1-3-Assertions" class="headerlink" title="1.3 Assertions"></a>1.3 Assertions</h2><p>All assertions are static methods in org.junit.jupiter.api.Assertions class.</p><p>See <a href="https://junit.org/junit5/docs/current/api/org/junit/jupiter/api/Assertions.html" target="_blank" rel="noopener">API doc</a> for detail: </p><ul><li>assertAll()</li><li>assertArrayEquals()</li><li>assertArrauEqualsString()</li><li>assertEquals()</li><li>assertNotEquals()</li><li>assertTimeout()</li><li>assertTimeoutPreemptively()</li><li>assertTure()</li><li>fail()</li></ul><pre><code>@Test    void dependentAssertions() {        // Within a code block, if an assertion fails the        // subsequent code in the same block will be skipped.        assertAll(&quot;properties&quot;,            () -&gt; {                String firstName = person.getFirstName();                assertNotNull(firstName);                // Executed only if the previous assertion is valid.                assertAll(&quot;first name&quot;,                    () -&gt; assertTrue(firstName.startsWith(&quot;J&quot;)),                    () -&gt; assertTrue(firstName.endsWith(&quot;e&quot;))                );            },            () -&gt; {                // Grouped assertion, so processed independently                // of results of first name assertions.                String lastName = person.getLastName();                assertNotNull(lastName);                // Executed only if the previous assertion is valid.                assertAll(&quot;last name&quot;,                    () -&gt; assertTrue(lastName.startsWith(&quot;D&quot;)),                    () -&gt; assertTrue(lastName.endsWith(&quot;e&quot;))                );            }        );    }</code></pre><h2 id="1-4-Assumptions"><a href="#1-4-Assumptions" class="headerlink" title="1.4 Assumptions"></a>1.4 Assumptions</h2><p>Assumptions is a collection of utility methods that support conditional test execution based on assumptions.In direct contrast to failed assertions, failed assumptions do not result in a test failure; rather, a failed assumption results in a <strong>test being aborted</strong>.</p><ul><li><p>assumeFalse()</p></li><li><p>assumeTrue()</p></li><li><p>assumingThat(boolean assumption, Executable executable)</p><p>   @Test</p><pre><code>  void testOnlyOnDeveloperWorkstation() {      assumeTrue(&quot;DEV&quot;.equals(System.getenv(&quot;ENV&quot;)),          () -&gt; &quot;Aborting test: not on developer workstation&quot;);      // remainder of test  }  @Test  void testInAllEnvironments() {      assumingThat(&quot;CI&quot;.equals(System.getenv(&quot;ENV&quot;)),          () -&gt; {              // perform these assertions only on the CI server              assertEquals(2, calculator.divide(4, 2));          });      // perform these assertions in all environments      assertEquals(42, calculator.multiply(6, 7));  }</code></pre></li></ul><h2 id="1-5-Test-Instance-Lifecycle"><a href="#1-5-Test-Instance-Lifecycle" class="headerlink" title="1.5 Test Instance Lifecycle"></a>1.5 Test Instance Lifecycle</h2><p>In order to allow individual test methods to be executed in isolation and to avoid unexpected side effects due to mutable test instance state, <strong>JUnit creates a new instance of each test class before executing each test method</strong></p><p>You can annotate your test class with <code>@TestInstance(Lifecycle.PER_CLASS)</code> if you <strong>prefer to execute all test methods on the same test instance</strong>. And if your test mothods rely on state stored in instance variables, may need to reset the state in @BeforeEach or @AfterEach methods. </p><p>The “per-class” mode has some additional benefits over the default “per-method” mode. Specifically, with the “per-class” mode it becomes possible to declare @BeforeAll and @AfterAll on non-static methods as well as on interface default methods. The “per-class” mode therefore also makes it possible to use @BeforeAll and @AfterAll methods in @Nested test classes.</p><pre><code>@TestInstance(Lifecycle.PER_CLASS)interface TestLifecycleLogger {    static final Logger logger = Logger.getLogger(TestLifecycleLogger.class.getName());    @BeforeAll    default void beforeAllTests() {        logger.info(&quot;Before all tests&quot;);    }    @AfterAll    default void afterAllTests() {        logger.info(&quot;After all tests&quot;);    }    @BeforeEach    default void beforeEachTest(TestInfo testInfo) {        logger.info(() -&gt; String.format(&quot;About to execute [%s]&quot;,            testInfo.getDisplayName()));    }    @AfterEach    default void afterEachTest(TestInfo testInfo) {        logger.info(() -&gt; String.format(&quot;Finished executing [%s]&quot;,            testInfo.getDisplayName()));    }}</code></pre><h2 id="1-6-Repeated-Test"><a href="#1-6-Repeated-Test" class="headerlink" title="1.6 Repeated Test"></a>1.6 Repeated Test</h2><pre><code>import static org.junit.jupiter.api.Assertions.assertEquals;import java.util.logging.Logger;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.DisplayName;import org.junit.jupiter.api.RepeatedTest;import org.junit.jupiter.api.RepetitionInfo;import org.junit.jupiter.api.TestInfo;class RepeatedTestsDemo {    private Logger logger = // ...    @BeforeEach    void beforeEach(TestInfo testInfo, RepetitionInfo repetitionInfo) {        int currentRepetition = repetitionInfo.getCurrentRepetition();        int totalRepetitions = repetitionInfo.getTotalRepetitions();        String methodName = testInfo.getTestMethod().get().getName();        logger.info(String.format(&quot;About to execute repetition %d of %d for %s&quot;, //            currentRepetition, totalRepetitions, methodName));    }    @RepeatedTest(10)    void repeatedTest() {        // ...    }    @RepeatedTest(5)    void repeatedTestWithRepetitionInfo(RepetitionInfo repetitionInfo) {        assertEquals(5, repetitionInfo.getTotalRepetitions());    }    @RepeatedTest(value = 1, name = &quot;{displayName} {currentRepetition}/{totalRepetitions}&quot;)    @DisplayName(&quot;Repeat!&quot;)    void customDisplayName(TestInfo testInfo) {        assertEquals(&quot;Repeat! 1/1&quot;, testInfo.getDisplayName());    }    @RepeatedTest(value = 1, name = RepeatedTest.LONG_DISPLAY_NAME)    @DisplayName(&quot;Details...&quot;)    void customDisplayNameWithLongPattern(TestInfo testInfo) {        assertEquals(&quot;Details... :: repetition 1 of 1&quot;, testInfo.getDisplayName());    }    @RepeatedTest(value = 5, name = &quot;Wiederholung {currentRepetition} von {totalRepetitions}&quot;)    void repeatedTestInGerman() {        // ...    }}</code></pre><h2 id="1-7-Parameterized-Tests"><a href="#1-7-Parameterized-Tests" class="headerlink" title="1.7 Parameterized Tests"></a>1.7 Parameterized Tests</h2><p>With parameterized, we could run a test multiple times with different arguments. And we must declare at least one source that will provide the arguments for each invocation and then consume the arguments in the test method. </p><pre><code>@ParameterizedTest@ValueSource(strings = { &quot;racecar&quot;, &quot;radar&quot;, &quot;able was I ere I saw elba&quot; })void palindromes(String candidate) {    assertTrue(StringUtils.isPalindrome(candidate));}</code></pre><h3 id="1-7-1-Annotations-used-in-parameterized-tests"><a href="#1-7-1-Annotations-used-in-parameterized-tests" class="headerlink" title="1.7.1 Annotations used in parameterized tests"></a>1.7.1 Annotations used in parameterized tests</h3><ul><li>@ValueSource<ul><li>specify a single array of literal values </li></ul></li><li>@NullSource<ul><li>provides a single null argument to the annotated @ParameterizedTest method.</li></ul></li><li>@EmptySource<ul><li>provides a single empty argument to the annotated @ParameterizedTest method for parameters of the following types: java.lang.String, java.util.List, java.util.Set, java.util.Map, primitive arrays (e.g., int[], char[][], etc.), object arrays (e.g.,String[], Integer[][], etc.).</li></ul></li><li>@NullAndEmptySource: <ul><li>a composed annotation that combines the functionality of @NullSource and @EmptySource.</li></ul></li></ul><pre><code>@ParameterizedTest@NullAndEmptySource@ValueSource(strings = { &quot; &quot;, &quot;   &quot;, &quot;\t&quot;, &quot;\n&quot; })void nullEmptyAndBlankStrings(String text) {    assertTrue(text == null || text.trim().isEmpty());}</code></pre><ul><li>@EnumSource<ul><li>provides a convenient way to use Enum constants. </li><li>also provides an optional names parameter that lets you specify which constants shall be used </li></ul></li></ul><pre><code>@ParameterizedTest@EnumSource(value = TimeUnit.class, names = { &quot;DAYS&quot;, &quot;HOURS&quot; })void testWithEnumSourceInclude(TimeUnit timeUnit) {    assertTrue(EnumSet.of(TimeUnit.DAYS, TimeUnit.HOURS).contains(timeUnit));}@ParameterizedTest@EnumSource(value = TimeUnit.class, mode = EXCLUDE, names = { &quot;DAYS&quot;, &quot;HOURS&quot; })void testWithEnumSourceExclude(TimeUnit timeUnit) {    assertFalse(EnumSet.of(TimeUnit.DAYS, TimeUnit.HOURS).contains(timeUnit));    assertTrue(timeUnit.name().length() &gt; 5);}</code></pre><ul><li>@MethodSource<ul><li>Allow you to refer to one or more factory methods of the test class or external classes </li><li>Each factory method must generate a stream of arguments</li></ul></li></ul><pre><code>@ParameterizedTest@MethodSource(&quot;stringProvider&quot;)void testWithExplicitLocalMethodSource(String argument) {    assertNotNull(argument);}static Stream&lt;String&gt; stringProvider() {    return Stream.of(&quot;apple&quot;, &quot;banana&quot;);}</code></pre><ul><li>@CsvSource </li><li>@CsvFileSource</li><li>@ArgumentsSource <ul><li>can be used to specify a custom resuable ArgumentsProvider </li><li>An implementation of ArgumentsProvider mush be declared as either a top-level class or as a static nested class. </li></ul></li></ul><pre><code>@ParameterizedTest@ArgumentsSource(MyArgumentsProvider.class)void testWithArgumentsSource(String argument) {    assertNotNull(argument);}public class MyArgumentsProvider implements ArgumentsProvider {    @Override    public Stream&lt;? extends Arguments&gt; provideArguments(ExtensionContext context) {        return Stream.of(&quot;apple&quot;, &quot;banana&quot;).map(Arguments::of);    }}</code></pre><h3 id="1-7-2-Lifecycle-and-Interoperability"><a href="#1-7-2-Lifecycle-and-Interoperability" class="headerlink" title="1.7.2 Lifecycle and Interoperability"></a>1.7.2 Lifecycle and Interoperability</h3><p>Each invocation of a parameterized test has the same lifecycle </p><h2 id="1-8-Test-Templates"><a href="#1-8-Test-Templates" class="headerlink" title="1.8 Test Templates"></a>1.8 Test Templates</h2><p>A @TestTemplate method is not a regular test case but rather a template for test cases. It is designed to be invoked multiple times depending on the number of invocation contexts returned by the registerd providers. </p><p>Thus, it must be used in conjunction with a registered TestTemplateInvocationContextProvider extension. Each invocation of a test template method behaves like the execution of a regular @Test method with full support for the same lifecycle callbacks and extensions.</p><h2 id="1-9-Dynamic-Tests"><a href="#1-9-Dynamic-Tests" class="headerlink" title="1.9 Dynamic Tests"></a>1.9 Dynamic Tests</h2><p> @Test describe methods that implement test cases. These test cases are static in the sense that they are fully specified at compile time, and their behavior cannot be changed by anything happening at runtime.</p><p> This new kind of test is a dynamic test which is generated at runtime by a factory method that is annotated with @TestFactory</p><p> In contrast to @Test methods, a @TestFactory method is not itself a test case but rather a factory for test cases. Thus, a dynamic test is the product of a factory. Technically speaking, a @TestFactory method must return a single DynamicNode or a Stream, Collection, Iterable, Iterator, or array of DynamicNode instances. Instantiable subclasses of DynamicNode are DynamicContainer and </p><p> DynamicContainer instances are composed of <strong>a display name</strong> and <strong>a list of dynamic child nodes</strong>, enabling the creation of arbitrarily nested hierarchies of dynamic nodes. DynamicTest instances will be executed lazily, enabling dynamic and even non-deterministic generation of test cases.</p><h3 id="1-9-1-Dynamic-test-lifecycle"><a href="#1-9-1-Dynamic-test-lifecycle" class="headerlink" title="1.9.1 Dynamic test lifecycle"></a>1.9.1 Dynamic test lifecycle</h3><p>The execution lifecycle of a dynamic test is quite different than it is for a standard @Test case. Specifically, there are <strong>no lifecycle callbacks for individual dynamic tests</strong>. This means that @BeforeEach and @AfterEach methods and their corresponding extension callbacks are** executed for the @TestFactory method** but not for each dynamic test. In other words, if you access fields from the test instance within a lambda expression for a dynamic test, those fields will not be reset by callback methods or extensions between the execution of individual dynamic tests generated by the same @TestFactory method.</p><h2 id="1-10-Parallel-Execution"><a href="#1-10-Parallel-Execution" class="headerlink" title="1.10 Parallel Execution"></a>1.10 Parallel Execution</h2><h3 id="1-10-1-Mode"><a href="#1-10-1-Mode" class="headerlink" title="1.10.1 Mode"></a>1.10.1 Mode</h3><p>Offers two mode: </p><ul><li>SAME_THREAD<ul><li>Force execution in the same thread used by the parent. For example, when used on a test method, the test method will be executed in the same thread as any @BeforeAll or @AfterAll methods of the containing test class. </li></ul></li><li>CONCURRENT<ul><li>Execute concurrently unless a resource lock forces execution in the same thread.</li></ul></li></ul><p>Alternatively, you can use the @Execution annotation to change the execution mode for the annotated element and its subelements (if any) which allows you to activate parallel execution for individual test classes, one by one.</p><h3 id="1-10-2-Synchronization"><a href="#1-10-2-Synchronization" class="headerlink" title="1.10.2 Synchronization"></a>1.10.2 Synchronization</h3><p>The @ResourceLock annotation allows you to declare that a test class or method uses a specific shared resource that requires synchronized access to ensure reliable test execution. </p><pre><code>@Execution(CONCURRENT)class SharedResourcesDemo {    private Properties backup;    @BeforeEach    void backup() {        backup = new Properties();        backup.putAll(System.getProperties());    }    @AfterEach    void restore() {        System.setProperties(backup);    }    @Test    @ResourceLock(value = SYSTEM_PROPERTIES, mode = READ)    void customPropertyIsNotSetByDefault() {        assertNull(System.getProperty(&quot;my.prop&quot;));    }    @Test    @ResourceLock(value = SYSTEM_PROPERTIES, mode = READ_WRITE)    void canSetCustomPropertyToApple() {        System.setProperty(&quot;my.prop&quot;, &quot;apple&quot;);        assertEquals(&quot;apple&quot;, System.getProperty(&quot;my.prop&quot;));    }    @Test    @ResourceLock(value = SYSTEM_PROPERTIES, mode = READ_WRITE)    void canSetCustomPropertyToBanana() {        System.setProperty(&quot;my.prop&quot;, &quot;banana&quot;);        assertEquals(&quot;banana&quot;, System.getProperty(&quot;my.prop&quot;));    }}</code></pre><h1 id="2-Extension-Model"><a href="#2-Extension-Model" class="headerlink" title="2. Extension Model"></a>2. Extension Model</h1><p>In contrast to Runner, TestRule and MethodRule extension points in JUnit4, the JUnit Jupiter extension model consists of a single, coherent concept – Extension API. </p><h2 id="2-1-Registering-Extensions"><a href="#2-1-Registering-Extensions" class="headerlink" title="2.1 Registering Extensions"></a>2.1 Registering Extensions</h2><p>Extensions can be registered declaraticely via @ExtendWith, programmatically via @RegisterExtension, or automatically via Java’s ServiceLoader mechanism. </p><h3 id="2-1-1-Declarative-Extension-Registration"><a href="#2-1-1-Declarative-Extension-Registration" class="headerlink" title="2.1.1 Declarative Extension Registration"></a>2.1.1 Declarative Extension Registration</h3><pre><code>@ExtendWith(RandomParametersExtension.class)@Testvoid test(@Random int i) {    // ...}</code></pre><p>Notice: we could annotate it in class level to register an extension for all tests in this specific class. </p><p>We can also register multiple extensions: </p><pre><code>@ExtendWith({ DatabaseExtension.class, WebServerExtension.class })class MyFirstTests {    // ...}</code></pre><h3 id="2-1-2-Programmatic-Extension-Registration"><a href="#2-1-2-Programmatic-Extension-Registration" class="headerlink" title="2.1.2 Programmatic Extension Registration"></a>2.1.2 Programmatic Extension Registration</h3><p>Register extensions programmatically by annotating fields in test classes with @RegisterExtension </p><p>When an extension is registered declaratively via @ExtendWith, it can typically only be configured via annotations. In contrast, when an extension is registered via @RegisterExtension, it can be <strong>configured programmatically</strong> - for example, in order to pass arguments to the extension’s constructor, a static factory method, or a builder API.</p><p>If a @RegisterExtension field is static, the extension will be registered after extensions that are registered at the class level via @ExtendWith. Such static extensions are not limited in which extension APIs they can implement. Extensions registered via static fields may therefore implement class-level and instance-level extension APIs such as BeforeAllCallback, AfterAllCallback, and TestInstancePostProcessor as well as method-level extension APIs such as BeforeEachCallback, etc.</p><pre><code>class WebServerDemo {    @RegisterExtension    static WebServerExtension server = WebServerExtension.builder()        .enableSecurity(false)        .build();    @Test    void getProductList() {        WebClient webClient = new WebClient();        String serverUrl = server.getServerUrl();        // Use WebClient to connect to web server using serverUrl and verify response        assertEquals(200, webClient.get(serverUrl + &quot;/products&quot;).getResponseStatus());    }}</code></pre><ul><li><p>For a non-static field with @RegisterExtension, it will be registered after the test class has been instantiated </p></li><li><p>By default, an instance extension will be registered after extensions that are registered at the method level via @ExtendWith </p></li><li><p>If the class is configured with @TestInstance(Lifecycle.PER_CLASS) semantics, an instance extension will be registered at the method level via @ExtendWith.</p><p>  class DocumentationDemo {</p><pre><code>  static Path lookUpDocsDir() {      // return path to docs dir  }  // The configured DocumentationExtension will be automatically registered as an extension at the method level.  @RegisterExtension  DocumentationExtension docs = DocumentationExtension.forPath(lookUpDocsDir());  @Test  void generateDocumentation() {      // use this.docs ...  }</code></pre><p>  }</p></li></ul><h3 id="2-1-3-Automatic-Extension-Registration"><a href="#2-1-3-Automatic-Extension-Registration" class="headerlink" title="2.1.3 Automatic Extension Registration"></a>2.1.3 Automatic Extension Registration</h3><p>JUnit Jupiter also supports global extension registration via Java’s java.util.ServiceLoader mechanism, allowing third-party extensions to be *<em>auto-detected and automatically registered *</em>based on what is available in the classpath.</p><h2 id="2-2-Conditional-Test-Execution"><a href="#2-2-Conditional-Test-Execution" class="headerlink" title="2.2 Conditional Test Execution"></a>2.2 Conditional Test Execution</h2><p>Used to define conditional test execution. </p><p>An ExecutionCondition is evaluated for each container (e.g., a test class) to determine if all the tests it contains should be executed based on the supplied ExtensionContext</p><h2 id="2-3-Execution-Order-of-User-Code-and-Extensions"><a href="#2-3-Execution-Order-of-User-Code-and-Extensions" class="headerlink" title="2.3 Execution Order of User Code and Extensions"></a>2.3 Execution Order of User Code and Extensions</h2><p>When executing a test class that contains one or more test methods, a number of extension callbacks are called in addition to the user-supplied test and lifecycle methods.</p><p><img src="https://i.loli.net/2020/02/09/9OkZPCtrFL8RfYM.png" alt="fig1.png"></p><p>JUnit Jupiter always guarantees wrapping behavior for multiple registered extensions that implement lifecycle callbacks such as BeforeAllCallback, AfterAllCallback, BeforeEachCallback, AfterEachCallback, BeforeTestExecutionCallback, and AfterTestExecutionCallback.</p><p>That means that, given two extensions Extension1 and Extension2 with Extension1 registered before Extension2, <strong>any “before” callbacks implemented by Extension1 are guaranteed to execute before any “before” callbacks implemented by Extension2</strong>.</p><pre><code>import static example.callbacks.Logger.afterAllMethod;import static example.callbacks.Logger.afterEachMethod;import static example.callbacks.Logger.beforeAllMethod;import static example.callbacks.Logger.beforeEachMethod;import org.junit.jupiter.api.AfterAll;import org.junit.jupiter.api.AfterEach;import org.junit.jupiter.api.BeforeAll;import org.junit.jupiter.api.BeforeEach;/** * Abstract base class for tests that use the database. */abstract class AbstractDatabaseTests {    @BeforeAll    static void createDatabase() {        beforeAllMethod(AbstractDatabaseTests.class.getSimpleName() + &quot;.createDatabase()&quot;);    }    @BeforeEach    void connectToDatabase() {        beforeEachMethod(AbstractDatabaseTests.class.getSimpleName() + &quot;.connectToDatabase()&quot;);    }    @AfterEach    void disconnectFromDatabase() {        afterEachMethod(AbstractDatabaseTests.class.getSimpleName() + &quot;.disconnectFromDatabase()&quot;);    }    @AfterAll    static void destroyDatabase() {        afterAllMethod(AbstractDatabaseTests.class.getSimpleName() + &quot;.destroyDatabase()&quot;);    }}</code></pre><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://junit.org/junit5/docs/current/user-guide/" target="_blank" rel="noopener">https://junit.org/junit5/docs/current/user-guide/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Writing-Tests&quot;&gt;&lt;a href=&quot;#1-Writing-Tests&quot; class=&quot;headerlink&quot; title=&quot;1. Writing Tests&quot;&gt;&lt;/a&gt;1. Writing Tests&lt;/h1&gt;&lt;p&gt;JUnit5 = Junit P
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
      <category term="Unit Test" scheme="https://www.llchen60.com/tags/Unit-Test/"/>
    
  </entry>
  
  <entry>
    <title>Java日志管理 - slf4j + log4j - 探究Distribute system 的threadContext复用的问题</title>
    <link href="https://www.llchen60.com/Java%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-slf4j-log4j-%E6%8E%A2%E7%A9%B6Distribute-system-%E7%9A%84threadContext%E5%A4%8D%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://www.llchen60.com/Java%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-slf4j-log4j-%E6%8E%A2%E7%A9%B6Distribute-system-%E7%9A%84threadContext%E5%A4%8D%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2020-02-07T03:48:00.000Z</published>
    <updated>2020-02-07T03:48:21.842Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-常用日志系统介绍"><a href="#1-常用日志系统介绍" class="headerlink" title="1. 常用日志系统介绍"></a>1. 常用日志系统介绍</h1><ul><li>日志门面<ul><li>jcl - jakarta common logging  <ul><li>日志接口，支持运行时动态加载日志组件的实现 </li></ul></li><li>slf4j<ul><li>日志接口</li><li>在log层和代码层之间起到门面作用，对于用户来说只要使用SLF4J的接口，就可以隐藏日志的具体实现，其提供的核心API是一些接口和一个LoggerFactory的工厂类，用户只需要按照其提供的日志接口进行使用，最终日志的格式，记录级别，输出方式等都可以通过具体日志系统的配置来实现</li></ul></li></ul></li><li>日志框架<ul><li>jul - java.util.logging </li><li>log4j</li><li>log4j2</li><li>logback<ul><li>slf4j的实现 </li><li>是log4j的升级版</li></ul></li></ul></li></ul><h1 id="2-日志级别"><a href="#2-日志级别" class="headerlink" title="2. 日志级别"></a>2. 日志级别</h1><ul><li>severe</li><li>warning </li><li>info</li><li>config</li><li>fine </li><li>finer </li></ul><h1 id="3-常见使用方式"><a href="#3-常见使用方式" class="headerlink" title="3. 常见使用方式"></a>3. 常见使用方式</h1><p>一般工程上会选择一个日志门面，加日志框架，常用的门面基本上还是SLF4J比较多，框架的选择很多，主要是需要注意工程上分布式系统的多线程方面的支持。</p><h1 id="4-Log4j2-ThreadContext复用的问题"><a href="#4-Log4j2-ThreadContext复用的问题" class="headerlink" title="4. Log4j2 ThreadContext复用的问题"></a>4. Log4j2 ThreadContext复用的问题</h1><p>ThreadContext出现的背景主要是因为现代系统基本上都需要都是和多个client打交道，在一个典型的多线程的应用系统当中，不同的线程就需要和不同的client打交道.为了能够分辨出同一个client发出的不同log请求，我们就需要给每个请求一个id，来做标记。</p><p>Log4j2使用Thread Context Map和Thread Context Stack来进行标记。常用Map，因为键值对更容易进行添加和处理</p><p>使用Stack: </p><pre><code>ThreadContext.push(UUID.randomUUID().toString()); // Add the fishtag;logger.debug(&quot;Message 1&quot;);...logger.debug(&quot;Message 2&quot;);..ThreadContext.pop();</code></pre><p>使用Map: </p><pre><code>ThreadContext.put(&quot;id&quot;, UUID.randomUUID().toString()); // Add the fishtag;ThreadContext.put(&quot;ipAddress&quot;, request.getRemoteAddr());ThreadContext.put(&quot;loginId&quot;, session.getAttribute(&quot;loginId&quot;));ThreadContext.put(&quot;hostName&quot;, request.getServerName());.logger.debug(&quot;Message 1&quot;);..logger.debug(&quot;Message 2&quot;);..ThreadContext.clear();</code></pre><p>问题来了，如果我们使用Executor.execute(new CachedThreadPool())的话，因为线程的复用，（所有使用完的线程会归还到线程池当中），那么ThreadContext里面的东西必须要进行手动清除，才能防止原先记录的这个线程的东西被复用掉。比如一般会记录的[Client][API]此类信息。</p><p>这个时候需要使用getContext()和cloneStack()来使得子线程获得父线程的信息。</p><pre><code>ThreadContext.clearAll();ThreadContext.putAll(preSavedThreadContextMap);ThreadContext.setStack(preSavedThreadContextStack);</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-常用日志系统介绍&quot;&gt;&lt;a href=&quot;#1-常用日志系统介绍&quot; class=&quot;headerlink&quot; title=&quot;1. 常用日志系统介绍&quot;&gt;&lt;/a&gt;1. 常用日志系统介绍&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;日志门面&lt;ul&gt;
&lt;li&gt;jcl - jakarta com
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
      <category term="Log" scheme="https://www.llchen60.com/tags/Log/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识</title>
    <link href="https://www.llchen60.com/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://www.llchen60.com/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2020-02-06T03:05:08.000Z</published>
    <updated>2020-02-06T03:05:28.755Z</updated>
    
    <content type="html"><![CDATA[<p>给自己搭个脚手架，建个基础知识的小字典，查遗用(持续更新)：</p><h1 id="1-Java平台"><a href="#1-Java平台" class="headerlink" title="1.Java平台"></a>1.Java平台</h1><h2 id="1-1-Java解释执行？"><a href="#1-1-Java解释执行？" class="headerlink" title="1.1 Java解释执行？"></a>1.1 Java解释执行？</h2><p>Java源代码，通过javac编译成字节码，运行时通过JVM内嵌的解释器将字节码转换为机器码。但是大部分JVM都提供了JIT(just in time),即动态编译器，它能够在运行时将热点代码编成机器码，这种情况下热点代码就属于编译执行。</p><h2 id="1-2-Java类加载机制"><a href="#1-2-Java类加载机制" class="headerlink" title="1.2 Java类加载机制"></a>1.2 Java类加载机制</h2><p>类加载大致过程：加载-验证-链接-初始化</p><h2 id="1-3-Java反射机制"><a href="#1-3-Java反射机制" class="headerlink" title="1.3 Java反射机制"></a>1.3 Java反射机制</h2><h2 id="1-4-面向对象编程SOLID原则"><a href="#1-4-面向对象编程SOLID原则" class="headerlink" title="1.4 面向对象编程SOLID原则"></a>1.4 面向对象编程SOLID原则</h2><ol><li>Single Responsibility </li><li>Open for extension, close for modification </li><li>Liskov Substitution </li><li>Interface Segragation </li><li>Dependency Injection </li></ol><p>E.G</p><pre><code>public class VIPCenter {  void serviceVIP(T extend User user&gt;) {     if (user instanceof SlumDogVIP) {        // 穷 X VIP，活动抢的那种        // do somthing      } else if(user instanceof RealVIP) {        // do somthing      }      // ...  }</code></pre><p>增加其扩展性：</p><pre><code>public class VIPCenter {   private Map&lt;User.TYPE, ServiceProvider&gt; providers;   void serviceVIP(T extend User user） {      providers.get(user.getType()).service(user);   } } interface ServiceProvider{   void service(T extend User user) ; } class SlumDogVIPServiceProvider implements ServiceProvider{   void service(T extend User user){     // do somthing   } } class RealVIPServiceProvider implements ServiceProvider{   void service(T extend User user) {     // do something   } } </code></pre><p>在另一篇博文里，有对SOLID的详细描述，详情见<a href="https://www.llchen60.com/2018/11/12/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/">面向对象设计原则</a></p><h2 id="1-5-类加载过程"><a href="#1-5-类加载过程" class="headerlink" title="1.5 类加载过程"></a>1.5 类加载过程</h2><p>load-link-initialize</p><ul><li>load </li></ul><p>首先是加载阶段（Loading），它是 Java 将字节码数据从不同的数据源读取到 JVM 中，并映射为 JVM 认可的数据结构（Class 对象），这里的数据源可能是各种各样的形态，如 jar 文件、class 文件，甚至是网络数据源等；如果输入数据不是 ClassFile 的结构，则会抛出 ClassFormatError。</p><ul><li>link </li></ul><p>第二阶段是链接（Linking），这是核心的步骤，简单说是把原始的类定义信息平滑地转化入 JVM 运行的过程中。这里可进一步细分为三个步骤：</p><ol><li>验证， JVM需要验证字节信息是符合Java虚拟机规范的，否则会被认为是Verify Error</li><li>准备 创建类或接口中的静态变量，并初始化静态变量的初始值，侧重点在分配所需要的内存空间，不会去执行更进一步的JVM指令</li><li>解析。将常量池中的符号引用替换为直接引用。</li></ol><p>再来谈谈双亲委派模型，简单说就是当类加载器（Class-Loader）试图加载某个类型的时候，除非父加载器找不到相应类型，否则尽量将这个任务代理给当前加载器的父加载器去做。使用委派模型的目的是避免重复加载 Java 类型。</p><h1 id="2-Java语言特性"><a href="#2-Java语言特性" class="headerlink" title="2. Java语言特性"></a>2. Java语言特性</h1><h2 id="2-1-泛型"><a href="#2-1-泛型" class="headerlink" title="2.1 泛型"></a>2.1 泛型</h2><h2 id="2-2-Lambda"><a href="#2-2-Lambda" class="headerlink" title="2.2 Lambda"></a>2.2 Lambda</h2><h2 id="2-3-Exception-Error"><a href="#2-3-Exception-Error" class="headerlink" title="2.3 Exception/ Error"></a>2.3 Exception/ Error</h2><h3 id="2-3-1-定义"><a href="#2-3-1-定义" class="headerlink" title="2.3.1 定义"></a>2.3.1 定义</h3><blockquote><p>Exception: 程序正常运行中可以预料到的意外情况，可能并且应该被捕获，进行相应处理</p></blockquote><blockquote><p>Error: 在正常情况下，不应该出现的情况。绝大部分的Error都会导致程序比如JVM自身处于非正常的、不可恢复的状态</p></blockquote><p>Throwable分类图！！！！！</p><p>异常之所以很强大，在调试方面，在于其回答了以下三个问题：</p><ol><li>什么出了错？    异常类型</li><li>在哪出了错？    异常堆栈跟踪位置</li><li>为什么出错？    异常信息</li></ol><h3 id="2-3-2-Tips"><a href="#2-3-2-Tips" class="headerlink" title="2.3.2 Tips"></a>2.3.2 Tips</h3><ol><li>不捕获通用异常，写自己的Exception，方便Debug</li><li>不要生吞异常，不知道怎么处理了可以继续向外层抛出</li><li>提早抛出，延迟捕获！ </li><li>把异常处理的责任往调用链的上游传递的方法就是在方法的throws子句声明异常。<a href="https://www.zhihu.com/question/28254987" target="_blank" rel="noopener">(如何优雅的处理异常？)</a></li></ol><h3 id="2-3-3-性能角度分析"><a href="#2-3-3-性能角度分析" class="headerlink" title="2.3.3 性能角度分析"></a>2.3.3 性能角度分析</h3><ol><li>try-catch代码段会产生额外的性能开销，往往会影响JVM对代码进行优化，因此应该仅捕获有必要的代码，尽量不要使用一个大的try包住整段代码</li><li>Java每实例化一个Exception，都会对<strong>当时的栈进行快照</strong>，这是个比较重的操作。</li></ol><h2 id="2-4-引用"><a href="#2-4-引用" class="headerlink" title="2.4 引用"></a>2.4 引用</h2><p>Java中除了原始数据类型的变量其他所有都是引用类型，指向不同的对象。理解引用，以理解Java对象的生命周期和JVM内部的相关机制。</p><p>不同的引用类型，主要体现在对象的不同的可达性状态和对垃圾收集的影响。</p><h3 id="2-4-1-强引用"><a href="#2-4-1-强引用" class="headerlink" title="2.4.1 强引用"></a>2.4.1 强引用</h3><p>Strong Reference, 即普通对象引用。只要还有强引用指向一个对象，那么垃圾收集器就不会碰。</p><h3 id="2-4-2-弱引用"><a href="#2-4-2-弱引用" class="headerlink" title="2.4.2 弱引用"></a>2.4.2 弱引用</h3><p>不能使对象豁免垃圾收集，提供一种访问在弱引用装天下对象的途径</p><p>使用weak reference类来实现的</p><h3 id="2-4-3-软引用"><a href="#2-4-3-软引用" class="headerlink" title="2.4.3 软引用"></a>2.4.3 软引用</h3><p>Soft Reference. 相对强引用弱化一些的引用，可以让对象豁免一些垃圾收集，只有当JVM认为内存不足时，才会去试图回收软引用指向的对象。</p><p>使用soft reference类实现的</p><h3 id="2-4-4-幻象引用"><a href="#2-4-4-幻象引用" class="headerlink" title="2.4.4 幻象引用"></a>2.4.4 幻象引用</h3><p>虚引用，提供一种确保对象被finalize以后，做某些事情的机制。</p><p>通过PhantomReference类来实现的</p><h2 id="2-5-String-vs-StringBuffer-vs-StringBuilder"><a href="#2-5-String-vs-StringBuffer-vs-StringBuilder" class="headerlink" title="2.5 String vs. StringBuffer vs. StringBuilder"></a>2.5 String vs. StringBuffer vs. StringBuilder</h2><ul><li><p>字符串缓存，放在对重，后来放在metaSpace当中，可以通过JVM调参来修改大小</p><p>  -XX:+PrintStringTableStatistics<br>  -XX:StringTableSize=N</p></li><li><p>String 压缩</p></li></ul><p>从使用Char到使用Byte + 标志编码位。紧凑字符串带来了很大优势，更小的内存占用，更快的操作速度。</p><h3 id="2-5-1-String"><a href="#2-5-1-String" class="headerlink" title="2.5.1 String"></a>2.5.1 String</h3><p>Immutable类，声明为final class,所有属性也都是final的。</p><p>java引入了字符创常量池，创建一个字符串，首先看常量池里面有没有值相同的字符串，如果有直接到池里拿对应的对象引用，如果没有就创建新的，并放到池里去。</p><pre><code>String str1 = &quot;123&quot;;// 放入常量池String str2 = new String(&quot;123&quot;); // 不放入常量池</code></pre><h3 id="2-5-2-StringBuffer"><a href="#2-5-2-StringBuffer" class="headerlink" title="2.5.2 StringBuffer"></a>2.5.2 StringBuffer</h3><p>为了解决String拼接产生太多中间对象的问题，本质上是一个线程安全的可修改字符序列。保证了线程安全，但是也带来了额外的性能开销。</p><p>线程安全是通过在各种修改数据的方法上加<code>synchronized</code>关键字来实现的。</p><p>底层使用char/ byte数组，继承了AbstractStringBuilder</p><h3 id="2-5-3-StringBuilder"><a href="#2-5-3-StringBuilder" class="headerlink" title="2.5.3 StringBuilder"></a>2.5.3 StringBuilder</h3><p>与StringBuffer类似，去掉了线程安全的部分，有效减少了开销</p><p>底层使用char/ byte数组，继承了AbstractStringBuilder。</p><h2 id="2-6-Abstract-and-Interface"><a href="#2-6-Abstract-and-Interface" class="headerlink" title="2.6 Abstract and Interface"></a>2.6 Abstract and Interface</h2><h3 id="2-6-1-接口"><a href="#2-6-1-接口" class="headerlink" title="2.6.1 接口"></a>2.6.1 接口</h3><p>接口是对行为的抽象，是抽象方法的集合，利用接口可以达到API定义和实现分离的目的。接口不能实例化，不能包含任何非常量成员，任何field都是隐含着public static final的意义的。同时，没有非静态方法的实现。要么是静态方法，要么是抽象方法。</p><p>接口可以多继承！类只可以单继承</p><h3 id="2-6-2-抽象类"><a href="#2-6-2-抽象类" class="headerlink" title="2.6.2 抽象类"></a>2.6.2 抽象类</h3><p>不能实例化的类，用abstract关键字来修饰，其目的主要是代码重用。抽象类大多用于抽取相关Java类的公用方法实现或者是共同成员变量，然后通过继承达到代码复用的目的。Java标准库中，比如Collection框架，很多通用部分就抽象成了抽象类来使用。</p><h1 id="3-Java基础类库"><a href="#3-Java基础类库" class="headerlink" title="3. Java基础类库"></a>3. Java基础类库</h1><h2 id="3-1-集合"><a href="#3-1-集合" class="headerlink" title="3.1 集合"></a>3.1 集合</h2><h3 id="3-1-1-Vector-vs-ArrayList-vs-LinkedList"><a href="#3-1-1-Vector-vs-ArrayList-vs-LinkedList" class="headerlink" title="3.1.1 Vector vs. ArrayList vs.LinkedList"></a>3.1.1 Vector vs. ArrayList vs.LinkedList</h3><p>三者都是集合框架中的List，根据位置有定位，添加或者删除的操作。Vector是Java早期提供的线程安全的动态数组。ArrayList动态数组，不是线程安全的，ArrayList扩容时会增加50%。LinkedList双向链表，不是线程安全的。</p><p>Vector, arrayList作为动态数组，非常适合随机访问的场合，插入删除元素性能会比较差，因为要移动后续的所有元素。LinkedList进行节点插入，删除会很高效，但是随机访问性能很差。</p><h3 id="3-1-2-Hashtable-vs-HashMap-vs-TreeMap"><a href="#3-1-2-Hashtable-vs-HashMap-vs-TreeMap" class="headerlink" title="3.1.2 Hashtable vs. HashMap vs. TreeMap"></a>3.1.2 Hashtable vs. HashMap vs. TreeMap</h3><p>Hashtable是同步的，性能开销大</p><p>HashMap 非同步的，性能开销小，put，get操作能达到常数时间的性能</p><p>TreeMap是基于红黑树的一种提供顺序访问的Map，和Hashmap不同，它的get\put\remove之类的操作都是O(log(n))的时间复杂度。</p><h2 id="3-2-IO-NIO"><a href="#3-2-IO-NIO" class="headerlink" title="3.2 IO/NIO"></a>3.2 IO/NIO</h2><h3 id="3-2-1-IO"><a href="#3-2-1-IO" class="headerlink" title="3.2.1 IO"></a>3.2.1 IO</h3><p>java.io包，基于流模型实现，提供了我们最熟知的一些IO功能，比如File抽象、输入输出流等。交互方式是同步、阻塞的方式。也就是说，在读取输入流或者写入输出流时，在读写动作之前，线程会一直阻塞在那里，他们之间的调用是可靠的线性顺序。</p><h3 id="3-2-2-NIO"><a href="#3-2-2-NIO" class="headerlink" title="3.2.2 NIO"></a>3.2.2 NIO</h3><p>NIO框架，提供Channel, selector, Buffer等新的抽象，可以构建<strong>多路复用，同步非阻塞IO程序</strong>，同时提供了更接近操作系统底层的高性能数据操作方式。</p><ul><li>Channel </li><li>Buffer</li><li>Selector </li></ul><h2 id="3-3-网络"><a href="#3-3-网络" class="headerlink" title="3.3 网络"></a>3.3 网络</h2><h2 id="3-4-并发"><a href="#3-4-并发" class="headerlink" title="3.4 并发"></a>3.4 并发</h2><h3 id="3-4-1-synchronized"><a href="#3-4-1-synchronized" class="headerlink" title="3.4.1 synchronized"></a>3.4.1 synchronized</h3><ul><li>概念</li></ul><p>是java内部的同步机制，也称为intrinsic locking, 提供了互斥的语义和可见性，当一个线程已经获取当前锁时，其他试图获取的线程只能等待或者阻塞在那里了。</p><p>在 Java 5 以前，synchronized 是仅有的同步手段，在代码中， synchronized 可以用来修饰方法，也可以使用在特定的代码块儿上，本质上** synchronized 方法等同于把方法全部语句用 synchronized 块包起来**。</p><ul><li>底层实现</li></ul><p>synchronized代码块是由一对<code>monitorenter/ moniterexit</code>指令来实现的，Monitor对象是同步的基本实现单元。</p><p>在 Java 6 之前，Monitor 的实现完全是依靠操作系统内部的互斥锁，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作。现代的（Oracle）JDK 中，JVM 对此进行了大刀阔斧地改进，提供了三种不同的 Monitor 实现，也就是常说的三种不同的锁：偏斜锁（Biased Locking）、轻量级锁和重量级锁，大大改进了其性能。</p><p>所谓锁的升级、降级，就是 JVM 优化 synchronized 运行的机制，当 JVM 检测到不同的竞争状况时，会自动切换到适合的锁实现，这种切换就是锁的升级、降级。</p><p>没有竞争的时候，默认使用偏斜锁。JVM会利用CAS操作，在对象头上的Mark Word部分设置线程ID，以表示这个对象偏向于当前线程，所以并不涉及真正的互斥锁。如果有另外的线程试图锁定某个已经被偏斜过的对象，JVM就需要撤销偏斜锁，并切换到轻量锁的实现。</p><h3 id="3-4-2-ReeantrantLock"><a href="#3-4-2-ReeantrantLock" class="headerlink" title="3.4.2 ReeantrantLock"></a>3.4.2 ReeantrantLock</h3><ul><li>ReentrantLock 再入锁</li></ul><p>再入锁通过代码直接调用lock()方法来获取，是表示当一个线程试图获取一个它已经获取的锁时，这个获取动作就自动成功。这是多锁获取粒度上的一个区分，锁的持有是以线程为单位而不是基于调用次数了，java锁实现强调再入性是为了和pthread的行为进行区分。</p><p>再入锁可以设置公平性：</p><pre><code>ReentrantLock fairLock = new ReetrantLock(true);</code></pre><p>这里所谓的公平性是指在竞争场景中，当公平性为真时，会倾向于将锁赋予等待时间最久的线程。公平性是减少线程“饥饿”（个别线程长期等待锁，但始终无法获取）情况发生的一个办法。</p><p>使用synchronized我们无法进行公平性的选择，其永远是不公平的，这也是主流操作系统线程调度的选择。通用场景中，公平性未必有想象中的那么重要，Java 默认的调度策略很少会导致 “饥饿”发生。与此同时，若要保证公平性则会引入额外开销，自然会导致一定的吞吐量下降。</p><h3 id="3-4-3-死锁"><a href="#3-4-3-死锁" class="headerlink" title="3.4.3 死锁"></a>3.4.3 死锁</h3><h2 id="3-5-安全"><a href="#3-5-安全" class="headerlink" title="3.5 安全"></a>3.5 安全</h2><h1 id="4-JVM基础概念和机制"><a href="#4-JVM基础概念和机制" class="headerlink" title="4. JVM基础概念和机制"></a>4. JVM基础概念和机制</h1><h2 id="4-1-类加载机制"><a href="#4-1-类加载机制" class="headerlink" title="4.1 类加载机制"></a>4.1 类加载机制</h2><h2 id="4-2-常见的垃圾收集器"><a href="#4-2-常见的垃圾收集器" class="headerlink" title="4.2 常见的垃圾收集器"></a>4.2 常见的垃圾收集器</h2><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://www.zhihu.com/question/28254987" target="_blank" rel="noopener">如何优雅的处理异常？</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给自己搭个脚手架，建个基础知识的小字典，查遗用(持续更新)：&lt;/p&gt;
&lt;h1 id=&quot;1-Java平台&quot;&gt;&lt;a href=&quot;#1-Java平台&quot; class=&quot;headerlink&quot; title=&quot;1.Java平台&quot;&gt;&lt;/a&gt;1.Java平台&lt;/h1&gt;&lt;h2 id=&quot;1-1
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Javadoc tutorial</title>
    <link href="https://www.llchen60.com/Javadoc-tutorial/"/>
    <id>https://www.llchen60.com/Javadoc-tutorial/</id>
    <published>2020-02-06T03:04:12.000Z</published>
    <updated>2020-02-06T03:04:33.985Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-What-is-javadoc"><a href="#1-What-is-javadoc" class="headerlink" title="1. What is javadoc"></a>1. What is javadoc</h1><p>A tool comes with JDK and used for generating Java code documentation in <strong>HTML format from Java source code</strong>, which requires documentation in a predefined format </p><h1 id="2-Javadoc-tags"><a href="#2-Javadoc-tags" class="headerlink" title="2. Javadoc tags"></a>2. Javadoc tags</h1><ul><li>@author</li><li>{@code}<ul><li>Displays text in code font without interpreting the text as HTML markup or nested javadoc tags.</li></ul></li><li>{@docRoot}<ul><li>Represents the relative path to the generated document’s root directory from any generated page.</li></ul></li><li>@deprecated</li><li>@exception<ul><li>Adds a Throws subheading to the generated documentation, with the classname and description text.</li></ul></li><li>{@inheritDoc}<ul><li>Inherits a comment from the nearest inheritable class or implementable interface.</li></ul></li><li>{@link}<ul><li>Inserts an in-line link with the visible text label that points to the documentation for the specified package, class, or member name of a referenced class. </li></ul></li><li>@param</li><li>@return</li><li>@see</li><li>@serial</li><li>@serialData <ul><li>Documents the data written by the writeObject( ) or writeExternal( ) methods.</li></ul></li><li>@serialField<ul><li>Documents an ObjectStreamField component.</li></ul></li><li>@since <ul><li>Adds a since heading with the specified since text to the generated documentation</li></ul></li><li>@throws </li><li>{@value}<ul><li>When {@value} is used in the doc comment of a static field, it displays the value of that constant. </li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-What-is-javadoc&quot;&gt;&lt;a href=&quot;#1-What-is-javadoc&quot; class=&quot;headerlink&quot; title=&quot;1. What is javadoc&quot;&gt;&lt;/a&gt;1. What is javadoc&lt;/h1&gt;&lt;p&gt;A tool c
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java 继承与组合</title>
    <link href="https://www.llchen60.com/Java-%E7%BB%A7%E6%89%BF%E4%B8%8E%E7%BB%84%E5%90%88/"/>
    <id>https://www.llchen60.com/Java-%E7%BB%A7%E6%89%BF%E4%B8%8E%E7%BB%84%E5%90%88/</id>
    <published>2020-02-06T03:03:28.000Z</published>
    <updated>2020-02-06T03:03:53.281Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-什么是组合？"><a href="#1-什么是组合？" class="headerlink" title="1. 什么是组合？"></a>1. 什么是组合？</h1><p>组合将类定义为各个部分的集合</p><pre><code>public class MerchantListHelper {    // TODO     void addToDDB (ListEntry entry) {    }    void removeFromDDB(DDBRecord record) {    }    List&lt;ListEntry&gt; getFromDDB() {    }}public class MerchantBlacklistBizLogic {    private MerchantListHelper merchantListHelper;    merchantListHelper.addToDDB(blabla..);    merchantListHelper.removeFromDDB(blabla..)}</code></pre><h1 id="2-什么是继承？"><a href="#2-什么是继承？" class="headerlink" title="2. 什么是继承？"></a>2. 什么是继承？</h1><p>将父类和子类通过集成关系紧密联系在一起 （紧耦合）。但与之相对的是继承会允许再利用类的方法以及其他的属性，会很便捷。</p><p>使用super()方法来直接访问父类的方法，构造器，属性等。</p><pre><code>public Abstract class MerchantListHelper {    // TODO     abstract void addToDDB (ListEntry entry);    abstract void removeFromDDB(DDBRecord record);    abstract List&lt;ListEntry&gt; getFromDDB();}public class MerchantBlacklistBizLogic {    private MerchantListHelper merchantListHelper;    @Override    void addToDDB(ListEntry entry) {        // TODO    }    @Override    void removeFromDDB(DDBRecord record) {        // TODO    }    ...}</code></pre><h1 id="3-Use-cases"><a href="#3-Use-cases" class="headerlink" title="3. Use cases"></a>3. Use cases</h1><p>组合和继承都可以将子对象放到新的类当中，组合一般是当你想要在这个新类当中使用一个已经存在的类的特征的时候。这意味着，通过这种方式你可以嵌入一个对象，并将其放在新的类当中。 继承表示的是一种is-a的关系，组合表达的含有某种功能。</p><p>如何判断是否需要继承或者组合 -&gt; 看是否需要从你的新类到基本类进行向上转型。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="http://thedeanbear.com/2012/09/24/composition_vs_inheritance/" target="_blank" rel="noopener">http://thedeanbear.com/2012/09/24/composition_vs_inheritance/</a></li><li>Java Challengers #7: Debugging Java inheritance </li><li>javaworld.com/article/3409071/java-challenger-7-debugging-java-inheritance.html</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-什么是组合？&quot;&gt;&lt;a href=&quot;#1-什么是组合？&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是组合？&quot;&gt;&lt;/a&gt;1. 什么是组合？&lt;/h1&gt;&lt;p&gt;组合将类定义为各个部分的集合&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class M
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
      <category term="Composition" scheme="https://www.llchen60.com/tags/Composition/"/>
    
  </entry>
  
  <entry>
    <title>Java 反射机制</title>
    <link href="https://www.llchen60.com/Java-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
    <id>https://www.llchen60.com/Java-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</id>
    <published>2020-02-06T03:02:35.000Z</published>
    <updated>2020-02-06T03:02:58.113Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h1><p>Java反射机制是在运行时用来判定或者修改方法，类，接口的行为的API。</p><ul><li><p>反射可以告诉我们类和对象之间的信息，以及我们可以用类的哪些方法来使用这个对象</p></li><li><p>通过反射，我们就可以在运行的时候赋予类一个新的对象</p></li></ul><h1 id="2-使用范例"><a href="#2-使用范例" class="headerlink" title="2. 使用范例"></a>2. 使用范例</h1><p>反射可以用来获取关于类，构造器和方法的信息：</p><ul><li><p>class: getClass()方法可以用来获取对象属于的类的名字</p></li><li><p>Constructors: getConstructor()可以用来获取对象属于的类的public的构造器</p></li><li><p>getMethods() 可以用来获取对象属于的类的public的方法</p><p>  // A simple Java program to demonstrate the use of reflection<br>  import java.lang.reflect.Method;<br>  import java.lang.reflect.Field;<br>  import java.lang.reflect.Constructor; </p><p>  // class whose object is to be created<br>  class Test<br>  { </p><pre><code>  // creating a private field   private String s;   // creating a public constructor   public Test() { s = &quot;GeeksforGeeks&quot;; }   // Creating a public method with no arguments   public void method1() {       System.out.println(&quot;The string is &quot; + s);   }   // Creating a public method with int as argument   public void method2(int n) {       System.out.println(&quot;The number is &quot; + n);   }   // creating a private method   private void method3() {       System.out.println(&quot;Private method invoked&quot;);   } </code></pre><p>  } </p><p>  class Demo<br>  { </p><pre><code>  public static void main(String args[]) throws Exception   {       // Creating object whose property is to be checked       Test obj = new Test();           // 构建类的对象      // getclass method       Class cls = obj.getClass();       System.out.println(&quot;The name of class is &quot; +                           cls.getName());       // Getting the constructor of the class through the       // object of the class       Constructor constructor = cls.getConstructor();       System.out.println(&quot;The name of constructor is &quot; +                           constructor.getName());       System.out.println(&quot;The public methods of class are : &quot;);       // Getting methods of the class through the object       // of the class by using getMethods       Method[] methods = cls.getMethods();       // Printing method names       for (Method method:methods)           System.out.println(method.getName());       // creates object of desired method by providing the       // method name and parameter class as arguments to       // the getDeclaredMethod        // 这里是通过方法的名字和输入变量来获取对应的方法      Method methodcall1 = cls.getDeclaredMethod(&quot;method2&quot;,                                               int.class);       // invokes the method at runtime       // 这里是在运行时执行这个方法       methodcall1.invoke(obj, 19);       // creates object of the desired field by providing       // the name of field as argument to the       // getDeclaredField method       // 运行时获取对应的private的变量      Field field = cls.getDeclaredField(&quot;s&quot;);       // allows the object to access the field irrespective       // of the access specifier used with the field       // 将这个变量设成可以获取的      field.setAccessible(true);       // takes object and the new value to be assigned       // to the field as arguments       field.set(obj, &quot;JAVA&quot;);       // Creates object of desired method by providing the       // method name as argument to the getDeclaredMethod       Method methodcall2 = cls.getDeclaredMethod(&quot;method1&quot;);       // invokes the method at runtime       methodcall2.invoke(obj);       // Creates object of the desired method by providing       // the name of method as argument to the       // getDeclaredMethod method       Method methodcall3 = cls.getDeclaredMethod(&quot;method3&quot;);       // allows the object to access the method irrespective       // of the access specifier used with the method       methodcall3.setAccessible(true);       // invokes the method at runtime       methodcall3.invoke(obj);   } </code></pre><p>  } </p></li></ul><h1 id="3-详细分析"><a href="#3-详细分析" class="headerlink" title="3. 详细分析"></a>3. 详细分析</h1><p>反射一言以蔽之，即在运行时拿到class，并创建类对应的对象的方式。这种好处是更具灵活性，劣势是会慢很多，代码会相对难理解些。</p><p>从代码本身的角度来讲，是指一部分代码有能力去观察/检查另一部分代码。用已知的部分合理推断出未知的部分，这未知的部分其实是指还不知道的信息。</p><p>一般来说在Java里我们都是和注解一起来使用反射的，</p><h1 id="4-优劣势"><a href="#4-优劣势" class="headerlink" title="4. 优劣势"></a>4. 优劣势</h1><ul><li>好处<ul><li>反射是什么呢？当我们的程序在运行时，需要动态的加载一些类这些类可能之前用不到所以不用加载到jvm，而是在运行时根据需要才加载，这样的好处对于服务器来说不言而喻，举个例子我们的项目底层有时是用mysql，有时用oracle，<strong>需要动态地根据实际情况加载驱动类，这个时候反射就有用了</strong>，假设 <code>com.java.dbtest.myqlConnection</code>，<code>com.java.dbtest.oracleConnection</code>这两个类我们要用，这时候我们的程序就写得比较动态化，通过<code>Class tc = Class.forName(&quot;com.java.dbtest.TestConnection&quot;);</code>通过类的全类名让jvm在服务器中找到并加载这个类，而如果是oracle则传入的参数就变成另一个了。这时候就可以看到反射的好处了，这个动态性就体现出java的特性了！</li><li>更具拓展性，可以在运行时获取信息</li><li>获取一些private的域的值方便debug</li></ul></li><li>劣势<ul><li>更慢，有延时</li><li>会暴露一些接口</li><li>反射会要求运行的许可，当在secure manager下来运行可能不被允许</li></ul></li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://stackoverflow.com/questions/37628/what-is-reflection-and-why-is-it-useful" target="_blank" rel="noopener">https://stackoverflow.com/questions/37628/what-is-reflection-and-why-is-it-useful</a></li><li><a href="https://docs.oracle.com/javase/tutorial/reflect/index.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/tutorial/reflect/index.html</a></li><li><a href="https://docs.oracle.com/javase/tutorial/reflect/class/index.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/tutorial/reflect/class/index.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-介绍&quot;&gt;&lt;a href=&quot;#1-介绍&quot; class=&quot;headerlink&quot; title=&quot;1. 介绍&quot;&gt;&lt;/a&gt;1. 介绍&lt;/h1&gt;&lt;p&gt;Java反射机制是在运行时用来判定或者修改方法，类，接口的行为的API。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;反射可以告诉我
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
      <category term="Reflection" scheme="https://www.llchen60.com/tags/Reflection/"/>
    
  </entry>
  
  <entry>
    <title>java - serialization</title>
    <link href="https://www.llchen60.com/java-serialization/"/>
    <id>https://www.llchen60.com/java-serialization/</id>
    <published>2020-02-06T03:01:26.000Z</published>
    <updated>2020-02-06T03:01:43.795Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a>1. Overview</h1><p>An object is eligible for serialization if and only if its class implements the <strong>java.io.Serializable</strong> interface. Serializable is a marker interface (contains no methods) that tell the Java Virtual Machine (JVM) that the objects of this class is ready for being written to and read from a persistent storage or over the network.</p><h1 id="2-Why-we-need-serialization"><a href="#2-Why-we-need-serialization" class="headerlink" title="2. Why we need serialization?"></a>2. Why we need serialization?</h1><p>It’s used when the need arises to send data/ object over network or stored in files.</p><p>The thing is network and hard disk are hardware component that understand bits and bytes but not Java Objects. </p><p>Serialization is the translation of your Java object’s values/states to bytes to send it over network or save it.</p><p>Also used to store into database. </p><h1 id="3-Implementation"><a href="#3-Implementation" class="headerlink" title="3. Implementation"></a>3. Implementation</h1><p>Ways for serialize/ deserialize  – xml JSON </p><p>Serialization process is instance independent. </p><ul><li>ObjectInputStream <ul><li>extends java.io.InputStream </li></ul></li></ul><pre><code>public final Object readObject() throws IOException, ClassNotFoundException;</code></pre><ul><li>ObjectOutputStream <ul><li>extends java.io.OutputStream</li></ul></li></ul><pre><code>public final void writeObject(Object o) throws IOException;</code></pre><h2 id="3-1-Example"><a href="#3-1-Example" class="headerlink" title="3.1 Example"></a>3.1 Example</h2><pre><code>public class Person implements Serializable {    private static final long serialVersionUID = 1L;    static String country = &quot;ITALY&quot;;    private int age;    private String name;    transient int height;    // getters and setters}@Testpublic void whenSerializingAndDeserializing_ThenObjectIsTheSame() ()   throws IOException, ClassNotFoundException {     Person person = new Person();    person.setAge(20);    person.setName(&quot;Joe&quot;);    FileOutputStream fileOutputStream      = new FileOutputStream(&quot;yourfile.txt&quot;);    ObjectOutputStream objectOutputStream       = new ObjectOutputStream(fileOutputStream);    objectOutputStream.writeObject(person);    objectOutputStream.flush();    objectOutputStream.close();    FileInputStream fileInputStream      = new FileInputStream(&quot;yourfile.txt&quot;);    ObjectInputStream objectInputStream      = new ObjectInputStream(fileInputStream);    Person p2 = (Person) objectInputStream.readObject();    objectInputStream.close();     assertTrue(p2.getAge() == p.getAge());    assertTrue(p2.getName().equals(p.getName()));}</code></pre><h1 id="4-Caveats"><a href="#4-Caveats" class="headerlink" title="4. Caveats"></a>4. Caveats</h1><ol><li>When a class implements the java.io.Serializable interface, all <strong>its sub-classes are serializable as well</strong>.</li><li>when an object has a reference to another object, these objects must implement the Serializable interface separately, or else a NotSerializableException will be thrown</li><li>JVM associates a version number with each serializable class. </li></ol><p>Reference</p><ol><li><a href="https://www.codejava.net/java-se/file-io/why-do-we-need-serialization-in-java" target="_blank" rel="noopener">https://www.codejava.net/java-se/file-io/why-do-we-need-serialization-in-java</a></li><li><a href="https://www.baeldung.com/java-serialization" target="_blank" rel="noopener">https://www.baeldung.com/java-serialization</a></li><li><a href="https://www.geeksforgeeks.org/serialization-in-java/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/serialization-in-java/</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Overview&quot;&gt;&lt;a href=&quot;#1-Overview&quot; class=&quot;headerlink&quot; title=&quot;1. Overview&quot;&gt;&lt;/a&gt;1. Overview&lt;/h1&gt;&lt;p&gt;An object is eligible for serializat
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java Pattern Regex表达式</title>
    <link href="https://www.llchen60.com/Java-Pattern-Regex%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://www.llchen60.com/Java-Pattern-Regex%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2020-02-06T03:00:32.000Z</published>
    <updated>2020-02-06T03:00:54.343Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-为什么要使用Pattern？"><a href="#1-为什么要使用Pattern？" class="headerlink" title="1. 为什么要使用Pattern？"></a>1. 为什么要使用Pattern？</h1><p>一般来说如果我们要对String做某个范式下的替换时，我们需要使用</p><pre><code>stringEG.replaceAll(&quot;(?i)@gmail\\.com$&quot;, &quot;&quot;);</code></pre><p>上面这行代码是将stringEG最后的@gmail.com给替换掉，通过这种方式来获得用户名。</p><p>这种Replace操作我们会经常使用，但是上述有一个问题，即每次运行都要执行一遍Regex操作，这样很费时间，每次都要进行编译，Pattern可以帮助我们解决这个问题。</p><p>通过设置static的变量，我们可以将Compile完的结果存起来，然后在需要的时候直接使用这个结果即可。</p><p>使用方法如下所示:</p><pre><code>private static final Pattern USER_NAME_PATTERN = Pattern.compile(&quot;(?i)@gmail\\.com$);final String username =  USER_NAME_PATTERN.matcher(stringEG.replace(&quot;&quot;));</code></pre><h1 id="2-如何使用Pattern？"><a href="#2-如何使用Pattern？" class="headerlink" title="2. 如何使用Pattern？"></a>2. 如何使用Pattern？</h1><p>使用Java Pattern，重点在于对于正则表达式的使用，可以看一下文章 - <a href="https://llchen60.com/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" target="_blank" rel="noopener">正则表达式</a>, 里面有对正则的详细介绍。</p><p>Pattern对象是一个已经编译过的正则表达式的表达，Pattern类没有public的构造器，想要创建一个Pattern，我们需要首先调用其静态的compile()方法，通过这个方法会得到一个Pattern对象。</p><p>Matcher 对象用来解释正则表达式然后根据表达式来找符合规则的相关表达，同样没有public的构造器，通过调用matcher() 方法来作比较</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-为什么要使用Pattern？&quot;&gt;&lt;a href=&quot;#1-为什么要使用Pattern？&quot; class=&quot;headerlink&quot; title=&quot;1. 为什么要使用Pattern？&quot;&gt;&lt;/a&gt;1. 为什么要使用Pattern？&lt;/h1&gt;&lt;p&gt;一般来说如果我们要对St
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
      <category term="Regex" scheme="https://www.llchen60.com/tags/Regex/"/>
    
  </entry>
  
</feed>
