<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Leilei&#39;s Blog | 磊磊的博客</title>
  
  <subtitle>Because it&#39;s there</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.llchen60.com/"/>
  <updated>2020-07-24T06:30:25.859Z</updated>
  <id>https://www.llchen60.com/</id>
  
  <author>
    <name>Leilei Chen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>设计模式-行为型-迭代器模式</title>
    <link href="https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-07-24T06:30:04.000Z</published>
    <updated>2020-07-24T06:30:25.859Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-迭代器模式的原理和实现"><a href="#1-迭代器模式的原理和实现" class="headerlink" title="1. 迭代器模式的原理和实现"></a>1. 迭代器模式的原理和实现</h1><ul><li>迭代器模式<ul><li>Iterator Design Pattern / Cursor Design Patten </li><li>用来遍历集合对象</li><li>编程语言基本上都将迭代器作为一个基础类库来提供了</li><li>集合对象指的是一个容器，而迭代器需要迭代的对象实际上是一组对象的对象</li><li>迭代器模式将集合对象的遍历操作从集合类当中拆分出来，放到迭代器类当中，使得二者的职责更加单一</li></ul></li></ul><ul><li>涉及部分<ul><li>容器<ul><li>接口</li><li>实现类</li></ul></li><li>容器迭代器<ul><li>接口</li><li>实现类</li></ul></li></ul></li></ul><h2 id="1-1-实现一个线性结构容器的迭代器"><a href="#1-1-实现一个线性结构容器的迭代器" class="headerlink" title="1.1 实现一个线性结构容器的迭代器"></a>1.1 实现一个线性结构容器的迭代器</h2><pre><code>// 接口定义方式一public interface Iterator&lt;E&gt; {  boolean hasNext();  void next();  E currentItem();}// 接口定义方式二public interface Iterator&lt;E&gt; {  boolean hasNext();  E next();}</code></pre><ul><li>定义方式一的好处在可以多次获得当前的对象，会更加灵活</li></ul><pre><code>public class ArrayIterator&lt;E&gt; implements Iterator&lt;E&gt; {  private int cursor;  private ArrayList&lt;E&gt; arrayList;  public ArrayIterator(ArrayList&lt;E&gt; arrayList) {    this.cursor = 0;    this.arrayList = arrayList;  }  @Override  public boolean hasNext() {    return cursor != arrayList.size(); //注意这里，cursor在指向最后一个元素的时候，hasNext()仍旧返回true。  }  @Override  public void next() {    cursor++;  }  @Override  public E currentItem() {    if (cursor &gt;= arrayList.size()) {      throw new NoSuchElementException();    }    return arrayList.get(cursor);  }}public class Demo {  public static void main(String[] args) {    ArrayList&lt;String&gt; names = new ArrayList&lt;&gt;();    names.add(&quot;xzg&quot;);    names.add(&quot;wang&quot;);    names.add(&quot;zheng&quot;);    Iterator&lt;String&gt; iterator = new ArrayIterator(names);    while (iterator.hasNext()) {      System.out.println(iterator.currentItem());      iterator.next();    }  }}</code></pre><ul><li>这里一个问题是还需要<code>new ArrayIterator()</code>，我们可以通过在List的接口当中定义迭代器，然后再ArrayList的类当中定义一个iterator()方法。然后在使用的时候，我们就可以通过实例化以后的容器，比如ArrayList，直接来调用iterator()方法了</li></ul><pre><code>public interface List&lt;E&gt; {  Iterator iterator();  //...省略其他接口函数...}public class ArrayList&lt;E&gt; implements List&lt;E&gt; {  //...  public Iterator iterator() {    return new ArrayIterator(this);  }  //...省略其他代码}public class Demo {  public static void main(String[] args) {    List&lt;String&gt; names = new ArrayList&lt;&gt;();    names.add(&quot;xzg&quot;);    names.add(&quot;wang&quot;);    names.add(&quot;zheng&quot;);    Iterator&lt;String&gt; iterator = names.iterator();    while (iterator.hasNext()) {      System.out.println(iterator.currentItem());      iterator.next();    }  }}</code></pre><ul><li><p>实现方式/ 设计思路</p><ul><li><p>迭代器当中实现</p><ul><li>hasNext()</li><li>currentItem()</li><li>next()</li></ul></li><li><p>待遍历的容器</p><ul><li>通过依赖注入传递到迭代器当中</li><li>容器通过iterator()方法来创建迭代器</li></ul></li></ul></li></ul><h2 id="1-2-为什么需要迭代器模式来遍历集合？"><a href="#1-2-为什么需要迭代器模式来遍历集合？" class="headerlink" title="1.2 为什么需要迭代器模式来遍历集合？"></a>1.2 为什么需要迭代器模式来遍历集合？</h2><ol><li>复杂数据结构遍历方式也会非常复杂，比如对于树，对于图来说。我们将遍历的方式定义到迭代器当中，这样就避免了要自己实现这样复杂的操作了。</li><li>通过迭代器模式，可以同时创建多个不同的迭代器，对同一个容器进行遍历而不互相影响</li><li>容器和迭代器都提供了抽象的接口，当我们需要改变遍历算法的时候，对代码的影响会很小，只在依赖注入处使用新的迭代器类所提供的算法即可</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-迭代器模式的原理和实现&quot;&gt;&lt;a href=&quot;#1-迭代器模式的原理和实现&quot; class=&quot;headerlink&quot; title=&quot;1. 迭代器模式的原理和实现&quot;&gt;&lt;/a&gt;1. 迭代器模式的原理和实现&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;迭代器模式&lt;ul&gt;
&lt;li&gt;Iter
      
    
    </summary>
    
    
      <category term="SystenDesign" scheme="https://www.llchen60.com/categories/SystenDesign/"/>
    
    
      <category term="迭代器模式" scheme="https://www.llchen60.com/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-行为型-状态模式</title>
    <link href="https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-07-21T05:14:07.000Z</published>
    <updated>2020-07-21T05:14:46.840Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-原理与实现"><a href="#1-原理与实现" class="headerlink" title="1. 原理与实现"></a>1. 原理与实现</h1><p>状态模式一般用来实现状态机，常常用在游戏，工作流引擎等系统开发当中。</p><p>做法是将状态，事件，以及动作都放置到不同的类当中，通过接口与继承，来实现各个方法，其中共享变量可以作为输入传入。 </p><h1 id="2-以有限状态机的实现为例"><a href="#2-以有限状态机的实现为例" class="headerlink" title="2. 以有限状态机的实现为例"></a>2. 以有限状态机的实现为例</h1><ul><li>有限状态机<ul><li>Finite State Machine</li><li>组成部分<ul><li>状态</li><li>事件/ 转移条件<ul><li>触发状态的转移</li><li>动作的执行</li></ul></li><li>动作</li></ul></li></ul></li></ul><p>以下面的状态转移图为例： </p><p><img src="https://i.loli.net/2020/07/21/jzSQHTRxkybDBYE.png" alt="状态转移图"></p><h2 id="2-1-分支逻辑法实现"><a href="#2-1-分支逻辑法实现" class="headerlink" title="2.1 分支逻辑法实现"></a>2.1 分支逻辑法实现</h2><p>会包含大量的if-else语句</p><pre><code>public class MarioStateMachine {  private int score;  private State currentState;  public MarioStateMachine() {    this.score = 0;    this.currentState = State.SMALL;  }  public void obtainMushRoom() {    if (currentState.equals(State.SMALL)) {      this.currentState = State.SUPER;      this.score += 100;    }  }  public void obtainCape() {    if (currentState.equals(State.SMALL) || currentState.equals(State.SUPER) ) {      this.currentState = State.CAPE;      this.score += 200;    }  }  public void obtainFireFlower() {    if (currentState.equals(State.SMALL) || currentState.equals(State.SUPER) ) {      this.currentState = State.FIRE;      this.score += 300;    }  }  public void meetMonster() {    if (currentState.equals(State.SUPER)) {      this.currentState = State.SMALL;      this.score -= 100;      return;    }    if (currentState.equals(State.CAPE)) {      this.currentState = State.SMALL;      this.score -= 200;      return;    }    if (currentState.equals(State.FIRE)) {      this.currentState = State.SMALL;      this.score -= 300;      return;    }  }  public int getScore() {    return this.score;  }  public State getCurrentState() {    return this.currentState;  }}</code></pre><h2 id="2-2-查表法"><a href="#2-2-查表法" class="headerlink" title="2.2 查表法"></a>2.2 查表法</h2><p><img src="https://i.loli.net/2020/07/21/127jeqv5CwsIWKP.png" alt="查表法.png"></p><p>使用一张二维表来表示状态机，纵向表示当前状态，横向表示事件，值表示当前状态经过事件以后，转移到的新状态和其执行的动作</p><pre><code>public enum Event {  GOT_MUSHROOM(0),  GOT_CAPE(1),  GOT_FIRE(2),  MET_MONSTER(3);  private int value;  private Event(int value) {    this.value = value;  }  public int getValue() {    return this.value;  }}public class MarioStateMachine {  private int score;  private State currentState;  private static final State[][] transitionTable = {          {SUPER, CAPE, FIRE, SMALL},          {SUPER, CAPE, FIRE, SMALL},          {CAPE, CAPE, CAPE, SMALL},          {FIRE, FIRE, FIRE, SMALL}  };  private static final int[][] actionTable = {          {+100, +200, +300, +0},          {+0, +200, +300, -100},          {+0, +0, +0, -200},          {+0, +0, +0, -300}  };  public MarioStateMachine() {    this.score = 0;    this.currentState = State.SMALL;  }  public void obtainMushRoom() {    executeEvent(Event.GOT_MUSHROOM);  }  public void obtainCape() {    executeEvent(Event.GOT_CAPE);  }  public void obtainFireFlower() {    executeEvent(Event.GOT_FIRE);  }  public void meetMonster() {    executeEvent(Event.MET_MONSTER);  }  private void executeEvent(Event event) {    int stateValue = currentState.getValue();    int eventValue = event.getValue();    this.currentState = transitionTable[stateValue][eventValue];    this.score = actionTable[stateValue][eventValue];  }  public int getScore() {    return this.score;  }  public State getCurrentState() {    return this.currentState;  }}</code></pre><h2 id="2-3-状态模式"><a href="#2-3-状态模式" class="headerlink" title="2.3 状态模式"></a>2.3 状态模式</h2><p>当要执行的动作是比较复杂的一系列逻辑操作的时候，我们就无法使用二维数组来表示了。状态模式是将事件触发的状态转移和动作执行来拆分到不同的状态类当中，来避免分支判断逻辑。</p><pre><code>public interface IMario {  State getName();  void obtainMushRoom(MarioStateMachine stateMachine);  void obtainCape(MarioStateMachine stateMachine);  void obtainFireFlower(MarioStateMachine stateMachine);  void meetMonster(MarioStateMachine stateMachine);}public class SmallMario implements IMario {  private static final SmallMario instance = new SmallMario();  private SmallMario() {}  public static SmallMario getInstance() {    return instance;  }  @Override  public State getName() {    return State.SMALL;  }  @Override  public void obtainMushRoom(MarioStateMachine stateMachine) {    stateMachine.setCurrentState(SuperMario.getInstance());    stateMachine.setScore(stateMachine.getScore() + 100);  }  @Override  public void obtainCape(MarioStateMachine stateMachine) {    stateMachine.setCurrentState(CapeMario.getInstance());    stateMachine.setScore(stateMachine.getScore() + 200);  }  @Override  public void obtainFireFlower(MarioStateMachine stateMachine) {    stateMachine.setCurrentState(FireMario.getInstance());    stateMachine.setScore(stateMachine.getScore() + 300);  }  @Override  public void meetMonster(MarioStateMachine stateMachine) {    // do nothing...  }}// 省略SuperMario、CapeMario、FireMario类...public class MarioStateMachine {  private int score;  private IMario currentState;  public MarioStateMachine() {    this.score = 0;    this.currentState = SmallMario.getInstance();  }  public void obtainMushRoom() {    this.currentState.obtainMushRoom(this);  }  public void obtainCape() {    this.currentState.obtainCape(this);  }  public void obtainFireFlower() {    this.currentState.obtainFireFlower(this);  }  public void meetMonster() {    this.currentState.meetMonster(this);  }  public int getScore() {    return this.score;  }  public State getCurrentState() {    return this.currentState.getName();  }  public void setScore(int score) {    this.score = score;  }  public void setCurrentState(IMario currentState) {    this.currentState = currentState;  }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-原理与实现&quot;&gt;&lt;a href=&quot;#1-原理与实现&quot; class=&quot;headerlink&quot; title=&quot;1. 原理与实现&quot;&gt;&lt;/a&gt;1. 原理与实现&lt;/h1&gt;&lt;p&gt;状态模式一般用来实现状态机，常常用在游戏，工作流引擎等系统开发当中。&lt;/p&gt;
&lt;p&gt;做法是将状态
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="状态模式" scheme="https://www.llchen60.com/tags/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-行为型-职责链模式</title>
    <link href="https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-07-12T01:22:10.000Z</published>
    <updated>2020-07-16T04:33:00.386Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-原理与实现"><a href="#1-原理与实现" class="headerlink" title="1. 原理与实现"></a>1. 原理与实现</h1><ul><li>职责链模式<ul><li>Chian of Responsibility Design Pattern </li><li>Avoid coupling the sender of a request to its receiver by giving more than one object a chance to hadle the request. Chain the receiving objects and pass the request along the chain until an object handles it. </li><li>将请求的发送和接收解耦，让多个接收对象都有机会处理这个请求。将这些接收对象串成一条链，并沿着这条链传递这个请求，直到链上的某个接收对象能够处理它为止</li><li>在职责链模式当中，多个处理器依次处理同一个请求，一个请求先经过A处理器处理，再把请求传递给B处理器，B处理器处理完以后再传递给C处理器。各个处理器之间形成了一个链条，链条上的每个处理器各自承担各自的处理职责，所以叫做职责链模式。</li></ul></li></ul><h2 id="1-1-使用链表实现HandlerChain"><a href="#1-1-使用链表实现HandlerChain" class="headerlink" title="1.1 使用链表实现HandlerChain"></a>1.1 使用链表实现HandlerChain</h2><ul><li>Handler是所有处理器的抽象父类</li><li>handle()是抽象方法</li><li>每个具体的处理器类的handle()函数结构会比较类似，如果能处理请求，则进行处理；如果不能，则交由后面的处理器来进行处理</li><li>HandlerChain是处理器链，从数据结构来看，是一个记录了链头、链尾的链表。</li></ul><p>public abstract class Handler {<br>  protected Handler successor = null;</p><p>  public void setSuccessor(Handler successor) {<br>    this.successor = successor;<br>  }</p><p>  public final void handle() {<br>    boolean handled = doHandle();</p><pre><code>if (successor != null &amp;&amp; !handled) {    successor.handle();}</code></pre><p>  }<br>  public abstract boolean doHandle();<br>}</p><p>public class HandlerA extends Handler {<br>  @Override<br>  public void doHandle() {<br>    boolean handled = false;<br>    //…<br>    return handled;<br>  }<br>}</p><p>public class HandlerB extends Handler {<br>  @Override<br>  public void doHandle() {<br>    boolean handled = false;<br>    //…<br>    return handled;<br>  }<br>}</p><p>public class HandlerChain {<br>  private Handler head = null;<br>  private Handler tail = null;</p><p>  public void addHandler(Handler handler) {<br>    handler.setSuccessor(null);</p><pre><code>if (head == null) {  head = handler;  tail = handler;  return;}tail.setSuccessor(handler);tail = handler;</code></pre><p>  }</p><p>  public void handle() {<br>    if (head != null) {<br>      head.handle();<br>    }<br>  }<br>}</p><p>// 使用举例<br>public class Application {<br>  public static void main(String[] args) {<br>    HandlerChain chain = new HandlerChain();<br>    chain.addHandler(new HandlerA());<br>    chain.addHandler(new HandlerB());<br>    chain.handle();<br>  }<br>}</p><h2 id="1-2-使用数组实现HandlerChain"><a href="#1-2-使用数组实现HandlerChain" class="headerlink" title="1.2 使用数组实现HandlerChain"></a>1.2 使用数组实现HandlerChain</h2><pre><code>public interface IHandler {  boolean handle();}public class HandlerA implements IHandler {  @Override  public boolean handle() {    boolean handled = false;    //...    return handled;  }}public class HandlerB implements IHandler {  @Override  public boolean handle() {    boolean handled = false;    //...    return handled;  }}public class HandlerChain {  private List&lt;IHandler&gt; handlers = new ArrayList&lt;&gt;();  public void addHandler(IHandler handler) {    this.handlers.add(handler);  }  public void handle() {    for (IHandler handler : handlers) {      boolean handled = handler.handle();      if (handled) {        break;      }    }  }}// 使用举例public class Application {  public static void main(String[] args) {    HandlerChain chain = new HandlerChain();    chain.addHandler(new HandlerA());    chain.addHandler(new HandlerB());    chain.handle();  }}</code></pre><h1 id="2-过滤器、拦截器的实现"><a href="#2-过滤器、拦截器的实现" class="headerlink" title="2. 过滤器、拦截器的实现"></a>2. 过滤器、拦截器的实现</h1><p>职责链模式最长建的使用位置是在框架的开发当中，比如过滤器和拦截器。</p><h2 id="2-1-Servlet-Filter"><a href="#2-1-Servlet-Filter" class="headerlink" title="2.1 Servlet Filter"></a>2.1 Servlet Filter</h2><ul><li><p>实现堆HTTP请求的过滤功能</p><ul><li>鉴权</li><li>限流</li><li>记录日志</li><li>验证参数等</li></ul></li><li><p>在实际使用当中，定义一个实现<code>javax.servlet.Filter</code>接口的过滤器类，并且将其配置在web.xml配置文件当中。Web容器启动的时候，会读取web.xml中的配置，创建过滤器对象。</p></li><li><p>当有请求到来的时候，就会先经过过滤器，然后经由Servlet来进行处理</p></li></ul><pre><code>public class LogFilter implements Filter {  @Override  public void init(FilterConfig filterConfig) throws ServletException {    // 在创建Filter时自动调用，    // 其中filterConfig包含这个Filter的配置参数，比如name之类的（从配置文件中读取的）  }  @Override  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {    System.out.println(&quot;拦截客户端发送来的请求.&quot;);    chain.doFilter(request, response);    System.out.println(&quot;拦截发送给客户端的响应.&quot;);  }  @Override  public void destroy() {    // 在销毁Filter时自动调用  }}// 在web.xml配置文件中如下配置：&lt;filter&gt;  &lt;filter-name&gt;logFilter&lt;/filter-name&gt;  &lt;filter-class&gt;com.xzg.cd.LogFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt;    &lt;filter-name&gt;logFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;</code></pre><ul><li>FilterChain的实现</li></ul><pre><code>public final class ApplicationFilterChain implements FilterChain {  private int pos = 0; //当前执行到了哪个filter  private int n; //filter的个数  private ApplicationFilterConfig[] filters;  private Servlet servlet;  @Override  public void doFilter(ServletRequest request, ServletResponse response) {    if (pos &lt; n) {      ApplicationFilterConfig filterConfig = filters[pos++];      Filter filter = filterConfig.getFilter();      filter.doFilter(request, response, this);    } else {      // filter都处理完毕后，执行servlet      servlet.service(request, response);    }  }  public void addFilter(ApplicationFilterConfig filterConfig) {    for (ApplicationFilterConfig filter:filters)      if (filter==filterConfig)         return;    if (n == filters.length) {//扩容      ApplicationFilterConfig[] newFilters = new ApplicationFilterConfig[n + INCREMENT];      System.arraycopy(filters, 0, newFilters, 0, n);      filters = newFilters;    }    filters[n++] = filterConfig;  }}</code></pre><h2 id="2-2-Spring-Interceptor"><a href="#2-2-Spring-Interceptor" class="headerlink" title="2.2 Spring Interceptor"></a>2.2 Spring Interceptor</h2><p>有Spring MVC框架来提供实现，客户端发送的请求，会先经过Servlet Filter，然后在经过Spring Interceptor，最后再到达具体的业务代码当中。 </p><pre><code>// 代码实现public class LogInterceptor implements HandlerInterceptor {  @Override  public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {    System.out.println(&quot;拦截客户端发送来的请求.&quot;);    return true; // 继续后续的处理  }  @Override  public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {    System.out.println(&quot;拦截发送给客户端的响应.&quot;);  }  @Override  public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {    System.out.println(&quot;这里总是被执行.&quot;);  }}//在Spring MVC配置文件中配置interceptors&lt;mvc:interceptors&gt;   &lt;mvc:interceptor&gt;       &lt;mvc:mapping path=&quot;/*&quot;/&gt;       &lt;bean class=&quot;com.xzg.cd.LogInterceptor&quot; /&gt;   &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt;</code></pre><ul><li>Spring Interceptor底层实现<ul><li>基于职责链模式</li><li>使用HandlerExecutionChain来处理</li></ul></li></ul><pre><code>public class HandlerExecutionChain { private final Object handler; private HandlerInterceptor[] interceptors; public void addInterceptor(HandlerInterceptor interceptor) {  initInterceptorList().add(interceptor); } boolean applyPreHandle(HttpServletRequest request, HttpServletResponse response) throws Exception {  HandlerInterceptor[] interceptors = getInterceptors();  if (!ObjectUtils.isEmpty(interceptors)) {   for (int i = 0; i &lt; interceptors.length; i++) {    HandlerInterceptor interceptor = interceptors[i];    if (!interceptor.preHandle(request, response, this.handler)) {     triggerAfterCompletion(request, response, null);     return false;    }   }  }  return true; } void applyPostHandle(HttpServletRequest request, HttpServletResponse response, ModelAndView mv) throws Exception {  HandlerInterceptor[] interceptors = getInterceptors();  if (!ObjectUtils.isEmpty(interceptors)) {   for (int i = interceptors.length - 1; i &gt;= 0; i--) {    HandlerInterceptor interceptor = interceptors[i];    interceptor.postHandle(request, response, this.handler, mv);   }  } } void triggerAfterCompletion(HttpServletRequest request, HttpServletResponse response, Exception ex)   throws Exception {  HandlerInterceptor[] interceptors = getInterceptors();  if (!ObjectUtils.isEmpty(interceptors)) {   for (int i = this.interceptorIndex; i &gt;= 0; i--) {    HandlerInterceptor interceptor = interceptors[i];    try {     interceptor.afterCompletion(request, response, this.handler, ex);    } catch (Throwable ex2) {     logger.error(&quot;HandlerInterceptor.afterCompletion threw exception&quot;, ex2);    }   }  } }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-原理与实现&quot;&gt;&lt;a href=&quot;#1-原理与实现&quot; class=&quot;headerlink&quot; title=&quot;1. 原理与实现&quot;&gt;&lt;/a&gt;1. 原理与实现&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;职责链模式&lt;ul&gt;
&lt;li&gt;Chian of Responsibility Desi
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="职责链模式" scheme="https://www.llchen60.com/tags/%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-行为型-策略模式</title>
    <link href="https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-07-10T05:19:17.000Z</published>
    <updated>2020-07-10T22:10:09.405Z</updated>
    
    <content type="html"><![CDATA[<p>策略模式，用于避免冗长的if else或者switch分支判断，并且可以像模板模式那样提供框架的扩展点。</p><h1 id="1-原理与实现"><a href="#1-原理与实现" class="headerlink" title="1. 原理与实现"></a>1. 原理与实现</h1><ul><li>策略模式<ul><li>Strategy Design Pattern </li><li>Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it. </li><li>对策略的定义，创建和使用进行解耦</li></ul></li></ul><h2 id="1-1-策略的定义"><a href="#1-1-策略的定义" class="headerlink" title="1.1 策略的定义"></a>1.1 策略的定义</h2><ul><li>策略接口</li><li>一组实现了这个接口的策略类</li></ul><pre><code>public interface Strategy {  void algorithmInterface();}public class ConcreteStrategyA implements Strategy {  @Override  public void  algorithmInterface() {    //具体的算法...  }}public class ConcreteStrategyB implements Strategy {  @Override  public void  algorithmInterface() {    //具体的算法...  }}</code></pre><h2 id="1-2-策略的创建"><a href="#1-2-策略的创建" class="headerlink" title="1.2 策略的创建"></a>1.2 策略的创建</h2><ul><li><p>策略在使用的时候需要根据类型来判断创建哪个策略来使用</p></li><li><p>因此，为了封装创建逻辑，需要对客户端代码屏蔽创建细节</p><p>  public class StrategyFactory {</p><pre><code>private static final Map&lt;String, Strategy&gt; strategies = new HashMap&lt;&gt;();static {  strategies.put(&quot;A&quot;, new ConcreteStrategyA());  strategies.put(&quot;B&quot;, new ConcreteStrategyB());}public static Strategy getStrategy(String type) {  if (type == null || type.isEmpty()) {    throw new IllegalArgumentException(&quot;type should not be empty.&quot;);  }  return strategies.get(type);}</code></pre><p>  }</p></li></ul><p>这里是需要根据策略是否是有状态的，根据业务场景的需要，来看是否需要返回新创建的对象，或者来复用已经创建好的对象。</p><pre><code>// 返回新创建好的对象的范例public class StrategyFactory {  public static Strategy getStrategy(String type) {    if (type == null || type.isEmpty()) {      throw new IllegalArgumentException(&quot;type should not be empty.&quot;);    }    if (type.equals(&quot;A&quot;)) {      return new ConcreteStrategyA();    } else if (type.equals(&quot;B&quot;)) {      return new ConcreteStrategyB();    }    return null;  }}</code></pre><h2 id="1-3-策略的使用"><a href="#1-3-策略的使用" class="headerlink" title="1.3 策略的使用"></a>1.3 策略的使用</h2><p>使用的时候一般是运行时动态来决定使用哪一种策略。即根据配置，用户的输入，计算结果等因素，来决定 </p><pre><code>// 策略接口：EvictionStrategy// 策略类：LruEvictionStrategy、FifoEvictionStrategy、LfuEvictionStrategy...// 策略工厂：EvictionStrategyFactorypublic class UserCache {  private Map&lt;String, User&gt; cacheData = new HashMap&lt;&gt;();  private EvictionStrategy eviction;  public UserCache(EvictionStrategy eviction) {    this.eviction = eviction;  }  //...}// 运行时动态确定，根据配置文件的配置决定使用哪种策略public class Application {  public static void main(String[] args) throws Exception {    EvictionStrategy evictionStrategy = null;    Properties props = new Properties();    props.load(new FileInputStream(&quot;./config.properties&quot;));    String type = props.getProperty(&quot;eviction_type&quot;);    evictionStrategy = EvictionStrategyFactory.getEvictionStrategy(type);    UserCache userCache = new UserCache(evictionStrategy);    //...  }}// 非运行时动态确定，在代码中指定使用哪种策略public class Application {  public static void main(String[] args) {    //...    EvictionStrategy evictionStrategy = new LruEvictionStrategy();    UserCache userCache = new UserCache(evictionStrategy);    //...  }}</code></pre><h1 id="2-实例"><a href="#2-实例" class="headerlink" title="2. 实例"></a>2. 实例</h1><h2 id="2-1-策略模式避免分支判断"><a href="#2-1-策略模式避免分支判断" class="headerlink" title="2.1 策略模式避免分支判断"></a>2.1 策略模式避免分支判断</h2><pre><code>public class OrderService {  public double discount(Order order) {    double discount = 0.0;    OrderType type = order.getType();    if (type.equals(OrderType.NORMAL)) { // 普通订单      //...省略折扣计算算法代码    } else if (type.equals(OrderType.GROUPON)) { // 团购订单      //...省略折扣计算算法代码    } else if (type.equals(OrderType.PROMOTION)) { // 促销订单      //...省略折扣计算算法代码    }    return discount;  }}// 策略的定义public interface DiscountStrategy {  double calDiscount(Order order);}// 省略NormalDiscountStrategy、GrouponDiscountStrategy、PromotionDiscountStrategy类代码...// 策略的创建public class DiscountStrategyFactory {  private static final Map&lt;OrderType, DiscountStrategy&gt; strategies = new HashMap&lt;&gt;();  static {    strategies.put(OrderType.NORMAL, new NormalDiscountStrategy());    strategies.put(OrderType.GROUPON, new GrouponDiscountStrategy());    strategies.put(OrderType.PROMOTION, new PromotionDiscountStrategy());  }  public static DiscountStrategy getDiscountStrategy(OrderType type) {    return strategies.get(type);  }}// 策略的使用public class OrderService {  public double discount(Order order) {    OrderType type = order.getType();    DiscountStrategy discountStrategy = DiscountStrategyFactory.getDiscountStrategy(type);    return discountStrategy.calDiscount(order);  }}</code></pre><h2 id="2-2-根据大小对文件排序"><a href="#2-2-根据大小对文件排序" class="headerlink" title="2.2 根据大小对文件排序"></a>2.2 根据大小对文件排序</h2><ul><li><p>对文件进行排序</p><ul><li>整型数</li><li>逗号间隔</li></ul></li><li><p>100GB大小的话</p><ul><li>利用外部排序算法  – MapReduce框架</li></ul></li></ul><pre><code>public class SortAlgFactory {  private static final Map&lt;String, ISortAlg&gt; algs = new HashMap&lt;&gt;();  static {    algs.put(&quot;QuickSort&quot;, new QuickSort());    algs.put(&quot;ExternalSort&quot;, new ExternalSort());    algs.put(&quot;ConcurrentExternalSort&quot;, new ConcurrentExternalSort());    algs.put(&quot;MapReduceSort&quot;, new MapReduceSort());  }  public static ISortAlg getSortAlg(String type) {    if (type == null || type.isEmpty()) {      throw new IllegalArgumentException(&quot;type should not be empty.&quot;);    }    return algs.get(type);  }}public class Sorter {  private static final long GB = 1000 * 1000 * 1000;  public void sortFile(String filePath) {    // 省略校验逻辑    File file = new File(filePath);    long fileSize = file.length();    ISortAlg sortAlg;    if (fileSize &lt; 6 * GB) { // [0, 6GB)      sortAlg = SortAlgFactory.getSortAlg(&quot;QuickSort&quot;);    } else if (fileSize &lt; 10 * GB) { // [6GB, 10GB)      sortAlg = SortAlgFactory.getSortAlg(&quot;ExternalSort&quot;);    } else if (fileSize &lt; 100 * GB) { // [10GB, 100GB)      sortAlg = SortAlgFactory.getSortAlg(&quot;ConcurrentExternalSort&quot;);    } else { // [100GB, ~)      sortAlg = SortAlgFactory.getSortAlg(&quot;MapReduceSort&quot;);    }    sortAlg.sort(filePath);  }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;策略模式，用于避免冗长的if else或者switch分支判断，并且可以像模板模式那样提供框架的扩展点。&lt;/p&gt;
&lt;h1 id=&quot;1-原理与实现&quot;&gt;&lt;a href=&quot;#1-原理与实现&quot; class=&quot;headerlink&quot; title=&quot;1. 原理与实现&quot;&gt;&lt;/a&gt;1. 原
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="策略模式" scheme="https://www.llchen60.com/tags/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Intellij IDEA tips and tricks</title>
    <link href="https://www.llchen60.com/Intellij-IDEA-tips-and-tricks/"/>
    <id>https://www.llchen60.com/Intellij-IDEA-tips-and-tricks/</id>
    <published>2020-07-06T04:39:57.000Z</published>
    <updated>2020-07-06T04:40:23.103Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>Magic shortcut for almost everything<br>Alt + Enter </p></li><li><p>Jump to next error  </p></li></ol><p>F2 </p><ol start="3"><li><p>Project window<br>cmd + 1 </p></li><li><p>focus on editor  </p></li></ol><p>esc </p><ol start="5"><li>The recent file box  </li></ol><p>cmd E </p><ol start="6"><li>Go to declaration </li></ol><p>cmd + B </p><ol start="7"><li>Find usage </li></ol><p>Alt + F7 </p><ol start="8"><li>Run Anything </li></ol><p>double ctrl </p><p>*<em>9. Extend/ shrink selection *</em></p><p>option + up arrow </p><p>option + down arrow </p><ol start="10"><li>Add/ Remove comments</li></ol><p>cmd + / </p><ol start="11"><li>Complete current statement </li></ol><p>shift + cmd + enter </p><ol start="12"><li>Reformat file </li></ol><p>alt + cmd + l</p><ol start="13"><li>Refactor </li></ol><p>ctrl + t </p><p>Show all the refactor option </p><ol start="14"><li>Find action </li></ol><p>shift + cmd + A </p><ol start="15"><li>Search everywhere </li></ol><p>shift + shift </p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://www.youtube.com/watch?v=QYO5_riePOQ" target="_blank" rel="noopener">https://www.youtube.com/watch?v=QYO5_riePOQ</a> </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;Magic shortcut for almost everything&lt;br&gt;Alt + Enter &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Jump to next error  &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;F2 &lt;/p&gt;
&lt;ol start=
      
    
    </summary>
    
    
      <category term="Tools" scheme="https://www.llchen60.com/categories/Tools/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式-行为型-模板模式</title>
    <link href="https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-07-05T17:54:08.000Z</published>
    <updated>2020-07-07T05:11:42.063Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-原理与实现"><a href="#1-原理与实现" class="headerlink" title="1. 原理与实现"></a>1. 原理与实现</h1><ul><li>模板方法设计模式<ul><li>Template Method Design Pattern </li><li>Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template method lets subclasses redefine certain steps of an algorithm without changing the algorithm’s structure </li><li>在一个方法中定义一个算法股价，并将某些步骤推迟到子类当中进行实现，模板方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些不好走。</li></ul></li></ul><p>实现的基本方式就是设置一个抽象类，对于不想被子类重写的方法可以加上final关键字，其余的可以设置为抽象方法，让子类来实现。</p><pre><code>public abstract class AbstractClass {  public final void templateMethod() {    //...    method1();    //...    method2();    //...  }  protected abstract void method1();  protected abstract void method2();}public class ConcreteClass1 extends AbstractClass {  @Override  protected void method1() {    //...  }  @Override  protected void method2() {    //...  }}public class ConcreteClass2 extends AbstractClass {  @Override  protected void method1() {    //...  }  @Override  protected void method2() {    //...  }}AbstractClass demo = ConcreteClass1();demo.templateMethod();</code></pre><h1 id="2-功能实现的例子"><a href="#2-功能实现的例子" class="headerlink" title="2. 功能实现的例子"></a>2. 功能实现的例子</h1><h2 id="2-1-以复用为目的"><a href="#2-1-以复用为目的" class="headerlink" title="2.1 以复用为目的"></a>2.1 以复用为目的</h2><ol><li><p>InputStream 类的实现</p><p> public abstract class InputStream implements Closeable {<br>   //…省略其他代码…</p><p>   public int read(byte b[], int off, int len) throws IOException {</p><pre><code> if (b == null) {   throw new NullPointerException(); } else if (off &lt; 0 || len &lt; 0 || len &gt; b.length - off) {   throw new IndexOutOfBoundsException(); } else if (len == 0) {   return 0; } int c = read(); if (c == -1) {   return -1; } b[off] = (byte)c; int i = 1; try {   for (; i &lt; len ; i++) {     c = read();     if (c == -1) {       break;     }     b[off + i] = (byte)c;   } } catch (IOException ee) { } return i;</code></pre><p>   }</p><p>   // 在这里定义了一个可以供子类实现的抽象方法<br>   public abstract int read() throws IOException;<br> }</p><p> public class ByteArrayInputStream extends InputStream {<br>   //…省略其他代码…</p><p>   @Override<br>   public synchronized int read() {</p><pre><code> return (pos &lt; count) ? (buf[pos++] &amp; 0xff) : -1;</code></pre><p>   }<br> }</p></li></ol><ol start="2"><li>AbstractList的实现</li></ol><pre><code>public boolean addAll(int index, Collection&lt;? extends E&gt; c) {    rangeCheckForAdd(index);    boolean modified = false;    for (E e : c) {        add(index++, e);        modified = true;    }    return modified;}public void add(int index, E element) {    throw new UnsupportedOperationException();}</code></pre><h2 id="2-2-以扩展为目的"><a href="#2-2-以扩展为目的" class="headerlink" title="2.2 以扩展为目的"></a>2.2 以扩展为目的</h2><ol><li>Java Servlet</li></ol><p>抛开框架直接使用Servlet做开发的话，Servlet在接收到请求之后，会根据URL和Servlet的映射关系，找到对应的Servlet，然后来执行它的service()方法。service方法定义在父类HttpServelet当中，会调用doGet()还有doPost()方法。</p><p>为了实现上述的整个流程，我们需要继承HttpServlet，重新实现我们自己的doGet()以及doPost()方法。</p><pre><code>public class HelloServlet extends HttpServlet {  @Override  protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {    this.doPost(req, resp);  }  @Override  protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {    resp.getWriter().write(&quot;Hello World.&quot;);  }}// 存储映射关系的xml，也可以使用annotation来实现映射&lt;servlet&gt;    &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;com.xzg.cd.HelloServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;public void service(ServletRequest req, ServletResponse res)    throws ServletException, IOException{    HttpServletRequest  request;    HttpServletResponse response;    if (!(req instanceof HttpServletRequest &amp;&amp;            res instanceof HttpServletResponse)) {        throw new ServletException(&quot;non-HTTP request or response&quot;);    }    request = (HttpServletRequest) req;    response = (HttpServletResponse) res;    service(request, response);}protected void service(HttpServletRequest req, HttpServletResponse resp)    throws ServletException, IOException{    String method = req.getMethod();    if (method.equals(METHOD_GET)) {        long lastModified = getLastModified(req);        if (lastModified == -1) {            // servlet doesn&#39;t support if-modified-since, no reason            // to go through further expensive logic            doGet(req, resp);        } else {            long ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE);            if (ifModifiedSince &lt; lastModified) {                // If the servlet mod time is later, call doGet()                // Round down to the nearest second for a proper compare                // A ifModifiedSince of -1 will always be less                maybeSetLastModified(resp, lastModified);                doGet(req, resp);            } else {                resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);            }        }    } else if (method.equals(METHOD_HEAD)) {        long lastModified = getLastModified(req);        maybeSetLastModified(resp, lastModified);        doHead(req, resp);    } else if (method.equals(METHOD_POST)) {        doPost(req, resp);    } else if (method.equals(METHOD_PUT)) {        doPut(req, resp);    } else if (method.equals(METHOD_DELETE)) {        doDelete(req, resp);    } else if (method.equals(METHOD_OPTIONS)) {        doOptions(req,resp);    } else if (method.equals(METHOD_TRACE)) {        doTrace(req,resp);    } else {        String errMsg = lStrings.getString(&quot;http.method_not_implemented&quot;);        Object[] errArgs = new Object[1];        errArgs[0] = method;        errMsg = MessageFormat.format(errMsg, errArgs);        resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);    }}</code></pre><ol start="2"><li>JUnit TestCase</li></ol><p>Junit定义的功能扩展点为：</p><ul><li>setUp() </li><li>tearDown()</li><li>etc.</li></ul><p>写的测试类都是继承框架提供的testCase类，在这个类当中，runBare()函数是模板方法，定义了执行测试用例的整体流程:先执行setUp()做准备工作，然后执行runTest()运行真正的测试代码，最后执行tearDown()做扫尾工作。</p><pre><code>public abstract class TestCase extends Assert implements Test {  public void runBare() throws Throwable {    Throwable exception = null;    setUp();    try {      runTest();    } catch (Throwable running) {      exception = running;    } finally {      try {        tearDown();      } catch (Throwable tearingDown) {        if (exception == null) exception = tearingDown;      }    }    if (exception != null) throw exception;  }  /**  * Sets up the fixture, for example, open a network connection.  * This method is called before a test is executed.  */  protected void setUp() throws Exception {  }  /**  * Tears down the fixture, for example, close a network connection.  * This method is called after a test is executed.  */  protected void tearDown() throws Exception {  }}</code></pre><h2 id="2-3-模板模式对比Callback函数"><a href="#2-3-模板模式对比Callback函数" class="headerlink" title="2.3 模板模式对比Callback函数"></a>2.3 模板模式对比Callback函数</h2><p>回调函数可以起到和模板模式相同的作用，回调是一种双向调用关系</p><p>A 类事先注册某个函数 F 到 B 类，A 类在调用 B 类的 P 函数的时候，B 类反过来调用 A 类注册给它的 F 函数。这里的 F 函数就是“回调函数”。A 调用 B，B 反过来又调用 A，这种调用机制就叫作“回调”。</p><p>回调分为同步回调和异步回调，同步回调指函数返回之前执行回调函数；异步回调指函数返回之后执行回调函数。</p><pre><code>public interface ICallback {  void methodToCallback();}public class BClass {  public void process(ICallback callback) {    //...    callback.methodToCallback();    //...  }}public class AClass {  public static void main(String[] args) {    BClass b = new BClass();    b.process(new ICallback() { //回调对象      @Override      public void methodToCallback() {        System.out.println(&quot;Call back me.&quot;);      }    });  }}</code></pre><ul><li>使用Callback函数实现的JDBCTemplate</li></ul><pre><code>@Overridepublic &lt;T&gt; List&lt;T&gt; query(String sql, RowMapper&lt;T&gt; rowMapper) throws DataAccessException { return query(sql, new RowMapperResultSetExtractor&lt;T&gt;(rowMapper));}@Overridepublic &lt;T&gt; T query(final String sql, final ResultSetExtractor&lt;T&gt; rse) throws DataAccessException { Assert.notNull(sql, &quot;SQL must not be null&quot;); Assert.notNull(rse, &quot;ResultSetExtractor must not be null&quot;); if (logger.isDebugEnabled()) {  logger.debug(&quot;Executing SQL query [&quot; + sql + &quot;]&quot;); } class QueryStatementCallback implements StatementCallback&lt;T&gt;, SqlProvider {  @Override  public T doInStatement(Statement stmt) throws SQLException {   ResultSet rs = null;   try {    rs = stmt.executeQuery(sql);    ResultSet rsToUse = rs;    if (nativeJdbcExtractor != null) {     rsToUse = nativeJdbcExtractor.getNativeResultSet(rs);    }    return rse.extractData(rsToUse);   }   finally {    JdbcUtils.closeResultSet(rs);   }  }  @Override  public String getSql() {   return sql;  } } return execute(new QueryStatementCallback());}@Overridepublic &lt;T&gt; T execute(StatementCallback&lt;T&gt; action) throws DataAccessException { Assert.notNull(action, &quot;Callback object must not be null&quot;); Connection con = DataSourceUtils.getConnection(getDataSource()); Statement stmt = null; try {  Connection conToUse = con;  if (this.nativeJdbcExtractor != null &amp;&amp;    this.nativeJdbcExtractor.isNativeConnectionNecessaryForNativeStatements()) {   conToUse = this.nativeJdbcExtractor.getNativeConnection(con);  }  stmt = conToUse.createStatement();  applyStatementSettings(stmt);  Statement stmtToUse = stmt;  if (this.nativeJdbcExtractor != null) {   stmtToUse = this.nativeJdbcExtractor.getNativeStatement(stmt);  }  T result = action.doInStatement(stmtToUse);  handleWarnings(stmt);  return result; } catch (SQLException ex) {  // Release Connection early, to avoid potential connection pool deadlock  // in the case when the exception translator hasn&#39;t been initialized yet.  JdbcUtils.closeStatement(stmt);  stmt = null;  DataSourceUtils.releaseConnection(con, getDataSource());  con = null;  throw getExceptionTranslator().translate(&quot;StatementCallback&quot;, getSql(action), ex); } finally {  JdbcUtils.closeStatement(stmt);  DataSourceUtils.releaseConnection(con, getDataSource()); }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-原理与实现&quot;&gt;&lt;a href=&quot;#1-原理与实现&quot; class=&quot;headerlink&quot; title=&quot;1. 原理与实现&quot;&gt;&lt;/a&gt;1. 原理与实现&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;模板方法设计模式&lt;ul&gt;
&lt;li&gt;Template Method Design Pa
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="模板模式" scheme="https://www.llchen60.com/tags/%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-行为型-观察者模式</title>
    <link href="https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-06-30T03:48:34.000Z</published>
    <updated>2020-07-01T03:21:33.006Z</updated>
    
    <content type="html"><![CDATA[<ul><li>创建型设计模式<ul><li>解决对象创建的问题</li></ul></li></ul><ul><li><p>结构型设计模式</p><ul><li>解决类或者对象的组合或组装问题</li></ul></li><li><p>行为型设计模式</p><ul><li>解决类或对象之间的交互问题</li></ul></li></ul><h1 id="1-观察者模式原理"><a href="#1-观察者模式原理" class="headerlink" title="1. 观察者模式原理"></a>1. 观察者模式原理</h1><p>根据应用场景的不同，观察者模式是会有不同的代码实现的<br>    + 同步阻塞<br>    + 异步非阻塞<br>    + 进程内的实现方式<br>    + 跨进程的实现方式</p><ul><li>观察者模式  Observer Design Pattern<ul><li>发布订阅模式 Publish - Subscribe Design Pattern </li><li>Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically. </li><li>角色划分<ul><li>observable and observer </li><li>publisher and subscriber </li><li>producer and consumer </li><li>subject and observer </li><li>dispatcher and listener </li><li>eventEmitter and EventListener </li></ul></li></ul></li></ul><pre><code>// Example public interface RegObserver {  void handleRegSuccess(long userId);}public class RegPromotionObserver implements RegObserver {  private PromotionService promotionService; // 依赖注入  @Override  public void handleRegSuccess(long userId) {    promotionService.issueNewUserExperienceCash(userId);  }}public class RegNotificationObserver implements RegObserver {  private NotificationService notificationService;  @Override  public void handleRegSuccess(long userId) {    notificationService.sendInboxMessage(userId, &quot;Welcome...&quot;);  }}public class UserController {  private UserService userService; // 依赖注入  private List&lt;RegObserver&gt; regObservers = new ArrayList&lt;&gt;();  // 一次性设置好，之后也不可能动态的修改  public void setRegObservers(List&lt;RegObserver&gt; observers) {    regObservers.addAll(observers);  }  public Long register(String telephone, String password) {    //省略输入参数的校验代码    //省略userService.register()异常的try-catch代码    long userId = userService.register(telephone, password);    for (RegObserver observer : regObservers) {      observer.handleRegSuccess(userId);    }    return userId;  }}</code></pre><h1 id="2-探究异步非阻塞的EventBus框架"><a href="#2-探究异步非阻塞的EventBus框架" class="headerlink" title="2. 探究异步非阻塞的EventBus框架"></a>2. 探究异步非阻塞的EventBus框架</h1><h2 id="2-1-基本的异步非阻塞模式"><a href="#2-1-基本的异步非阻塞模式" class="headerlink" title="2.1 基本的异步非阻塞模式"></a>2.1 基本的异步非阻塞模式</h2><pre><code>// 第一种实现方式，其他类代码不变，就没有再重复罗列public class RegPromotionObserver implements RegObserver {  private PromotionService promotionService; // 依赖注入  @Override  public void handleRegSuccess(long userId) {    Thread thread = new Thread(new Runnable() {      @Override      public void run() {        promotionService.issueNewUserExperienceCash(userId);      }    });    thread.start();  }}// 第二种实现方式，其他类代码不变，就没有再重复罗列public class UserController {  private UserService userService; // 依赖注入  private List&lt;RegObserver&gt; regObservers = new ArrayList&lt;&gt;();  private Executor executor;  public UserController(Executor executor) {    this.executor = executor;  }  public void setRegObservers(List&lt;RegObserver&gt; observers) {    regObservers.addAll(observers);  }  public Long register(String telephone, String password) {    //省略输入参数的校验代码    //省略userService.register()异常的try-catch代码    long userId = userService.register(telephone, password);    for (RegObserver observer : regObservers) {      executor.execute(new Runnable() {        @Override        public void run() {          observer.handleRegSuccess(userId);        }      });    }    return userId;  }}</code></pre><ul><li><p>方法1 </p><ul><li>频繁创建销毁线程比较耗时</li><li>并且创建过多线程会导致堆栈溢出</li></ul></li><li><p>方法2 </p><ul><li>线程池，异步执行的逻辑耦合在了register()函数当中，维护成本会提高</li></ul></li></ul><h2 id="2-2-EventBus功能需求"><a href="#2-2-EventBus功能需求" class="headerlink" title="2.2 EventBus功能需求"></a>2.2 EventBus功能需求</h2><p>以google guava eventBus为例</p><pre><code>public class UserController {  private UserService userService; // 依赖注入  private EventBus eventBus;  private static final int DEFAULT_EVENTBUS_THREAD_POOL_SIZE = 20;  public UserController() {    //eventBus = new EventBus(); // 同步阻塞模式    eventBus = new AsyncEventBus(Executors.newFixedThreadPool(DEFAULT_EVENTBUS_THREAD_POOL_SIZE)); // 异步非阻塞模式  }  public void setRegObservers(List&lt;Object&gt; observers) {    for (Object observer : observers) {      eventBus.register(observer);    }  }  public Long register(String telephone, String password) {    //省略输入参数的校验代码    //省略userService.register()异常的try-catch代码    long userId = userService.register(telephone, password);    eventBus.post(userId);    return userId;  }}public class RegPromotionObserver {  private PromotionService promotionService; // 依赖注入  @Subscribe  public void handleRegSuccess(long userId) {    promotionService.issueNewUserExperienceCash(userId);  }}public class RegNotificationObserver {  private NotificationService notificationService;  @Subscribe  public void handleRegSuccess(long userId) {    notificationService.sendInboxMessage(userId, &quot;...&quot;);  }}</code></pre><ul><li>使用EventBus框架实现的观察者模式，大流程上相同，但是区别在于<ul><li>不用定义Observer接口了</li><li>任意类型的对象都可以注册到EventBus当中，通过<code>@Subscribe</code>注解来标明类当中哪个函数可以接收被观察者发送的消息</li></ul></li></ul><ul><li>EventBus, AsyncEventBus <ul><li>Guava EventBus 的所有可调用接口</li></ul></li></ul><pre><code>EventBus eventBus = new EventBus(); // 同步阻塞模式EventBus eventBus = new AsyncEventBus(Executors.newFixedThreadPool(8))；// 异步阻塞模式</code></pre><ul><li><p><code>register()</code>函数</p><ul><li>用来注册观察者</li><li>可以接受任何类型的观察者</li></ul></li><li><p><code>unregister()</code>函数</p><ul><li>删除某个观察者</li></ul></li><li><p><code>post()</code>函数</p><ul><li>用于给观察者发送消息</li></ul></li><li><p><code>@Subscribe</code>注解</p><ul><li>通过注解说明某个函数能够接收哪种类型的消息</li></ul></li></ul><p>最关键的一个数据结构是 Observer 注册表，记录了消息类型和可接收消息函数的对应关系。当调用 register() 函数注册观察者的时候，EventBus 通过解析 @Subscribe 注解，生成 Observer 注册表。当调用 post() 函数发送消息的时候，EventBus 通过注册表找到相应的可接收消息的函数，然后通过 Java 的反射语法来动态地创建对象、执行函数。对于同步阻塞模式，EventBus 在一个线程内依次执行相应的函数。对于异步非阻塞模式，EventBus 通过一个线程池来执行相应的函数。</p><h2 id="2-3-EventBus的实现"><a href="#2-3-EventBus的实现" class="headerlink" title="2.3 EventBus的实现"></a>2.3 EventBus的实现</h2><ol><li>Subscirbe 注解</li></ol><p>用于标明观察者中的哪个函数可以接收信息</p><pre><code>@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)@Betapublic @interface Subscribe {}</code></pre><ol start="2"><li>ObserverAction</li></ol><p>ObserverAction类用来表示Subscribe注解的方法，其中target表示观察者类，method表示方法，主要用在ObserverRegistry观察者注册表当中。</p><pre><code>public class ObserverAction {  private Object target;  private Method method;  public ObserverAction(Object target, Method method) {    this.target = Preconditions.checkNotNull(target);    this.method = method;    this.method.setAccessible(true);  }  public void execute(Object event) { // event是method方法的参数    try {      method.invoke(target, event);    } catch (InvocationTargetException | IllegalAccessException e) {      e.printStackTrace();    }  }}</code></pre><ol start="3"><li>ObserverRegistry</li></ol><p>Observer注册表类，大量使用Java的反射语法</p><pre><code>public class ObserverRegistry {  private ConcurrentMap&lt;Class&lt;?&gt;, CopyOnWriteArraySet&lt;ObserverAction&gt;&gt; registry = new ConcurrentHashMap&lt;&gt;();  public void register(Object observer) {    Map&lt;Class&lt;?&gt;, Collection&lt;ObserverAction&gt;&gt; observerActions = findAllObserverActions(observer);    for (Map.Entry&lt;Class&lt;?&gt;, Collection&lt;ObserverAction&gt;&gt; entry : observerActions.entrySet()) {      Class&lt;?&gt; eventType = entry.getKey();      Collection&lt;ObserverAction&gt; eventActions = entry.getValue();      CopyOnWriteArraySet&lt;ObserverAction&gt; registeredEventActions = registry.get(eventType);      if (registeredEventActions == null) {        registry.putIfAbsent(eventType, new CopyOnWriteArraySet&lt;&gt;());        registeredEventActions = registry.get(eventType);      }      registeredEventActions.addAll(eventActions);    }  }  public List&lt;ObserverAction&gt; getMatchedObserverActions(Object event) {    List&lt;ObserverAction&gt; matchedObservers = new ArrayList&lt;&gt;();    Class&lt;?&gt; postedEventType = event.getClass();    for (Map.Entry&lt;Class&lt;?&gt;, CopyOnWriteArraySet&lt;ObserverAction&gt;&gt; entry : registry.entrySet()) {      Class&lt;?&gt; eventType = entry.getKey();      Collection&lt;ObserverAction&gt; eventActions = entry.getValue();      if (postedEventType.isAssignableFrom(eventType)) {        matchedObservers.addAll(eventActions);      }    }    return matchedObservers;  }  private Map&lt;Class&lt;?&gt;, Collection&lt;ObserverAction&gt;&gt; findAllObserverActions(Object observer) {    Map&lt;Class&lt;?&gt;, Collection&lt;ObserverAction&gt;&gt; observerActions = new HashMap&lt;&gt;();    Class&lt;?&gt; clazz = observer.getClass();    for (Method method : getAnnotatedMethods(clazz)) {      Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();      Class&lt;?&gt; eventType = parameterTypes[0];      if (!observerActions.containsKey(eventType)) {        observerActions.put(eventType, new ArrayList&lt;&gt;());      }      observerActions.get(eventType).add(new ObserverAction(observer, method));    }    return observerActions;  }  private List&lt;Method&gt; getAnnotatedMethods(Class&lt;?&gt; clazz) {    List&lt;Method&gt; annotatedMethods = new ArrayList&lt;&gt;();    for (Method method : clazz.getDeclaredMethods()) {      if (method.isAnnotationPresent(Subscribe.class)) {        Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();        Preconditions.checkArgument(parameterTypes.length == 1,                &quot;Method %s has @Subscribe annotation but has %s parameters.&quot;                        + &quot;Subscriber methods must have exactly 1 parameter.&quot;,                method, parameterTypes.length);        annotatedMethods.add(method);      }    }    return annotatedMethods;  }}</code></pre><ol start="4"><li>EventBus</li></ol><pre><code>public class EventBus {  private Executor executor;  private ObserverRegistry registry = new ObserverRegistry();  public EventBus() {    this(MoreExecutors.directExecutor());  }  protected EventBus(Executor executor) {    this.executor = executor;  }  public void register(Object object) {    registry.register(object);  }  public void post(Object event) {    List&lt;ObserverAction&gt; observerActions = registry.getMatchedObserverActions(event);    for (ObserverAction observerAction : observerActions) {      executor.execute(new Runnable() {        @Override        public void run() {          observerAction.execute(event);        }      });    }  }}</code></pre><ol start="5"><li>AsyncEventBus</li></ol><pre><code>public class AsyncEventBus extends EventBus {  public AsyncEventBus(Executor executor) {    super(executor);  }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;创建型设计模式&lt;ul&gt;
&lt;li&gt;解决对象创建的问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;结构型设计模式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;解决类或者对象的组合或组装问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;行为型设计模式&lt;/
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="观察者模式" scheme="https://www.llchen60.com/tags/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>微观经济学 课程学习</title>
    <link href="https://www.llchen60.com/%E5%BE%AE%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6-%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    <id>https://www.llchen60.com/%E5%BE%AE%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6-%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-06-29T02:11:58.000Z</published>
    <updated>2020-06-29T02:12:28.351Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-导论"><a href="#1-导论" class="headerlink" title="1. 导论"></a>1. 导论</h1><h2 id="1-1-经济学发展史"><a href="#1-1-经济学发展史" class="headerlink" title="1.1 经济学发展史"></a>1.1 经济学发展史</h2><ul><li><p>国富论</p><ul><li>工业革命开始</li><li>市场的运作方式</li><li>自由市场经济是自我平衡的，人人皆会受益</li></ul></li><li><p>微观经济学</p><ul><li>单个生产者，管理者的研究</li></ul></li><li><p>资本论</p><ul><li>有辩证方法 批判 得出结论</li><li>资本主义制度是暂时的，潜在的本质性的矛盾</li></ul></li><li><p>就业、利息和货币通论</p></li></ul><ul><li>经济学分类<ul><li>微观经济学<ul><li>对于大的经济体系的某个经济单位</li></ul></li><li>宏观经济学<ul><li>整个经济系统的总体分析</li></ul></li></ul></li></ul><h2 id="1-2-经济学研究什么"><a href="#1-2-经济学研究什么" class="headerlink" title="1.2 经济学研究什么"></a>1.2 经济学研究什么</h2><p>根源是稀缺性，因为稀缺，所以要选择，机会成本是我们做出选择的方法论。</p><ul><li>经济学 – 稀缺资源配置的学科<ul><li>稀缺<ul><li>生产的产品资源无法满足人们的需要的情况 </li><li>稀缺是经济学最重要的假定</li><li>稀缺是普遍存在的</li><li>选择A还是选择B</li></ul></li><li>选择</li><li>机会成本<ul><li>因为稀缺，所以我们需要是的有限的物品，劳务在有限的时间内满足人们最急需的欲望</li><li>因此人们需要去选择</li><li>选择A B 选择A的机会成本是B的收益</li></ul></li></ul></li></ul><h2 id="1-3-十大经济学原理"><a href="#1-3-十大经济学原理" class="headerlink" title="1.3 十大经济学原理"></a>1.3 十大经济学原理</h2><p>看整个的学习框架</p><h3 id="1-3-1-关于个人的"><a href="#1-3-1-关于个人的" class="headerlink" title="1.3.1 关于个人的"></a>1.3.1 关于个人的</h3><ul><li>基本思想：人会通过权衡取舍来对激励做出反应</li><li>基本概念： <ul><li>收益</li><li>(机会)成本</li><li>激励</li></ul></li><li>分析方法<ul><li>边际分析</li></ul></li></ul><ol><li>People face tradeoffs. </li></ol><p>鱼和熊掌不可兼得</p><ul><li>国防 vs 消费</li><li>食品 vs 衣服</li><li>工作 vs 休息</li><li>效率 vs 公平</li></ul><ol start="2"><li>The cost of something is what you give up to get it </li></ol><ul><li>机会成本<ul><li>为了得到某种东西所必须放弃的东西</li></ul></li></ul><ol start="3"><li>Rational people think at the margin </li></ol><ul><li>理性人<ul><li>理性人 会使用所有可获得的信息来进行判断 </li><li>对某个决策的收益和成本进行比较</li></ul></li><li>边际<ul><li>微分的理念</li><li>对当前行动进行的微小的调整</li><li>边际成本–增量成本，指的是每增产以单位的产品所造成的总成本的增量</li><li>边际成本和单位平均成本不同，单位平均成本考虑了全部的产品，而边际成本忽略了最后一个产品之前的。例如每辆汽车的平均成本包括生产第一辆车的很大的固定成本，而边际成本根本不考虑固定成本<ul><li>因为固定成本几乎沉没了，理论上边际成本是可以让企业无损失的继续运转下去的 </li></ul></li><li>一个决策的额外或者追加的成本</li><li>E.G<ul><li>上两节课，很累，是否要上第三节课</li><li>第三节课的收益  边际收益</li><li>成本 休息一下 这个带来的收益就是你第三节课翘课的边际成本了</li></ul></li></ul></li></ul><ol start="4"><li>People respond to incentives 人们对激励做出反应</li></ol><ul><li><p>人们会对激励产生反应</p></li><li><p>对于价格的反应</p></li><li><p>对于竞争的反应</p></li><li><p>对产权 契约制度做出的反应</p></li><li><p><strong>最大值 边际收益 == 边际成本</strong></p></li></ul><h3 id="1-3-2-关于人和人之间的"><a href="#1-3-2-关于人和人之间的" class="headerlink" title="1.3.2 关于人和人之间的"></a>1.3.2 关于人和人之间的</h3><ol start="5"><li>Trade can make everyone better off </li></ol><ul><li>竞争 促进了交易的盈利</li><li>贸易造成的分工</li></ul><ol start="6"><li>Markets are usually a good way to organize economic activity </li></ol><ul><li>市场经济<ul><li>资源配置的办法</li><li>通过卖家买家单独分别的决策来做出最好的选择</li><li>公司  以及 家庭会分别决定怎么生产，生产多少</li></ul></li></ul><p>As if guided by an invisible hand. </p><p>通过价格来决定自己的买卖行为</p><ul><li>市场是否真的有效？<ul><li>法治体系不能由商人 利益集团来左右  亚当斯密</li><li>马克思 自由放任的市场会爆发周期性经济危机  因为人非理性</li><li>凯恩斯 非理性  动物精神  市场波动与宏观波动</li></ul></li></ul><ol start="7"><li>Governments can sometimes improve market outcomes </li></ol><ul><li>因为市场本身弊病，即非理性人的非理性决策</li><li>市场有可能在一些时候无法自身去有效的配置资源，那就需要政府的帮助了</li><li>譬如效率和公平的问题</li><li>市场失灵，无法调控的现象<ul><li>收入与财富分配不公</li><li>外部负效应问题<ul><li>污染</li></ul></li><li>竞争失败和市场垄断的形成</li><li>失业问题</li><li>区域经济的不协调问题</li><li>公共产品供给不足</li><li>公共资源的过度使用</li></ul></li></ul><h3 id="1-3-3-根据宏观经济现象提出的原理"><a href="#1-3-3-根据宏观经济现象提出的原理" class="headerlink" title="1.3.3 根据宏观经济现象提出的原理"></a>1.3.3 根据宏观经济现象提出的原理</h3><ol start="8"><li>一国的生活水平取决于它生产物品与劳务的能力</li><li>当政府发行了过多货币的时候，物价上升</li><li>社会面临通货膨胀与失业之间的短期权衡取舍</li></ol><h1 id="2-像经济学家一样思考"><a href="#2-像经济学家一样思考" class="headerlink" title="2.  像经济学家一样思考"></a>2.  像经济学家一样思考</h1><h2 id="2-1-经济学的社会科学属性"><a href="#2-1-经济学的社会科学属性" class="headerlink" title="2.1 经济学的社会科学属性"></a>2.1 经济学的社会科学属性</h2><ul><li>经济学家<ul><li>一方面，另一方面，lol  </li><li>考虑问题常常两个方面<ul><li>作为科学家<ul><li>经济分析</li></ul></li><li>作为政策顾问<ul><li>时政分析</li></ul></li></ul></li></ul></li></ul><ul><li><p>什么是科学？</p><ul><li><p>通常当我们定义一个概念的时候，需要一个外延更宽泛的概念</p></li><li><p>用科学定义经济学</p></li><li><p>用认识定义科学</p><ul><li>认识： 人们通过实践和思维，对单个事物的属性和事物之间联系的理解和判断</li></ul></li><li><p>科学的本质</p><ul><li>用实证的方法，实证性</li><li>解释对象是怎么样的问题，以及应该怎么样的规范性问题</li></ul></li><li><p>科学的性质</p><ul><li>可证伪性</li><li>假设与简化</li><li>内部一致性<ul><li>统一的假设系统，能够解释多种现象</li></ul></li><li>经验一致性<ul><li>观察事实等经验证据与理论相对照</li><li>通过可控制的试验来进行检验<ul><li>经济学</li><li>符合科学的可证伪原则</li><li>采用假设手段构造理论，并使用简化的模型表达理论</li><li>坚持内部逻辑的一致性</li><li>不断将卢纶假设和经验事实相对照，来检验理论的真伪 </li><li>主题</li><li>人们的选择如何引导他们的生活，以及他们是如何相互影响的</li></ul></li></ul></li></ul></li></ul></li></ul><h2 id="2-2-经济学的研究步骤"><a href="#2-2-经济学的研究步骤" class="headerlink" title="2.2 经济学的研究步骤"></a>2.2 经济学的研究步骤</h2><ol><li>确定研究问题</li><li>形成假设</li><li>建立模型</li><li>经验检验，也测货解释现实</li><li>通过检验结果决定放弃，修改模型</li></ol><ul><li>研究方法<ul><li>描述性的方法</li><li>分析性的办法 – 抽象推理</li></ul></li></ul><p>下面描述一些经常使用的经济模型：</p><h3 id="2-2-1-循环流量图"><a href="#2-2-1-循环流量图" class="headerlink" title="2.2.1 循环流量图"></a>2.2.1 循环流量图</h3><ul><li><p>说明货币如何通过市场在家庭和企业之间流动</p></li><li><p>主体</p><ul><li>家庭<ul><li>拥有并出售或出租生产要素给企业来获得收入</li><li>购买并消费物品与劳务</li></ul></li><li>企业<ul><li>购买或雇佣生产要素并用以生产物品与劳务</li><li>出售物品与劳务</li></ul></li></ul></li><li><p>两个市场</p><ul><li>物品与劳务市场</li><li>生产要素市场<ul><li>生产要素指经济体用来生产物品与劳务的资源<ul><li>劳动</li><li>土地</li><li>资本<ul><li>建筑物</li><li>用来生产的机器<h3 id="2-2-2-生产可能性边界"><a href="#2-2-2-生产可能性边界" class="headerlink" title="2.2.2 生产可能性边界"></a>2.2.2 生产可能性边界</h3></li></ul></li></ul></li></ul></li></ul></li><li><p>表明的是在生产要素和生产技术既定的情况下，一个经济所能生产的产品的各种数量的组合</p><ul><li>一条凹下去的曲线</li><li>在内部，失业，窝工</li><li>外部，无法实现</li><li>生产力提升，边界，y，x轴点的提升</li></ul></li><li><p>为什么不是直线呢？ </p><ul><li>边际转化率<ul><li>一个产品的增加导致另外一个产品的减少</li><li>转化率会有很大的变化<ul><li>比如边际状态，一个产品制造的转移，会使得做这个产品最熟练的工人转移，生产力大大减小，而对于另外一个产品的生产力的提升并不会有同等程度的增加</li></ul></li></ul></li></ul></li></ul><h2 id="2-3-作为政策顾问的经济学家"><a href="#2-3-作为政策顾问的经济学家" class="headerlink" title="2.3 作为政策顾问的经济学家"></a>2.3 作为政策顾问的经济学家</h2><ul><li>作为政策顾问，试图做出关于世界应该是什么样子的规范表述<ul><li>不是已经发生的，或者是能够规范到</li><li>是不能证伪的</li></ul></li></ul><h1 id="3-相互依存性与贸易的好处"><a href="#3-相互依存性与贸易的好处" class="headerlink" title="3. 相互依存性与贸易的好处"></a>3. 相互依存性与贸易的好处</h1><h2 id="3-1-相互依存性与贸易好处"><a href="#3-1-相互依存性与贸易好处" class="headerlink" title="3.1 相互依存性与贸易好处"></a>3.1 相互依存性与贸易好处</h2><ul><li><p>我们正在享用世界上的人给我们提供的服务</p><ul><li>为什么我们要相互依赖？ <ul><li>贸易使得每个人的状况会更好。</li><li>为什么国家之间会相互依存？</li><li>为什么还会存在贸易保护呢？ </li></ul></li></ul></li><li><p>贸易的必要性</p><ul><li><p>贸易有可能使得生产可能性曲线更凹 </p><ul><li>对双方都会有利</li></ul></li><li><p>绝对优势</p><ul><li>用比另一个生产者更少的投入来生产某种物品的能力</li></ul></li><li><p>比较优势原理</p><ul><li>用比另一个生产者更少的机会成本来生产某种物品的能力</li></ul></li><li><p>贸易获得的利益来源于比较优势。当每个国家专门生产它具有比较优势的物品的时候，所有国家的总产量会更高，世界的经济蛋糕也会更大。</p></li></ul></li></ul><h2 id="3-2-实际应用"><a href="#3-2-实际应用" class="headerlink" title="3.2 实际应用"></a>3.2 实际应用</h2><ul><li><p>小国更容易在贸易当中获利 </p><ul><li>亚洲四小龙  – 出口导向<ul><li>经济腾飞</li><li>劳动密集型</li><li>贸易获利，经济同质性强</li></ul></li></ul></li><li><p>中美贸易</p><ul><li>产品摩擦变大</li><li>中国对美国进出口依赖度降低，然而美国对中国的是呈上升趋势的</li></ul></li><li><p>我国强调产业升级，开始出现重叠了</p></li></ul><h1 id="4-供给与需求的市场力量"><a href="#4-供给与需求的市场力量" class="headerlink" title="4. 供给与需求的市场力量"></a>4. 供给与需求的市场力量</h1><ul><li><p>供给与供给量</p></li><li><p>需求与需求量</p></li><li><p>供需曲线的研究，对实际场景的分析</p><h2 id="4-1-物品需求"><a href="#4-1-物品需求" class="headerlink" title="4.1 物品需求"></a>4.1 物品需求</h2></li><li><p>市场</p><ul><li>买方卖方在一起</li></ul></li><li><p>市场势力</p><ul><li>卖方买方不适当的影响商品价格的能力</li></ul></li><li><p>完全竞争市场</p><ul><li>可供销售物品完全相同</li><li>买方卖方人数众多，以至于没有任何一个买方或卖方可以影响市场价格，每个人都是价格接受者(price taker)</li><li>比如农贸市场，地摊</li></ul></li><li><p>垄断</p><ul><li>电网</li><li>铁路</li><li>烟草</li></ul></li><li><p>寡头市场</p><ul><li>汽车</li><li>钢铁</li><li>造船</li><li>石油化工</li><li>有色冶金</li><li>飞机制造</li><li>航空运输</li></ul></li><li><p>垄断竞争</p><ul><li>洗发水</li><li>服装</li><li>药品</li></ul></li><li><p>需求</p><ul><li>物品需求量</li><li>买者愿意并且能够购买的一种物品的数量</li></ul></li><li><p>需求定理</p><ul><li>认为在其他条件不变的时候，一种物品的价格上升，对该物品的需求量会减少</li></ul></li><li><p>需求曲线</p><ul><li><p>表示在其他条件不变的情况下，价格和需求量之间的关系的图形</p></li><li><p>纵轴为价格，横轴为需求量，斜率为负，因为二者的增长态势是相反的</p></li><li><p>价格为自变量，需求为因变量</p></li><li><p>常见的其他条件 – 影响需求曲线变动的因素</p><ul><li><p>买者数量</p><ul><li>买者数量的增加会增加每一种价格水平下的需求量，从而使需求曲线向右移动</li></ul></li><li><p>收入</p><ul><li>正常商品<ul><li>收入上升，需求上升</li></ul></li><li>低档商品<ul><li>收入上升，需求下降</li></ul></li></ul></li><li><p>相关物品的价格</p><ul><li>替代品<ul><li>披萨和汉堡</li><li>可口可乐和百事可乐</li></ul></li><li>互补品<ul><li>电脑和软件</li><li>汽车和石油</li></ul></li></ul></li><li><p>嗜好</p></li><li><p>预期</p><ul><li>对未来的价格的预期</li><li>预期未来收入增加，那么对一些高档品的需求现在就有可能增加</li></ul></li></ul></li></ul></li><li><p>市场需求量</p><ul><li>所有买者在每一个价格水平下的需求量的总和</li></ul></li><li><p>需求 vs 需求量</p><ul><li>需求的变动指除了商品价格以外的其他因素引起的变动，图上表现为需求曲线的平行移动</li><li>供给量的变动指由价格变动引起的变动<h2 id="4-2-物品供给"><a href="#4-2-物品供给" class="headerlink" title="4.2 物品供给"></a>4.2 物品供给</h2></li></ul></li><li><p>从卖方角度来看</p></li><li><p>供给量</p><ul><li>卖者愿意并且能够出售的一种物品的数量</li></ul></li><li><p>供给定理</p><ul><li>认为在其他条件不变的时候，一种物品价格的上升，会使得该物品的供给量增加</li></ul></li><li><p>市场供给</p><ul><li>在每种价格水平下所有卖者的供给量之和</li></ul></li><li><p>市场供给曲线</p><ul><li>价格为纵轴，横轴为供给量，价格为自变量</li><li>影响曲线移动的因素<ul><li>投入品的价格<ul><li>价格下降，供给量提高</li></ul></li><li>技术水平</li><li>卖者的数量</li><li>预期</li></ul></li></ul></li></ul><h2 id="4-3-需求与供给的结合"><a href="#4-3-需求与供给的结合" class="headerlink" title="4.3 需求与供给的结合"></a>4.3 需求与供给的结合</h2><ul><li><p>供给需求曲线 – 大剪刀图 lol </p><ul><li>交点<ul><li>均衡<ul><li>供给量和需求量的相等</li></ul></li></ul></li><li>过剩  <ul><li>供给大于需求</li><li>厂商需要降价</li><li>需求量会相对上升</li></ul></li><li>短缺<ul><li>厂商愿意供给量少</li><li>想买，买不到，买者提高价格买</li><li>厂商来更多生产</li></ul></li></ul></li><li><p>分析市场价格的变动</p><ul><li><ol><li>使供给曲线移动还是需求曲线移动还是都移动</li></ol></li><li><ol start="2"><li>确定曲线的移动方向</li></ol></li><li><ol start="3"><li>用供求图来说明这种移动如何改变均衡价格和均衡数量的</li></ol></li></ul></li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li>学堂在线 经济学原理(微观部分) <a href="https://next.xuetangx.com/learn/THU02011001169" target="_blank" rel="noopener">https://next.xuetangx.com/learn/THU02011001169</a> </li><li>曼昆 经济学原理 第6版</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-导论&quot;&gt;&lt;a href=&quot;#1-导论&quot; class=&quot;headerlink&quot; title=&quot;1. 导论&quot;&gt;&lt;/a&gt;1. 导论&lt;/h1&gt;&lt;h2 id=&quot;1-1-经济学发展史&quot;&gt;&lt;a href=&quot;#1-1-经济学发展史&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="Notes" scheme="https://www.llchen60.com/categories/Notes/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式-结构型-享元模式</title>
    <link href="https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-06-28T03:14:26.000Z</published>
    <updated>2020-06-28T03:14:52.407Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-原理与实现"><a href="#1-原理与实现" class="headerlink" title="1. 原理与实现"></a>1. 原理与实现</h1><ul><li><p>享元模式 Flyweight Design Pattern </p><ul><li><p>用来复用对象，节省内存，</p></li><li><p>前提条件，享元对象是不可变对象</p><ul><li>不可以暴露任何set（）等修改内部状态的方法</li></ul></li><li><p>当一个系统中存在大量重复对象的时候，如果重复对象都是不可变对象，我们就可以利用享元模式将对象设计成享元，在内存中只保留一份实例，供多处代码来引用。</p></li></ul></li></ul><ul><li>是通过工厂模式，在工厂类当中，通过一个Map来缓存已经创建过的享元对象，来达到复用的目的</li></ul><ul><li>文本文件对于字体格式进行享元操作</li></ul><pre><code>public class CharacterStyle {  private Font font;  private int size;  private int colorRGB;  public CharacterStyle(Font font, int size, int colorRGB) {    this.font = font;    this.size = size;    this.colorRGB = colorRGB;  }  @Override  public boolean equals(Object o) {    CharacterStyle otherStyle = (CharacterStyle) o;    return font.equals(otherStyle.font)            &amp;&amp; size == otherStyle.size            &amp;&amp; colorRGB == otherStyle.colorRGB;  }}public class CharacterStyleFactory {  private static final List&lt;CharacterStyle&gt; styles = new ArrayList&lt;&gt;();  public static CharacterStyle getStyle(Font font, int size, int colorRGB) {    CharacterStyle newStyle = new CharacterStyle(font, size, colorRGB);    for (CharacterStyle style : styles) {      if (style.equals(newStyle)) {        return style;      }    }    styles.add(newStyle);    return newStyle;  }}public class Character {  private char c;  private CharacterStyle style;  public Character(char c, CharacterStyle style) {    this.c = c;    this.style = style;  }}public class Editor {  private List&lt;Character&gt; chars = new ArrayList&lt;&gt;();  public void appendCharacter(char c, Font font, int size, int colorRGB) {    Character character = new Character(c, CharacterStyleFactory.getStyle(font, size, colorRGB));    chars.add(character);  }}</code></pre><h1 id="2-享元模式在Java-Integer以及String当中的应用"><a href="#2-享元模式在Java-Integer以及String当中的应用" class="headerlink" title="2. 享元模式在Java Integer以及String当中的应用"></a>2. 享元模式在Java Integer以及String当中的应用</h1><pre><code>/** * Cache to support the object identity semantics of autoboxing for values between * -128 and 127 (inclusive) as required by JLS. * * The cache is initialized on first usage.  The size of the cache * may be controlled by the {@code -XX:AutoBoxCacheMax=&lt;size&gt;} option. * During VM initialization, java.lang.Integer.IntegerCache.high property * may be set and saved in the private system properties in the * sun.misc.VM class. */private static class IntegerCache {    static final int low = -128;    static final int high;    static final Integer cache[];    static {        // high value may be configured by property        int h = 127;        String integerCacheHighPropValue =            sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;);        if (integerCacheHighPropValue != null) {            try {                int i = parseInt(integerCacheHighPropValue);                i = Math.max(i, 127);                // Maximum array size is Integer.MAX_VALUE                h = Math.min(i, Integer.MAX_VALUE - (-low) -1);            } catch( NumberFormatException nfe) {                // If the property cannot be parsed into an int, ignore it.            }        }        high = h;        cache = new Integer[(high - low) + 1];        int j = low;        for(int k = 0; k &lt; cache.length; k++)            cache[k] = new Integer(j++);        // range [-128, 127] must be interned (JLS7 5.1.7)        assert IntegerCache.high &gt;= 127;    }    private IntegerCache() {}}</code></pre><p>IntegerCache 缓存在-128到127之间的内容，即指向的是同样的内存地址的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-原理与实现&quot;&gt;&lt;a href=&quot;#1-原理与实现&quot; class=&quot;headerlink&quot; title=&quot;1. 原理与实现&quot;&gt;&lt;/a&gt;1. 原理与实现&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;享元模式 Flyweight Design Pattern &lt;/p&gt;
&lt;ul&gt;
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="享元模式" scheme="https://www.llchen60.com/tags/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-结构型-组合模式</title>
    <link href="https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-06-25T03:32:25.000Z</published>
    <updated>2020-06-25T03:32:55.978Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-原理和实现"><a href="#1-原理和实现" class="headerlink" title="1. 原理和实现"></a>1. 原理和实现</h1><p>组合模式，是用来处理树形结构的数据的。</p><ul><li>Compose objects into tree structure to represent part-whole hierarchies. Composite lets client treat individual objects and compositions of objects uniformly. </li><li>将一组对象组织成树形结构，来表示一种 部分-整体的层次结构，组合让客户端可以统一单个对象和组合对象的处理逻辑。</li></ul><h1 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="2. 应用场景"></a>2. 应用场景</h1><ul><li>现在设计一个类来表示文件系统中的目录，来方便地实现下面的功能：<ul><li>动态添加、删除某个目录下的子目录或文件</li><li>统计指定目录下的文件个数</li><li>统计指定目录下的文件总大小</li></ul></li></ul><pre><code>public class FileSystemNode {  private String path;  private boolean isFile;  private List&lt;FileSystemNode&gt; subNodes = new ArrayList&lt;&gt;();  public FileSystemNode(String path, boolean isFile) {    this.path = path;    this.isFile = isFile;  }  public int countNumOfFiles() {    if (isFile) { return 1; }     int numOfFiles = 0;     for (FileSystemNode fileOrDir : subNodes) {         numOfFiles += fileOrDir.countNumOfFiles();     }     return numOfFiles;  }  public long countSizeOfFiles() {    if (isFile) {              File file = new File(path);              if (!file.exists()) return 0;              return file.length();        }        long sizeofFiles = 0;        for (FileSystemNode fileOrDir : subNodes) {              sizeofFiles += fileOrDir.countSizeOfFiles();        }        return sizeofFiles;  }  public String getPath() {    return path;  }  public void addSubNode(FileSystemNode fileOrDir) {    subNodes.add(fileOrDir);  }  public void removeSubNode(FileSystemNode fileOrDir) {    int size = subNodes.size();    int i = 0;    for (; i &lt; size; ++i) {      if (subNodes.get(i).getPath().equalsIgnoreCase(fileOrDir.getPath())) {        break;      }    }    if (i &lt; size) {      subNodes.remove(i);    }  }}</code></pre><ul><li>而后对文件和目录进行区分设计</li></ul><pre><code>public abstract class FileSystemNode {  protected String path;  public FileSystemNode(String path) {    this.path = path;  }  public abstract int countNumOfFiles();  public abstract long countSizeOfFiles();  public String getPath() {    return path;  }}public class File extends FileSystemNode {  public File(String path) {    super(path);  }  @Override  public int countNumOfFiles() {    return 1;  }  @Override  public long countSizeOfFiles() {    java.io.File file = new java.io.File(path);    if (!file.exists()) return 0;    return file.length();  }}public class Directory extends FileSystemNode {  private List&lt;FileSystemNode&gt; subNodes = new ArrayList&lt;&gt;();  public Directory(String path) {    super(path);  }  @Override  public int countNumOfFiles() {    int numOfFiles = 0;    for (FileSystemNode fileOrDir : subNodes) {      numOfFiles += fileOrDir.countNumOfFiles();    }    return numOfFiles;  }  @Override  public long countSizeOfFiles() {    long sizeofFiles = 0;    for (FileSystemNode fileOrDir : subNodes) {      sizeofFiles += fileOrDir.countSizeOfFiles();    }    return sizeofFiles;  }  public void addSubNode(FileSystemNode fileOrDir) {    subNodes.add(fileOrDir);  }  public void removeSubNode(FileSystemNode fileOrDir) {    int size = subNodes.size();    int i = 0;    for (; i &lt; size; ++i) {      if (subNodes.get(i).getPath().equalsIgnoreCase(fileOrDir.getPath())) {        break;      }    }    if (i &lt; size) {      subNodes.remove(i);    }  }}public class Demo {  public static void main(String[] args) {    /**     * /     * /wz/     * /wz/a.txt     * /wz/b.txt     * /wz/movies/     * /wz/movies/c.avi     * /xzg/     * /xzg/docs/     * /xzg/docs/d.txt     */    Directory fileSystemTree = new Directory(&quot;/&quot;);    Directory node_wz = new Directory(&quot;/wz/&quot;);    Directory node_xzg = new Directory(&quot;/xzg/&quot;);    fileSystemTree.addSubNode(node_wz);    fileSystemTree.addSubNode(node_xzg);    File node_wz_a = new File(&quot;/wz/a.txt&quot;);    File node_wz_b = new File(&quot;/wz/b.txt&quot;);    Directory node_wz_movies = new Directory(&quot;/wz/movies/&quot;);    node_wz.addSubNode(node_wz_a);    node_wz.addSubNode(node_wz_b);    node_wz.addSubNode(node_wz_movies);    File node_wz_movies_c = new File(&quot;/wz/movies/c.avi&quot;);    node_wz_movies.addSubNode(node_wz_movies_c);    Directory node_xzg_docs = new Directory(&quot;/xzg/docs/&quot;);    node_xzg.addSubNode(node_xzg_docs);    File node_xzg_docs_d = new File(&quot;/xzg/docs/d.txt&quot;);    node_xzg_docs.addSubNode(node_xzg_docs_d);    System.out.println(&quot;/ files num:&quot; + fileSystemTree.countNumOfFiles());    System.out.println(&quot;/wz/ files num:&quot; + node_wz.countNumOfFiles());  }}</code></pre><blockquote><p>将一组对象（文件和目录）组织成树形结构，以表示一种‘部分 - 整体’的层次结构（目录与子目录的嵌套结构）。组合模式让客户端可以统一单个对象（文件）和组合对象（目录）的处理逻辑（递归遍历）</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-原理和实现&quot;&gt;&lt;a href=&quot;#1-原理和实现&quot; class=&quot;headerlink&quot; title=&quot;1. 原理和实现&quot;&gt;&lt;/a&gt;1. 原理和实现&lt;/h1&gt;&lt;p&gt;组合模式，是用来处理树形结构的数据的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Compose objects
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="组合模式" scheme="https://www.llchen60.com/tags/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-结构型-门面模式</title>
    <link href="https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-06-24T05:39:48.000Z</published>
    <updated>2020-06-24T05:40:23.631Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-原理与实现"><a href="#1-原理与实现" class="headerlink" title="1. 原理与实现"></a>1. 原理与实现</h1><p>门面模式应用场景主要在于接口设计方面，是为了处理和解决接口粒度的相关问题。</p><p>为了保证接口的可复用性(通用性)，我们需要将接口设计的粒度细一些，职责单一。但是，如果接口的粒度过小，在接口使用者开发一个业务功能的时候，就需要开发不同的接口来满足，这样会导致系统的接口无限膨胀。</p><ul><li>门面模式  Facade Design Pattern <ul><li>provide a unified interface to a set of interfaces in a subsystem</li><li>facade pattern defines a higher level interface that makes the subsystem easier to use </li></ul></li></ul><ul><li>场景举例<ul><li>比如系统A提供a,b,c,d四个接口，系统B完成某个业务功能，需要调用A系统的a,b,d接口。利用门面模式，提供一个包裹a,b,d接口调用的门面接口x，给系统B直接使用</li><li>如果上述AB一个是后端，一个是APP端的话，那么他们之间网络通信耗时会比较多</li></ul></li></ul><h1 id="2-门面模式的应用场景"><a href="#2-门面模式的应用场景" class="headerlink" title="2. 门面模式的应用场景"></a>2. 门面模式的应用场景</h1><h2 id="2-1-解决易用性问题"><a href="#2-1-解决易用性问题" class="headerlink" title="2.1 解决易用性问题"></a>2.1 解决易用性问题</h2><ul><li>封装系统的底层实现，隐藏系统的复杂性</li><li>提供一组更加简单易用，更高层的接口</li><li>例子<ul><li>Linux系统调用函数<ul><li>封装了底层Linux内核的调用</li></ul></li><li>Shell指令<ul><li>封装系统调用</li><li>提供更加友好的指令</li></ul></li></ul></li></ul><h2 id="2-2-解决性能问题"><a href="#2-2-解决性能问题" class="headerlink" title="2.2 解决性能问题"></a>2.2 解决性能问题</h2><ul><li>当使用一个门面接口替换多个接口的调用的时候，减少了网络通信成本</li><li>如果门面接口比较多<ul><li>可以抽象出一层，专门放置门面接口</li><li>如果跨多个子系统，可以将门面接口放到一个新的子系统当中</li></ul></li></ul><h2 id="2-3-解决分布式事务问题"><a href="#2-3-解决分布式事务问题" class="headerlink" title="2.3 解决分布式事务问题"></a>2.3 解决分布式事务问题</h2><p>在一个金融系统中，有两个业务领域模型，用户和钱包。这两个业务领域模型都对外暴露了一系列接口，比如用户的增删改查接口、钱包的增删改查接口。假设有这样一个业务场景：在用户注册的时候，我们不仅会创建用户（在数据库 User 表中），还会给用户创建一个钱包（在数据库的 Wallet 表中）。</p><p>对于这样一个简单的业务需求，我们可以通过依次调用用户的创建接口和钱包的创建接口来完成。但是，用户注册需要支持事务，也就是说，创建用户和钱包的两个操作，要么都成功，要么都失败，不能一个成功、一个失败。</p><p>要支持两个接口调用在一个事务中执行，是比较难实现的，这涉及分布式事务问题。虽然我们可以通过引入分布式事务框架或者事后补偿的机制来解决，但代码实现都比较复杂。而最简单的解决方案是，利用数据库事务或者 Spring 框架提供的事务（如果是 Java 语言的话），在一个事务中，执行创建用户和创建钱包这两个 SQL 操作。这就要求两个 SQL 操作要在一个接口中完成，所以，我们可以借鉴门面模式的思想，再设计一个包裹这两个操作的新接口，让新接口在一个事务中执行两个 SQL 操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-原理与实现&quot;&gt;&lt;a href=&quot;#1-原理与实现&quot; class=&quot;headerlink&quot; title=&quot;1. 原理与实现&quot;&gt;&lt;/a&gt;1. 原理与实现&lt;/h1&gt;&lt;p&gt;门面模式应用场景主要在于接口设计方面，是为了处理和解决接口粒度的相关问题。&lt;/p&gt;
&lt;p&gt;为了保
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="门面模式" scheme="https://www.llchen60.com/tags/%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-结构型-适配器模式</title>
    <link href="https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-06-24T03:55:54.000Z</published>
    <updated>2020-06-23T03:56:23.132Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-适配器模式原理和实现"><a href="#1-适配器模式原理和实现" class="headerlink" title="1. 适配器模式原理和实现"></a>1. 适配器模式原理和实现</h1><ul><li><p>Adapter Design Pattern </p><ul><li>做适配的，将不兼容的接口转换为可兼容的接口</li><li>将原本由于接口不兼容而不能一起工作的类一起工作</li></ul></li><li><p>实现方式</p><ul><li>类适配器<ul><li>使用继承关系实现</li></ul></li><li>对象适配器<ul><li>使用组合关系实现</li></ul></li></ul></li></ul><pre><code>// 类适配器: 基于继承public interface ITarget {  void f1();  void f2();  void fc();}public class Adaptee {  public void fa() { //... }  public void fb() { //... }  public void fc() { //... }}public class Adaptor extends Adaptee implements ITarget {  public void f1() {    super.fa();  }  public void f2() {    //...重新实现f2()...  }  // 这里fc()不需要实现，直接继承自Adaptee，这是跟对象适配器最大的不同点}// 对象适配器：基于组合public interface ITarget {  void f1();  void f2();  void fc();}public class Adaptee {  public void fa() { //... }  public void fb() { //... }  public void fc() { //... }}public class Adaptor implements ITarget {  private Adaptee adaptee;  public Adaptor(Adaptee adaptee) {    this.adaptee = adaptee;  }  public void f1() {    adaptee.fa(); //委托给Adaptee  }  public void f2() {    //...重新实现f2()...  }  public void fc() {    adaptee.fc();  }}</code></pre><ul><li><p>类适配器和对象适配器的选择取决于</p><ul><li>Adaptee接口的个数</li><li>Adaptee 和Itarget的契合程度</li></ul></li><li><p>如果 Adaptee 接口并不多，那两种实现方式都可以。</p></li><li><p>如果 Adaptee 接口很多，而且 Adaptee 和 ITarget 接口定义大部分都相同，那我们推荐使用类适配器，因为 Adaptor 复用父类 Adaptee 的接口，比起对象适配器的实现方式，Adaptor 的代码量要少一些。</p></li><li><p>如果 Adaptee 接口很多，而且 Adaptee 和 ITarget 接口定义大部分都不相同，那我们推荐使用对象适配器，因为组合结构相对于继承更加灵活。</p></li></ul><h1 id="2-应用场景总结"><a href="#2-应用场景总结" class="headerlink" title="2. 应用场景总结"></a>2. 应用场景总结</h1><ul><li>适配器模式 – 一种补偿模式<ul><li>主要用来弥补一些设计上的缺陷</li><li>主要用来解决接口不兼容的问题</li></ul></li></ul><h2 id="2-1-封装有缺陷的接口设计"><a href="#2-1-封装有缺陷的接口设计" class="headerlink" title="2.1 封装有缺陷的接口设计"></a>2.1 封装有缺陷的接口设计</h2><p>譬如我们依赖的外部系统在接口设计上有缺陷（包含大量的静态方法），引入后会影响到我们自身代码的可测试性。为了隔离设计上的缺陷，我们希望对外部系统提供的接口进行二次封装，抽象出更好的接口设计。</p><pre><code>public class CD { //这个类来自外部sdk，我们无权修改它的代码  //...  public static void staticFunction1() { //... }  public void uglyNamingFunction2() { //... }  public void tooManyParamsFunction3(int paramA, int paramB, ...) { //... }   public void lowPerformanceFunction4() { //... }}// 使用适配器模式进行重构public class ITarget {  void function1();  void function2();  void fucntion3(ParamsWrapperDefinition paramsWrapper);  void function4();  //...}// 注意：适配器类的命名不一定非得末尾带Adaptorpublic class CDAdaptor extends CD implements ITarget {  //...  public void function1() {     super.staticFunction1();  }  public void function2() {    super.uglyNamingFucntion2();  }  public void function3(ParamsWrapperDefinition paramsWrapper) {     super.tooManyParamsFunction3(paramsWrapper.getParamA(), ...);  }  public void function4() {    //...reimplement it...  }}</code></pre><h2 id="2-2-统一多个类的接口设计"><a href="#2-2-统一多个类的接口设计" class="headerlink" title="2.2 统一多个类的接口设计"></a>2.2 统一多个类的接口设计</h2><p>某个功能的实现依赖多个外部系统，通过适配器模式，将其接口适配为统一的接口定义，然后使用多态的特性来复用代码逻辑。</p><p>下述代码使用适配器模式来处理有不同的接口设计的几个来自第三方做词汇过滤的API</p><pre><code>public class ASensitiveWordsFilter { // A敏感词过滤系统提供的接口  //text是原始文本，函数输出用***替换敏感词之后的文本  public String filterSexyWords(String text) {    // ...  }  public String filterPoliticalWords(String text) {    // ...  } }public class BSensitiveWordsFilter  { // B敏感词过滤系统提供的接口  public String filter(String text) {    //...  }}public class CSensitiveWordsFilter { // C敏感词过滤系统提供的接口  public String filter(String text, String mask) {    //...  }}// 未使用适配器模式之前的代码：代码的可测试性、扩展性不好public class RiskManagement {  private ASensitiveWordsFilter aFilter = new ASensitiveWordsFilter();  private BSensitiveWordsFilter bFilter = new BSensitiveWordsFilter();  private CSensitiveWordsFilter cFilter = new CSensitiveWordsFilter();  public String filterSensitiveWords(String text) {    String maskedText = aFilter.filterSexyWords(text);    maskedText = aFilter.filterPoliticalWords(maskedText);    maskedText = bFilter.filter(maskedText);    maskedText = cFilter.filter(maskedText, &quot;***&quot;);    return maskedText;  }}// 使用适配器模式进行改造public interface ISensitiveWordsFilter { // 统一接口定义  String filter(String text);}public class ASensitiveWordsFilterAdaptor implements ISensitiveWordsFilter {  private ASensitiveWordsFilter aFilter;  public String filter(String text) {    String maskedText = aFilter.filterSexyWords(text);    maskedText = aFilter.filterPoliticalWords(maskedText);    return maskedText;  }}//...省略BSensitiveWordsFilterAdaptor、CSensitiveWordsFilterAdaptor...// 扩展性更好，更加符合开闭原则，如果添加一个新的敏感词过滤系统，// 这个类完全不需要改动；而且基于接口而非实现编程，代码的可测试性更好。public class RiskManagement {   private List&lt;ISensitiveWordsFilter&gt; filters = new ArrayList&lt;&gt;();  public void addSensitiveWordsFilter(ISensitiveWordsFilter filter) {    filters.add(filter);  }  public String filterSensitiveWords(String text) {    String maskedText = text;    for (ISensitiveWordsFilter filter : filters) {      maskedText = filter.filter(maskedText);    }    return maskedText;  }}</code></pre><h2 id="2-3-替换依赖的外部系统"><a href="#2-3-替换依赖的外部系统" class="headerlink" title="2.3 替换依赖的外部系统"></a>2.3 替换依赖的外部系统</h2><pre><code>// 外部系统Apublic interface IA {  //...  void fa();}public class A implements IA {  //...  public void fa() { //... }}// 在我们的项目中，外部系统A的使用示例public class Demo {  private IA a;  public Demo(IA a) {    this.a = a;  }  //...}Demo d = new Demo(new A());// 将外部系统A替换成外部系统Bpublic class BAdaptor implemnts IA {  private B b;  public BAdaptor(B b) {    this.b= b;  }  public void fa() {    //...    b.fb();  }}// 借助BAdaptor，Demo的代码中，调用IA接口的地方都无需改动，// 只需要将BAdaptor如下注入到Demo即可。Demo d = new Demo(new BAdaptor(new B()));</code></pre><h2 id="2-4-兼容老版本的接口"><a href="#2-4-兼容老版本的接口" class="headerlink" title="2.4 兼容老版本的接口"></a>2.4 兼容老版本的接口</h2><p>做版本升级的时候，对于一些要废弃的接口，不能直接将其删除，而是暂时保留，并且标注为deprecated，并将内部实现逻辑委托为新的接口实现。这样就可以是的项目有个过渡期。</p><p>Enumeration –&gt; Iterator的升级</p><pre><code>public class Collections {  public static Emueration emumeration(final Collection c) {    return new Enumeration() {      Iterator i = c.iterator();      public boolean hasMoreElments() {        return i.hashNext();      }      public Object nextElement() {        return i.next():      }    }  }}</code></pre><h1 id="3-代理-vs-桥接-vs-装饰器-vs-适配器"><a href="#3-代理-vs-桥接-vs-装饰器-vs-适配器" class="headerlink" title="3. 代理 vs 桥接 vs 装饰器 vs 适配器"></a>3. 代理 vs 桥接 vs 装饰器 vs 适配器</h1><ul><li><p>代理模式</p><ul><li>在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是访问控制，而非加强功能</li></ul></li><li><p>桥接模式</p><ul><li>将接口部分和实现部分分离，使得其能够相对独立的进行改变</li></ul></li><li><p>装饰器模式</p><ul><li>在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用</li></ul></li><li><p>适配器模式</p><ul><li>事后补救策略，适配器提供跟原始类不同的接口</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-适配器模式原理和实现&quot;&gt;&lt;a href=&quot;#1-适配器模式原理和实现&quot; class=&quot;headerlink&quot; title=&quot;1. 适配器模式原理和实现&quot;&gt;&lt;/a&gt;1. 适配器模式原理和实现&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Adapter Design Patt
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="适配器模式" scheme="https://www.llchen60.com/tags/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-结构型-装饰器模式</title>
    <link href="https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-06-23T03:09:04.000Z</published>
    <updated>2020-06-23T03:09:29.625Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a>1. Overview</h1><h2 id="1-1-Java-IO类的使用"><a href="#1-1-Java-IO类的使用" class="headerlink" title="1.1 Java IO类的使用"></a>1.1 Java IO类的使用</h2><table><thead><tr><th></th><th>字节流</th><th>字符流</th></tr></thead><tbody><tr><td>输入流</td><td>InputStream</td><td>Reader</td></tr><tr><td>输出流</td><td>OutputStream</td><td>Writer</td></tr></tbody></table><p>JavaIO库非常庞大，几十个类一同来负责IO数据的读取和写入。</p><pre><code>InputStream in = new FileInputStream(&quot;/user/wangzheng/test.txt&quot;);InputStream bin = new BufferedInputStream(in);byte[] data = new byte[128];while (bin.read(data) != -1) {  //...}</code></pre><p>上述代码先使用了FileInputStream来读取文件流，然后又使用了BufferedInputStream，来支持缓存。</p><p>问题来了，为什么不能设置一个继承了FileInputStream并且支持缓存的BufferedFileInputStream类呢？ </p><p>问题在于各种use case太多，如果为了各种功能的组合都设置一个类的话，那么类的继承结构会变得非常负责，代码会变得很难扩展和维护。</p><p>Java IO的设计思路，就是使用组合来替代继承</p><pre><code>public abstract class InputStream {  //...  public int read(byte b[]) throws IOException {    return read(b, 0, b.length);  }  public int read(byte b[], int off, int len) throws IOException {    //...  }  public long skip(long n) throws IOException {    //...  }  public int available() throws IOException {    return 0;  }  public void close() throws IOException {}  public synchronized void mark(int readlimit) {}  public synchronized void reset() throws IOException {    throw new IOException(&quot;mark/reset not supported&quot;);  }  public boolean markSupported() {    return false;  }}public class BufferedInputStream extends InputStream {  protected volatile InputStream in;  protected BufferedInputStream(InputStream in) {    this.in = in;  }  //...实现基于缓存的读数据接口...  }public class DataInputStream extends InputStream {  protected volatile InputStream in;  protected DataInputStream(InputStream in) {    this.in = in;  }  //...实现读取基本类型数据的接口}</code></pre><h2 id="1-2-装饰器模式"><a href="#1-2-装饰器模式" class="headerlink" title="1.2 装饰器模式"></a>1.2 装饰器模式</h2><ul><li>使用组合来替代继承关系</li><li>装饰器类和原始类继承同样的父类，这样我们就可以对原始类嵌套多个装饰器类</li><li>是对功能的增强，是和原始功能相关的</li><li>为了解决继承关系过于复杂的问题</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Overview&quot;&gt;&lt;a href=&quot;#1-Overview&quot; class=&quot;headerlink&quot; title=&quot;1. Overview&quot;&gt;&lt;/a&gt;1. Overview&lt;/h1&gt;&lt;h2 id=&quot;1-1-Java-IO类的使用&quot;&gt;&lt;a href=&quot;#1-1-
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="装饰器模式" scheme="https://www.llchen60.com/tags/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-结构型-桥接模式</title>
    <link href="https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-06-21T21:54:45.000Z</published>
    <updated>2020-06-21T21:55:09.965Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-原理解析"><a href="#1-原理解析" class="headerlink" title="1. 原理解析"></a>1. 原理解析</h1><ul><li>桥接模式 Bridge Design Pattern<ul><li>将抽象和实现解耦，使之可以独立变化</li><li>一个类存在两个或者多个独立变化的维度，通过组合的方式，让这几个维度都可以独立进行扩展<ul><li>通过组合关系来替代继承关系，避免继承层次的指数级爆炸</li></ul></li></ul></li></ul><h2 id="1-1-JDBC驱动的实现"><a href="#1-1-JDBC驱动的实现" class="headerlink" title="1.1 JDBC驱动的实现"></a>1.1 JDBC驱动的实现</h2><pre><code>    Class.forName(&quot;com.mysql.jdbc.Driver&quot;);//加载及注册JDBC驱动程序    String url = &quot;jdbc:mysql://localhost:3306/sample_db?user=root&amp;password=your_password&quot;;    Connection con = DriverManager.getConnection(url);    Statement stmt = con.createStatement()；    String query = &quot;select * from test&quot;;    ResultSet rs=stmt.executeQuery(query);    while(rs.next()) {      rs.getString(1);      rs.getInt(2);    }</code></pre><ul><li>上述代码中只要改变forName中的路径，就可以改变数据库了</li><li>或者我们可以通过将加载的Driver类写到配置文件当中，来实现数据库的切换，只需要修改配置文件就可以完成数据库的切换了</li></ul><pre><code>package com.mysql.jdbc;import java.sql.SQLException;public class Driver extends NonRegisteringDriver implements java.sql.Driver {  static {    try {      java.sql.DriverManager.registerDriver(new Driver());    } catch (SQLException E) {      throw new RuntimeException(&quot;Can&#39;t register driver!&quot;);    }  }  /**   * Construct a new driver and register it with DriverManager   * @throws SQLException if a database error occurs.   */  public Driver() throws SQLException {    // Required for Class.forName().newInstance()  }}</code></pre><ul><li>在执行<code>Class.forName</code>的时候，首先是使得JVM查找并加载指定的Driver类，</li><li>其次是执行该类的静态代码<ul><li>实例变量需要在类实例化以后才能存在</li><li>静态变量是该类素有对象公有的，不需要实例化就已经存在了</li><li>静态代码会在类被加载的时候自动执行</li></ul></li></ul><pre><code>public class DriverManager {  private final static CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers = new CopyOnWriteArrayList&lt;DriverInfo&gt;();  //...  static {    loadInitialDrivers();    println(&quot;JDBC DriverManager initialized&quot;);  }  //...  public static synchronized void registerDriver(java.sql.Driver driver) throws SQLException {    if (driver != null) {      registeredDrivers.addIfAbsent(new DriverInfo(driver));    } else {      throw new NullPointerException();    }  }  public static Connection getConnection(String url, String user, String password) throws SQLException {    java.util.Properties info = new java.util.Properties();    if (user != null) {      info.put(&quot;user&quot;, user);    }    if (password != null) {      info.put(&quot;password&quot;, password);    }    return (getConnection(url, info, Reflection.getCallerClass()));  }  //...}</code></pre><ul><li>JDBC本身相当于抽象，即和具体的数据库无关的被抽象出来的一套类库</li><li>具体的Driver相当于实现</li></ul><h2 id="1-2-实例"><a href="#1-2-实例" class="headerlink" title="1.2 实例"></a>1.2 实例</h2><p>设计一个根据不同的告警规则，触发不同的类型的告警。</p><ul><li><p>紧急程度</p><ul><li>SEVERE</li><li>URGENCY</li><li>NORMAL</li><li>TRIVIAL</li></ul></li><li><p>通知渠道</p><ul><li>邮件</li><li>短信</li><li>微信</li><li>自动语音通话</li></ul></li><li><p>下述代码实质上就是在实现一个解耦，希望避免复杂的if else逻辑，让代码更易懂，修改更方便。</p></li></ul><pre><code>public interface MsgSender {  void send(String message);}public class TelephoneMsgSender implements MsgSender {  private List&lt;String&gt; telephones;  public TelephoneMsgSender(List&lt;String&gt; telephones) {    this.telephones = telephones;  }  @Override  public void send(String message) {    //...  }}public class EmailMsgSender implements MsgSender {  // 与TelephoneMsgSender代码结构类似，所以省略...}public class WechatMsgSender implements MsgSender {  // 与TelephoneMsgSender代码结构类似，所以省略...}public abstract class Notification {  protected MsgSender msgSender;  public Notification(MsgSender msgSender) {    this.msgSender = msgSender;  }  public abstract void notify(String message);}public class SevereNotification extends Notification {  public SevereNotification(MsgSender msgSender) {    super(msgSender);  }  @Override  public void notify(String message) {    msgSender.send(message);  }}public class UrgencyNotification extends Notification {  // 与SevereNotification代码结构类似，所以省略...}public class NormalNotification extends Notification {  // 与SevereNotification代码结构类似，所以省略...}public class TrivialNotification extends Notification {  // 与SevereNotification代码结构类似，所以省略...}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-原理解析&quot;&gt;&lt;a href=&quot;#1-原理解析&quot; class=&quot;headerlink&quot; title=&quot;1. 原理解析&quot;&gt;&lt;/a&gt;1. 原理解析&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;桥接模式 Bridge Design Pattern&lt;ul&gt;
&lt;li&gt;将抽象和实现解耦，使之
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="桥接模式" scheme="https://www.llchen60.com/tags/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-结构型-代理模式</title>
    <link href="https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-06-19T19:27:01.000Z</published>
    <updated>2020-06-19T19:27:54.269Z</updated>
    
    <content type="html"><![CDATA[<p>结构型模式主要总结了一些类和对象组合在一起的经典结构，这些经典的结构可以解决特定应用场景的问题。结构型模式包括：</p><ul><li>代理模式</li><li>桥接模式</li><li>装饰器模式</li><li>适配器模式</li><li>门面模式</li><li>组合模式</li><li>享元模式</li></ul><h1 id="1-代理模式原理解析"><a href="#1-代理模式原理解析" class="headerlink" title="1. 代理模式原理解析"></a>1. 代理模式原理解析</h1><ul><li>代理模式 Proxy Design Pattern <ul><li>在不改变原始类（被代理类）代码的情况下，通过引入代理类来给原始类附加功能</li></ul></li></ul><ul><li><p>下述是实现MetricsCollector的初始想法</p><ul><li><p>框架代码和业务代码耦合度太高，后期维护或者框架的更换代价都会很大</p></li><li><p>业务类职责最好单一，只聚焦业务处理</p><p>// Original idea for metricsCollector<br>public class UserController {<br>//…省略其他属性和方法…<br>private MetricsCollector metricsCollector; // 依赖注入</p><p>public UserVo login(String telephone, String password) {<br>  long startTimestamp = System.currentTimeMillis();</p><p>  // … 省略login逻辑…</p><p>  long endTimeStamp = System.currentTimeMillis();<br>  long responseTime = endTimeStamp - startTimestamp;<br>  RequestInfo requestInfo = new RequestInfo(“login”, responseTime, startTimestamp);<br>  metricsCollector.recordRequest(requestInfo);</p><p>  //…返回UserVo数据…<br>}</p><p>public UserVo register(String telephone, String password) {<br>  long startTimestamp = System.currentTimeMillis();</p><p>  // … 省略register逻辑…</p><p>  long endTimeStamp = System.currentTimeMillis();<br>  long responseTime = endTimeStamp - startTimestamp;<br>  RequestInfo requestInfo = new RequestInfo(“register”, responseTime, startTimestamp);<br>  metricsCollector.recordRequest(requestInfo);</p><p>  //…返回UserVo数据…<br>}<br>}</p></li></ul></li></ul><ul><li>构建代理类UserControllerProxy<ul><li>代理类UserCOntrollerProxy和原始类UserController实现相同的接口IUserController。UserController只负责业务功能，代理类UserControllerProxy负责在业务代码执行前后附加其他逻辑代码，并通过委托的方式来调用原始类执行业务代码。</li></ul></li></ul><pre><code>    public interface IUserController {      UserVo login(String telephone, String password);      UserVo register(String telephone, String password);    }    public class UserController implements IUserController {      //...省略其他属性和方法...      @Override      public UserVo login(String telephone, String password) {        //...省略login逻辑...        //...返回UserVo数据...      }      @Override      public UserVo register(String telephone, String password) {        //...省略register逻辑...        //...返回UserVo数据...      }    }    public class UserControllerProxy implements IUserController {      private MetricsCollector metricsCollector;      private UserController userController;      public UserControllerProxy(UserController userController) {        this.userController = userController;        this.metricsCollector = new MetricsCollector();      }      @Override      public UserVo login(String telephone, String password) {        long startTimestamp = System.currentTimeMillis();        // 委托        UserVo userVo = userController.login(telephone, password);        long endTimeStamp = System.currentTimeMillis();        long responseTime = endTimeStamp - startTimestamp;        RequestInfo requestInfo = new RequestInfo(&quot;login&quot;, responseTime, startTimestamp);        metricsCollector.recordRequest(requestInfo);        return userVo;      }      @Override      public UserVo register(String telephone, String password) {        long startTimestamp = System.currentTimeMillis();        UserVo userVo = userController.register(telephone, password);        long endTimeStamp = System.currentTimeMillis();        long responseTime = endTimeStamp - startTimestamp;        RequestInfo requestInfo = new RequestInfo(&quot;register&quot;, responseTime, startTimestamp);        metricsCollector.recordRequest(requestInfo);        return userVo;      }    }    //UserControllerProxy使用举例    //因为原始类和代理类实现相同的接口，是基于接口而非实现编程    //将UserController类对象替换为UserControllerProxy类对象，不需要改动太多代码    IUserController userController = new UserControllerProxy(new UserController());</code></pre><ul><li>面对原始类无接口，或者属于其他service无法做改动的时候，可以直接通过继承，来对其进行扩展</li></ul><pre><code>public class UserControllerProxy extends UserController {  private MetricsCollector metricsCollector;  public UserControllerProxy() {    this.metricsCollector = new MetricsCollector();  }  public UserVo login(String telephone, String password) {    long startTimestamp = System.currentTimeMillis();    UserVo userVo = super.login(telephone, password);    long endTimeStamp = System.currentTimeMillis();    long responseTime = endTimeStamp - startTimestamp;    RequestInfo requestInfo = new RequestInfo(&quot;login&quot;, responseTime, startTimestamp);    metricsCollector.recordRequest(requestInfo);    return userVo;  }  public UserVo register(String telephone, String password) {    long startTimestamp = System.currentTimeMillis();    UserVo userVo = super.register(telephone, password);    long endTimeStamp = System.currentTimeMillis();    long responseTime = endTimeStamp - startTimestamp;    RequestInfo requestInfo = new RequestInfo(&quot;register&quot;, responseTime, startTimestamp);    metricsCollector.recordRequest(requestInfo);    return userVo;  }}//UserControllerProxy使用举例UserController userController = new UserControllerProxy();</code></pre><h1 id="2-动态代理原理解析"><a href="#2-动态代理原理解析" class="headerlink" title="2. 动态代理原理解析"></a>2. 动态代理原理解析</h1><p>代理类的实现需要将原始类当中的所有方法都实现一遍，并加上你需要的代码逻辑，这样做会创建大量的代理类，很麻烦。因此我们需要使用动态代理来解决这个问题，即我们不事先为每个原始类编写代理类，而是在运行的时候，动态的创建原始类对应的代理类，然后在系统当中用代理类替换掉原始类。</p><p>Java本身用反射语法来实现动态代理。</p><pre><code>public class MetricsCollectorProxy {  private MetricsCollector metricsCollector;  public MetricsCollectorProxy() {    this.metricsCollector = new MetricsCollector();  }  public Object createProxy(Object proxiedObject) {    Class&lt;?&gt;[] interfaces = proxiedObject.getClass().getInterfaces();    DynamicProxyHandler handler = new DynamicProxyHandler(proxiedObject);    return Proxy.newProxyInstance(proxiedObject.getClass().getClassLoader(), interfaces, handler);  }  private class DynamicProxyHandler implements InvocationHandler {    private Object proxiedObject;    public DynamicProxyHandler(Object proxiedObject) {      this.proxiedObject = proxiedObject;    }    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {      long startTimestamp = System.currentTimeMillis();      Object result = method.invoke(proxiedObject, args);      long endTimeStamp = System.currentTimeMillis();      long responseTime = endTimeStamp - startTimestamp;      String apiName = proxiedObject.getClass().getName() + &quot;:&quot; + method.getName();      RequestInfo requestInfo = new RequestInfo(apiName, responseTime, startTimestamp);      metricsCollector.recordRequest(requestInfo);      return result;    }  }}//MetricsCollectorProxy使用举例MetricsCollectorProxy proxy = new MetricsCollectorProxy();IUserController userController = (IUserController) proxy.createProxy(new UserController());</code></pre><ul><li><p>InvocationHandler </p><ul><li>java的标准接口</li></ul></li><li><p>创建Proxy 实例</p><ul><li>Proxy.newProxyInstance(classLoader, class, handlerClass)</li></ul></li><li><p>Spring的AOP的实现原理就是基于动态代理。用户配置好需要给哪些类创建代理，并定义好在执行原始类的业务代码前后执行哪些附加功能、Spring为这些类创建动态代理对象，并且在JVM中替代原始类对象。通过这种方式，实现了给原始类添加附加功能的目的。</p><h1 id="3-代理模式的应用场景"><a href="#3-代理模式的应用场景" class="headerlink" title="3. 代理模式的应用场景"></a>3. 代理模式的应用场景</h1></li><li><p>业务系统中的非功能性需求的开发</p><ul><li>监控</li><li>统计</li><li>鉴权</li><li>限流</li><li>事务</li><li>幂等</li><li>日志</li></ul></li><li><p>在RPC，缓存中的应用</p><ul><li>RPC将网络通信，数据编解码的细节隐藏起来</li><li>AOP切面完成接口缓存的功能</li></ul></li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://www.baeldung.com/java-dynamic-proxies" target="_blank" rel="noopener">https://www.baeldung.com/java-dynamic-proxies</a></li><li><a href="https://time.geekbang.org/column/article/201823" target="_blank" rel="noopener">https://time.geekbang.org/column/article/201823</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;结构型模式主要总结了一些类和对象组合在一起的经典结构，这些经典的结构可以解决特定应用场景的问题。结构型模式包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;代理模式&lt;/li&gt;
&lt;li&gt;桥接模式&lt;/li&gt;
&lt;li&gt;装饰器模式&lt;/li&gt;
&lt;li&gt;适配器模式&lt;/li&gt;
&lt;li&gt;门面模式&lt;/li&gt;
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="代理模式" scheme="https://www.llchen60.com/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-创建型-原型模式</title>
    <link href="https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-06-17T18:46:18.000Z</published>
    <updated>2020-06-17T18:46:53.268Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-什么是原型模式"><a href="#1-什么是原型模式" class="headerlink" title="1. 什么是原型模式"></a>1. 什么是原型模式</h1><p>如果说对象的创建成本比较大，并且同一个类的不同对象之间的差别不大（大部分字段都相同），在这种情况下，我们可以利用对已有对象(原型)进行复制/拷贝的方式来创建新对象，来达到节省创建时间的目的。</p><ul><li>如何理解对象的创建成本比较大<ul><li>比如对象当中的数据需要经过复杂的计算才能得到（排序，哈希）</li><li>需要IO读取</li></ul></li></ul><p>在这种情况下，我们就可以利用原型模式，从其他已有对象当中直接拷贝，而不是在每次创建对象的时候，重复执行这个非常耗时的操作。</p><h1 id="2-如何使用原型模式"><a href="#2-如何使用原型模式" class="headerlink" title="2.如何使用原型模式"></a>2.如何使用原型模式</h1><h2 id="2-1-实际场景案例"><a href="#2-1-实际场景案例" class="headerlink" title="2.1 实际场景案例"></a>2.1 实际场景案例</h2><ul><li><p>数据库 存储10万条搜索关键词信息</p><ul><li><p>包含关键词，关键词被搜索次数，信息最近被更新的时间</p></li><li><p>系统A启动的时候会加载这份数据到内存当中，用于处理某些其他的业务需求</p></li><li><p>构建散列表索引 – hashmap</p><ul><li>key为搜索关键词</li><li>value为关键词的详细信息</li></ul></li><li><p>系统B分析搜索日志，每隔10分钟就批量更新数据库中的数据，并且标记为新的数据版本</p></li><li><p>系统A需要定期根据数据库的数据更新内存中的索引和数据</p></li></ul></li></ul><h2 id="2-2-根据需求的迭代"><a href="#2-2-根据需求的迭代" class="headerlink" title="2.2 根据需求的迭代"></a>2.2 根据需求的迭代</h2><ul><li>在系统A中记录更新时间，在数据库中拿出更新时间大于系统A当中的搜索关键词，然后针对差集中的每个关键词进行处理</li><li>如果在散列表中了，更新相应的搜索次数，更新时间等</li><li>如果不在，插入散列表当中</li></ul><pre><code>public class Demo {  private ConcurrentHashMap&lt;String, SearchWord&gt; currentKeywords = new ConcurrentHashMap&lt;&gt;();  private long lastUpdateTime = -1;  public void refresh() {    // 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到currentKeywords中    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);    long maxNewUpdatedTime = lastUpdateTime;    for (SearchWord searchWord : toBeUpdatedSearchWords) {      if (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) {        maxNewUpdatedTime = searchWord.getLastUpdateTime();      }      if (currentKeywords.containsKey(searchWord.getKeyword())) {        currentKeywords.replace(searchWord.getKeyword(), searchWord);      } else {        currentKeywords.put(searchWord.getKeyword(), searchWord);      }    }    lastUpdateTime = maxNewUpdatedTime;  }  private List&lt;SearchWord&gt; getSearchWords(long lastUpdateTime) {    // TODO: 从数据库中取出更新时间&gt;lastUpdateTime的数据    return null;  }}</code></pre><ul><li>如果需要任何时刻系统A中的所有数据都必须是同一个版本的</li><li>更新内存数据的时候，系统A不能处于不可用的状态，不能停机更新数据<ul><li>针对需求，我们需要出了正在使用的服务版本之外，创建另外一个版本的数据。当新的版本数据建好之后，再一次性地将服务版本进行切换</li><li>可以保证数据一直可用，并且避免中间状态的存在</li></ul></li></ul><pre><code>public class Demo {  private HashMap&lt;String, SearchWord&gt; currentKeywords=new HashMap&lt;&gt;();  public void refresh() {    HashMap&lt;String, SearchWord&gt; newKeywords = new LinkedHashMap&lt;&gt;();    // 从数据库中取出所有的数据，放入到newKeywords中    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords();    for (SearchWord searchWord : toBeUpdatedSearchWords) {      newKeywords.put(searchWord.getKeyword(), searchWord);    }    currentKeywords = newKeywords;  }  private List&lt;SearchWord&gt; getSearchWords() {    // TODO: 从数据库中取出所有的数据    return null;  }}</code></pre><ul><li>新数据结构的构建成本非常高，需要IO读出数据库，计算哈希值，构建newKeywords</li><li>我们可以拷贝当前的版本到新的待处理的散列表当中，然后从数据库当中拿出新增或者有更新的关键词，来做更新</li></ul><pre><code>public class Demo {  private HashMap&lt;String, SearchWord&gt; currentKeywords=new HashMap&lt;&gt;();  private long lastUpdateTime = -1;  public void refresh() {    // 原型模式就这么简单，拷贝已有对象的数据，更新少量差值    HashMap&lt;String, SearchWord&gt; newKeywords = (HashMap&lt;String, SearchWord&gt;) currentKeywords.clone();    // 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);    long maxNewUpdatedTime = lastUpdateTime;    for (SearchWord searchWord : toBeUpdatedSearchWords) {      if (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) {        maxNewUpdatedTime = searchWord.getLastUpdateTime();      }      if (newKeywords.containsKey(searchWord.getKeyword())) {        SearchWord oldSearchWord = newKeywords.get(searchWord.getKeyword());        oldSearchWord.setCount(searchWord.getCount());        oldSearchWord.setLastUpdateTime(searchWord.getLastUpdateTime());      } else {        newKeywords.put(searchWord.getKeyword(), searchWord);      }    }    lastUpdateTime = maxNewUpdatedTime;    currentKeywords = newKeywords;  }  private List&lt;SearchWord&gt; getSearchWords(long lastUpdateTime) {    // TODO: 从数据库中取出更新时间&gt;lastUpdateTime的数据    return null;  }}</code></pre><ul><li>上述代码做的是浅拷贝，因为在散列表当中，key存的是搜索关键词，而value实际上存储的是对象的内存地址</li><li>当我们做浅拷贝的时候，我们实际上是把内存地址给拷贝了过来；这样的话当我们做修改的话，实际上两个版本的数据都做了变动，并没有将其彻底的分割开</li><li>我们实际需要的是深拷贝，即不仅仅复制索引，并且复制数据本身<ul><li>递归拷贝对象，对象的引用对象以及引用对象的引用对象</li><li>先将对象序列化，再反序列化成新对象</li></ul></li></ul><pre><code>// 实现递归深拷贝public class Demo {  private HashMap&lt;String, SearchWord&gt; currentKeywords=new HashMap&lt;&gt;();  private long lastUpdateTime = -1;  public void refresh() {    // Deep copy    HashMap&lt;String, SearchWord&gt; newKeywords = new HashMap&lt;&gt;();    for (HashMap.Entry&lt;String, SearchWord&gt; e : currentKeywords.entrySet()) {      SearchWord searchWord = e.getValue();      SearchWord newSearchWord = new SearchWord(              searchWord.getKeyword(), searchWord.getCount(), searchWord.getLastUpdateTime());      newKeywords.put(e.getKey(), newSearchWord);    }    // 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);    long maxNewUpdatedTime = lastUpdateTime;    for (SearchWord searchWord : toBeUpdatedSearchWords) {      if (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) {        maxNewUpdatedTime = searchWord.getLastUpdateTime();      }      if (newKeywords.containsKey(searchWord.getKeyword())) {        SearchWord oldSearchWord = newKeywords.get(searchWord.getKeyword());        oldSearchWord.setCount(searchWord.getCount());        oldSearchWord.setLastUpdateTime(searchWord.getLastUpdateTime());      } else {        newKeywords.put(searchWord.getKeyword(), searchWord);      }    }    lastUpdateTime = maxNewUpdatedTime;    currentKeywords = newKeywords;  }  private List&lt;SearchWord&gt; getSearchWords(long lastUpdateTime) {    // TODO: 从数据库中取出更新时间&gt;lastUpdateTime的数据    return null;  }}// 实现递归深拷贝public Object deepCopy(Object object) {  ByteArrayOutputStream bo = new ByteArrayOutputStream();  ObjectOutputStream oo = new ObjectOutputStream(bo);  oo.writeObject(object);  ByteArrayInputStream bi = new ByteArrayInputStream(bo.toByteArray());  ObjectInputStream oi = new ObjectInputStream(bi);  return oi.readObject();}</code></pre><ul><li>最快的方式，是可以先用浅拷贝来创建，对于需要更新的对象，再用深拷贝的方式创建一份新的对象，来做替换</li></ul><pre><code>public class Demo {  private HashMap&lt;String, SearchWord&gt; currentKeywords=new HashMap&lt;&gt;();  private long lastUpdateTime = -1;  public void refresh() {    // Shallow copy    HashMap&lt;String, SearchWord&gt; newKeywords = (HashMap&lt;String, SearchWord&gt;) currentKeywords.clone();    // 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);    long maxNewUpdatedTime = lastUpdateTime;    for (SearchWord searchWord : toBeUpdatedSearchWords) {      if (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) {        maxNewUpdatedTime = searchWord.getLastUpdateTime();      }      if (newKeywords.containsKey(searchWord.getKeyword())) {        newKeywords.remove(searchWord.getKeyword());      }      newKeywords.put(searchWord.getKeyword(), searchWord);    }    lastUpdateTime = maxNewUpdatedTime;    currentKeywords = newKeywords;  }  private List&lt;SearchWord&gt; getSearchWords(long lastUpdateTime) {    // TODO: 从数据库中取出更新时间&gt;lastUpdateTime的数据    return null;  }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-什么是原型模式&quot;&gt;&lt;a href=&quot;#1-什么是原型模式&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是原型模式&quot;&gt;&lt;/a&gt;1. 什么是原型模式&lt;/h1&gt;&lt;p&gt;如果说对象的创建成本比较大，并且同一个类的不同对象之间的差别不大（大部分字段都相
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="原型模式" scheme="https://www.llchen60.com/tags/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-创建型-建造者模式</title>
    <link href="https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-06-16T04:17:36.000Z</published>
    <updated>2020-06-16T04:18:58.833Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-为什么需要建造者模式"><a href="#1-为什么需要建造者模式" class="headerlink" title="1. 为什么需要建造者模式"></a>1. 为什么需要建造者模式</h1><p>一个关于如何使用建造者模式的问题是：当我们能够使用构造函数或者使用set方法就能够创建对象的时候，我们为什么会需要建造者模式来创建呢？ </p><p>一个例子，假设我们要定义一个类，其大部分的属性都是可以选择的，那么我们可以使用构造函数来做如下的声明： </p><pre><code>public class ResourcePoolConfig {  private static final int DEFAULT_MAX_TOTAL = 8;  private static final int DEFAULT_MAX_IDLE = 8;  private static final int DEFAULT_MIN_IDLE = 0;  private String name;  private int maxTotal = DEFAULT_MAX_TOTAL;  private int maxIdle = DEFAULT_MAX_IDLE;  private int minIdle = DEFAULT_MIN_IDLE;  public ResourcePoolConfig(String name, Integer maxTotal, Integer maxIdle, Integer minIdle) {    if (StringUtils.isBlank(name)) {      throw new IllegalArgumentException(&quot;name should not be empty.&quot;);    }    this.name = name;    if (maxTotal != null) {      if (maxTotal &lt;= 0) {        throw new IllegalArgumentException(&quot;maxTotal should be positive.&quot;);      }      this.maxTotal = maxTotal;    }    if (maxIdle != null) {      if (maxIdle &lt; 0) {        throw new IllegalArgumentException(&quot;maxIdle should not be negative.&quot;);      }      this.maxIdle = maxIdle;    }    if (minIdle != null) {      if (minIdle &lt; 0) {        throw new IllegalArgumentException(&quot;minIdle should not be negative.&quot;);      }      this.minIdle = minIdle;    }  }  //...省略getter方法...}</code></pre><p>在这个例子当中，除了name以外的所有选项都是可选的，因此会看到在构造函数当中，我们做了很多的null check。这样做当参数很多的时候，是很难看懂的。我们可以将其改良为一系列的set()函数，构造函数只实例化NonNull的参数，对于Nullable的参数，我们可以用set方法来实现声明。如下所示： </p><pre><code>public class ResourcePoolConfig {  private static final int DEFAULT_MAX_TOTAL = 8;  private static final int DEFAULT_MAX_IDLE = 8;  private static final int DEFAULT_MIN_IDLE = 0;  private String name;  private int maxTotal = DEFAULT_MAX_TOTAL;  private int maxIdle = DEFAULT_MAX_IDLE;  private int minIdle = DEFAULT_MIN_IDLE;  public ResourcePoolConfig(String name) {    if (StringUtils.isBlank(name)) {      throw new IllegalArgumentException(&quot;name should not be empty.&quot;);    }    this.name = name;  }  public void setMaxTotal(int maxTotal) {    if (maxTotal &lt;= 0) {      throw new IllegalArgumentException(&quot;maxTotal should be positive.&quot;);    }    this.maxTotal = maxTotal;  }  public void setMaxIdle(int maxIdle) {    if (maxIdle &lt; 0) {      throw new IllegalArgumentException(&quot;maxIdle should not be negative.&quot;);    }    this.maxIdle = maxIdle;  }  public void setMinIdle(int minIdle) {    if (minIdle &lt; 0) {      throw new IllegalArgumentException(&quot;minIdle should not be negative.&quot;);    }    this.minIdle = minIdle;  }  //...省略getter方法...}</code></pre><p>上述的set方法还是有一些缺陷的，即：</p><ul><li>首先如果必填的配置项有很多，且都需要放置到构造函数当中，那构造函数就会出现参数列表很长的问题了。</li><li>假设配置项之间有一定的依赖关系，我们需要将配置项之间的依赖关系和校验逻辑找地方放</li><li>如果我们希望类对象是不可变对象，即对象在创建好之后就不能再修改内部的属性值，那么我们就不能再ResourcePoolConfig类当中暴露set()方法</li></ul><p>Builder模式可以很好的解决上述我们的需求，我们可以将校验逻辑放在调用build()方法之前，也可以将构造函数私有化，这样就只能通过建造者来创建ResourcePoolConfig类对象</p><h1 id="2-如何使用建造者模式构建对象"><a href="#2-如何使用建造者模式构建对象" class="headerlink" title="2. 如何使用建造者模式构建对象"></a>2. 如何使用建造者模式构建对象</h1><pre><code>public class ResourcePoolConfig {  private String name;  private int maxTotal;  private int maxIdle;  private int minIdle;  private ResourcePoolConfig(Builder builder) {    this.name = builder.name;    this.maxTotal = builder.maxTotal;    this.maxIdle = builder.maxIdle;    this.minIdle = builder.minIdle;  }  //...省略getter方法...  //我们将Builder类设计成了ResourcePoolConfig的内部类。  //我们也可以将Builder类设计成独立的非内部类ResourcePoolConfigBuilder。  public static class Builder {    private static final int DEFAULT_MAX_TOTAL = 8;    private static final int DEFAULT_MAX_IDLE = 8;    private static final int DEFAULT_MIN_IDLE = 0;    private String name;    private int maxTotal = DEFAULT_MAX_TOTAL;    private int maxIdle = DEFAULT_MAX_IDLE;    private int minIdle = DEFAULT_MIN_IDLE;    public ResourcePoolConfig build() {      // 校验逻辑放到这里来做，包括必填项校验、依赖关系校验、约束条件校验等      if (StringUtils.isBlank(name)) {        throw new IllegalArgumentException(&quot;...&quot;);      }      if (maxIdle &gt; maxTotal) {        throw new IllegalArgumentException(&quot;...&quot;);      }      if (minIdle &gt; maxTotal || minIdle &gt; maxIdle) {        throw new IllegalArgumentException(&quot;...&quot;);      }      return new ResourcePoolConfig(this);    }    public Builder setName(String name) {      if (StringUtils.isBlank(name)) {        throw new IllegalArgumentException(&quot;...&quot;);      }      this.name = name;      return this;    }    public Builder setMaxTotal(int maxTotal) {      if (maxTotal &lt;= 0) {        throw new IllegalArgumentException(&quot;...&quot;);      }      this.maxTotal = maxTotal;      return this;    }    public Builder setMaxIdle(int maxIdle) {      if (maxIdle &lt; 0) {        throw new IllegalArgumentException(&quot;...&quot;);      }      this.maxIdle = maxIdle;      return this;    }    public Builder setMinIdle(int minIdle) {      if (minIdle &lt; 0) {        throw new IllegalArgumentException(&quot;...&quot;);      }      this.minIdle = minIdle;      return this;    }  }}// 这段代码会抛出IllegalArgumentException，因为minIdle&gt;maxIdleResourcePoolConfig config = new ResourcePoolConfig.Builder()        .setName(&quot;dbconnectionpool&quot;)        .setMaxTotal(16)        .setMaxIdle(10)        .setMinIdle(12)        .build();</code></pre><h1 id="3-何时使用"><a href="#3-何时使用" class="headerlink" title="3. 何时使用"></a>3. 何时使用</h1><p>建造者模式用来创建一种类型的复杂对象，通过设置不同的可选参数，定制化地创建不同的对象。建造者模式和工厂模式的区别可以用一个例子来说明，顾客走进一家餐馆点餐，我们利用工厂模式，根据用户不同的选择，来制作不同的食物，比如披萨、汉堡、沙拉。对于披萨来说，用户又有各种配料可以定制，比如奶酪、西红柿、起司，我们通过建造者模式根据用户选择的不同配料来制作披萨。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-为什么需要建造者模式&quot;&gt;&lt;a href=&quot;#1-为什么需要建造者模式&quot; class=&quot;headerlink&quot; title=&quot;1. 为什么需要建造者模式&quot;&gt;&lt;/a&gt;1. 为什么需要建造者模式&lt;/h1&gt;&lt;p&gt;一个关于如何使用建造者模式的问题是：当我们能够使用构造函
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="建造者模式" scheme="https://www.llchen60.com/tags/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-创建型-工厂模式</title>
    <link href="https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-06-14T20:58:25.000Z</published>
    <updated>2020-06-16T04:18:00.563Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-简单工厂-Simple-Factory"><a href="#1-简单工厂-Simple-Factory" class="headerlink" title="1. 简单工厂 Simple Factory"></a>1. 简单工厂 Simple Factory</h1><p>假设要做一个parser类，根据后缀来实例化Parser</p><pre><code>public class RuleConfigSource {  public RuleConfig load(String ruleConfigFilePath) {    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);    IRuleConfigParser parser = RuleConfigParserFactory.createParser(ruleConfigFileExtension);    if (parser == null) {      throw new InvalidRuleConfigException(              &quot;Rule config file format is not supported: &quot; + ruleConfigFilePath);    }    String configText = &quot;&quot;;    //从ruleConfigFilePath文件中读取配置文本到configText中    RuleConfig ruleConfig = parser.parse(configText);    return ruleConfig;  }  private String getFileExtension(String filePath) {    //...解析文件名获取扩展名，比如rule.json，返回json    return &quot;json&quot;;  }}public class RuleConfigParserFactory {  public static IRuleConfigParser createParser(String configFormat) {    IRuleConfigParser parser = null;    if (&quot;json&quot;.equalsIgnoreCase(configFormat)) {      parser = new JsonRuleConfigParser();    } else if (&quot;xml&quot;.equalsIgnoreCase(configFormat)) {      parser = new XmlRuleConfigParser();    } else if (&quot;yaml&quot;.equalsIgnoreCase(configFormat)) {      parser = new YamlRuleConfigParser();    } else if (&quot;properties&quot;.equalsIgnoreCase(configFormat)) {      parser = new PropertiesRuleConfigParser();    }    return parser;  }}</code></pre><p>上述代码是创建了工厂类，并且在工厂类当中制定了静态方法，根据输入参数的不同来分别实例化不同的parser。一般来说工厂当中创建对象的方法都是create开头，或者说明对于instance的操作，常见的方法名比如：</p><ul><li>createXXX()</li><li>getInstance()</li><li>createInstance()</li><li>newInstance() </li></ul><p>同样，如果要声明的类时很可能可以复用的，那么我们就可以在调用前就创建好，来节省对象创建的时间</p><pre><code>public class RuleConfigParserFactory {  private static final Map&lt;String, RuleConfigParser&gt; cachedParsers = new HashMap&lt;&gt;();  static {    cachedParsers.put(&quot;json&quot;, new JsonRuleConfigParser());    cachedParsers.put(&quot;xml&quot;, new XmlRuleConfigParser());    cachedParsers.put(&quot;yaml&quot;, new YamlRuleConfigParser());    cachedParsers.put(&quot;properties&quot;, new PropertiesRuleConfigParser());  }  public static IRuleConfigParser createParser(String configFormat) {    if (configFormat == null || configFormat.isEmpty()) {      return null;//返回null还是IllegalArgumentException全凭你自己说了算    }    IRuleConfigParser parser = cachedParsers.get(configFormat.toLowerCase());    return parser;  }}</code></pre><h1 id="2-工厂方法"><a href="#2-工厂方法" class="headerlink" title="2. 工厂方法"></a>2. 工厂方法</h1><p>利用多态将if分支逻辑给去掉： </p><pre><code>public interface IRuleConfigParserFactory {  IRuleConfigParser createParser();}public class JsonRuleConfigParserFactory implements IRuleConfigParserFactory {  @Override  public IRuleConfigParser createParser() {    return new JsonRuleConfigParser();  }}public class XmlRuleConfigParserFactory implements IRuleConfigParserFactory {  @Override  public IRuleConfigParser createParser() {    return new XmlRuleConfigParser();  }}public class YamlRuleConfigParserFactory implements IRuleConfigParserFactory {  @Override  public IRuleConfigParser createParser() {    return new YamlRuleConfigParser();  }}public class PropertiesRuleConfigParserFactory implements IRuleConfigParserFactory {  @Override  public IRuleConfigParser createParser() {    return new PropertiesRuleConfigParser();  }}// 关于如何选取需要import的factory，使用hashmap，相当于为工厂类创建了一个简单的工厂；一种委托给别人进行生产的模式思路public class RuleConfigSource {  public RuleConfig load(String ruleConfigFilePath) {    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);    IRuleConfigParserFactory parserFactory = RuleConfigParserFactoryMap.getParserFactory(ruleConfigFileExtension);    if (parserFactory == null) {      throw new InvalidRuleConfigException(&quot;Rule config file format is not supported: &quot; + ruleConfigFilePath);    }    IRuleConfigParser parser = parserFactory.createParser();    String configText = &quot;&quot;;    //从ruleConfigFilePath文件中读取配置文本到configText中    RuleConfig ruleConfig = parser.parse(configText);    return ruleConfig;  }  private String getFileExtension(String filePath) {    //...解析文件名获取扩展名，比如rule.json，返回json    return &quot;json&quot;;  }}//因为工厂类只包含方法，不包含成员变量，完全可以复用，//不需要每次都创建新的工厂类对象，所以，简单工厂模式的第二种实现思路更加合适。public class RuleConfigParserFactoryMap { //工厂的工厂  private static final Map&lt;String, IRuleConfigParserFactory&gt; cachedFactories = new HashMap&lt;&gt;();  static {    cachedFactories.put(&quot;json&quot;, new JsonRuleConfigParserFactory());    cachedFactories.put(&quot;xml&quot;, new XmlRuleConfigParserFactory());    cachedFactories.put(&quot;yaml&quot;, new YamlRuleConfigParserFactory());    cachedFactories.put(&quot;properties&quot;, new PropertiesRuleConfigParserFactory());  }  public static IRuleConfigParserFactory getParserFactory(String type) {    if (type == null || type.isEmpty()) {      return null;    }    IRuleConfigParserFactory parserFactory = cachedFactories.get(type.toLowerCase());    return parserFactory;  }}</code></pre><h1 id="3-Dependency-Injection-框架"><a href="#3-Dependency-Injection-框架" class="headerlink" title="3. Dependency Injection 框架"></a>3. Dependency Injection 框架</h1><p>依赖注入框架想要解决的是在基于Inversion of control的理念下，我们应该如何做，如何简化整个创建对象的过程。</p><p>DI容器底层最基本的设计思路是基于工厂模式来进行的，DI容器就相当于一个大的工厂类，复杂在程序启动的时候，根据配置（需要创建哪些类对象，每个类对象的创建需要依赖哪些其他类的对象）事先创建好对象。当应用程序需要使用某个类对象的时候，直接从容器当中获取即可。</p><p>DI容器的核心功能主要有：</p><ul><li>配置解析</li><li>对象创建</li><li>对象生命周期管理</li></ul><h2 id="3-1-配置解析"><a href="#3-1-配置解析" class="headerlink" title="3.1 配置解析"></a>3.1 配置解析</h2><p>应用需要告知DI容器需要创建哪些对象，需要将由DI容器来创建的类对象和创建类对象的必要信息，放到配置文件当中。容器读取配置文件，根据配置文件提供的信息来创建对象。像在spring当中，就是依靠xml文件或者注解，来告诉spring 用何种方式来创建对象。</p><h2 id="3-2-对象创建"><a href="#3-2-对象创建" class="headerlink" title="3.2 对象创建"></a>3.2 对象创建</h2><p>Spring当中将所有类对象的创建都放到了一个工厂类当中实现</p><h2 id="3-3-对象生命周期管理"><a href="#3-3-对象生命周期管理" class="headerlink" title="3.3 对象生命周期管理"></a>3.3 对象生命周期管理</h2><ul><li><p>通过配置scope属性，决定是每次都返回一个新创建的对象还是每次都返回一个事先创建好的对象 – 单例对象</p></li><li><p>配置是否懒加载；lazy-init</p><ul><li>真正被使用的时候被创建</li><li>在应用启动的时候就事先创建好</li></ul></li><li><p>配置对象的init-method, destroy-method </p><ul><li>DI容器在创建好对象之后，会主动调用init-method属性指定的方法来初始化对象</li><li>在对象被最终销毁之前，DI容器会主动调用destroy-method属性指定的方法来做一些清理工作</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-简单工厂-Simple-Factory&quot;&gt;&lt;a href=&quot;#1-简单工厂-Simple-Factory&quot; class=&quot;headerlink&quot; title=&quot;1. 简单工厂 Simple Factory&quot;&gt;&lt;/a&gt;1. 简单工厂 Simple Factory
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="工厂模式" scheme="https://www.llchen60.com/tags/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>思维模型的搜集/整理</title>
    <link href="https://www.llchen60.com/%E6%80%9D%E7%BB%B4%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%90%9C%E9%9B%86-%E6%95%B4%E7%90%86/"/>
    <id>https://www.llchen60.com/%E6%80%9D%E7%BB%B4%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%90%9C%E9%9B%86-%E6%95%B4%E7%90%86/</id>
    <published>2020-06-12T05:46:32.000Z</published>
    <updated>2020-06-16T04:35:44.663Z</updated>
    
    <content type="html"><![CDATA[<p>看到了Adam Amran的<a href="https://untools.co/，感觉是有一些元知识是衍生的根本，希望能够用这篇blog作为总结分享的集散地，把自己看到的认为在某些方面有实际效用的思维模型分享给大家。" target="_blank" rel="noopener">https://untools.co/，感觉是有一些元知识是衍生的根本，希望能够用这篇blog作为总结分享的集散地，把自己看到的认为在某些方面有实际效用的思维模型分享给大家。</a></p><h1 id="1-问题树-Issue-Tree"><a href="#1-问题树-Issue-Tree" class="headerlink" title="1. 问题树 - Issue Tree"></a>1. 问题树 - <a href="https://untools.co/issue-trees" target="_blank" rel="noopener">Issue Tree</a></h1><h2 id="1-1-是什么"><a href="#1-1-是什么" class="headerlink" title="1.1 是什么"></a>1.1 是什么</h2><ul><li>一个问题地图</li><li>旨在给你需要解决的问题一个清晰而系统的思考方式</li><li>帮助你对问题进行拆分，其实很符合divide and conquer 即分治的思想</li></ul><p>对自己而言，确实有在做，在思考。值得注意且需要加强的一点是MECE原则 – mutually exclusive, collectively exhaustive。 对提高思维的完备性很有作用</p><h2 id="1-2-怎么做"><a href="#1-2-怎么做" class="headerlink" title="1.2 怎么做"></a>1.2 怎么做</h2><ul><li><p>问题树应该能够覆盖所有的问题，需要非常细致</p></li><li><p>一些需要遵循的原则</p><ul><li><p><strong>MECE - mutually exclusive, collectively exhaustive</strong> </p><ul><li><strong>需要做到相互之间没有交集，并集即为全集</strong></li></ul></li><li><p>不要过度纠结于太小的细节，需要先做大类目的划分，来定义问题</p></li><li><p>二八法则，专注于起于数据的有价值的问题</p></li></ul></li></ul><h1 id="2-Second-order-thinking"><a href="#2-Second-order-thinking" class="headerlink" title="2. Second-order thinking"></a>2. <a href="https://untools.co/second-order-thinking" target="_blank" rel="noopener">Second-order thinking</a></h1><h2 id="2-1-Overview"><a href="#2-1-Overview" class="headerlink" title="2.1 Overview"></a>2.1 Overview</h2><p>有的时候我们下的决定看起来直观上会给我们带来好处，但是长远看来是对我们不利的。我们通常的思考链条是 需求 - 设定方案 - 评估方案 - 执行。其实大到公司的项目，小到晚上吃什么，我们的脑海里都会先给出需求，饿了，需要吃饭。到设定方案，在家吃vs出去吃，然后是吃什么，然后做出决定，并且按照决定来执行。</p><p>这种思考方式希望你做的是在要做出决定的时候，在想了决定的直接影响之后。再多问自己一个问题，即 – 然后呢？ 这个决定后续还会带来什么结果呢？ </p><p><strong>从事情发展的阶段来看，思考二度的发展；也可以从时间维度，去思考做出的决定在接下来几天，几个月，甚至相对更长的时间里可能对你带来的影响。</strong></p><h1 id="3-第一性原理"><a href="#3-第一性原理" class="headerlink" title="3. 第一性原理"></a>3. 第一性原理</h1><p>在每一种系统的探索当中，存在第一性原理，这是一个最基本的命题或假设，不能被忽略或删除，也不能被违反。</p><p>首先是归纳法与演绎法的对比，我们生活中最经常使用的是归纳法，即根据经验，现象到结果的链条来总结事情是如何发生的；而演绎法是基于一些元知识，做出自己的推论。</p><p>第一性原理 – First Principle，说的就是不能被省略，不能被删除，不能违反的最基本的命题或假设。是演绎法的一种，即从根本原理上，剔除干扰因素和常识性知识的思考方法。目的是希望能够将人从错综复杂的现实问题中换一个视角，将复杂的事情努力转化为简单的结构，来从源头上理解。</p><p>“我们运用第一性原理，而不是比较思维去思考问题是非常重要的。我们在生活中总是倾向于比较，对别人已经做过或者正在做的事情我们也都去做，这样发展的结果只能产生细小的迭代发展。</p><p>第一性原理的思想方式是用物理学的角度看待世界，也就是说一层层拨开事物表象，看到里面的本质，再从本质一层层往上走。”</p><h2 id="3-1-如何使用第一性原理"><a href="#3-1-如何使用第一性原理" class="headerlink" title="3.1 如何使用第一性原理"></a>3.1 如何使用第一性原理</h2><ul><li><p>苏格拉底式的提问</p><ul><li>问题源头，源起，具体表现形式？</li><li>这个情况总是发生么？什么因素会导致问题出现？</li><li>假设的证据在哪里？是否可靠？</li><li>替代观点和角度</li><li>影响和后果</li><li>对问题本身的质疑</li></ul></li><li><p>实践过程</p><ul><li>溯源</li><li>拆解</li><li>重构</li><li>迭代</li></ul></li><li><p>比较思维 vs 第一性原理</p><ul><li>看资讯</li><li>自己总结分析想法</li></ul></li></ul><h1 id="4-抽象梯子"><a href="#4-抽象梯子" class="headerlink" title="4. 抽象梯子"></a>4. 抽象梯子</h1><p>通过在不同的抽象层的移动来更好的构建你的问题。我们可以向上移动，从更大的视角看问题，看到树木背后的森林；也可以向下移动，来演化出一个更加精细的解决方案。</p><h2 id="4-1-如何使用"><a href="#4-1-如何使用" class="headerlink" title="4.1 如何使用"></a>4.1 如何使用</h2><ul><li>从一个普通的问题开始</li><li>通过问为什么来获得更大更远的视角</li><li>通过问如何做来逐步获得一个更具体的解决方案</li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://untools.co/issue-trees" target="_blank" rel="noopener">https://untools.co/issue-trees</a></li><li><a href="https://medium.com/@idtimw/%E6%80%9D%E7%BB%B4%E6%A8%A1%E5%9E%8B03-first-principles-%E7%AC%AC%E4%B8%80%E6%80%A7%E5%8E%9F%E7%90%86-7571fc664faf" target="_blank" rel="noopener">https://medium.com/@idtimw/%E6%80%9D%E7%BB%B4%E6%A8%A1%E5%9E%8B03-first-principles-%E7%AC%AC%E4%B8%80%E6%80%A7%E5%8E%9F%E7%90%86-7571fc664faf</a></li><li><a href="http://fund.jrj.com.cn/2018/06/04151524634381.shtml" target="_blank" rel="noopener">http://fund.jrj.com.cn/2018/06/04151524634381.shtml</a></li><li><a href="https://36kr.com/p/5068808" target="_blank" rel="noopener">https://36kr.com/p/5068808</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;看到了Adam Amran的&lt;a href=&quot;https://untools.co/，感觉是有一些元知识是衍生的根本，希望能够用这篇blog作为总结分享的集散地，把自己看到的认为在某些方面有实际效用的思维模型分享给大家。&quot; target=&quot;_blank&quot; rel=&quot;noop
      
    
    </summary>
    
    
      <category term="Notes" scheme="https://www.llchen60.com/categories/Notes/"/>
    
    
      <category term="思维模型" scheme="https://www.llchen60.com/tags/%E6%80%9D%E7%BB%B4%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-创建型-单例模式</title>
    <link href="https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-06-11T22:00:48.000Z</published>
    <updated>2020-06-13T05:00:36.811Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-为什么需要单例模式"><a href="#1-为什么需要单例模式" class="headerlink" title="1. 为什么需要单例模式"></a>1. 为什么需要单例模式</h1><p>windows系统的任务管理器，只能有一个,唯一性的原因：</p><ol><li>如果能弹出多个窗口，且这些窗口的内容完全一致，全都是重复对象，那势必会浪费资源，尤其是任务管理器会需要进入内核态调取各种状态信息，会对性能造成一定的影响。</li><li>而且多个窗口之间需要保持一致性，绝对的同步，相互之间的同步也是资源的浪费。</li></ol><p>现实中的例子，就是为了节约系统资源，有时需要确保系统中某个类只有唯一一个实例，当这个实例创建成功以后，我们无法再创建一个同类型的其他对象，所有的操作都只能基于这个唯一的实例。</p><h2 id="1-1-处理资源的访问冲突"><a href="#1-1-处理资源的访问冲突" class="headerlink" title="1.1 处理资源的访问冲突"></a>1.1 处理资源的访问冲突</h2><p>下述代码自定义了一个往文件当中打印日志的logger类： </p><pre><code>public class Logger {  private FileWriter writer;  public Logger() {    File file = new File(&quot;/Users/leilei/log.txt&quot;);    writer = new FileWriter(file, true); //true表示追加写入  }  public void log(String message) {    writer.write(mesasge);  }}// Logger类的应用示例：public class UserController {  private Logger logger = new Logger();  public void login(String username, String password) {    // ...省略业务逻辑代码...    logger.log(username + &quot; logined!&quot;);  }}public class OrderController {  private Logger logger = new Logger();  public void create(OrderVo order) {    // ...省略业务逻辑代码...    logger.log(&quot;Created an order: &quot; + order.toString());  }}</code></pre><p>这段代码的问题在于每个类在实现的过程中都创建了一个新的Logger对象，如果我们同时创建了两个controller，然后执行的话，会同时写入同一个文件当中，这会有可能导致日志信息互相覆盖的情况。</p><p>想要解决这个问题，我们需要加上类级别的锁，让所有的对象都能够共享一把锁：</p><pre><code>public class Logger {  private FileWriter writer;  public Logger() {    File file = new File(&quot;/Users/wangzheng/log.txt&quot;);    writer = new FileWriter(file, true); //true表示追加写入  }  public void log(String message) {    synchronized(Logger.class) { // 类级别的锁      writer.write(mesasge);    }  }}</code></pre><p>我们也可以使用单例模式，使得程序当中只允许创建一个Logger对象，所有的线程共享这一个Logger对象，共享一个FileWriter对象（本身有对象级别的线程安全的保障）</p><pre><code>public class Logger {  private FileWriter writer;  private static final Logger instance = new Logger();  private Logger() {    File file = new File(&quot;/Users/leilei/log.txt&quot;);    writer = new FileWriter(file, true); //true表示追加写入  }  public static Logger getInstance() {    return instance;  }  public void log(String message) {    writer.write(mesasge);  }}// Logger类的应用示例：public class UserController {  public void login(String username, String password) {    // ...省略业务逻辑代码...    Logger.getInstance().log(username + &quot; logined!&quot;);  }}public class OrderController {    public void create(OrderVo order) {    // ...省略业务逻辑代码...    Logger.getInstance().log(&quot;Created a order: &quot; + order.toString());  }}</code></pre><h2 id="1-2-表示全局唯一类"><a href="#1-2-表示全局唯一类" class="headerlink" title="1.2 表示全局唯一类"></a>1.2 表示全局唯一类</h2><p>对于只应该在系统当中保存一份的数据，比较适合设计为单例类。</p><pre><code>import java.util.concurrent.atomic.AtomicLong;public class IdGenerator {  // AtomicLong是一个Java并发库中提供的一个原子变量类型,  // 它将一些线程不安全需要加锁的复合操作封装为了线程安全的原子操作，  // 比如下面会用到的incrementAndGet().  private AtomicLong id = new AtomicLong(0);  private static final IdGenerator instance = new IdGenerator();  private IdGenerator() {}  public static IdGenerator getInstance() {    return instance;  }  public long getId() {     return id.incrementAndGet();  }}// IdGenerator使用举例long id = IdGenerator.getInstance().getId();</code></pre><h1 id="2-单例模式概述"><a href="#2-单例模式概述" class="headerlink" title="2. 单例模式概述"></a>2. 单例模式概述</h1><ul><li><p>单例的定义</p><ul><li>一个类只允许创建唯一一个对象，那这个类就是一个单例类</li></ul></li><li><p>对象的唯一性指</p><ul><li>进程内只允许创建一个对象</li><li>进程之间是不唯一的</li></ul></li></ul><h2 id="2-1-模拟任务管理类"><a href="#2-1-模拟任务管理类" class="headerlink" title="2.1 模拟任务管理类"></a>2.1 模拟任务管理类</h2><pre><code>class TaskManager{     public TaskManager() {...} //初始化窗口     public void displayProcesses()  {……} //显示进程     public void  displayServices() {……} //显示服务}</code></pre><p>对其进行重构，为了使其是单一实例的，那我们需要禁止类的外部直接使用new来创建对象  —–&gt;  将其构造函数的可见性变为private</p><pre><code>public TaskManager() {...}</code></pre><p>在类内部创建对象，保存这个唯一实例</p><pre><code>private static TaskManager tm = null;public static TaskManager getInstance() {    if (tm == null) {        tm = new TaskManager();    }    return tm;}</code></pre><p><code>getInstance()</code>定义成一个静态方法，这样可以直接通过类名来使用</p><h2 id="2-2-定义"><a href="#2-2-定义" class="headerlink" title="2.2 定义"></a>2.2 定义</h2><blockquote><p>单例模式(Singleton Pattern)：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式是一种对象创建型模式。</p></blockquote><ol><li>只有一个实例</li><li>必须自行创建这个实例</li><li>必须自行向整个系统提供这个实例</li></ol><p><img src="https://i.loli.net/2020/02/03/vKPVAeCrImYXq1U.gif" alt="s1.gif"></p><h2 id="2-3-负载均衡器的设计与实现"><a href="#2-3-负载均衡器的设计与实现" class="headerlink" title="2.3 负载均衡器的设计与实现"></a>2.3 负载均衡器的设计与实现</h2><p> Sunny软件公司承接了一个服务器负载均衡(Load Balance)软件的开发工作，该软件运行在一台负载均衡服务器上，可以将并发访问和数据流量分发到服务器集群中的多台设备上进行并发处理，提高系统的整体处理能力，缩短响应时间。由于集群中的服务器需要动态删减，且客户端请求需要统一分发，因此需要确保负载均衡器的唯一性，只能有一个负载均衡器来负责服务器的管理和请求的分发，否则将会带来服务器状态的不一致以及请求分配冲突等问题。如何确保负载均衡器的唯一性是该软件成功的关键。</p><p>使用单例模式来设计该负载均衡器： </p><p><img src="https://i.loli.net/2020/02/03/4vJzXqlRCITLUge.gif" alt="s2.gif"></p><pre><code>import java.util.*;//负载均衡器LoadBalancer：单例类，真实环境下该类将非常复杂，包括大量初始化的工作和业务方法，考虑到代码的可读性和易理解性，只列出部分与模式相关的核心代码class LoadBalancer {    //私有静态成员变量，存储唯一实例    private static LoadBalancer instance = null;    //服务器集合    private List serverList = null;    //私有构造函数    private LoadBalancer() {        serverList = new ArrayList();    }    //公有静态成员方法，返回唯一实例    public static LoadBalancer getLoadBalancer() {        if (instance == null) {            instance = new LoadBalancer();        }        return instance;    }    //增加服务器    public void addServer(String server) {        serverList.add(server);    }    //删除服务器    public void removeServer(String server) {        serverList.remove(server);    }    //使用Random类随机获取服务器    public String getServer() {        Random random = new Random();        int i = random.nextInt(serverList.size());        return (String)serverList.get(i);    }}</code></pre><h1 id="3-饿汉式单例模式和懒汉式单例模式"><a href="#3-饿汉式单例模式和懒汉式单例模式" class="headerlink" title="3. 饿汉式单例模式和懒汉式单例模式"></a>3. 饿汉式单例模式和懒汉式单例模式</h1><h2 id="3-1-饿汉式单例模式"><a href="#3-1-饿汉式单例模式" class="headerlink" title="3.1 饿汉式单例模式"></a>3.1 饿汉式单例模式</h2><p><img src="https://i.loli.net/2020/02/03/UAk8topvxWQTwfd.gif" alt="s3.gif"></p><pre><code>class EagerSingleton {     private static final EagerSingleton instance = new EagerSingleton();     private EagerSingleton() { }     public static EagerSingleton getInstance() {        return instance;     }   }</code></pre><p>在类加载的时候，静态变量instance就会被初始化，此时类的私有构造函数会被调用，然后单例类的唯一实例会在这个时候被创建出来。</p><p>恶汉模式的好处是没有延迟加载，这样子是在需要用到它的时候才来执行这个耗时长的初始化过程，可以避免在程序运行的时候才初始化导致的新跟那个问题。</p><h2 id="3-2-懒汉式单例模式"><a href="#3-2-懒汉式单例模式" class="headerlink" title="3.2 懒汉式单例模式"></a>3.2 懒汉式单例模式</h2><p><img src="https://i.loli.net/2020/02/03/bDLQtESdzF8Ugmq.gif" alt="s4.gif"></p><p>在第一个调用getInstance()方法的时候进行实例化。又叫做延迟加载技术——在需要的时候再加载实例，为了避免多个线程同时调用getInstance()方法，我们需要使用<strong><em>synchronized关键字</em></strong>：</p><pre><code>class LazySingleton {     private static LazySingleton instance = null;     private LazySingleton() { }     synchronized public static LazySingleton getInstance() {         if (instance == null) {            instance = new LazySingleton();         }        return instance;     }}</code></pre><p>getInstance()方法带锁，并发度很低，如果频繁调用，需要频繁开关锁的话，效率是很低的。</p><h2 id="3-3-兼顾效率和安全性的方式-饱汉-饿汉"><a href="#3-3-兼顾效率和安全性的方式-饱汉-饿汉" class="headerlink" title="3.3 兼顾效率和安全性的方式(饱汉+饿汉)"></a>3.3 兼顾效率和安全性的方式(饱汉+饿汉)</h2><pre><code>class LazySingleton {     private static LazySingleton instance；     private LazySingleton() { }     public static LazySingleton getInstance() {         if (instance == null) {            synchronized(LazySingleton.class) {                instance = new LazySingleton();             }        }        return instance;     }}</code></pre><h2 id="3-4-使用静态内部类"><a href="#3-4-使用静态内部类" class="headerlink" title="3.4 使用静态内部类"></a>3.4 使用静态内部类</h2><p>利用Java的静态内部类，因为静态内部类只有在被调用的时候，才会被加载。而静态内部类的唯一性，线程安全型都由JVM来保证。</p><p>public class LazySingleton {<br>    private static class LazySingletonHolder{<br>        private static final LazySingleton instance = new LazySingleton();<br>    }</p><pre><code>public static LazySingleton getInstance() {    return LazySingletonHolder.instance;}</code></pre><p>}</p><h1 id="4-单例的问题"><a href="#4-单例的问题" class="headerlink" title="4. 单例的问题"></a>4. 单例的问题</h1><ul><li>违背了基于接口而非实现的设计原则，如果我们想要更改的话，是需要到每个类的位置去做更改的</li><li>单例会隐藏类之间的依赖关系<ul><li>一般来说我们通过构造函数，参数传递来声明类之间的依赖关系</li><li>单例不需要显示创建，不需要依赖参数传递，在函数中直接调用</li><li>对代码的扩展性不友好<h1 id="5-优缺点分析"><a href="#5-优缺点分析" class="headerlink" title="5. 优缺点分析"></a>5. 优缺点分析</h1></li></ul></li></ul><h2 id="5-1-优点"><a href="#5-1-优点" class="headerlink" title="5.1 优点"></a>5.1 优点</h2><ol><li>提供了对唯一实例的访问控制</li><li>因为内存中只存在一个对象，因此可以节约系统资源。尤其是对于一些需要频繁创建和销毁的对象，单例模式可以很大程度上提高系统性能</li></ol><h2 id="5-2-缺点"><a href="#5-2-缺点" class="headerlink" title="5.2 缺点"></a>5.2 缺点</h2><ol><li>扩展困难</li><li>职责相对比较重。因为单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身的功能融合到一起。</li><li>一些语言的垃圾自动回收技术，如果实例化的对象在一段时间内没有被使用，系统会认为它是垃圾，会自动销毁并回收资源。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-为什么需要单例模式&quot;&gt;&lt;a href=&quot;#1-为什么需要单例模式&quot; class=&quot;headerlink&quot; title=&quot;1. 为什么需要单例模式&quot;&gt;&lt;/a&gt;1. 为什么需要单例模式&lt;/h1&gt;&lt;p&gt;windows系统的任务管理器，只能有一个,唯一性的原因：&lt;/p
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="Design Pattern" scheme="https://www.llchen60.com/tags/Design-Pattern/"/>
    
  </entry>
  
</feed>
