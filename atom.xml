<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Leilei&#39;s Blog | 磊磊的博客</title>
  
  <subtitle>Because it&#39;s there</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.llchen60.com/"/>
  <updated>2020-02-06T03:02:58.113Z</updated>
  <id>https://www.llchen60.com/</id>
  
  <author>
    <name>Leilei Chen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java 反射机制</title>
    <link href="https://www.llchen60.com/Java-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
    <id>https://www.llchen60.com/Java-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</id>
    <published>2020-02-06T03:02:35.000Z</published>
    <updated>2020-02-06T03:02:58.113Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h1><p>Java反射机制是在运行时用来判定或者修改方法，类，接口的行为的API。</p><ul><li><p>反射可以告诉我们类和对象之间的信息，以及我们可以用类的哪些方法来使用这个对象</p></li><li><p>通过反射，我们就可以在运行的时候赋予类一个新的对象</p></li></ul><h1 id="2-使用范例"><a href="#2-使用范例" class="headerlink" title="2. 使用范例"></a>2. 使用范例</h1><p>反射可以用来获取关于类，构造器和方法的信息：</p><ul><li><p>class: getClass()方法可以用来获取对象属于的类的名字</p></li><li><p>Constructors: getConstructor()可以用来获取对象属于的类的public的构造器</p></li><li><p>getMethods() 可以用来获取对象属于的类的public的方法</p><p>  // A simple Java program to demonstrate the use of reflection<br>  import java.lang.reflect.Method;<br>  import java.lang.reflect.Field;<br>  import java.lang.reflect.Constructor; </p><p>  // class whose object is to be created<br>  class Test<br>  { </p><pre><code>  // creating a private field   private String s;   // creating a public constructor   public Test() { s = &quot;GeeksforGeeks&quot;; }   // Creating a public method with no arguments   public void method1() {       System.out.println(&quot;The string is &quot; + s);   }   // Creating a public method with int as argument   public void method2(int n) {       System.out.println(&quot;The number is &quot; + n);   }   // creating a private method   private void method3() {       System.out.println(&quot;Private method invoked&quot;);   } </code></pre><p>  } </p><p>  class Demo<br>  { </p><pre><code>  public static void main(String args[]) throws Exception   {       // Creating object whose property is to be checked       Test obj = new Test();           // 构建类的对象      // getclass method       Class cls = obj.getClass();       System.out.println(&quot;The name of class is &quot; +                           cls.getName());       // Getting the constructor of the class through the       // object of the class       Constructor constructor = cls.getConstructor();       System.out.println(&quot;The name of constructor is &quot; +                           constructor.getName());       System.out.println(&quot;The public methods of class are : &quot;);       // Getting methods of the class through the object       // of the class by using getMethods       Method[] methods = cls.getMethods();       // Printing method names       for (Method method:methods)           System.out.println(method.getName());       // creates object of desired method by providing the       // method name and parameter class as arguments to       // the getDeclaredMethod        // 这里是通过方法的名字和输入变量来获取对应的方法      Method methodcall1 = cls.getDeclaredMethod(&quot;method2&quot;,                                               int.class);       // invokes the method at runtime       // 这里是在运行时执行这个方法       methodcall1.invoke(obj, 19);       // creates object of the desired field by providing       // the name of field as argument to the       // getDeclaredField method       // 运行时获取对应的private的变量      Field field = cls.getDeclaredField(&quot;s&quot;);       // allows the object to access the field irrespective       // of the access specifier used with the field       // 将这个变量设成可以获取的      field.setAccessible(true);       // takes object and the new value to be assigned       // to the field as arguments       field.set(obj, &quot;JAVA&quot;);       // Creates object of desired method by providing the       // method name as argument to the getDeclaredMethod       Method methodcall2 = cls.getDeclaredMethod(&quot;method1&quot;);       // invokes the method at runtime       methodcall2.invoke(obj);       // Creates object of the desired method by providing       // the name of method as argument to the       // getDeclaredMethod method       Method methodcall3 = cls.getDeclaredMethod(&quot;method3&quot;);       // allows the object to access the method irrespective       // of the access specifier used with the method       methodcall3.setAccessible(true);       // invokes the method at runtime       methodcall3.invoke(obj);   } </code></pre><p>  } </p></li></ul><h1 id="3-详细分析"><a href="#3-详细分析" class="headerlink" title="3. 详细分析"></a>3. 详细分析</h1><p>反射一言以蔽之，即在运行时拿到class，并创建类对应的对象的方式。这种好处是更具灵活性，劣势是会慢很多，代码会相对难理解些。</p><p>从代码本身的角度来讲，是指一部分代码有能力去观察/检查另一部分代码。用已知的部分合理推断出未知的部分，这未知的部分其实是指还不知道的信息。</p><p>一般来说在Java里我们都是和注解一起来使用反射的，</p><h1 id="4-优劣势"><a href="#4-优劣势" class="headerlink" title="4. 优劣势"></a>4. 优劣势</h1><ul><li>好处<ul><li>反射是什么呢？当我们的程序在运行时，需要动态的加载一些类这些类可能之前用不到所以不用加载到jvm，而是在运行时根据需要才加载，这样的好处对于服务器来说不言而喻，举个例子我们的项目底层有时是用mysql，有时用oracle，<strong>需要动态地根据实际情况加载驱动类，这个时候反射就有用了</strong>，假设 <code>com.java.dbtest.myqlConnection</code>，<code>com.java.dbtest.oracleConnection</code>这两个类我们要用，这时候我们的程序就写得比较动态化，通过<code>Class tc = Class.forName(&quot;com.java.dbtest.TestConnection&quot;);</code>通过类的全类名让jvm在服务器中找到并加载这个类，而如果是oracle则传入的参数就变成另一个了。这时候就可以看到反射的好处了，这个动态性就体现出java的特性了！</li><li>更具拓展性，可以在运行时获取信息</li><li>获取一些private的域的值方便debug</li></ul></li><li>劣势<ul><li>更慢，有延时</li><li>会暴露一些接口</li><li>反射会要求运行的许可，当在secure manager下来运行可能不被允许</li></ul></li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://stackoverflow.com/questions/37628/what-is-reflection-and-why-is-it-useful" target="_blank" rel="noopener">https://stackoverflow.com/questions/37628/what-is-reflection-and-why-is-it-useful</a></li><li><a href="https://docs.oracle.com/javase/tutorial/reflect/index.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/tutorial/reflect/index.html</a></li><li><a href="https://docs.oracle.com/javase/tutorial/reflect/class/index.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/tutorial/reflect/class/index.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-介绍&quot;&gt;&lt;a href=&quot;#1-介绍&quot; class=&quot;headerlink&quot; title=&quot;1. 介绍&quot;&gt;&lt;/a&gt;1. 介绍&lt;/h1&gt;&lt;p&gt;Java反射机制是在运行时用来判定或者修改方法，类，接口的行为的API。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;反射可以告诉我
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
      <category term="Reflection" scheme="https://www.llchen60.com/tags/Reflection/"/>
    
  </entry>
  
  <entry>
    <title>java - serialization</title>
    <link href="https://www.llchen60.com/java-serialization/"/>
    <id>https://www.llchen60.com/java-serialization/</id>
    <published>2020-02-06T03:01:26.000Z</published>
    <updated>2020-02-06T03:01:43.795Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a>1. Overview</h1><p>An object is eligible for serialization if and only if its class implements the <strong>java.io.Serializable</strong> interface. Serializable is a marker interface (contains no methods) that tell the Java Virtual Machine (JVM) that the objects of this class is ready for being written to and read from a persistent storage or over the network.</p><h1 id="2-Why-we-need-serialization"><a href="#2-Why-we-need-serialization" class="headerlink" title="2. Why we need serialization?"></a>2. Why we need serialization?</h1><p>It’s used when the need arises to send data/ object over network or stored in files.</p><p>The thing is network and hard disk are hardware component that understand bits and bytes but not Java Objects. </p><p>Serialization is the translation of your Java object’s values/states to bytes to send it over network or save it.</p><p>Also used to store into database. </p><h1 id="3-Implementation"><a href="#3-Implementation" class="headerlink" title="3. Implementation"></a>3. Implementation</h1><p>Ways for serialize/ deserialize  – xml JSON </p><p>Serialization process is instance independent. </p><ul><li>ObjectInputStream <ul><li>extends java.io.InputStream </li></ul></li></ul><pre><code>public final Object readObject() throws IOException, ClassNotFoundException;</code></pre><ul><li>ObjectOutputStream <ul><li>extends java.io.OutputStream</li></ul></li></ul><pre><code>public final void writeObject(Object o) throws IOException;</code></pre><h2 id="3-1-Example"><a href="#3-1-Example" class="headerlink" title="3.1 Example"></a>3.1 Example</h2><pre><code>public class Person implements Serializable {    private static final long serialVersionUID = 1L;    static String country = &quot;ITALY&quot;;    private int age;    private String name;    transient int height;    // getters and setters}@Testpublic void whenSerializingAndDeserializing_ThenObjectIsTheSame() ()   throws IOException, ClassNotFoundException {     Person person = new Person();    person.setAge(20);    person.setName(&quot;Joe&quot;);    FileOutputStream fileOutputStream      = new FileOutputStream(&quot;yourfile.txt&quot;);    ObjectOutputStream objectOutputStream       = new ObjectOutputStream(fileOutputStream);    objectOutputStream.writeObject(person);    objectOutputStream.flush();    objectOutputStream.close();    FileInputStream fileInputStream      = new FileInputStream(&quot;yourfile.txt&quot;);    ObjectInputStream objectInputStream      = new ObjectInputStream(fileInputStream);    Person p2 = (Person) objectInputStream.readObject();    objectInputStream.close();     assertTrue(p2.getAge() == p.getAge());    assertTrue(p2.getName().equals(p.getName()));}</code></pre><h1 id="4-Caveats"><a href="#4-Caveats" class="headerlink" title="4. Caveats"></a>4. Caveats</h1><ol><li>When a class implements the java.io.Serializable interface, all <strong>its sub-classes are serializable as well</strong>.</li><li>when an object has a reference to another object, these objects must implement the Serializable interface separately, or else a NotSerializableException will be thrown</li><li>JVM associates a version number with each serializable class. </li></ol><p>Reference</p><ol><li><a href="https://www.codejava.net/java-se/file-io/why-do-we-need-serialization-in-java" target="_blank" rel="noopener">https://www.codejava.net/java-se/file-io/why-do-we-need-serialization-in-java</a></li><li><a href="https://www.baeldung.com/java-serialization" target="_blank" rel="noopener">https://www.baeldung.com/java-serialization</a></li><li><a href="https://www.geeksforgeeks.org/serialization-in-java/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/serialization-in-java/</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Overview&quot;&gt;&lt;a href=&quot;#1-Overview&quot; class=&quot;headerlink&quot; title=&quot;1. Overview&quot;&gt;&lt;/a&gt;1. Overview&lt;/h1&gt;&lt;p&gt;An object is eligible for serializat
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java Pattern Regex表达式</title>
    <link href="https://www.llchen60.com/Java-Pattern-Regex%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://www.llchen60.com/Java-Pattern-Regex%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2020-02-06T03:00:32.000Z</published>
    <updated>2020-02-06T03:00:54.343Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-为什么要使用Pattern？"><a href="#1-为什么要使用Pattern？" class="headerlink" title="1. 为什么要使用Pattern？"></a>1. 为什么要使用Pattern？</h1><p>一般来说如果我们要对String做某个范式下的替换时，我们需要使用</p><pre><code>stringEG.replaceAll(&quot;(?i)@gmail\\.com$&quot;, &quot;&quot;);</code></pre><p>上面这行代码是将stringEG最后的@gmail.com给替换掉，通过这种方式来获得用户名。</p><p>这种Replace操作我们会经常使用，但是上述有一个问题，即每次运行都要执行一遍Regex操作，这样很费时间，每次都要进行编译，Pattern可以帮助我们解决这个问题。</p><p>通过设置static的变量，我们可以将Compile完的结果存起来，然后在需要的时候直接使用这个结果即可。</p><p>使用方法如下所示:</p><pre><code>private static final Pattern USER_NAME_PATTERN = Pattern.compile(&quot;(?i)@gmail\\.com$);final String username =  USER_NAME_PATTERN.matcher(stringEG.replace(&quot;&quot;));</code></pre><h1 id="2-如何使用Pattern？"><a href="#2-如何使用Pattern？" class="headerlink" title="2. 如何使用Pattern？"></a>2. 如何使用Pattern？</h1><p>使用Java Pattern，重点在于对于正则表达式的使用，可以看一下文章 - <a href="https://llchen60.com/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" target="_blank" rel="noopener">正则表达式</a>, 里面有对正则的详细介绍。</p><p>Pattern对象是一个已经编译过的正则表达式的表达，Pattern类没有public的构造器，想要创建一个Pattern，我们需要首先调用其静态的compile()方法，通过这个方法会得到一个Pattern对象。</p><p>Matcher 对象用来解释正则表达式然后根据表达式来找符合规则的相关表达，同样没有public的构造器，通过调用matcher() 方法来作比较</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-为什么要使用Pattern？&quot;&gt;&lt;a href=&quot;#1-为什么要使用Pattern？&quot; class=&quot;headerlink&quot; title=&quot;1. 为什么要使用Pattern？&quot;&gt;&lt;/a&gt;1. 为什么要使用Pattern？&lt;/h1&gt;&lt;p&gt;一般来说如果我们要对St
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
      <category term="Regex" scheme="https://www.llchen60.com/tags/Regex/"/>
    
  </entry>
  
  <entry>
    <title>Java map() 与 flatMap()的比较</title>
    <link href="https://www.llchen60.com/Java-map-%E4%B8%8E-flatMap-%E7%9A%84%E6%AF%94%E8%BE%83/"/>
    <id>https://www.llchen60.com/Java-map-%E4%B8%8E-flatMap-%E7%9A%84%E6%AF%94%E8%BE%83/</id>
    <published>2020-02-06T02:59:48.000Z</published>
    <updated>2020-02-06T03:00:06.496Z</updated>
    
    <content type="html"><![CDATA[<p><code>map()</code>和<code>flatMap()</code>方法都来自于functional languages. 在Java8当中，我们可以在Optional, Stream还有CompletableFuture当中找到他们。</p><p>Stream代表一些列的对象，而Optional代表一个存在或者空的值。<code>map()</code>和<code>flatmap()</code>都是聚合方法，尽管其有着相同的返回类型，但是实际上他们有很多的不同。下面我们通过例子来逐一展现。</p><h1 id="1-在Optionals当中"><a href="#1-在Optionals当中" class="headerlink" title="1. 在Optionals当中"></a>1. 在Optionals当中</h1><pre><code>// map()Optional&lt;String&gt; s = Optional.of(&quot;Test&quot;);assertEquals(Optional.of(&quot;TEST&quot;), s.map(String::toUpperCase));// 如果情况更为复杂，变成Optional&lt;Optional&lt;String&gt;&gt;assertEquals(Optional.of(Optional.of(&quot;STRING&quot;)),     Optional.of(&quot;string&quot;).map(s -&gt; Optional.of(&quot;STRING&quot;)));// 同样的代码用flatmap来表示assertEquals(Optional.of(&quot;STRING&quot;), Optional.of(&quot;string&quot;).flatMap(s -&gt; Optional.of(&quot;STRING&quot;)));</code></pre><h1 id="2-在Streams当中"><a href="#2-在Streams当中" class="headerlink" title="2. 在Streams当中"></a>2. 在Streams当中</h1><p>map方法只能做一层的序列化，但是flatmap可以做多层的，来解决Stream&lt;Stream<R>&gt;的这种结构的问题。</p><pre><code>// 对于这种多层架构的, map()方法就显得力有未逮了List&lt;List&lt;String&gt;&gt; list = Arrays.asList(  Arrays.asList(&quot;a&quot;),  Arrays.asList(&quot;b&quot;));System.out.println(list);// flatmap可以很好的解决System.out.println(list.stream().flatMap(Collection::stream).collect(Collectors.toList()));</code></pre><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://www.baeldung.com/java-difference-map-and-flatmap" target="_blank" rel="noopener">https://www.baeldung.com/java-difference-map-and-flatmap</a></li><li><a href="https://www.mkyong.com/java8/java-8-flatmap-example/" target="_blank" rel="noopener">https://www.mkyong.com/java8/java-8-flatmap-example/</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;map()&lt;/code&gt;和&lt;code&gt;flatMap()&lt;/code&gt;方法都来自于functional languages. 在Java8当中，我们可以在Optional, Stream还有CompletableFuture当中找到他们。&lt;/p&gt;
&lt;p&gt;Stre
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
      <category term="Map" scheme="https://www.llchen60.com/tags/Map/"/>
    
  </entry>
  
  <entry>
    <title>Java - ExecutorService</title>
    <link href="https://www.llchen60.com/Java-ExecutorService/"/>
    <id>https://www.llchen60.com/Java-ExecutorService/</id>
    <published>2020-02-06T02:58:50.000Z</published>
    <updated>2020-02-06T02:59:23.181Z</updated>
    
    <content type="html"><![CDATA[<p>ExecutorService is a framework provided by the JDK which simplifies the execution of tasks in <strong><em>asynchronous</em></strong> mode. ExecutorService automatically provides a pool of threads and API for assigning tasks to it. </p><h1 id="1-Instantiation"><a href="#1-Instantiation" class="headerlink" title="1. Instantiation"></a>1. Instantiation</h1><h2 id="1-1-Factory-methods-of-Executors-class"><a href="#1-1-Factory-methods-of-Executors-class" class="headerlink" title="1.1 Factory methods of Executors class"></a>1.1 Factory methods of Executors class</h2><p>Use its factory methods of the Executors class to create ExecutorService. </p><pre><code>ExecutorService executor = Executors.newFixedThreadPool(10);</code></pre><h2 id="1-2-Directly-create"><a href="#1-2-Directly-create" class="headerlink" title="1.2 Directly create"></a>1.2 Directly create</h2><pre><code>ExecutorService executorService =   new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS,     new LinkedBlockingQueue&lt;Runnable&gt;());</code></pre><h1 id="2-Assigning-Tasks"><a href="#2-Assigning-Tasks" class="headerlink" title="2. Assigning Tasks"></a>2. Assigning Tasks</h1><p>ExecutorService can execute Runnable and Callable tasks. </p><pre><code>Runnable runnableTask = () -&gt; {    try {        TimeUnit.MILLISECONDS.sleep(300);    } catch (InterruptedException e) {        e.printStackTrace();    }};Callable&lt;String&gt; callableTask = () -&gt; {    TimeUnit.MILLISECONDS.sleep(300);    return &quot;Task&#39;s execution&quot;;};List&lt;Callable&lt;String&gt;&gt; callableTasks = new ArrayList&lt;&gt;();callableTasks.add(callableTask);callableTasks.add(callableTask);callableTasks.add(callableTask);</code></pre><h2 id="2-1-execute"><a href="#2-1-execute" class="headerlink" title="2.1 execute()"></a>2.1 execute()</h2><p>The execute() method is void, and it doesn’t give any possibility to get the result of task’s execution or to check the task’s status (is it running or executed).</p><pre><code>executerService.execute(runnableTask);</code></pre><h2 id="2-2-submit"><a href="#2-2-submit" class="headerlink" title="2.2 submit()"></a>2.2 submit()</h2><p>submit() submits a Callable or a Runnable task to an ExecutorService and returns a result of type Future.</p><pre><code>Future&lt;String&gt; future = executorService.submit(callableTask);</code></pre><h2 id="2-3-invokeAny"><a href="#2-3-invokeAny" class="headerlink" title="2.3 invokeAny()"></a>2.3 invokeAny()</h2><p>invokeAny() assigns a collection of tasks to an ExecutorService, causing each to be executed, and returns the result of a successful execution of one task (if there was a successful execution).</p><pre><code>String result = executorService.invokeAny(callableTasks);</code></pre><h2 id="2-4-invokeAll"><a href="#2-4-invokeAll" class="headerlink" title="2.4 invokeAll()"></a>2.4 invokeAll()</h2><p>invokeAll() assigns a collection of tasks to an ExecutorService, causing each to be executed, and returns the result of all task executions in the form of a list of objects of type Future.</p><pre><code>List&lt;Future&lt;String&gt;&gt; futures = executorService.invokeAll(callableTasks);</code></pre><h1 id="3-Shutdown"><a href="#3-Shutdown" class="headerlink" title="3. Shutdown"></a>3. Shutdown</h1><p>In general, the ExecutorService will not be automatically destroyed when there is not task to process. It will stay alive and wait for new work to do.</p><p>In some cases this is very helpful; for example, if an app needs to process tasks which appear on an irregular basis or the quantity of these tasks is not known at compile time.</p><p>On the other hand, an app could reach its end, but it will not be stopped because a waiting ExecutorService will cause the JVM to keep running.</p><h2 id="3-1-shutdown"><a href="#3-1-shutdown" class="headerlink" title="3.1 shutdown()"></a>3.1 shutdown()</h2><p>The shutdown() method doesn’t cause an immediate destruction of the ExecutorService. It will make the ExecutorService stop accepting new tasks and shut down after all running threads finish their current work.</p><pre><code>executorService.shutdown();</code></pre><h2 id="3-2-shutdownNow"><a href="#3-2-shutdownNow" class="headerlink" title="3.2 shutdownNow()"></a>3.2 shutdownNow()</h2><p>The shutdownNow() method tries to destroy the ExecutorService immediately, but it doesn’t guarantee that all the running threads will be stopped at the same time. This method returns a list of tasks which are waiting to be processed. It is up to the developer to decide what to do with these tasks.</p><pre><code>List&lt;Runnable&gt; notExecutedTasks = executorService.shutDownNow();</code></pre><h2 id="3-3-best-behavior"><a href="#3-3-best-behavior" class="headerlink" title="3.3 best behavior"></a>3.3 best behavior</h2><pre><code>executorService.shutdown();try {    if (!executorService.awaitTermination(800, TimeUnit.MILLISECONDS)) {        executorService.shutdownNow();    } } catch (InterruptedException e) {    executorService.shutdownNow();}</code></pre><h1 id="4-Future-interface"><a href="#4-Future-interface" class="headerlink" title="4. Future interface"></a>4. Future interface</h1><p>Future interface provides a <code>get()</code> which returns an actual result of the Callable task’s execution or null in the case of Runnable task. Calling the get() method while the task is still running will cause execution to block until the task is properly executed and the result is available.</p><pre><code>Future&lt;String&gt; future = executorService.submit(callableTask);String result = null;try {    result = future.get();} catch (InterruptedException | ExecutionException e) {    e.printStackTrace();}</code></pre><p>With very long blocking caused by the get() method, an application’s performance can degrade. If the resulting data is not crucial, it is possible to avoid such a problem by using timeouts:</p><pre><code>String result = future.get(200, TimeUnit.MILLISECONDS);</code></pre><p>some other methods provided:</p><pre><code>cancel()isCancelled()isDone() </code></pre><h1 id="5-How-to-sync-the-value-across-different-threads"><a href="#5-How-to-sync-the-value-across-different-threads" class="headerlink" title="5. How to sync the value across different threads?"></a>5. How to sync the value across different threads?</h1><p>Suppose we have i++ in several threads, and they all perform such operations. To make the i computed properly, we need to make it atomic. </p><p>Use <code>AtomicInteger</code> or <code>synchronized</code> to get the final correct result. </p><p>Notice, <code>volatile</code> cannot make sure the final result is correct. It mainly makes sure the visibility of newest value, but there is possibility that we mound and switch to other thread before the new value being recorded. </p><p>AtomicInteger class uses CAS(Compare and swap) low level CPU operations. They allow you to modify a particular variable only if the present value is equal to something else (and is returned successfully).</p><h1 id="6-Executor-execute-and-ExecutorService-submit-differences"><a href="#6-Executor-execute-and-ExecutorService-submit-differences" class="headerlink" title="6. Executor.execute() and ExecutorService.submit() differences"></a>6. Executor.execute() and ExecutorService.submit() differences</h1><ol><li>execute(Runnable) does not return anything; while submit(Callable<T>) returns a Future object which allows a way to programatically cancel the running thread and get the return result. </li><li>submit() can accept both Runnable and Callable task but execute() can only accept the Runnable task</li><li>submit() return a Future object while execute() has no return</li><li>get() is a blocking call, which will take some time</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ExecutorService is a framework provided by the JDK which simplifies the execution of tasks in &lt;strong&gt;&lt;em&gt;asynchronous&lt;/em&gt;&lt;/strong&gt; mode
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
      <category term="Executor Service" scheme="https://www.llchen60.com/tags/Executor-Service/"/>
    
  </entry>
  
  <entry>
    <title>Java - callback</title>
    <link href="https://www.llchen60.com/Java-callback/"/>
    <id>https://www.llchen60.com/Java-callback/</id>
    <published>2020-02-06T02:57:58.000Z</published>
    <updated>2020-02-06T02:58:23.254Z</updated>
    
    <content type="html"><![CDATA[<p>In C/ C++, callback refers to the mechanism of calling a function from another function. Memory address of a function is represented as function pointer here. SO the callback is achieved by passing the pointer of func1() to func2().</p><p>However, in java, there is no function pointer existing. And we use a callback object or a callback interface, and the interface is passed that refers to the location of a function. </p><p>Below is an example to compute tax by state tax and fedaral tax. Suppose federal tax keeps same while state tax vary by state. We can build interface and implements interface to realize it.<br>    // Java program to demonstrate callback mechanism<br>    // using interface is Java </p><pre><code>// Create interface import java.util.Scanner; interface STax {     double stateTax(); } // Implementation class of Punjab state tax class Punjab implements STax {     public double stateTax()     {         return 3000.0;     } } // Implementation class of Himachal Pardesh state tax class HP implements STax {     public double stateTax()     {         return 1000.0;     } } class TAX {     public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException     {         Scanner sc = new Scanner(System.in);         System.out.println(&quot;Enter the state name&quot;);         String state = sc.next(); // name of the state         // The state name is then stored in an object c         Class c = Class.forName(state);         // Create the new object of the class whose name is in c         // Stax interface reference is now referencing that new object         STax ref = (STax)c.newInstance();         /*Call the method to calculate total tax         and pass interface reference - this is callback .         Here, ref may refer to stateTax() of Punjab or HP classes         depending on the class for which the object is created         in the previous step         */        calculateTax(ref);     }     static void calculateTax(STax t)     {         // calculate central tax         double ct = 2000.0;         // calculate state tax         double st = t.stateTax();         double totaltax = st + ct;         // display total tax         System.out.println(&quot;Total tax =&quot; + totaltax);     } } </code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;In C/ C++, callback refers to the mechanism of calling a function from another function. Memory address of a function is represented as f
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Callback" scheme="https://www.llchen60.com/tags/Callback/"/>
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java Annotations 注解详解</title>
    <link href="https://www.llchen60.com/Java-Annotations-%E6%B3%A8%E8%A7%A3%E8%AF%A6%E8%A7%A3/"/>
    <id>https://www.llchen60.com/Java-Annotations-%E6%B3%A8%E8%A7%A3%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-02-06T02:57:11.000Z</published>
    <updated>2020-02-06T02:57:33.469Z</updated>
    
    <content type="html"><![CDATA[<p>Java annotation很有用，这篇博客会带着大家去理解Annotation的语法以及用法，希望能有所裨益。</p><h1 id="1-Annotation架构"><a href="#1-Annotation架构" class="headerlink" title="1. Annotation架构"></a>1. Annotation架构</h1><h2 id="1-0-Annotation的介绍"><a href="#1-0-Annotation的介绍" class="headerlink" title="1.0 Annotation的介绍"></a>1.0 Annotation的介绍</h2><p>用一句话来解释Annotation的话，我想可以称其为Metadata(元数据) - 即数据的数据。</p><p>举个例子，比如这里我使用了@Override：</p><pre><code>@Overridepublic String toString() {return &quot;This is String Representation of current object.&quot;;}</code></pre><p>通过注解的方式，我告诉编译器我重写了这个toString()的方法。但其实就算我没有加这个注解，代码仍然是可以有效运行的，那么用注解的好处有哪些呢？为什么我们需要使用注解呢？？？ </p><p>上述的注解告诉编译器我重写了父类里面的一个方法，然后编译器会去父类检查看这个方法是否存在，如果不存在的话，那就会扔出一个编译错误。通过这种方式我们可以减少错误的发生，并且提高整个代码的可读性，给我们带来一些便利。</p><p>其实就像上面说的那样，注解是一种携带元数据的方式，我们实际上在注解之前是用XML来做元数据的存储的。二者各有自己的适用场景。对于XML来说，如果你写的应用有大量的常数，参量，用XML会更好，因为我们可以将这些常量和代码完全解耦，这样在改变常量值的时候会方便很多。如果你想对外暴露一些方法来做服务，那注解会是更好的选择。因为这种情形下元数据最好和方法紧密相连，让开发者意识到这个方法的一些特征。</p><p>另外注解提供了一个标准的在代码中定义元数据的方式，在注解之前工程师常会自己定义，比如注释，接口，等等。注解将这个过程做了标准化。</p><h2 id="1-1-Annotation-组成部分"><a href="#1-1-Annotation-组成部分" class="headerlink" title="1.1 Annotation 组成部分"></a>1.1 Annotation 组成部分</h2><p><img src="fig1.jpg" alt="fig1.jpg"></p><ul><li>Annotation<ul><li>1 RetentionPolicy 每一个注解对象都会有唯一的RetentionPolicy属性</li><li>1 - n ElementType  每个注解对象都可以有若干个ElementType属性</li><li>Annotation有多个实现类，包括<ul><li>Deprecated </li><li>Documented</li><li>Inherited </li><li>Override </li><li>Retention </li><li>Target </li></ul></li></ul></li></ul><p>第一个很重要的观念，就是<strong><em>注解只是元数据，它不包括任何真正的代码逻辑</em></strong>。</p><p>第二个很重要的观念，建立在第一个的基础之上，即如果注解不包括代码逻辑，那么就一定有针对注解的消费者，来读取注解提供的信息，并且执行对应的代码逻辑。</p><p>比如以@override为例，这里JVM就是这个注解的消费者，并且在字节码的水平利用注解信息。</p><h3 id="1-1-1-Annotation-java"><a href="#1-1-1-Annotation-java" class="headerlink" title="1.1.1 Annotation.java"></a>1.1.1 Annotation.java</h3><pre><code>package java.lang.annotation;public interface Annotation {    boolean equals(Object obj);    int hashCode();    String toString();    Class&lt;? extends Annotation&gt; annotationType();}</code></pre><p>一个接口</p><h3 id="1-1-2-ElementType-java"><a href="#1-1-2-ElementType-java" class="headerlink" title="1.1.2 ElementType.java"></a>1.1.2 ElementType.java</h3><pre><code>package java.lang.annotation;public enum ElementType {    TYPE,               /* 类、接口（包括注释类型）或枚举声明  */    FIELD,              /* 字段声明（包括枚举常量）  */    METHOD,             /* 方法声明  */    PARAMETER,          /* 参数声明  */    CONSTRUCTOR,        /* 构造方法声明  */    LOCAL_VARIABLE,     /* 局部变量声明  */    ANNOTATION_TYPE,    /* 注释类型声明  */    PACKAGE             /* 包声明  */}</code></pre><p>枚举类型，用来指定Annotation的类型。就是这个注解对象是用来修饰什么的，是方法，是变量，还是其他的各种…</p><h3 id="1-1-3-RetentionPolicy-java"><a href="#1-1-3-RetentionPolicy-java" class="headerlink" title="1.1.3 RetentionPolicy.java"></a>1.1.3 RetentionPolicy.java</h3><pre><code>package java.lang.annotation;public enum RetentionPolicy {    SOURCE,            /* Annotation信息仅存在于编译器处理期间，编译器处理完之后就没有该Annotation信息了  */    CLASS,             /* 编译器将Annotation存储于类对应的.class文件中。默认行为  */    RUNTIME            /* 编译器将Annotation存储于class文件中，并且可由JVM读入 */}</code></pre><p>RetentionPolicy是Enum枚举类型，每个都有其对应的行为。</p><p><strong>RetentionPolicy.SOURCE</strong> – Discard during the compile. These annotations don’t make any sense after the compile has completed, so they aren’t written to the bytecode. Examples @Override, @SuppressWarnings</p><p><strong>RetentionPolicy.CLASS</strong> – Discard during class load. Useful when doing bytecode-level post-processing. Somewhat surprisingly, this is the default.</p><p><strong>RetentionPolicy.RUNTIME</strong> – Do not discard. The annotation should be available for reflection at runtime. This is what we generally use for our custom annotations.</p><h2 id="1-2-通用定义"><a href="#1-2-通用定义" class="headerlink" title="1.2 通用定义"></a>1.2 通用定义</h2><pre><code>@Documented@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface MyAnnotation1 {}</code></pre><h3 id="1-2-1-interface"><a href="#1-2-1-interface" class="headerlink" title="1.2.1 @interface"></a>1.2.1 @interface</h3><p>意味着实现了java.lang.annotation.Annotation接口，即该注解就是一个Annotation。Annotation接口的实现细节都由编译器来完成的，通过@interface定义注解吼，该注解不能继承其他的注解或接口。</p><h3 id="1-2-2-Documented"><a href="#1-2-2-Documented" class="headerlink" title="1.2.2 @Documented"></a>1.2.2 @Documented</h3><p>类和方法的Annotation在缺省情况下是不出现在javadoc中的。如果使用@Documented修饰该Annotation，则表示它可以出现在javadoc中。</p><h3 id="1-2-3-Target-ElementType-TYPE"><a href="#1-2-3-Target-ElementType-TYPE" class="headerlink" title="1.2.3 @Target(ElementType.TYPE)"></a>1.2.3 @Target(ElementType.TYPE)</h3><p>ElementType是Annotation的类型属性，而@Target的作用，就是来指定类型属性的</p><p>有@Target，则该Annotation只能用于其所指定的地方；若没有，则该Annotation可以用于任何地方</p><h3 id="1-2-4-Retention-RetentionPolicy-RUNTIME"><a href="#1-2-4-Retention-RetentionPolicy-RUNTIME" class="headerlink" title="1.2.4 @Retention(RetentionPolicy.RUNTIME)"></a>1.2.4 @Retention(RetentionPolicy.RUNTIME)</h3><p>RetentionPolicy是Annotation的策略属性，</p><h2 id="1-3-常用Annotation"><a href="#1-3-常用Annotation" class="headerlink" title="1.3 常用Annotation"></a>1.3 常用Annotation</h2><h3 id="1-3-1-Deprecated"><a href="#1-3-1-Deprecated" class="headerlink" title="1.3.1 @Deprecated"></a>1.3.1 @Deprecated</h3><pre><code>@Documented@Retention(RetentionPolicy.RUNTIME)public @interface Deprecated {}</code></pre><ol><li>@interface – 它的用来修饰Deprecated，意味着Deprecated实现了java.lang.annotation.Annotation接口；即Deprecated就是一个注解。</li><li>@Documented – 它的作用是说明该注解能出现在javadoc中。</li><li>@Retention(RetentionPolicy.RUNTIME) – 它的作用是指定Deprecated的策略是RetentionPolicy.RUNTIME。这就意味着，编译器会将Deprecated的信息保留在.class文件中，并且能被虚拟机读取。</li><li>@Deprecated 所标注内容，不再被建议使用。<h3 id="1-3-2-Override"><a href="#1-3-2-Override" class="headerlink" title="1.3.2 @Override"></a>1.3.2 @Override</h3></li></ol><h3 id="1-3-3-Documented"><a href="#1-3-3-Documented" class="headerlink" title="1.3.3 @Documented"></a>1.3.3 @Documented</h3><h3 id="1-3-4-Inherited"><a href="#1-3-4-Inherited" class="headerlink" title="1.3.4 @Inherited"></a>1.3.4 @Inherited</h3><p>用来标注Annotation类型，所标注的Annotation具有继承性</p><pre><code>@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Inherited {}</code></pre><ol><li>@interface – 它的用来修饰Inherited，意味着Inherited实现了java.lang.annotation.Annotation接口；即Inherited就是一个注解。</li><li>@Documented – 它的作用是说明该注解能出现在javadoc中。</li><li>@Retention(RetentionPolicy.RUNTIME) – 它的作用是指定Inherited的策略是RetentionPolicy.RUNTIME。这就意味着，编译器会将Inherited的信息保留在.class文件中，并且能被虚拟机读取。</li><li>@Target(ElementType.ANNOTATION_TYPE) – 它的作用是指定Inherited的类型是ANNOTATION_TYPE。这就意味着，@Inherited只能被用来标注“Annotation类型”。</li></ol><h3 id="1-3-5-Retention"><a href="#1-3-5-Retention" class="headerlink" title="1.3.5 @Retention"></a>1.3.5 @Retention</h3><p>用来标注Annotation类型，用来指定RetentionPolicy属性</p><h3 id="1-3-6-Target"><a href="#1-3-6-Target" class="headerlink" title="1.3.6 @Target"></a>1.3.6 @Target</h3><p>@Target只能被用来标注“Annotation类型”，而且它被用来指定Annotation的ElementType属性。</p><h3 id="1-3-7-SuppressWarnings"><a href="#1-3-7-SuppressWarnings" class="headerlink" title="1.3.7 @SuppressWarnings"></a>1.3.7 @SuppressWarnings</h3><p>@SuppressWarnings 所标注内容产生的警告，编译器会对这些警告保持静默。</p><pre><code>@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})@Retention(RetentionPolicy.SOURCE)public @interface SuppressWarnings {    String[] value();}</code></pre><ol><li>@interface – 它的用来修饰SuppressWarnings，意味着SuppressWarnings实现了java.lang.annotation.Annotation接口；即SuppressWarnings就是一个注解。</li><li>@Retention(RetentionPolicy.SOURCE) – 它的作用是指定SuppressWarnings的策略是RetentionPolicy.SOURCE。这就意味着，SuppressWarnings信息仅存在于编译器处理期间，编译器处理完之后SuppressWarnings就没有作用了。</li><li>@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE}) – 它的作用是指定SuppressWarnings的类型同时包括TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE。</li></ol><ul><li>TYPE意味着，它能标注“类、接口（包括注释类型）或枚举声明”。</li><li>FIELD意味着，它能标注“字段声明”。</li><li>METHOD意味着，它能标注“方法”。</li><li>PARAMETER意味着，它能标注“参数”。</li><li>CONSTRUCTOR意味着，它能标注“构造方法”。</li><li>LOCAL_VARIABLE意味着，它能标注“局部变量”。</li></ul><ol start="4"><li>String[] value(); 意味着，SuppressWarnings能指定参数</li><li>SuppressWarnings 的作用是，让编译器对“它所标注的内容”的某些警告保持静默。例如，”@SuppressWarnings(value={“deprecation”, “unchecked”})” 表示对“它所标注的内容”中的 “SuppressWarnings不再建议使用警告”和“未检查的转换时的警告”保持沉默。<h1 id="2-创建自己的Annotation"><a href="#2-创建自己的Annotation" class="headerlink" title="2. 创建自己的Annotation"></a>2. 创建自己的Annotation</h1></li></ol><p>注解只支持基本类型，String，还有Enum。所有的注解的属性都被定义为方法，default的值也会在方法里提供。</p><pre><code>@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)@interface Todo {public enum Priority {LOW, MEDIUM, HIGH}public enum Status {STARTED, NOT_STARTED}String author() default &quot;Yash&quot;;Priority priority() default Priority.LOW;Status status() default Status.NOT_STARTED;}</code></pre><p>这里我们创建了一个新的注解，@Todo</p><pre><code>@Todo(priority = Todo.Priority.MEDIUM, author = &quot;Yashwant&quot;, status = Todo.Status.STARTED)public void incompleteMethod1() {    //一些业务逻辑}</code></pre><p>值得注意的一点，如果注解只有一个属性，那么它应该被命名为value,在使用它的时候不用使用具体的变量名了。</p><pre><code>@interface Author{String value();}@Author(&quot;Yashwant&quot;)public void someMethod() {}</code></pre><p>定义好注解以后，我们需要写注解的消费者，使用反射。</p><pre><code>Class businessLogicClass = BusinessLogic.class;for(Method method : businessLogicClass.getMethods()) {    Todo todoAnnotation = (Todo)method.getAnnotation(Todo.class);    if(todoAnnotation != null) {    System.out.println(&quot; Method Name : &quot; + method.getName());    System.out.println(&quot; Author : &quot; + todoAnnotation.author());    System.out.println(&quot; Priority : &quot; + todoAnnotation.priority());    System.out.println(&quot; Status : &quot; + todoAnnotation.status());    }}</code></pre><h1 id="3-Reference"><a href="#3-Reference" class="headerlink" title="3. Reference"></a>3. Reference</h1><ol><li><a href="https://www.cnblogs.com/skywang12345/p/3344137.html" target="_blank" rel="noopener">https://www.cnblogs.com/skywang12345/p/3344137.html</a> </li><li><a href="https://dzone.com/articles/how-annotations-work-java" target="_blank" rel="noopener">https://dzone.com/articles/how-annotations-work-java</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java annotation很有用，这篇博客会带着大家去理解Annotation的语法以及用法，希望能有所裨益。&lt;/p&gt;
&lt;h1 id=&quot;1-Annotation架构&quot;&gt;&lt;a href=&quot;#1-Annotation架构&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
      <category term="Annotations" scheme="https://www.llchen60.com/tags/Annotations/"/>
    
  </entry>
  
  <entry>
    <title>Jackson  java-json parser</title>
    <link href="https://www.llchen60.com/Jackson-java-json-parser/"/>
    <id>https://www.llchen60.com/Jackson-java-json-parser/</id>
    <published>2020-02-06T02:55:49.000Z</published>
    <updated>2020-02-06T02:56:25.555Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Intro"><a href="#1-Intro" class="headerlink" title="1. Intro"></a>1. Intro</h1><ul><li>JSON <ul><li>JavaScript Object Notation </li><li>Data exchange format between browsers and web servers </li></ul></li><li>Jackson <ul><li>2 main parsers <ul><li>ObjectMapper <ul><li>parse JSON into custom Java objects, or into a jackson specific tree structure </li></ul></li><li>JsonParser <ul><li>JSON pull parser, parsing JSON one token at a time </li></ul></li></ul></li><li>2 main JSON generator<ul><li>ObjectMapper </li><li>JsonGenerator<ul><li>generate JSON one token at a time </li></ul></li></ul></li><li>3 main packages <ul><li>Jackson Core</li><li>Jackson Annotations</li><li>Jackson Databind </li></ul></li></ul></li></ul><h1 id="2-Parsers-JSON-to-Java-Object"><a href="#2-Parsers-JSON-to-Java-Object" class="headerlink" title="2. Parsers - JSON to Java Object"></a>2. Parsers - JSON to Java Object</h1><pre><code>ObjectMapper objectMapper = new ObjectMapper();String lakers = &quot;{ \&quot;SuperStar\&quot;:\&quot;Kobe Bryant\&quot;}&quot;;try {    Lakers lakers = objectMapper.readValue(lakers, Lakers.class);} catch (IOException e) {    log.error(e);}@Datapublic class Lakers {    private String superStar;}</code></pre><h2 id="2-1-How-Jackson-ObjectMapper-matches-JSON-fields-to-Java-Fields"><a href="#2-1-How-Jackson-ObjectMapper-matches-JSON-fields-to-Java-Fields" class="headerlink" title="2.1 How Jackson ObjectMapper matches JSON fields to Java Fields?"></a>2.1 How Jackson ObjectMapper matches JSON fields to Java Fields?</h2><p>By default, Jackson maps the fields of a JSON object to fields in a Java object by matching the names of the JSON field to the getter and setter methods in the Java object.<br>Jackson removes the “get” and “set” part of the names of the getter and setter methods, and converts the first character of the remaining name to lowercase.</p><p>If you want to customize the parsing process, you may want to use a custom serializer and deserializer, or use Jackson Annotations </p><h2 id="2-2-Fail-on-Null-for-primitive-types"><a href="#2-2-Fail-on-Null-for-primitive-types" class="headerlink" title="2.2 Fail on Null for primitive types"></a>2.2 Fail on Null for primitive types</h2><p>We could configure the Jackson ObjectMapper to fail if a JSON string contains a field with its value set to null. </p><pre><code>ObjectMapper objectMapper = new ObjectMapper();objectMapper.configure(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES, true);</code></pre><h2 id="2-3-Jackson-JsonParser"><a href="#2-3-Jackson-JsonParser" class="headerlink" title="2.3 Jackson JsonParser"></a>2.3 Jackson JsonParser</h2><ul><li><p>lower level than the ObjectMapper </p><ul><li>faster than the ObjectMapper</li></ul></li><li><p>Create a JsonParser </p><ul><li><code>JsonFactory factory = new JsonFactory();</code></li><li><code>JsonParser parser = factory.createParser(carJson);</code></li></ul></li><li><p>Parsing Json with JsonParser</p><ul><li>break the JSON up into a sequence of tokens which you can iterate one by one </li></ul></li></ul><pre><code>String carJson =        &quot;{ \&quot;brand\&quot; : \&quot;Mercedes\&quot;, \&quot;doors\&quot; : 5 }&quot;;JsonFactory factory = new JsonFactory();JsonParser  parser  = factory.createParser(carJson);while(!parser.isClosed()){    JsonToken jsonToken = parser.nextToken();    System.out.println(&quot;jsonToken = &quot; + jsonToken);}</code></pre><h1 id="3-Generators-Java-Object-to-JSON"><a href="#3-Generators-Java-Object-to-JSON" class="headerlink" title="3. Generators - Java Object to JSON"></a>3. Generators - Java Object to JSON</h1><ul><li>ObjectMapper<ul><li>writeValue()</li><li>writeValueAsString()</li><li>writeValueAsBytes()</li></ul></li></ul><h2 id="3-1-Jackson-JsonGenerator"><a href="#3-1-Jackson-JsonGenerator" class="headerlink" title="3.1 Jackson JsonGenerator"></a>3.1 Jackson JsonGenerator</h2><ul><li>used to generate JSON from java objects </li></ul><pre><code>JsonFactory factory = new JsonFactory();JsonGenerator generator = factory.createGenerator(    new File(&quot;blabla&quot;), JsonEncoding.UTF8);</code></pre><h1 id="4-Jackson-JSON-Tree-Model"><a href="#4-Jackson-JSON-Tree-Model" class="headerlink" title="4. Jackson JSON Tree Model"></a>4. Jackson JSON Tree Model</h1><ul><li>A built-in tree model: used to represent a JSON object </li><li>Represented by the JsonNode class <ul><li>use the ObjectMapper to parse JSON into a JsonNode tree model</li></ul></li><li>JsonNode class lets you navigate the JSOn as a Java object in a quite flexible and dynamic way </li></ul><pre><code>String carJson =        &quot;{ \&quot;brand\&quot; : \&quot;Mercedes\&quot;, \&quot;doors\&quot; : 5 }&quot;;ObjectMapper objectMapper = new ObjectMapper();try {    JsonNode jsonNode = objectMapper.readValue(carJson, JsonNode.class);} catch (IOException e) {    e.printStackTrace();}// ways on how to access JSON fields, arrays and nested objects String carJson =    &quot;{ \&quot;brand\&quot; : \&quot;Mercedes\&quot;, \&quot;doors\&quot; : 5,&quot; +    &quot;  \&quot;owners\&quot; : [\&quot;John\&quot;, \&quot;Jack\&quot;, \&quot;Jill\&quot;],&quot; +    &quot;  \&quot;nestedObject\&quot; : { \&quot;field\&quot; : \&quot;value\&quot; } }&quot;;ObjectMapper objectMapper = new ObjectMapper();try {    JsonNode jsonNode = objectMapper.readValue(carJson, JsonNode.class);    // we could always use get() to get the node     JsonNode brandNode = jsonNode.get(&quot;brand&quot;);    String brand = brandNode.asText();    System.out.println(&quot;brand = &quot; + brand);    JsonNode doorsNode = jsonNode.get(&quot;doors&quot;);    int doors = doorsNode.asInt();    System.out.println(&quot;doors = &quot; + doors);    JsonNode array = jsonNode.get(&quot;owners&quot;);    JsonNode jsonNode = array.get(0);    String john = jsonNode.asText();    System.out.println(&quot;john  = &quot; + john);    JsonNode child = jsonNode.get(&quot;nestedObject&quot;);    JsonNode childField = child.get(&quot;field&quot;);    String field = childField.asText();    System.out.println(&quot;field = &quot; + field);} catch (IOException e) {    e.printStackTrace();}</code></pre><h2 id="4-1-Read-JsonNode-from-JSON"><a href="#4-1-Read-JsonNode-from-JSON" class="headerlink" title="4.1 Read JsonNode from JSON"></a>4.1 Read JsonNode from JSON</h2><pre><code>String jsonStr = blablabla;ObjectMapper objectMapper = new ObjectMapper();JsonNode jsonNode = objectMapper.readTree(json);</code></pre><h2 id="4-2-Write-JsonNode-to-JSON"><a href="#4-2-Write-JsonNode-to-JSON" class="headerlink" title="4.2 Write JsonNode to JSON"></a>4.2 Write JsonNode to JSON</h2><pre><code>ObjectMapper objectMapper = new ObjectMapper();JsonNode jsonNode = readJsonIntoJsonNode();String json = objectMapper.writeValueAsString(jsonNode);</code></pre><h1 id="5-JsonAnnotation"><a href="#5-JsonAnnotation" class="headerlink" title="5. JsonAnnotation"></a>5. JsonAnnotation</h1><ul><li>@JsonIgnore</li><li>@JsonIgnoreProperties<ul><li>specify a list of properties of a class to ignore </li></ul></li><li>@JsonIgnoreType</li><li>@JsonAutoDetect </li><li>@JsonSetter </li><li>@JsonCreator</li><li>@JsonProperty </li><li>@JsonInclude<ul><li>tells Jackson only to include properties under certain circumstances</li></ul></li><li>@JsonGetter <ul><li>tell Jackson that a certain field value should be obtained from calling a getter method instead of via direct field access </li></ul></li><li>@JsonPropertyOrder<ul><li>specify in what order the fields of your java object should be serialized into JSON</li></ul></li><li>@JsonValue<ul><li>tells jackson that it should not attempt to serialize the obejct itself, but rather call a method on the object which serialize the object to a JSON string </li></ul></li><li>@JsonSerialize <ul><li>specify a custom serializer for a field in a Java object  </li></ul></li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="http://tutorials.jenkov.com/java-json/jackson-objectmapper.html" target="_blank" rel="noopener">http://tutorials.jenkov.com/java-json/jackson-objectmapper.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Intro&quot;&gt;&lt;a href=&quot;#1-Intro&quot; class=&quot;headerlink&quot; title=&quot;1. Intro&quot;&gt;&lt;/a&gt;1. Intro&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;JSON &lt;ul&gt;
&lt;li&gt;JavaScript Object Notation &lt;
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
      <category term="Jackson" scheme="https://www.llchen60.com/tags/Jackson/"/>
    
      <category term="Serialization" scheme="https://www.llchen60.com/tags/Serialization/"/>
    
  </entry>
  
  <entry>
    <title>HashMap在Java中是如何工作的</title>
    <link href="https://www.llchen60.com/HashMap%E5%9C%A8Java%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/"/>
    <id>https://www.llchen60.com/HashMap%E5%9C%A8Java%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/</id>
    <published>2020-02-04T17:15:10.000Z</published>
    <updated>2020-02-04T17:15:47.639Z</updated>
    
    <content type="html"><![CDATA[<p>HashMap是存储以及获取数据的一种简单有效的方式，本文探究Java的HashMap的内部实现。</p><h1 id="1-内部存储"><a href="#1-内部存储" class="headerlink" title="1. 内部存储"></a>1. 内部存储</h1><p>Java的HashMap Class implements <code>Map&lt;K,V&gt;</code> 接口。这个接口的主要方法有：</p><ul><li>put(K key, V value)</li><li>get(Object key)</li><li>remove(Object key)</li><li>Boolean containsKey(Object key)</li></ul><p>HashMap在内部用键值对来进行存储，但是还包含两份其他数据，分别为：</p><ul><li>一个到其他的Entry的reference，这样子HashMap就可以像存单向链表一样来存Entries</li><li>一个代表key的哈希值的值。将这个值存储来避免每次hashMap需要的时候都要重新计算。</li></ul><h2 id="1-1-Java-的Entry的实现"><a href="#1-1-Java-的Entry的实现" class="headerlink" title="1.1 Java 的Entry的实现"></a>1.1 Java 的Entry的实现</h2><pre><code>static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {    final K key;    V value;    Entry&lt;K,V&gt; next;    int hash;}</code></pre><p>一个HashMap存储在多个单向链表中，每个单向链表称为Buckets或者bins. 所有的链表都注册在一个数组中，数组元素为<code>Entry&lt;K,V&gt;</code>. 默认的数组大小是16.<br><img src="https://i.loli.net/2020/02/05/yORJs9NVWXPt75p.jpg" alt="fig1.jpg"></p><p>所有有相同哈希值的key值会存在同一个单向链表当中， 当使用者用put或者get方法的时候，程序会计算需要分配搭配哪个链表(数组的位置)，然后会在链表里用equal方法去找entry中有相同key的entry(针对get方法而言)</p><p>值得注意的是当调用put方法时，如果找到了同样的key，会将value进行替换。</p><p>链表的序号(在数组中的位置)由以下三步来生成：</p><ul><li>得到key的哈希值</li><li>rehash哈希值，来避免不佳的哈希函数把所有数据都放到了一个单向链表当中</li><li>用rehash的哈希值和数组的大小做位掩码， </li></ul><pre><code>// the &quot;rehash&quot; function in JAVA 7 that takes the hashcode of the keystatic int hash(int h) {    h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);    return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);}// the &quot;rehash&quot; function in JAVA 8 that directly takes the keystatic final int hash(Object key) {    int h;    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);    }// the function that returns the index from the rehashed hashstatic int indexFor(int h, int length) {    return h &amp; (length-1);}</code></pre><h2 id="1-2-自动重置大小"><a href="#1-2-自动重置大小" class="headerlink" title="1.2 自动重置大小"></a>1.2 自动重置大小</h2><p>在得到在数组中的位置以后，假设要寻找一个key值，我们需要遍历整个单向链表，来找到这个key值。如果array的size固定的话，单个链表的大小可能会非常大，会使整个查找效率变得很低，因此我们需要自动更新整个数组的大小来保证查找效率。</p><p>当我们创建一个HashMap的时候，我们可以定义初始数组的大小和加载参数(Load Factor).如果你不自行定义，那默认的数组大小是16，加载参数是0.75.</p><pre><code>public HashMap(int initialCapacity, float loadFactor)</code></pre><p>当你调用put方法尝试往HashMap里加新的entry的时候，函数会检测是否需要去增加整个数组的大小。HashMap会存储两个数据：</p><ol><li>HashMap的大小：代表了HashMap中的entry的数量</li><li>Threshold = 数组当下的大小 * load factor. </li></ol><p>当调用put方法的时候，会先检测现在的数组的大小是否超过了定义的阈值(Threshold)，如果超过，就会将当前数组的大小进行加倍处理。值得注意的是，当数组大小发生变化的时候，哈希值和数组大小减一的位操作的值会发生变化，也就是说原先的entry会按照现在的数组大小进行重新的分配，将现存的所有entry分配到不同的bucket里面。</p><p>这样做的目的就是减小每个数组元素- 单向链表的大小，让put, remove, get操作所需要的时间在合理的范围内。</p><p><img src="https://i.loli.net/2020/02/05/xk4JnhHSFTPupgQ.jpg" alt="fig2.jpg"></p><h1 id="2-线程安全？"><a href="#2-线程安全？" class="headerlink" title="2. 线程安全？"></a>2. 线程安全？</h1><p>HashMap不是线程安全的，是因为假设现在到了设的阈值，需要进行HashMap内部数组的resize。这个时候新的entry可能是用原先的哈希函数来做bucket的分配的，这样子就会造成整个数据的不同步。</p><h1 id="3-键值的不可变性"><a href="#3-键值的不可变性" class="headerlink" title="3. 键值的不可变性"></a>3. 键值的不可变性</h1><p>String和Integer是很好的键值选项，因为他们本身就是不可变的。如果你创建自己的键值类，而且这个键值类是可变的，那么我们也许就会在HashMap中丢失数据。</p><p>因为旧哈希值是被存储在Array中的，作为分配到特定bucket的基准，你改变了键值，也就是改变了传入的哈希值，这时候这是全新的一条数据，无法回到原来的bucket，也无法对其进行覆盖了。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="http://coding-geek.com/how-does-a-hashmap-work-in-java/" target="_blank" rel="noopener">Coding Geek</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;HashMap是存储以及获取数据的一种简单有效的方式，本文探究Java的HashMap的内部实现。&lt;/p&gt;
&lt;h1 id=&quot;1-内部存储&quot;&gt;&lt;a href=&quot;#1-内部存储&quot; class=&quot;headerlink&quot; title=&quot;1. 内部存储&quot;&gt;&lt;/a&gt;1. 内部存储&lt;/h
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
      <category term="HashMap" scheme="https://www.llchen60.com/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>Handling overload effectively with load balancers</title>
    <link href="https://www.llchen60.com/Handling-overload-effectively-with-load-balancers/"/>
    <id>https://www.llchen60.com/Handling-overload-effectively-with-load-balancers/</id>
    <published>2020-02-04T17:13:39.000Z</published>
    <updated>2020-02-04T17:14:06.176Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Fail-Smarter"><a href="#1-Fail-Smarter" class="headerlink" title="1. Fail Smarter"></a>1. Fail Smarter</h1><ul><li>Average latency has a spike, availability down</li><li>reasons <ul><li>dependencies </li><li>cascading effect </li><li>client change   peak </li></ul></li></ul><h1 id="2-Load-balancers"><a href="#2-Load-balancers" class="headerlink" title="2. Load balancers"></a>2. Load balancers</h1><ul><li>clients - load balancers - servers </li><li>hardware devices </li><li>multi tenant - use VIP - for efficiency </li><li>used for (features)<ul><li>scaling </li><li>even traffic distribution </li><li>overload protection</li></ul></li><li>how<ul><li>how to pick a server <ul><li>random dice </li><li>round robin </li><li>least conns </li></ul></li><li>desired algorithm - we use least conns <ul><li>simple </li><li>reliable </li><li>even </li></ul></li><li>max conns? </li><li>how to deal with overload? <ul><li>attributes <ul><li>cheap </li><li>local </li><li>buffering - having capacity soon </li><li>priority </li></ul></li><li>reject requests  - spillover - choose! <ul><li>close the TCP connection </li><li>no buffer </li></ul></li><li>hang on, wait in a queue - surge queue <ul><li>may mkes it take longer</li></ul></li></ul></li></ul></li><li>some default we set - maxConns - perhost setting <ul><li>little’s law <ul><li>arrival rate * time shopping = people in the store </li></ul></li><li>see load balancers how many services we have </li><li>fleet-wide concurrent requests / host count = <strong>avg conns</strong></li></ul></li></ul><ul><li>metrics matter <ul><li>latency netwrok latency + 25% <ul><li>client side </li><li>server side </li></ul></li><li>request rate </li></ul></li><li>coral server <ul><li>concurrent requests - outstanding request - in one host </li></ul></li><li>33% overhead room - dependency failures </li></ul><h1 id="3-Actual-behave"><a href="#3-Actual-behave" class="headerlink" title="3. Actual behave"></a>3. Actual behave</h1><ul><li>increase load to see average latency </li><li>run actual test </li><li>generate graph with outstanding requests <ul><li>see the cross of client timeout and p99 </li></ul></li></ul><h1 id="4-Abnormal-cases"><a href="#4-Abnormal-cases" class="headerlink" title="4. Abnormal cases"></a>4. Abnormal cases</h1><ul><li>dependency latency, timeout </li><li>network  packet loss </li></ul><ul><li>let server decide what’s the maxCon should be </li><li>coral has<ul><li>connection </li><li>worker  work thread </li></ul></li><li>classify requests <ul><li>importance <ul><li>droppable </li></ul></li><li>priority <ul><li>order  </li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Fail-Smarter&quot;&gt;&lt;a href=&quot;#1-Fail-Smarter&quot; class=&quot;headerlink&quot; title=&quot;1. Fail Smarter&quot;&gt;&lt;/a&gt;1. Fail Smarter&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Average latenc
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Load Balancers" scheme="https://www.llchen60.com/tags/Load-Balancers/"/>
    
  </entry>
  
  <entry>
    <title>Google Dagger Tutorial</title>
    <link href="https://www.llchen60.com/Google-Dagger-Tutorial/"/>
    <id>https://www.llchen60.com/Google-Dagger-Tutorial/</id>
    <published>2020-02-04T17:12:52.000Z</published>
    <updated>2020-02-04T17:14:18.480Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Comparisons"><a href="#1-Comparisons" class="headerlink" title="1. Comparisons"></a>1. Comparisons</h1><p>Spring is a giant collection of libraries and utilities. with a lot of integration, an XML configuration, runtime/ reflective bindings. Application already using Spring can use its dependency injection smoothly. </p><p>Dependency is only a small part of it. Guice and Dagger is lightweight and only a dependency injection framework</p><p>Dagger is very lightweight framework with very few integrations, java interface/ annotation configuration, and compile-time code generated bindings. </p><p>For dependency injection and IOC container, there is <a href="https://llchen60.com/IOC%E5%AE%B9%E5%99%A8%E5%92%8CDependency-Injection%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">a post in Chinese</a> wrote last year.</p><p>Also a big difference between those DI framework is when does the injection happen, compile time or runtime? </p><p>Run-time DI is <strong>based on reflection</strong> which is simpler to use but slower at run-time —- Spring, Guice </p><p>Compile-time DI is <strong>based on code generation</strong>. This means that all the heavy-weight operations are performed during compilation. It adds complexity but generally performs faster</p><h1 id="2-Implementation"><a href="#2-Implementation" class="headerlink" title="2. Implementation"></a>2. Implementation</h1><ul><li>POJO</li><li>Module<ul><li>a class provides or builds the objects’ dependencies </li></ul></li><li>Component<ul><li>an interface used to generate the injector </li></ul></li></ul><h2 id="2-1-POJO"><a href="#2-1-POJO" class="headerlink" title="2.1 POJO"></a>2.1 POJO</h2><pre><code>public class Car {    private Engine engine;    private Brand brand;    @Inject    public Car(Engine engine, Brand brand) {        this.engine = engine;        this.brand = brand;    }    // getters and setters}</code></pre><h2 id="2-2-Module"><a href="#2-2-Module" class="headerlink" title="2.2 Module"></a>2.2 Module</h2><pre><code>@Module // similar to @Controller  @Service public class VehiclesModule {    @Provides // similar to @Bean     public Engine provideEngine() {        return new Engine();    }    @Provides    @Singleton    public Brand provideBrand() {         return new Brand(&quot;lol&quot;);     }}</code></pre><h2 id="2-3-Component"><a href="#2-3-Component" class="headerlink" title="2.3 Component"></a>2.3 Component</h2><p>here we could return the real object we want to be the starting point of the whole mechanism:</p><p>Dagger will start from here, go through all the @Inject and satisfy those dependencies. In our example, will create engine and brand object. </p><pre><code>@Singleton@Component(modules = VehiclesModule.class)public interface VehiclesComponent {    Car buildCar();}</code></pre><h2 id="2-4-client-side"><a href="#2-4-client-side" class="headerlink" title="2.4 client side"></a>2.4 client side</h2><p>Notice: <code>DaggerVehiclesComponent</code> is created by dagger automatically. </p><pre><code>VehiclesComponent component = DaggerVehiclesComponent.create();Car eg = component.buildCar();</code></pre><h1 id="3-Dagger-User-Guide"><a href="#3-Dagger-User-Guide" class="headerlink" title="3. Dagger User Guide"></a>3. Dagger User Guide</h1><h2 id="3-1-Declaring-Dependencies"><a href="#3-1-Declaring-Dependencies" class="headerlink" title="3.1 Declaring Dependencies"></a>3.1 Declaring Dependencies</h2><p>Dagger constructs instances of application classes and satisfies their dependencies. It uses @Inject annotation to identify which constructors and fields it is interested in. </p><h2 id="3-2-Satisfying-Dependencies"><a href="#3-2-Satisfying-Dependencies" class="headerlink" title="3.2 Satisfying Dependencies"></a>3.2 Satisfying Dependencies</h2><p>By default, Dagger satisfies each dependency by constructing an instance of the requested type. It call <code>new SomeObject()</code> and setting its injectable fields. </p><ul><li>@Inject <ul><li>interfaces cannot be constructed </li><li>third party classes cannot be annotated </li><li>configurable objects must be configured </li></ul></li><li>Instead, use @provides <ul><li>all @provides methods should be named with a provide prefix and module classes are named with a Module suffix </li></ul></li></ul><h2 id="3-3-Building-the-Graph"><a href="#3-3-Building-the-Graph" class="headerlink" title="3.3 Building the Graph"></a>3.3 Building the Graph</h2><p>The @Inject and @Provides annotated classes form a graph of objects, linked by their dependencies. Build the application by <strong>an interface with methods that have no arguments and return the desired type</strong>. </p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://stackoverflow.com/questions/39688830/why-use-develop-guice-when-you-have-spring-and-dagger" target="_blank" rel="noopener">https://stackoverflow.com/questions/39688830/why-use-develop-guice-when-you-have-spring-and-dagger</a></li><li><a href="https://www.baeldung.com/dagger-2" target="_blank" rel="noopener">https://www.baeldung.com/dagger-2</a></li><li><a href="https://rskupnik.github.io/dependency-injection-in-pet-project-dagger2" target="_blank" rel="noopener">https://rskupnik.github.io/dependency-injection-in-pet-project-dagger2</a></li><li><a href="https://dagger.dev/" target="_blank" rel="noopener">https://dagger.dev/</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Comparisons&quot;&gt;&lt;a href=&quot;#1-Comparisons&quot; class=&quot;headerlink&quot; title=&quot;1. Comparisons&quot;&gt;&lt;/a&gt;1. Comparisons&lt;/h1&gt;&lt;p&gt;Spring is a giant collec
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
      <category term="Dagger" scheme="https://www.llchen60.com/tags/Dagger/"/>
    
      <category term="DI" scheme="https://www.llchen60.com/tags/DI/"/>
    
  </entry>
  
  <entry>
    <title>Executor, ExecutorService and Executors</title>
    <link href="https://www.llchen60.com/Executor-ExecutorService-and-Executors/"/>
    <id>https://www.llchen60.com/Executor-ExecutorService-and-Executors/</id>
    <published>2020-02-04T17:11:48.000Z</published>
    <updated>2020-02-04T17:12:16.419Z</updated>
    
    <content type="html"><![CDATA[<p>Executor, ExecutorService and Executors, they are all part of Java’s Executor framework, this framework offers a threadpool. Thus we don’t need to manage threads on our own, the pool can help us manage themselves. </p><p>A thread pool which is created when an application is a startup solves both of these problems. It has <strong>ready threads</strong> to serve clients when needed and it also has a bound on how many threads to create under load.</p><h1 id="1-Executor"><a href="#1-Executor" class="headerlink" title="1. Executor"></a>1. Executor</h1><p><strong>the core interface</strong> which is an abstraction for parallel execution</p><p>It separates task from execution, this is different from java.lang.Thread class which <strong>combines both task and its execution</strong>. </p><h1 id="2-ExecutorService"><a href="#2-ExecutorService" class="headerlink" title="2. ExecutorService"></a>2. ExecutorService</h1><p>ExecutorService is an extension of Executor interface and provides a facility for returning a Future object and terminate, or shut down the thread pool. Once the shutdown is called, the thread pool will not accept new task but complete any pending task. It also provides a submit() method which extends Executor.execute() method and returns a Future.</p><p>The Future object provides the facility of asynchronous execution, which means you don’t need to wait until the execution finishes, you can just submit the task and go around, come back and check if Future object has the result, if execution is completed then it would have result which you can access by using the Future.get() method. Just remember that this method is a <strong>blocking method</strong> i.e. it will wait until execution finish and the result is available if it’s not finished already.</p><p>By using the Future object returned by ExecutorService.submit() method, you can also cancel the execution if you are not interested anymore. It provides cancel() method to cancel any pending execution.</p><h1 id="3-Executors"><a href="#3-Executors" class="headerlink" title="3. Executors"></a>3. Executors</h1><p>Third one Executors is a utility class similar to Collections, which provides <strong>factory methods</strong> to create different types of thread pools e.g. fixed and cached thread pools. Let’s see some more difference between these three classes.</p><h1 id="4-Difference"><a href="#4-Difference" class="headerlink" title="4. Difference"></a>4. Difference</h1><p>1) One of the key difference between Executor and ExecutorService interface is that <strong>former is a parent interface while ExecutorService extends Executor</strong> i.e. it’s a sub-interface of Executor.</p><p>2) Another important difference between ExecutorService and Executor is that Executor defines execute() method which accepts an object of the Runnable interface, while submit() method can accept objects of both Runnable and Callable interfaces.</p><p>3) The third difference between Executor and ExecutorService interface is that execute() method doesn’t return any result, its return type is void but submit() method returns the result of computation via a Future object. This is also the key difference between submit() and execute() method, which is one of the frequently asked Java concurrency interview questions.</p><p>4) The fourth difference between ExecutorService and Executor interface is that apart from allowing a client to submit a task, <strong>ExecutorService also provides methods to control the thread pool</strong> e.g. terminate the thread pool by calling the shutDown() method. You should also read “Java Concurrency in Practice” to learn more about the graceful shutdown of a thread-pool and how to handle pending tasks.</p><p>5) Executors class provides factory methods to create different kinds of thread pools e.g. newSingleThreadExecutor() creates a thread pool of just one thread, newFixedThreadPool(int numOfThreads) creates a thread pool of fixed number of threads and newCachedThreadPool() creates new threads when needed but reuse the existing threads if they are available.</p><h1 id="5-Differences-between-Executor-and-Thread"><a href="#5-Differences-between-Executor-and-Thread" class="headerlink" title="5. Differences between Executor and Thread"></a>5. Differences between Executor and Thread</h1><ol><li>Executor provides a thread pool in java, while Thread not. </li><li>java.lang.Thread is a class in Java while java.util.concurrent.Executor is an interface.</li><li>The Executor concept is actually an abstraction over parallel computation. It allows concurrent code to be run in managed way. On the other hand, Thread is a concrete way to run the code in parallel.</li><li>Executor decouples a task (the code which needs to be executed in parallel) from execution, while in the case of a Thread, both task and execution are tightly coupled.</li><li>The Executor concept allows your task is to be executed by a worker thread from the thread pool, while Thread itself execute your task</li><li>a Thread can only execute one Runnable task but an Executor can execute any number of Runnable task.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Executor, ExecutorService and Executors, they are all part of Java’s Executor framework, this framework offers a threadpool. Thus we don’
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>EnumMap vs HashMap</title>
    <link href="https://www.llchen60.com/EnumMap-vs-HashMap/"/>
    <id>https://www.llchen60.com/EnumMap-vs-HashMap/</id>
    <published>2020-02-04T17:10:34.000Z</published>
    <updated>2020-02-04T17:11:21.139Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-EnumMap"><a href="#1-EnumMap" class="headerlink" title="1. EnumMap"></a>1. EnumMap</h1><ul><li>Can only be used with <strong>enum type</strong> keys </li><li>It’s specialized implementation of Map Interface for use with enum type keys</li><li>Internally using <strong>arrays</strong> </li><li>stored in <strong>natural order</strong></li><li>not possible for collision </li><li>much efficient compared with HashMap </li></ul><h1 id="2-HashMap"><a href="#2-HashMap" class="headerlink" title="2. HashMap"></a>2. HashMap</h1><ul><li>Extends AbstrctMap and implement Map interface </li><li>Internally using hashTable</li><li>Possible for collision </li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://www.geeksforgeeks.org/enummap-class-java-example/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/enummap-class-java-example/</a> </li><li><a href="https://walkingtechie.blogspot.com/2017/03/difference-between-enummap-and-hashmap.html" target="_blank" rel="noopener">https://walkingtechie.blogspot.com/2017/03/difference-between-enummap-and-hashmap.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-EnumMap&quot;&gt;&lt;a href=&quot;#1-EnumMap&quot; class=&quot;headerlink&quot; title=&quot;1. EnumMap&quot;&gt;&lt;/a&gt;1. EnumMap&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Can only be used with &lt;strong&gt;enum
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Effective Java</title>
    <link href="https://www.llchen60.com/Effective-Java/"/>
    <id>https://www.llchen60.com/Effective-Java/</id>
    <published>2020-02-04T17:09:44.000Z</published>
    <updated>2020-02-04T17:10:04.050Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-General-Programming"><a href="#1-General-Programming" class="headerlink" title="1. General Programming"></a>1. General Programming</h1><h2 id="1-1-Scope-of-Local-variables"><a href="#1-1-Scope-of-Local-variables" class="headerlink" title="1.1 Scope of Local variables"></a>1.1 Scope of Local variables</h2><pre><code>for (Iterator&lt;Element&gt; i = c.iterator(); i.hasNext(); ) {    Element e = i.next();    ... // Do something with e and i}// code with bugIterator&lt;Element&gt; i2 = c2.iterator();while (i.hasNext()) {    Element e2 = i2.next();    ... // Do something with e2 and i2}</code></pre><p>i - i2. causing a runtime bug. This bug can be caught at compile time if you <strong>use local variable with minimal scope</strong>. </p><ol><li>Declare the scope of a local variable where it is first used </li><li>initialize every local variable</li><li>prefer for loops to while loops </li><li>keep methods small and focused on a single task </li></ol><h2 id="1-2-Use-library"><a href="#1-2-Use-library" class="headerlink" title="1.2 Use library"></a>1.2 Use library</h2><p>Use library will give you some advantages:</p><ul><li>The knowledge of experts who implemented it and the experience of others who used it before you. </li><li>Better performance that is implemented by experts.</li><li>New features that are added to the libraries in every major release. </li></ul><h2 id="1-3-Float-Double-and-Exact-Calculations"><a href="#1-3-Float-Double-and-Exact-Calculations" class="headerlink" title="1.3 Float, Double and Exact Calculations"></a>1.3 Float, Double and Exact Calculations</h2><pre><code>int getPossibleBoughtItems() {    double dollarFunds = 1.0;    int numItems = 0;    for (double price = 0.10; dollarFunds &gt;= price; price += 0.10) {        dollarFunds -= price;        numItems++;    }    return numItems;}</code></pre><p>We should use BigDecimal, int or long for exact calculations. We should avoid using float and double for exact calculations because they are carefully designed for accurate approximations in scientific and engineering calculations. </p><p>Note that the first method above will return 3, which is wrong, with funds left of $0.3999999999999999. The correct return should be 4, with funds left 0 (see the second implementation).</p><h2 id="1-4-Primitive-Types-and-Boxed-Primitives"><a href="#1-4-Primitive-Types-and-Boxed-Primitives" class="headerlink" title="1.4 Primitive Types and Boxed Primitives"></a>1.4 Primitive Types and Boxed Primitives</h2><p>When possible, you should use primitives, instead of boxed primitives, because: </p><ol><li>Unnecessary use of boxed primitives may result in a hideously slow program because of repeated boxed and unboxed operations. </li><li>whenboxes primitives are used, applying <code>==</code> operator is almost always wrong and can lead to deadly bugs that are difficult to discover. </li></ol><h2 id="1-5-Use-of-Strings-and-Other-Types"><a href="#1-5-Use-of-Strings-and-Other-Types" class="headerlink" title="1.5 Use of Strings and Other Types"></a>1.5 Use of Strings and Other Types</h2><pre><code>// goodpublic final class ThreadLocal&lt;T&gt; {    public ThreadLocal() {};    public void set (T value) {...};    public T get() {...};}// not good public final class ThreadLocal {    private ThreadLocal() {};    public static void set (String key, Object value) {...};    public static Object get(String key) {...};}</code></pre><p>We should avoid using String, because it is poor substitutes for other value types, or aggregate types, or capacity types. It is cumbersome, slower, error-prone and inflexible than other types. </p><h2 id="1-6-String-Builder-and-String-Concatenation"><a href="#1-6-String-Builder-and-String-Concatenation" class="headerlink" title="1.6 String Builder and String Concatenation"></a>1.6 String Builder and String Concatenation</h2><p>Use String Builder instead of String Concatenation, due to its poor performance. </p><pre><code>// Good public String firstNamesToString(List&lt;Person&gt; members) {    StringBuilder sb = new StringBuilder();    for (Person p : members) {        sb.append(&quot;[&quot;);        sb.append(p.firstName);        sb.append(&quot;]&quot;);    }    return sb.toString();}// Bad public String firstNamesToString(List&lt;Person&gt; members) {    String s = &quot;&quot;;    for (Person p : members) {        s += &quot;[&quot; + p.firstName + &quot;]&quot;;    }    return s;}</code></pre><h2 id="1-7-Interface-and-Class-reference"><a href="#1-7-Interface-and-Class-reference" class="headerlink" title="1.7 Interface and Class reference"></a>1.7 Interface and Class reference</h2><p>Use of interface reference </p><pre><code>public List&lt;Person&gt; getPeopleByFirstName(List&lt;Person&gt; members, String firstName) {}</code></pre><p>It would be desirable, more flexible and more backward-compatible to use interface types to refer to parameters, return values, variables and fields if appropriate interface types exist. If appropriate interface types do not exist, use least specific class types to refer to parameters, return values, variables and fields if appropriate interface types do not exist. </p><h1 id="2-Objects"><a href="#2-Objects" class="headerlink" title="2. Objects"></a>2. Objects</h1><h2 id="2-1-Static-Factory-Methods-and-Constructors"><a href="#2-1-Static-Factory-Methods-and-Constructors" class="headerlink" title="2.1 Static Factory Methods and Constructors"></a>2.1 Static Factory Methods and Constructors</h2><p>You are designing a class such as Date and you want to allow a client to obtain an instance of the class, given some input such as instant.</p><p>We should use static factory methods because Factory method has following advantages: </p><ol><li>have names </li><li>not required to create a new object each time invoked </li><li>can return an object of any subtype of their return type </li><li>decouple service provider frameworks </li></ol><h2 id="2-2-Builders-and-Constructors"><a href="#2-2-Builders-and-Constructors" class="headerlink" title="2.2 Builders and Constructors"></a>2.2 Builders and Constructors</h2><p>Use builders since it makes code easier for reading</p><h2 id="2-3-Singleton"><a href="#2-3-Singleton" class="headerlink" title="2.3 Singleton"></a>2.3 Singleton</h2><h3 id="2-3-1-Use-of-enum"><a href="#2-3-1-Use-of-enum" class="headerlink" title="2.3.1 Use of enum"></a>2.3.1 Use of enum</h3><pre><code>public enum MySingleton {    INSTANCE;    public void getDataByMarketplaceId(MarketplaceId id) { ... }}</code></pre><h3 id="2-3-2-Use-of-static-factory"><a href="#2-3-2-Use-of-static-factory" class="headerlink" title="2.3.2 Use of static factory"></a>2.3.2 Use of static factory</h3><pre><code>public class MySingleton {    private static final MySingleton INSTANCE = new MySingleton();    private MySingleton() { ... }    public static MySingleton getInstance() { return INSTANCE; }    public void getDataByMarketplaceId(MarketplaceId id) { ... }}</code></pre><h2 id="2-4-Reusable-Objects"><a href="#2-4-Reusable-Objects" class="headerlink" title="2.4 Reusable Objects"></a>2.4 Reusable Objects</h2><pre><code>public class RomanNumber {    private static Pattern ROMAN = Pattern.compile(&quot;^(?=.)M*(C[MD]|D?C{0,3})(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$&quot;);    static boolean isRomanNumber(String s) {        return ROMAN.matcher(s).matches();    }}</code></pre><p>Reuse the expensive objects(here is Pattern), in performace critical situations. </p><h1 id="3-Classes"><a href="#3-Classes" class="headerlink" title="3. Classes"></a>3. Classes</h1><h2 id="3-1-Accessibility-of-Classes-and-Members"><a href="#3-1-Accessibility-of-Classes-and-Members" class="headerlink" title="3.1 Accessibility of Classes and Members"></a>3.1 Accessibility of Classes and Members</h2><p>Avoid using a public array because a nonzero length array is always mutable, and thus clients will be able to modify the elements of the array. </p><h2 id="3-2-Mutability"><a href="#3-2-Mutability" class="headerlink" title="3.2 Mutability"></a>3.2 Mutability</h2><p>In general, classes should be immutable unless there’s a very good reason to make them mutable; and if so, you should minimize mutability when designing and implementing classes. Rules to make a class immutable: </p><ol><li>Don’t provide methods that modify the state of objects that you want to be immutable. </li><li>Ensure that the class cann’t be extended.</li><li>Make all fields final to express your intent clearly</li><li>Make all fields private to prevent clients from obtaining access to mutable objects </li><li>Ensure exclusive access to any mutable components</li></ol><p>Try to use more immutability, since it offers benefits byu nature: </p><ol><li>Immutable objects are simple: providing failure atomicity </li><li>Inherently thread-safe, require no synchronization </li><li>Can share immutable objects freely</li><li>Immutable objects make great building blocks for other objects. </li></ol><h2 id="3-3-Interfaces-and-Abstract-Classes"><a href="#3-3-Interfaces-and-Abstract-Classes" class="headerlink" title="3.3 Interfaces and Abstract Classes"></a>3.3 Interfaces and Abstract Classes</h2><p>In general, use of interfaces is the best way to define a type that permits multiple implementations because a class can implement multiple interfaces whereas it cannot extend multiple abstract classes. </p><h2 id="3-4-Static-Member-Classes"><a href="#3-4-Static-Member-Classes" class="headerlink" title="3.4 Static Member Classes"></a>3.4 Static Member Classes</h2><pre><code>public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable {    ...    static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {        final int hash;        final K key;        V value;        Node&lt;K,V&gt; next;        ...        public final K getKey()        { return key; }        public final V getValue()      { return value; }        ...    }}</code></pre><p>A nested class is a class defined within another class, the former should exist only to serve the latter. If you declare a member class that doesn’t require access to its enclosing instance then always put static modifier in its declaration. </p><p>If you omit this modifier then each instance will have a hidden extraneous reference to its enclosing instance, and storing this reference takes time and space. More seriously, it can result in the enclosing instance being retained when it would be otherwise be eligible for garbage collection, causing catastrophic memory leak.</p><h1 id="4-Methods-and-Generics"><a href="#4-Methods-and-Generics" class="headerlink" title="4. Methods and Generics"></a>4. Methods and Generics</h1><h2 id="4-1-Empty-and-Null-returns"><a href="#4-1-Empty-and-Null-returns" class="headerlink" title="4.1 Empty and Null returns"></a>4.1 Empty and Null returns</h2><p>Never return null in place of an empty array or collection because it will require clients to check null return for all method calls, ugly!</p><h2 id="4-2-Optional-Returns"><a href="#4-2-Optional-Returns" class="headerlink" title="4.2 Optional Returns"></a>4.2 Optional Returns</h2><pre><code>public static &lt;E extends Comparable&lt;E&gt;&gt; Optional&lt;E&gt; max(Collection&lt;E&gt; c) {    if (c.isEmpty()) {        return Optional.empty();    }    E result = null;    for (E e : c) {        if (result == null || e.compareTo(result) &gt; 0) {            result = Objects.requireNonNull(e);        }    }    return Optional.of(result);}</code></pre><p>Since Java 8, an Optional-returning method is possible, more flexible, and easier to use than one that throws an exception; it is also less error-prone than one that returns  null . Here are some best practices when using   Optional :</p><ul><li>Never return a null value from an optinal-returning method because doing so defeats the entire purpose of the facility.</li><li>Use helpers provided by the facility</li></ul><pre><code> String lastWordInLexicon = max(words).orElse(&quot;No words...&quot;); ,   Toy myToy = max(toys).orElseThrow(ToyException::new); </code></pre><ul><li>Container types, including collections, maps, streams, arrays, and optionals, should not be wrapped in optionals, because they have already provided facility to handle empty values.</li><li>Never return an optional of a boxed primitive type, with possible exception of  Boolean ,  Byte ,   Character ,  Short ,  Float . For other boxed primitive types, use  OptionalInt ,   OptionalLong ,  OptionalDouble  instead.</li></ul><h2 id="4-3-Generics-and-Unchecked-Warnings"><a href="#4-3-Generics-and-Unchecked-Warnings" class="headerlink" title="4.3 Generics and Unchecked Warnings"></a>4.3 Generics and Unchecked Warnings</h2><pre><code>public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable {    ...    public &lt;T&gt; T[] toArray(T[] a) {        if (a.length &lt; size) {            @SuppressWarnings(&quot;unchecked&quot;) T[] result = (T[]) Arrays.copyOf(elementData, size, a.getClass());            return result;        }        System.arraycopy(elementData, 0, a, 0, size);        if (a.length &gt; size) {            a[size] = null;        }        return a;    }    ...} </code></pre><p>Unchecked warnings are important; don’t ignore them because every unchecked warning has the potential to throw a   ClassCastException  at runtime. You should do your best to eliminate as many of them as possible. If you can’t, however, get rid of an unchecked warning, but you can prove that the code that provoke it is typesafe then suppress it with the corresponding annotation in the <strong>narrowest possible scope</strong>.</p><p>@SupressWarning: An anotation to surpress compile warnings about unchecked generic operations. </p><h2 id="4-4-Generics-and-Wildcards"><a href="#4-4-Generics-and-Wildcards" class="headerlink" title="4.4 Generics and Wildcards"></a>4.4 Generics and Wildcards</h2><pre><code>public class Stack&lt;E&gt; {    ...    public Stack() { ... }    public void push(E e) { ... }    public E pop() { ... }    public boolean isEmpty { ... }    public void pushAll(Iterable&lt;? extends E&gt; src) {        for (E e : src) {            push(e);        }    }    public void popAll(Collection&lt;? super E&gt; dst) {        while (!isEmpty()) {            dst.add(pop());        }    }}</code></pre><p>It is clear that for maximum flexibility you should use wildcard types on input parameters that represent producers or consumers.</p><ul><li>Remember PECS, which stands for <strong>Producer-Extends and Consumer-Super</strong>. Note that  Comparable  and   Comparator  are always consumers.</li></ul><h1 id="5-Exceptions"><a href="#5-Exceptions" class="headerlink" title="5. Exceptions"></a>5. Exceptions</h1><h2 id="5-1-Checked-Exceptions-and-Unchecked-Exceptions"><a href="#5-1-Checked-Exceptions-and-Unchecked-Exceptions" class="headerlink" title="5.1 Checked Exceptions and Unchecked Exceptions"></a>5.1 Checked Exceptions and Unchecked Exceptions</h2><pre><code>/** * Returns MarketplaceInfo of a given marketplace. * @throws NotFoundException if marketplaceId is not found; do not retry. * @throws ServiceUnavailableException if MarketplaceService does not respond after 3 retries. */public MarketplaceInfo getMarketplaceInfoById(MarketplaceId marketplaceId) {    try {        return getMarketplaceInfoByIdFromLocalCache(marketplaceId);    } catch (IOException e) {        try {            MarketplaceInfo info = getMarketplaceInfoByIdFromRemoteCache(marketplaceId);            putMarketplaceInfoToLocalCache(marketplaceId, info);            return info;        } catch (IOException e) {            for (int numRetries = 0; numRetries &lt; 3; numRetries++) {                try {                    // Call dependent service to get marketplace info                    MarketplaceInfo info = marketplaceService.getMarketplaceInfoById(marketplaceId);                    putMarketplaceInfoToLocalCache(marketplaceId, info);                    putMarketplaceInfoToRemoteCache(marketplaceId, info);                                    return info;                } catch (ServiceUnavailableException e) {                    sleep(5); // sleep 5 seconds before retry                } catch (NotFoundException e) {                    LOG.error(&quot;Unable to get marketplace info because marketplace id {} is not found.&quot;, marketplaceId);                    throw e;                }            }            throw new ServiceUnavailableException(&quot;Unable to get marketplace info after 3 retries.&quot;);        }    }}</code></pre><p>We should: </p><ul><li>throw checked exceptions, a subclass of Exception <ul><li>for recoverable conditions</li></ul></li><li>throw unchecked exceptions, a subclass of runtimeException <ul><li>for programming errors </li></ul></li></ul><p>When in doubt, throw unchecked exceptions. When throwing checked exceptions, add methods to aid in recovery for clients. </p><p>You should declare checked exceptions individually and document precisely the conditions under which each exception is thrown, by using Javadoc  @throws  tag. If the same exception is thrown by many methods in a class for the same reason then you can document it in the class’s documentation comment. In addition, it is particularly important to document unchecked exceptions of methods in interfaces they may throw</p><h2 id="5-2-Exception-Implementation"><a href="#5-2-Exception-Implementation" class="headerlink" title="5.2 Exception Implementation"></a>5.2 Exception Implementation</h2><ul><li>Provide detail as much as possible</li><li>detail msg should contain the values of all parameters and fields that have contributed to the exception </li><li>No sensitive information contained </li></ul><h1 id="6-Lambdas-and-Streams"><a href="#6-Lambdas-and-Streams" class="headerlink" title="6. Lambdas and Streams"></a>6. Lambdas and Streams</h1><h2 id="6-1-Method-references"><a href="#6-1-Method-references" class="headerlink" title="6.1 Method references"></a>6.1 Method references</h2><ul><li><code>Integer::parseInt</code> -&gt; a static method reference for <code>str -&gt; Integer.parseInt(str)</code></li><li><code>Instant.now()::isAfter</code> -&gt; a bound method reference for <code>Instance i = Instant.now(); t -&gt; i.isAfter(t)</code></li><li><code>String::toLowerCase</code> -&gt; an unbound method reference for <code>str -&gt; str.toLowerCase()</code></li><li><code>TreeMap&lt;K, V&gt;::new</code> -&gt; A class constructor for <code>() -&gt; new TreeMap&lt;K, V&gt;</code></li></ul><h1 id="7-Concurrency"><a href="#7-Concurrency" class="headerlink" title="7. Concurrency"></a>7. Concurrency</h1><h2 id="7-1-Synchronize-Access-to-Sharable-Mutable-Data"><a href="#7-1-Synchronize-Access-to-Sharable-Mutable-Data" class="headerlink" title="7.1 Synchronize Access to Sharable Mutable Data"></a>7.1 Synchronize Access to Sharable Mutable Data</h2><p>When multiple threads share mutable data, each thread that reads or writes the data must <strong>perform synchronization</strong>, otherwise there is no guarantee that one thread’s changes of the data will be visible to other threads, and therefore may cause liveness and safety failures. These failures are among the most difficult to debug.<br><code>var ++</code><br>It performs two operations on var : (1) it reads the value, (2) it writes back a new value that is equal to the old value plus one. If a second thread reads the field between the time the first thread reads the old value and writes back the new one, then both threads will see the same value and thus return the same serial number, OUCH; this is a safety failure.</p><p>Note that the best way to avoid safety failure is <strong>not to share mutable data</strong>, meaning share only immutable data or don’t share at all — confine mutable data to a single thread. If you adopt this policy then you should document it carefully, so that the policy is maintained as your program evolves. It is also crucial to have a deep understanding of the frameworks and libraries you’re using because they may introduce threads that you are unaware of.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-General-Programming&quot;&gt;&lt;a href=&quot;#1-General-Programming&quot; class=&quot;headerlink&quot; title=&quot;1. General Programming&quot;&gt;&lt;/a&gt;1. General Programming
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Cost of abstraction</title>
    <link href="https://www.llchen60.com/Cost-of-abstraction/"/>
    <id>https://www.llchen60.com/Cost-of-abstraction/</id>
    <published>2020-02-04T17:08:47.000Z</published>
    <updated>2020-02-04T17:09:17.706Z</updated>
    
    <content type="html"><![CDATA[<p>Duplicate is definitely something we are trying to get rid of, however, what’s the cost of abstraction? It seems some problem we could think for a while. </p><p>We should think of the tradeoff between code duplication and increased level of abstraction. </p><h1 id="1-Definition-cost-of-abstraction"><a href="#1-Definition-cost-of-abstraction" class="headerlink" title="1. Definition - cost of abstraction"></a>1. Definition - cost of abstraction</h1><ul><li>An abstraction is adding to the cognitive load of whoever works with the code </li><li>The main cost of abstraction: separating the implementation from the specification. Or we say separate the letter of function from the spirit of the function</li><li>The former being what the function does, the latter being what everybody believes it should do </li><li>Should involve everybody to consider what the code does, or we say what the function does </li></ul><h1 id="2-Thought"><a href="#2-Thought" class="headerlink" title="2. Thought"></a>2. Thought</h1><ul><li>The decision about creating an abstraction should not be taken lightly.</li><li>There’s a large social cost to every abstraction, may lead the project to be unmaintainable.</li><li>lambda is also a way to reduce the abstraction layers in some way </li><li>Abstraction is a good way to get rid of verbose code, but itself may bring uncertainty to some extent. Only implement <strong><em>necessary</em></strong> abstraction. </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Duplicate is definitely something we are trying to get rid of, however, what’s the cost of abstraction? It seems some problem we could th
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>CacheLoader 教程</title>
    <link href="https://www.llchen60.com/CacheLoader-%E6%95%99%E7%A8%8B/"/>
    <id>https://www.llchen60.com/CacheLoader-%E6%95%99%E7%A8%8B/</id>
    <published>2020-02-04T17:07:09.000Z</published>
    <updated>2020-02-04T17:07:32.984Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-LoadingCache"><a href="#1-LoadingCache" class="headerlink" title="1. LoadingCache"></a>1. LoadingCache</h1><p>LoadingCache是指用CacheLoader建立的缓存。想要使用LoadingCache的话，就是使用方法<code>get(K)</code>。如果不在LoadingCache里面的话，就会使用CacheLoader做一次加载；如果有的话就直接拿回结果了。</p><h1 id="2-使用CacheLoader以及LoadingCache"><a href="#2-使用CacheLoader以及LoadingCache" class="headerlink" title="2. 使用CacheLoader以及LoadingCache"></a>2. 使用CacheLoader以及LoadingCache</h1><pre><code>LoadingCache&lt;String, String&gt; loadingCache = CacheBuilder.newBuilder()    .build(new CacheLoader&lt;String, String&gt;() {        @Override        public String load(final String s) throws Exception {            return response;        }    });</code></pre><ul><li>CacheLoader在使用newBuilder()创造新实例的时候还可以做很多的设置，比如<ul><li><code>expireAfterAccess(long duration, TimeUnit unit)</code><ul><li>在每个entry被创建以后，经过一段固定的时间做自动移除操作</li></ul></li><li><code>maximumSize(long size)</code><ul><li>定义cache能有的最大entry数量 </li></ul></li></ul></li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://www.baeldung.com/guava-cacheloader" target="_blank" rel="noopener">https://www.baeldung.com/guava-cacheloader</a> </li><li><a href="https://stackoverflow.com/questions/43993731/what-is-a-loadingcache" target="_blank" rel="noopener">https://stackoverflow.com/questions/43993731/what-is-a-loadingcache</a></li><li><a href="https://guava.dev/releases/21.0/api/docs/com/google/common/cache/LoadingCache.html" target="_blank" rel="noopener">https://guava.dev/releases/21.0/api/docs/com/google/common/cache/LoadingCache.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-LoadingCache&quot;&gt;&lt;a href=&quot;#1-LoadingCache&quot; class=&quot;headerlink&quot; title=&quot;1. LoadingCache&quot;&gt;&lt;/a&gt;1. LoadingCache&lt;/h1&gt;&lt;p&gt;LoadingCache是指用Cache
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
      <category term="Cache" scheme="https://www.llchen60.com/tags/Cache/"/>
    
  </entry>
  
  <entry>
    <title>Apache-Ant</title>
    <link href="https://www.llchen60.com/Apache-Ant/"/>
    <id>https://www.llchen60.com/Apache-Ant/</id>
    <published>2020-02-04T16:32:50.000Z</published>
    <updated>2020-02-04T16:33:18.973Z</updated>
    
    <content type="html"><![CDATA[<p>Apache Ant is a Java-based build tool. A java library and command line tool, which aims to drive processes described in build files as targets and extension points dependent upon each other. </p><p>Main usage: build java applications. It can pilot any type of processes which can be described <strong>in terms of targets and tasks.</strong></p><h1 id="1-Writing-a-Simple-BuildFile"><a href="#1-Writing-a-Simple-BuildFile" class="headerlink" title="1. Writing a Simple BuildFile"></a>1. Writing a Simple BuildFile</h1><h2 id="1-1-Intro"><a href="#1-1-Intro" class="headerlink" title="1.1 Intro"></a>1.1 Intro</h2><p>Ant’s buildfile are written in XML. Each buildfile contains one project and as least one target. Targets contain task elements. Each task element of the build file can have an id attribute and can later be referred to by the value supplied to this. </p><p>The structure comes to be: </p><ul><li>project </li><li>target<ul><li>task elements<ul><li>id attribute </li></ul></li></ul></li></ul><h2 id="1-2-Projects"><a href="#1-2-Projects" class="headerlink" title="1.2 Projects"></a>1.2 Projects</h2><p>A project has three attributes: </p><ul><li>name <ul><li>the name of project</li></ul></li><li>default<ul><li>the default target to use when no target is supplied </li></ul></li><li>basedir<ul><li>the base directory from which all path calculations are done. A relative path is resolved relative to the directory containing the buildfile. </li><li>defaults to the parent directory of the buildfile </li></ul></li></ul><h2 id="1-3-Targets"><a href="#1-3-Targets" class="headerlink" title="1.3 Targets"></a>1.3 <a href="https://ant.apache.org/manual/targets.html" target="_blank" rel="noopener">Targets</a></h2><p>It’s a container of tasks that cooperate to reach a desired state during the build process. </p><p>A target can depend on other targets. **You might have a target for compiling, for example, and a target for creating a distributable. You can only build a distributable when you have compiled first, so the “distribute” target depends on the “compile” target. Ant resolves these dependencies</p><pre><code>&lt;target name=&quot;A&quot;/&gt;&lt;target name=&quot;B&quot; depends=&quot;A&quot;/&gt;&lt;target name=&quot;C&quot; depends=&quot;B&quot;/&gt;&lt;target name=&quot;D&quot; depends=&quot;C,B,A&quot;/&gt;</code></pre><p>Suppose we want to execute target D. From its depends attribute, you might think that first target C, then B and then A is executed. Wrong! C depends on B, and B depends on A, so first A is executed, then B, then C, and finally D.</p><p>A target also has the ability to perform its execution if(or unless) a property has been set. </p><pre><code>&lt;target name=&quot;myTarget&quot; depends=&quot;myTarget.check&quot; if=&quot;myTarget.run&quot;&gt;    &lt;echo&gt;Files foo.txt and bar.txt are present.&lt;/echo&gt;&lt;/target&gt;&lt;target name=&quot;myTarget.check&quot;&gt;    &lt;condition property=&quot;myTarget.run&quot;&gt;        &lt;and&gt;            &lt;available file=&quot;foo.txt&quot;/&gt;            &lt;available file=&quot;bar.txt&quot;/&gt;        &lt;/and&gt;    &lt;/condition&gt;&lt;/target&gt;</code></pre><h2 id="1-4-Tasks"><a href="#1-4-Tasks" class="headerlink" title="1.4 Tasks"></a>1.4 Tasks</h2><h3 id="1-4-1-Intro"><a href="#1-4-1-Intro" class="headerlink" title="1.4.1 Intro"></a>1.4.1 Intro</h3><p>Task is a piece of code that can be executed. </p><p>A task can have multiple attributes. The value of an attribute might contain reference to a property. These references will be resolved before the task is executed. </p><p>Task has a common structure: </p><pre><code>&lt;name attribute1=&quot;value1&quot; attribute2=&quot;value2&quot; ... /&gt;</code></pre><p>where name is the name of the task, attributeN is the attribute name, and valueN is the value for this attribute.</p><p>All tasks can have a name attribute, which will be used in the logging messages generated by Ant. </p><h3 id="1-4-2-Built-in-tasks"><a href="#1-4-2-Built-in-tasks" class="headerlink" title="1.4.2 Built-in tasks"></a>1.4.2 Built-in tasks</h3><p><a href="https://ant.apache.org/manual/tasklist.html" target="_blank" rel="noopener">https://ant.apache.org/manual/tasklist.html</a> </p><h3 id="1-4-3-Write-your-own-tasks"><a href="#1-4-3-Write-your-own-tasks" class="headerlink" title="1.4.3 Write your own tasks"></a>1.4.3 Write your own tasks</h3><p><a href="https://ant.apache.org/manual/develop.html#writingowntask" target="_blank" rel="noopener">https://ant.apache.org/manual/develop.html#writingowntask</a></p><h2 id="1-5-Properties"><a href="#1-5-Properties" class="headerlink" title="1.5 Properties"></a>1.5 <a href="https://ant.apache.org/manual/properties.html#if+unless" target="_blank" rel="noopener">Properties</a></h2><p>Properties are an important way to customize a build process or to just provide shortcuts for strings that are used repeatedly inside a buildfile.</p><p>In its most simple form properties are defined in the buildfile (for example by the property task) or might be set outside Ant. <strong>A property has a name and a value</strong>; the name is case-sensitive. Properties may be used in the value of task attributes or in the nested text of tasks that support them. This is done by <strong>placing the property name between “${“ and “}” in the attribute value</strong>. For example, if there is a builddir property with the value “build”, then this could be used in an attribute like this: ${builddir}/classes. This is resolved at run-time as build/classes.</p><pre><code>&lt;project name=&quot;MyProject&quot; default=&quot;dist&quot; basedir=&quot;.&quot;&gt;  &lt;description&gt;    simple example build file  &lt;/description&gt;  &lt;!-- set global properties for this build --&gt;  &lt;property name=&quot;src&quot; location=&quot;src&quot;/&gt;  &lt;property name=&quot;build&quot; location=&quot;build&quot;/&gt;  &lt;property name=&quot;dist&quot; location=&quot;dist&quot;/&gt;  &lt;target name=&quot;init&quot;&gt;    &lt;!-- Create the time stamp --&gt;    &lt;tstamp/&gt;    &lt;!-- Create the build directory structure used by compile --&gt;    &lt;mkdir dir=&quot;${build}&quot;/&gt;  &lt;/target&gt;  &lt;target name=&quot;compile&quot; depends=&quot;init&quot;        description=&quot;compile the source&quot;&gt;    &lt;!-- Compile the Java code from ${src} into ${build} --&gt;    &lt;javac srcdir=&quot;${src}&quot; destdir=&quot;${build}&quot;/&gt;  &lt;/target&gt;  &lt;target name=&quot;dist&quot; depends=&quot;compile&quot;        description=&quot;generate the distribution&quot;&gt;    &lt;!-- Create the distribution directory --&gt;    &lt;mkdir dir=&quot;${dist}/lib&quot;/&gt;    &lt;!-- Put everything in ${build} into the MyProject-${DSTAMP}.jar file --&gt;    &lt;jar jarfile=&quot;${dist}/lib/MyProject-${DSTAMP}.jar&quot; basedir=&quot;${build}&quot;/&gt;  &lt;/target&gt;  &lt;target name=&quot;clean&quot;        description=&quot;clean up&quot;&gt;    &lt;!-- Delete the ${build} and ${dist} directory trees --&gt;    &lt;delete dir=&quot;${build}&quot;/&gt;    &lt;delete dir=&quot;${dist}&quot;/&gt;  &lt;/target&gt;&lt;/project&gt;</code></pre><p>Properties are key-value pair where Apache Ant tries to expand ${key} to value at run time.  In general properties are of global scope, i.e., once they have been defined they are available for any task or target invoked subsequently—it is not possible to set a property in a child build process created via the ant, antcall or subant tasks and make it available to the calling build process, though. </p><h3 id="1-5-2-Built-in-Properties"><a href="#1-5-2-Built-in-Properties" class="headerlink" title="1.5.2 Built-in Properties"></a>1.5.2 Built-in Properties</h3><p>Ant provides access to all system properties as if they had been defined using a <property> task. </p><ul><li>javadoc of <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/System.html#getProperties--" target="_blank" rel="noopener">System.getProperties</a></li><li>basedir: the absolute path of the project’s basedir </li><li>ant.file: the absolute path of the buildfile</li><li>ant.version</li><li>ant.project.name </li></ul><h1 id="2-Concepts-and-Types"><a href="#2-Concepts-and-Types" class="headerlink" title="2. Concepts and Types"></a>2. Concepts and Types</h1><h2 id="2-1-Concepts"><a href="#2-1-Concepts" class="headerlink" title="2.1 Concepts"></a>2.1 Concepts</h2><ul><li>targets and Extension-points </li><li>Properties and PropertyHelpers</li></ul><h2 id="2-2-List-of-Types"><a href="#2-2-List-of-Types" class="headerlink" title="2.2 List of Types"></a>2.2 List of Types</h2><p><a href="https://ant.apache.org/manual/index.html" target="_blank" rel="noopener">https://ant.apache.org/manual/index.html</a> </p><ul><li>Class Fileset </li><li>Description Type </li><li>Directory based Tasks</li><li>Dirset</li><li>Extension Package </li><li>Set of Extension Packages</li><li>FileList</li><li>FileSet </li><li>File Mappers </li><li>FilterChains and FilterReaders</li><li>FilterSet </li><li>MultiRootFileSet </li><li>PatternSet </li><li>Path-like Structures</li><li>Permissions</li><li>PropertySet </li><li>I/O redirectors </li><li>Regexp</li><li>Resources </li><li>Resource Collections </li><li>Selectors </li><li>TarFileSet </li><li>XMLCatalog </li><li>ZipFileSet </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Apache Ant is a Java-based build tool. A java library and command line tool, which aims to drive processes described in build files as ta
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
      <category term="Apache" scheme="https://www.llchen60.com/tags/Apache/"/>
    
  </entry>
  
  <entry>
    <title>编程范式系列-面向对象编程</title>
    <link href="https://www.llchen60.com/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F%E7%B3%BB%E5%88%97-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
    <id>https://www.llchen60.com/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F%E7%B3%BB%E5%88%97-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</id>
    <published>2020-02-04T04:32:33.000Z</published>
    <updated>2020-02-04T04:32:55.523Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-函数式编程-vs-面向对象编程"><a href="#1-函数式编程-vs-面向对象编程" class="headerlink" title="1. 函数式编程 vs 面向对象编程"></a>1. 函数式编程 vs 面向对象编程</h1><p>函数式编程主要是把一些功能或逻辑代码通过函数的拼装方式来组织。尽量无状态，但是状态总归是需要一些地方来存放的。</p><p>对于状态和数据的处理，常用面向对象编程这个范式。</p><p>面向对象编程三大特性： </p><ul><li>封装</li><li>继承</li><li>多态</li></ul><h1 id="2-面向对象编程"><a href="#2-面向对象编程" class="headerlink" title="2. 面向对象编程"></a>2. 面向对象编程</h1><p>对象是类的实例，将对象作为程序的基本单元。对象里的程序可以访问及修改对象相关联的数据。</p><p>在程序中包含各种独立又相互调用的对象的思想。面向对象设计中的每一个对象都应该能够<strong>接受数据，处理数据并将数据传达给其它对象</strong>。</p><h2 id="2-1-面向对象的核心理念"><a href="#2-1-面向对象的核心理念" class="headerlink" title="2.1 面向对象的核心理念"></a>2.1 面向对象的核心理念</h2><ol><li>Program to an interface, not an implementation </li></ol><ul><li>使用者不需要知道数据类型，结构，算法的细节</li><li>使用者不需要知道实现细节，只需要知道提供的接口</li><li>利于抽象、封装、动态绑定、多态</li></ul><ol start="2"><li>Favor object composition over class inheritance <ul><li>继承需要给子类暴露一些父类的设计和实现细节</li><li>父类的改变会造成子类也需要改变</li><li>继承更多是为了多态</li></ul></li></ol><h2 id="2-2-tips"><a href="#2-2-tips" class="headerlink" title="2.2 tips"></a>2.2 tips</h2><ol><li>使用接口实现具体类</li><li>其他类耦合的是接口而不是实现类。这就是多态，其增加了程序的可扩展性</li><li>接口编程</li></ol><h2 id="2-3-缺点"><a href="#2-3-缺点" class="headerlink" title="2.3 缺点"></a>2.3 缺点</h2><p>超级重的代码粘合层，大量的封装</p><h1 id="3-控制反转"><a href="#3-控制反转" class="headerlink" title="3. 控制反转"></a>3. 控制反转</h1><p>Ioc—Inversion of Control，即“控制反转”，不是什么技术，而是一种设计思想。在Java开发中，Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。</p><p>传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对象的创建；IoC容器控制了对象；主要控制了外部资源获取。</p><p>有了IoC容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-函数式编程-vs-面向对象编程&quot;&gt;&lt;a href=&quot;#1-函数式编程-vs-面向对象编程&quot; class=&quot;headerlink&quot; title=&quot;1. 函数式编程 vs 面向对象编程&quot;&gt;&lt;/a&gt;1. 函数式编程 vs 面向对象编程&lt;/h1&gt;&lt;p&gt;函数式编程主要是
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="编程范式" scheme="https://www.llchen60.com/tags/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>编程范式系列-泛型编程</title>
    <link href="https://www.llchen60.com/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F%E7%B3%BB%E5%88%97-%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/"/>
    <id>https://www.llchen60.com/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F%E7%B3%BB%E5%88%97-%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/</id>
    <published>2020-02-04T04:31:42.000Z</published>
    <updated>2020-02-04T04:32:02.474Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-起源"><a href="#1-起源" class="headerlink" title="1. 起源"></a>1. 起源</h1><p>编程范式, programming paradigm，是一类典型的编程风格。</p><p>将主流编程语言分为三部分，加上对于编程本质的理解。共四篇文章。</p><ul><li>泛型编程</li><li>函数式编程</li><li>面向对象编程</li><li>编程本质和逻辑编程</li></ul><h1 id="1-1-C语言"><a href="#1-1-C语言" class="headerlink" title="1.1 C语言"></a>1.1 C语言</h1><ul><li>几乎现行的所有编程语言都是从c语言拓展来的，简述c语言的特性：</li></ul><ol><li>静态弱类型语言，使用变量时需要声明变量类型，但类型之间有隐式转换</li><li>typedef 定义类型的别名，达到变量类型的抽象</li><li>不同变量类型可以用结构体组合在一起</li></ol><ul><li>c语言的类型抽象带来的复杂度的提升： </li></ul><pre><code>void swap(void* x, void* y, size_t size){     char tmp[size];     memcpy(tmp, y, size);     memcpy(y, x, size);     memcpy(x, tmp, size);}</code></pre><ul><li>利用宏定义来做泛型</li></ul><pre><code>#define swap(x, y, size) {\    char temp[size]; \    memcpy(temp, &amp;y, size); \    memcpy(&amp;y,   &amp;x, size); \    memcpy(&amp;x, temp, size); \}</code></pre><ul><li>比较大小的宏定义</li></ul><pre><code>#define min(x, y)  （(x)&gt;(y) ? (y) : (x)）</code></pre><p>这里如果比较<code>min(x++, y++)</code>的话，各自会加两次</p><ul><li>小结<br>如果说程序 = 算法 + 数据， C语言会有这几个问题</li></ul><ol><li>一个通用的算法，需要对所处理的数据的数据类型进行适配。但在适配数据类型的过程中，C 语言只能使用 <code>void *</code> 或宏替换的方式。这两种方式导致了类型过于宽松，并带来很多其它问题。</li><li>适配数据类型，需要 C 语言在泛型中加入一个类型的 size，这是因为我们识别不了被泛型后的数据类型，而 C 语言没有运行时的类型识别，所以，只能将这个工作抛给调用泛型算法的程序员来做了</li><li>算法其实是在操作数据结构，而数据则是放到数据结构中的。所以，真正的泛型除了适配数据类型外，还要适配数据结构。最后这个事情导致泛型算法的复杂急剧上升。比如容器内存的分配和释放，不同的数据体可能有非常不一样的内存分配和释放模型，再比如对象之间的复制，要把它存进来我需要有一个复制，这其中又涉及到是深拷贝，还是浅拷贝。</li><li>最后，在实现泛型算法的时候，你会发现自己在纠结哪些东西应该抛给调用者处理，哪些又是可以封装起来。如何平衡和选择，并没有定论，也不好解决。</li></ol><p>比如 C 语言就是过程式的编程语言，像C语言这样的过程式编程语言优点是底层灵活而且高效，特别适合开发运行较快且对系统资源利用率要求较高的程序，但我上面抛出的问题它在后来也没有试图去解决，因为<strong>编程范式</strong>的选择基本已经决定了它的“命运”。</p><h1 id="2-泛型编程"><a href="#2-泛型编程" class="headerlink" title="2. 泛型编程"></a>2. 泛型编程</h1><h2 id="2-1-C-语言"><a href="#2-1-C-语言" class="headerlink" title="2.1 C++ 语言"></a>2.1 C++ 语言</h2><p>C++ 很大程度上是来解决C语言中的各种问题和各种不方便。</p><ul><li>用引用来解决指针的问题。</li><li>用 namespace 来解决名字空间冲突的问题。</li><li>通过 try-catch 来解决检查返回值编程的问题。</li><li>用 class 来解决对象的创建、复制、销毁的问题，从而可以达到在结构体嵌套时可以深度复制的内存安全问题。</li><li>通过重载操作符来达到操作上的泛型</li><li>通过模板 template 和虚函数的多态以及运行时识别来达到更高层次的泛型和多态。</li><li>用 RAII、智能指针的方式，解决了 C 语言中因为需要释放资源而出现的那些非常 ugly 也很容易出错的代码的问题。</li><li>用 STL 解决了 C 语言中算法和数据结构的 N 多种坑。</li></ul><h2 id="2-2-C-语言的泛型编程"><a href="#2-2-C-语言的泛型编程" class="headerlink" title="2.2 C++ 语言的泛型编程"></a>2.2 C++ 语言的泛型编程</h2><p>理想情况下，算法应该与数据结构和类型无关的。各种特殊的数据结构应该能自己做好泛型处理，算法是一个标准的实现。</p><p>对于泛型的抽象，<strong>需要回答的问题是： 如果我们的数据类型符合通用算法，那么对数据类型的最小需求是什么？？？</strong></p><h3 id="2-2-1-C-如何解决泛型问题的？"><a href="#2-2-1-C-如何解决泛型问题的？" class="headerlink" title="2.2.1 C++ 如何解决泛型问题的？"></a>2.2.1 C++ 如何解决泛型问题的？</h3><ol><li>通过类的方式解决</li></ol><ul><li>类里面会有构造函数、析构函数表示这个类的分配和释放。</li><li>还有它的拷贝构造函数，表示了对内存的复制。</li><li>还有重载操作符，像我们要去比较大于、等于、不等于。</li></ul><ol start="2"><li>通过模板达到类型和算法的妥协</li></ol><ul><li>模板有点像 DSL，模板的特化会根据使用者的类型在编译时期生成那个模板的代码。</li><li>模板可以通过一个虚拟类型来做类型绑定，这样不会导致类型转换时的问题。</li></ul><ol start="3"><li>通过虚函数和运行时类识别</li></ol><ul><li>虚函数带来的多态在语义上可以让“同一类”的类型进行泛型。</li><li>运行时类型识别技术可以做到在泛型时对具体类型的特殊处理。</li></ul><p>一个良好的泛型编程需要解决 1） 算法的泛型 2） 类型的泛型  3） 数据结构的泛型</p><h3 id="2-2-2-泛型编程实例"><a href="#2-2-2-泛型编程实例" class="headerlink" title="2.2.2 泛型编程实例"></a>2.2.2 泛型编程实例</h3><ol><li>Search 函数</li></ol><p>不是所有的数据结构都是顺序型的，不能用 <code>for(int i = 0; i &lt; len; i++)</code> 来做抽象的，比如hashtable，二叉树，图就是非顺序型的。这种写法对他们来说没有意义。</p><pre><code>template&lt;typename T, typename Iter&gt; Iter search(Iter pStart, Iter pEnd, T target) {    for(Iter p = pStart; p != pEnd; p++) {        if ( *p == target )             return p;    }    return NULL;}</code></pre><p>可以看到： </p><ul><li>使用 <code>typename T</code> 抽象了数据结构中存储数据的类型</li><li>使用 <code>typename Iter</code>，让不同的数据结构实现自己的迭代器，用这种方式抽象掉了不同类型的数据结构。</li><li>然后，我们对数据容器的遍历使用了Iter中的++方法，这是数据容器需要重载的操作符，这样通过操作符重载也就泛型掉了遍历。</li><li>使用<code>*Iter</code>来取得指针的内容，这也是通过重载*取值操作符来达到的泛型。</li><li>tips: <code>Iter</code> 在实际代码中，是类似于<code>vector&lt;int&gt;::iterator</code> <code>map&lt;int, String&gt;::iterator</code>。是由相应的数据容器来实现和提供的。</li></ul><ol start="2"><li>迭代器</li></ol><pre><code>template &lt;class T&gt;class container {public:    class iterator {    public:        typedef iterator self_type;        typedef T   value_type;        typedef T*  pointer;        typedef T&amp;     reference;        reference operator*();        pointer operator-&gt;();        bool operator==(const self_type&amp; rhs)；        bool operator!=(const self_type&amp; rhs)；        self_type operator++() { self_type i = *this; ptr_++; return i; }        self_type operator++(int junk) { ptr_++; return *this; }        ...        ...    private:        pointer _ptr;    };    iterator begin();    iterator end();    ...    ...};</code></pre><ul><li>一个迭代器需要与一个容器在一起，因为里面是对这个容器的具体的代码实现</li><li>需要重载一些操作符</li><li>需要typedef一些类型，搞死容器内的数据的实际类型是什么样子的</li><li>begin() end()基本操作</li></ul><ol start="3"><li>Sum（）</li></ol><pre><code>template &lt;class Iter&gt; typename Iter::value_type sum(Iter start, Iter end, T init) {    typename Iter::value_type result = init;    while (start != end) {        result = result + *start;        start++;    }    return result;}</code></pre><ol start="4"><li>reduce()</li></ol><pre><code>template&lt;class Iter, class T, class Op&gt; T reduce (Iter start, Iter end, T init, Op op) {    T result = init;    while ( start != end ) {        result = op( result, *start );        start++;    }    return result;}</code></pre><h2 id="2-2-动态类型语言的泛型编程"><a href="#2-2-动态类型语言的泛型编程" class="headerlink" title="2.2 动态类型语言的泛型编程"></a>2.2 动态类型语言的泛型编程</h2><p>在编程世界，我们需要处理好两件事情： </p><ol><li>编程语言中的类型问题</li><li>对真实世界中业务代码的抽象、重用和拼装</li></ol><h3 id="2-2-1-类型系统"><a href="#2-2-1-类型系统" class="headerlink" title="2.2.1 类型系统"></a>2.2.1 类型系统</h3><p>在计算机科学中，类型系统用于定义如何将编程语言中的数值和表达式归类为许多不同的类型，以及如何操作这些类型，还有这些类型如何互相作用。类型可以确认一个值或者一组值具有特定的意义和目的。</p><p>类型系统在各种语言之间很不同，存在于编译时期的语法，以及运行时期的操作实现方式。</p><p>程序语言的类型系统主要提供如下功能： </p><ul><li>程序语言的安全性</li></ul><p>使用类型可以让编译器侦测一些代码的错误。例如：可以识别出一个错误无效的表达式。如：<code>“Hello, World” + 3</code>这样的不同数据类型间操作的问题。强类型语言提供更多的安全性，但是并不能保证绝对的安全。</p><ul><li>利于编译器的优化</li></ul><p>静态类型语言的类型声明，可以让编译器明确地知道程序员的意图。因此，编译器就可以利用这一信息做很多代码优化工作。例如：如果我们指定一个类型是int,那么编译就知道，这个类型会以4个字节的倍数进行对齐，编译器就可以非常有效地利用更有效率的机器指令。 </p><ul><li>代码的可读性</li></ul><p>有类型的编程语言，可以让代码更易读和更易维护。代码的语义也更清楚，代码模块的接口（如函数）也更丰富和更清楚。</p><ul><li>抽象化</li></ul><p>类型允许程序设计者对程序以较高层次的方式思考，而不是烦人的低层次实现。例如，我们使用整型或是浮点型来取代底层的字节实现，我们可以将字符串设计成一个值，而不是底层的字节的数组。从高层上来说，类型可以用来定义不同模块间的交互协议，比如函数的入参类型和返回类型，从而可以让接口更有语义，而且不同的模块数据交换更为直观和易懂。</p><p>在动态语言中，一个变量的类型是由运行时的解释器来动态标记的，这样就可以动态地和底层的计算机指令或内存布局对应起来。</p><h1 id="3-泛型的本质"><a href="#3-泛型的本质" class="headerlink" title="3. 泛型的本质"></a>3. 泛型的本质</h1><ul><li>类型是对内存的一种抽象。不同的类型，会有不同的内存布局和内存分配的策略。</li><li>不同的类型，有不同的操作。所以，对于特定的类型，也有特定的一组操作。</li></ul><blockquote><p>Generic programming centers around the idea of abstracting from concrete, efficient algorithms to obtain generic algorithms that can be combined with different data representations to produce a wide variety of useful software.</p></blockquote><p>屏蔽掉数据和操作数据的细节，让算法更为通用，让编程者更多地关注算法结构，而不是在算法中处理不同的数据类型。</p><p>要做到泛型，我们需要： </p><ul><li>标准化掉类型的内存分配、释放和访问。</li><li>标准化掉类型的操作。比如：比较操作，I/O 操作，复制操作……</li><li>标准化掉数据容器的操作。比如：查找算法、过滤算法、聚合算法……</li><li>标准化掉类型上特有的操作。需要有标准化的接口来回调不同类型的具体操作……</li></ul><h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><p><a href="https://time.geekbang.org/column/48" target="_blank" rel="noopener">左耳听风的极客时间专栏</a></p><p><a href="https://blog.csdn.net/Hackbuteer1/article/details/7558868" target="_blank" rel="noopener">虚函数</a></p><p><a href="https://lxwei.github.io/posts/262.html" target="_blank" rel="noopener">从源代码到可执行文件</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-起源&quot;&gt;&lt;a href=&quot;#1-起源&quot; class=&quot;headerlink&quot; title=&quot;1. 起源&quot;&gt;&lt;/a&gt;1. 起源&lt;/h1&gt;&lt;p&gt;编程范式, programming paradigm，是一类典型的编程风格。&lt;/p&gt;
&lt;p&gt;将主流编程语言分为三部分，加
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="编程范式" scheme="https://www.llchen60.com/tags/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>编程范式系列-基于原型的编程</title>
    <link href="https://www.llchen60.com/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F%E7%B3%BB%E5%88%97-%E5%9F%BA%E4%BA%8E%E5%8E%9F%E5%9E%8B%E7%9A%84%E7%BC%96%E7%A8%8B/"/>
    <id>https://www.llchen60.com/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F%E7%B3%BB%E5%88%97-%E5%9F%BA%E4%BA%8E%E5%8E%9F%E5%9E%8B%E7%9A%84%E7%BC%96%E7%A8%8B/</id>
    <published>2020-02-04T04:30:57.000Z</published>
    <updated>2020-02-04T04:31:16.073Z</updated>
    
    <content type="html"><![CDATA[<p>基于原型的编程，是指没有class化，直接使用对象的编程方式。又叫做基于实例的编程，主流语言是JavaScript。 </p><h1 id="1-与传统面向对象编程的比较"><a href="#1-与传统面向对象编程的比较" class="headerlink" title="1. 与传统面向对象编程的比较"></a>1. 与传统面向对象编程的比较</h1><h2 id="1-1-关注对象实例行为，而后对类进行划分"><a href="#1-1-关注对象实例行为，而后对类进行划分" class="headerlink" title="1.1 关注对象实例行为，而后对类进行划分"></a>1.1 关注对象实例行为，而后对类进行划分</h2><p>在基于类的编程当中，对象总共有两种类型。</p><ol><li>类</li></ol><p>定义了对象的基本布局，函数特性。—-&gt; 是行为和结构的集合，对所有的接口来说这些类的行为和结构都是相同的。</p><ol start="2"><li>接口</li></ol><p>是可以使用的对象,定义了一些行为，基于特定类的样式。</p><p>在这种模式下，类的划分是基于行为和结构，而不是状态。原型编程的主张者提倡关注一系列对象实例的行为，而后关注将其划分到使用方式相似的原型对象。实际上说，不同之处在于对于状态的看重程度。</p><h2 id="1-2-创建实例的时间"><a href="#1-2-创建实例的时间" class="headerlink" title="1.2 创建实例的时间"></a>1.2 创建实例的时间</h2><p>对于基于类的系统，新的实例是通过类构造器以及参数来构造，实例是由类的行为和结构来定义的。</p><p>对于基于原型的系统，可以通过复制已有的对象或者通过扩展空对象来创建，是在<strong>运行时</strong>对原型进行修改的。</p><h1 id="2-JavaScript-原型的概念"><a href="#2-JavaScript-原型的概念" class="headerlink" title="2. JavaScript 原型的概念"></a>2. JavaScript 原型的概念</h1><pre><code>var foo = {name: &quot;foo&quot;, one: 1, two: 2};var bar = {three: 3};bar.__proto__ = foo; // foo is...// If we try to access foo&#39;s properties from bar // from now on, we&#39;ll succeed. bar.one // Resolves to 1.// The child object&#39;s properties are also accessible.bar.three // Resolves to 3.// Own properties shadow prototype propertiesbar.name = &quot;bar&quot;;foo.name; // unaffected, resolves to &quot;foo&quot;bar.name; // Resolves to &quot;bar&quot;</code></pre><p>每个对象都有个<code>_proto_</code>属性，通过赋值操作，bar的原型现在是foo了。因此我们可以在bar里面访问foo的属性。</p><h2 id="2-1-区分-proto-以及prototype"><a href="#2-1-区分-proto-以及prototype" class="headerlink" title="2.1 区分_proto_以及prototype"></a>2.1 区分<code>_proto_</code>以及<code>prototype</code></h2><ul><li><p><code>_proto_</code><br>主要安放在一个实际的对象当中，用它来产生一个链接，用于寻找方法名或属性。用于链接原型的一个指针。</p></li><li><p><code>prototype</code><br>当用new来构造一个新的对象的时候构造<code>_proto_</code>的时候用的，是构造函数的一个属性。</p></li></ul><h2 id="2-2-对象的表现形式"><a href="#2-2-对象的表现形式" class="headerlink" title="2.2 对象的表现形式"></a>2.2 对象的表现形式</h2><ul><li>Object </li><li>Function </li></ul><h1 id="3-Conclusion"><a href="#3-Conclusion" class="headerlink" title="3. Conclusion"></a>3. Conclusion</h1><p>其实是一种委托方式，通过一个序列的指针来定位属性，寻找数据。可以带来运行时的灵活性，数据方法都可以进行修改了。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;基于原型的编程，是指没有class化，直接使用对象的编程方式。又叫做基于实例的编程，主流语言是JavaScript。 &lt;/p&gt;
&lt;h1 id=&quot;1-与传统面向对象编程的比较&quot;&gt;&lt;a href=&quot;#1-与传统面向对象编程的比较&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="编程范式" scheme="https://www.llchen60.com/tags/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/"/>
    
  </entry>
  
</feed>
