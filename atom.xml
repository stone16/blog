<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Leilei&#39;s Blog | 磊磊的博客</title>
  
  <subtitle>Because it&#39;s there</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.llchen60.com/"/>
  <updated>2020-04-13T00:34:29.013Z</updated>
  <id>https://www.llchen60.com/</id>
  
  <author>
    <name>Leilei Chen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>中台</title>
    <link href="https://www.llchen60.com/%E4%B8%AD%E5%8F%B0/"/>
    <id>https://www.llchen60.com/%E4%B8%AD%E5%8F%B0/</id>
    <published>2020-04-13T00:32:59.000Z</published>
    <updated>2020-04-13T00:34:29.013Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-什么是中台？"><a href="#1-什么是中台？" class="headerlink" title="1. 什么是中台？"></a>1. 什么是中台？</h1><p>看到几篇关于中台的博客，是国内提出的一个新的概念，稍微研究了下，很有意思的概念。</p><p>中台，在我看来，从业务上来讲，可以说是为了解决系统的复用性的问题而出现的。一个简单的例子，阿里刚刚开始的时候只有淘宝，但是后来出现了天猫，二者尽管顶层业务逻辑有不同，但是他们都是需要一套订单，商品，库存，仓储，物流的各种系统的。如果每次我们想做一个新的业务模块的时候，都要来实现这样一套系统，迭代速度会很慢，而且很容易在做改动的时候因为各个类似功能的系统的改动不一致产生错误。</p><p>因此，将这些公用的系统提升，做成–中台，统一来使得各个业务部门重复使用，将需要反复建设的功能和系统进行统一的规划和管理。</p><p>主要解决的问题实质上有两类： </p><ol><li>需要业务需求或者功能需求是高度类似的，通用化程度很高，但是由于没有专门的团队负责规划和开发，大量的系统重复开发、重复建设、导致复用性很低，效率低，研发资源被浪费，用户体验也不够统一</li><li>早起业务发展过程当中，为了解决当下的一些业务问题，垂直的个性化的业务逻辑与基础系统耦合太深，由于没有平台性质的规划，横向系统之间、上下游系统之间的交叉逻辑非常多，导致了在新业务新市场的拓展过程当中，市场没有办法直接复用，甚至没有办法快速迭代。</li></ol><h1 id="2-为什么要中台，为什么要平台化？"><a href="#2-为什么要中台，为什么要平台化？" class="headerlink" title="2. 为什么要中台，为什么要平台化？"></a>2. 为什么要中台，为什么要平台化？</h1><p>引述《白话中台战略》当中的内容，“因为在当今互联网时代，⽤户才是商业战场的中心，为了快速响应用户的需求，借助平台化的力量可以事半功倍”</p><blockquote><p>不断快速响应、探索、挖掘、引领⽤户的需求，才是企业得以⽣存和持续发展的关键因素。</p></blockquote><blockquote><p>那些真正尊重用户，甚⾄不惜调整⾃己颠覆⾃己来响应⽤户的企业将在这场以⽤户为中心的商业战争中得以⽣存和发展；⽽反之，那些在过去的成就上故步⾃封，存在侥幸⼼理希望⽤户会像之前一样继续追随⾃己的企业则会被用户淘汰。很残酷，但这就是这个时代最基本的企业⽣存法则。</p></blockquote><p>平台化能够赋予或加强企业在以用户为中心的现代商业战争当中最为核心的能力 –&gt; 用户响应力。 </p><p>中台，可以说是与前台，后台相对应的。</p><ul><li>前台<ul><li>由各类前台系统组成的前端平台。每个前台系统就是一个用户触点，即企业的最终用户直接使用或者交互的系统，是企业与最终用户的交点。</li></ul></li><li>后台<ul><li>后台系统组成的后端平台，宝具哦企业的核心资源 – 数据 + 计算 <ul><li>财务系统</li><li>产品系统</li><li>客户管理系统</li><li>仓库物流管理系统</li></ul></li></ul></li><li>中台<ul><li>因为企业后台往往不能很好的支撑前台快速创新，响应用户的需求</li><li>前台直接使用后台，会遇到处理复杂，迭代速度缓慢的问题</li><li>前台要处理的是快速响应用户的需求，但是后台拿着整个公司的数据，是需要越稳定越好的，随着公司的发展，按照对速度和稳定的追求的冲突会越来越多</li><li>有了中台以后就可以将前台系统当中的稳定通用业务能力沉降到中台层，恢复前台的响应力</li></ul></li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://www.infoq.cn/article/3tbJZ8aS5pYdWYX5bBfg?utm_source=rss&amp;utm_medium=article" target="_blank" rel="noopener">https://www.infoq.cn/article/3tbJZ8aS5pYdWYX5bBfg?utm_source=rss&amp;utm_medium=article</a></li><li><a href="https://mp.weixin.qq.com/s/yfhaEkO1DG_ihJMhwtkWjA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/yfhaEkO1DG_ihJMhwtkWjA</a></li><li><a href="https://www.infoq.cn/article/hfONAlDdhK3fD9JjduGR" target="_blank" rel="noopener">https://www.infoq.cn/article/hfONAlDdhK3fD9JjduGR</a></li><li><a href="https://www.zhihu.com/question/57717433" target="_blank" rel="noopener">https://www.zhihu.com/question/57717433</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-什么是中台？&quot;&gt;&lt;a href=&quot;#1-什么是中台？&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是中台？&quot;&gt;&lt;/a&gt;1. 什么是中台？&lt;/h1&gt;&lt;p&gt;看到几篇关于中台的博客，是国内提出的一个新的概念，稍微研究了下，很有意思的概念。&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="中台" scheme="https://www.llchen60.com/tags/%E4%B8%AD%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>关于抖音的一些分析</title>
    <link href="https://www.llchen60.com/%E5%85%B3%E4%BA%8E%E6%8A%96%E9%9F%B3%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E6%9E%90/"/>
    <id>https://www.llchen60.com/%E5%85%B3%E4%BA%8E%E6%8A%96%E9%9F%B3%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E6%9E%90/</id>
    <published>2020-04-11T21:29:43.000Z</published>
    <updated>2020-04-11T22:45:17.990Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a>1. Overview</h1><h2 id="1-1-外部环境背景"><a href="#1-1-外部环境背景" class="headerlink" title="1.1 外部环境背景"></a>1.1 外部环境背景</h2><p>短视频是当前超高速发展的赛道，流量持续迅猛增长，越来越多的公司进入这个赛道，头部的国内有抖音快手，主要着眼于1min以内的短视频，主要为UGC(User Generated Content)，少量PGC(Professional Generated Content)产出内容；美国有刚刚成立的quibi，着眼于制作10min左右的优质内容，完全走PGC的路线。</p><p>短视频的兴起是有一些需要的社会以及科技的基础背景的。 </p><ul><li>从经济发展角度<ul><li>经济的持续发展，刺激了人们的休闲娱乐的需求的增长</li></ul></li><li>从用户需求角度<ul><li>需要填补自己的碎片时间</li><li>需要更多的娱乐休闲</li><li>自我表达，自我实现，社会联结的需求</li><li>发泄情绪</li></ul></li><li>从用户使用习惯角度<ul><li>截止2019年6月<ul><li>全国手机网民数量达到8.47亿(根据第44次中国互联网发展状况统计报告)，互联网普及率达到61.2%</li><li>网络购物用户规模6.39亿 </li><li>手机网络购物用户规模6.22亿</li><li>网络视频用户7.59亿</li><li>移动互联网接入流量消费553.9亿GB 同比增长107.3% </li><li>网民平均每周上网时长 27.9小时</li><li>短视频时长占比 11.5%，使用高峰为12点以及21点左右  </li></ul></li></ul></li><li>从技术角度<ul><li>4G 5G兴起，高速网络建设</li><li>手机的广泛普及</li><li>云平台普及，企业架构的相对简化，成本的降低 </li></ul></li><li>政策影响<ul><li>推出《网络短视频平台管理规范》</li><li>推出《网络短视频内容审核标准细则》 </li></ul></li></ul><h2 id="1-2-时间线"><a href="#1-2-时间线" class="headerlink" title="1.2 时间线"></a>1.2 时间线</h2><ul><li>2016年9月上线 <ul><li>A.me 定位为音乐短视频社区 </li><li>年轻人的15秒音乐短视频社区 </li></ul></li><li>2016年11月<ul><li>查找通讯录，邀请QQ 微博好友</li></ul></li><li>2016年11月10日<ul><li>微博话题挑战</li><li>雇佣 召集大学生，舞蹈音乐达人，拍摄视频引流</li></ul></li><li>2016年12月10日<ul><li>抖音 – 音乐视频应用</li></ul></li><li>2016年12月22日<ul><li>推荐热门视频</li><li>捧红一部分人，再带动普通用户的理念 – 偏向于中心化的运营方式出现端倪    </li></ul></li><li>2017年3月<ul><li>邀请岳云鹏等诸多明星加入抖音</li><li>开始有大批用户从明星微博当中看到抖音水印，进入抖音平台</li></ul></li><li>2017年6月开始<ul><li>给视频创作者更多权限<ul><li>对评论的控制，删减</li></ul></li><li>附近 tab，增强社交属性</li><li>抖音故事<ul><li>可以设置只开放24小时，希望普通人可以在上面记录自己的生活</li></ul></li><li>可以绑定微博主页</li></ul></li><li>2017年8月<ul><li>Tik Tok出海</li><li>吴亦凡的抖音挑战</li><li>中国有嘻哈 官方推荐</li><li>抖音开始砸钱到各个节目，增加曝光度了</li></ul></li><li>2017年9月<ul><li>首次线下party，狂欢节</li><li>和汉堡王，摩拜单车等等公司展开合作，联名等</li><li>AR相机</li><li>开启信息流广告，开屏广告的尝试 </li></ul></li><li>2017年10月<ul><li>上线直播功能</li></ul></li><li>2017年11月<ul><li>全新滤镜</li><li>倒计时自动暂停</li><li>直播间优化，增加弹幕功能</li></ul></li><li>2017年12月<ul><li>全新尬舞机功能    </li></ul></li><li>2018年1月<ul><li>百万英雄</li><li>私信功能</li><li>优化举报 评论功能</li></ul></li><li>2018年3月<ul><li>大规模的广告接入和投放开始</li></ul></li><li>2018年8月  <ul><li>直达淘宝功能上线</li><li>反沉迷系统上线        </li><li>增加游戏贴纸</li></ul></li><li>2018年10月<ul><li>个人页背景设置，个性化主页</li></ul></li><li>2018年12月<ul><li>直播粉丝团任务体系</li></ul></li><li>2019年1月<ul><li>地点详情页上传视频图片，用抖音来记录生活</li><li>直播 礼物一键连送</li><li>随拍功能</li><li>春晚独家社交媒体传播平台，五亿现金分享</li></ul></li><li>2019年2月<ul><li>AR画笔功能</li></ul></li><li>2019年3月<ul><li>随拍支持发布纯文字内容</li><li>新增聚焦拍摄模式</li><li>私信可置顶</li><li>热血鼓手道具玩法</li><li>新增位置贴纸</li></ul></li><li>2019年4月   <ul><li>道具玩法 – 橙子脸 </li><li>道具玩法 – 漫画擦拭</li></ul></li><li>2019年5月<ul><li>道具玩法 - change face   </li><li>挡脸变男生</li><li>道具玩法 - LineDancer</li></ul></li><li>2019年6月<ul><li>合拍 测相似度</li><li>道具玩法 – 炫光衣服 </li><li>道具玩法 – 照片连拍</li></ul></li><li>2019年7月<ul><li>道具玩法 – 动感轮廓</li><li>道具玩法 – 擦拭隐身</li><li>增加文字功能，可以在视频上添加文字了</li></ul></li><li>2019年9月<ul><li>青少年模式</li><li>道具玩法 – 百变抖抖秀</li></ul></li><li>2019年10月<ul><li>新增贴纸</li><li>青少年模式优化</li><li>新增变声功能</li></ul></li><li>2020年1月 - 至今<ul><li>春节20亿现金等你拿  </li><li>新增贴纸</li><li>新增特效  <h1 id="2-平台分析"><a href="#2-平台分析" class="headerlink" title="2. 平台分析"></a>2. 平台分析</h1><h2 id="2-1-市场定位"><a href="#2-1-市场定位" class="headerlink" title="2.1 市场定位"></a>2.1 市场定位</h2>从1.1的整个时间轴，我们会发现整个抖音的发展很小步快跑，迅速迭代。刚开始出了产品原型，用初始用户群体开始迅速做迭代，在锚定自己的定位，目标人群之后，通过召集KOL，明星，通过微博，QQ微信引流，实现其迅速的增长。</li></ul></li></ul><p>抖音的slogan是<strong>记录美好生活</strong>，<strong>以一二线城市年轻潮人为目标用户，市场定位突出音乐与创意</strong>，是一个相对中心化的高热度高流量的聚集年轻人的音乐短视频平台。整体是以音乐为核心布局的，用户在拍摄视频前首先选择一首背景音乐，根据音乐内容进行动作编排和加工特效。</p><h2 id="2-2-产品设计"><a href="#2-2-产品设计" class="headerlink" title="2.2 产品设计"></a>2.2 产品设计</h2><h3 id="2-2-1-浏览体验"><a href="#2-2-1-浏览体验" class="headerlink" title="2.2.1 浏览体验"></a>2.2.1 浏览体验</h3><ul><li>整体以黑白灰三色为主，风格简洁，有潮流感</li><li>全屏沉浸式体验<ul><li>无限向下滑动</li></ul></li><li>竖屏播放 – 适用更多的场景(上班，通勤，吃饭，等等) – 也很符合于短视频碎片时间使用的定位</li><li>点击背景音乐会跳转到同款音乐其他的短视频集合</li><li>交互 任意位置双击点赞，上下滑浏览其他视频</li><li>长按 可以看到更多的一些选择<ul><li>不感兴趣</li><li>加到喜欢 </li></ul></li></ul><h3 id="2-2-2-拍摄"><a href="#2-2-2-拍摄" class="headerlink" title="2.2.2 拍摄"></a>2.2.2 拍摄</h3><p>抖音在拍摄方面下了很大功夫，从更新日志上也能很明显看出他在尝试着不断降低拍摄出高质量视频的门槛，通过大量的特效，各种道具，让短视频不至于单调，可以用比较简单的素材，加上特效，音乐，撑起来。</p><ul><li>多种类型音乐<ul><li>国风</li><li>流行</li><li>原创 </li><li>etc.</li></ul></li><li>视频制作的功能<ul><li>速度切换</li><li>多段混剪</li><li>贴纸道具</li><li>美化滤镜</li><li>特效滤镜<h3 id="2-2-3-特色功能"><a href="#2-2-3-特色功能" class="headerlink" title="2.2.3 特色功能"></a>2.2.3 特色功能</h3></li></ul></li><li>热搜榜</li><li>尬舞机</li><li>时间锁</li></ul><h2 id="2-3-内容生产与分发"><a href="#2-3-内容生产与分发" class="headerlink" title="2.3 内容生产与分发"></a>2.3 内容生产与分发</h2><h3 id="2-3-1-内容生产模式"><a href="#2-3-1-内容生产模式" class="headerlink" title="2.3.1 内容生产模式"></a>2.3.1 内容生产模式</h3><p>UGC + PGC模式</p><ul><li>UGC<ul><li>普通用户</li></ul></li><li>PGC<ul><li>明星</li><li>网红</li><li>专业垂直领域KOL</li></ul></li></ul><h3 id="2-3-2-内容分发模式"><a href="#2-3-2-内容分发模式" class="headerlink" title="2.3.2 内容分发模式"></a>2.3.2 内容分发模式</h3><ul><li>算法推荐+人工精选推荐<ul><li>根据用户的观看数据，计算用户内容标签，按照一定频率推送相似的视频内容 </li><li>推荐爆款内容，越优质的内容会得到越多的曝光机会</li><li>推荐机制不太在意内容的发布时间，只要足够精彩，可能<strong><em>已经发布了几个月的视频</em></strong>还会不断推给用户</li></ul></li></ul><h2 id="2-4-营销推广"><a href="#2-4-营销推广" class="headerlink" title="2.4 营销推广"></a>2.4 营销推广</h2><ul><li>开屏广告</li><li>信息流广告</li><li>定制挑战赛<ul><li>为品牌独家定制</li><li>保持剧情，自主拍摄权交给视频制作者</li></ul></li><li>聚合电商<ul><li>同淘宝的直接链接</li></ul></li></ul><h2 id="2-5-技术能力"><a href="#2-5-技术能力" class="headerlink" title="2.5 技术能力"></a>2.5 技术能力</h2><ul><li>监管<ul><li>人工为主，机器学习为辅 <ul><li>通过建立完善数据库，将用户上传的内容与数据库进行匹配，被识别为不良内容就予以直接删除</li></ul></li><li>用户举报  <ul><li><h1 id="3-Thoughts"><a href="#3-Thoughts" class="headerlink" title="3. Thoughts"></a>3. Thoughts</h1></li></ul></li></ul></li></ul><h2 id="3-1-用户的需求"><a href="#3-1-用户的需求" class="headerlink" title="3.1 用户的需求"></a>3.1 用户的需求</h2><p>用户参与到虚拟社区的动机，可以是基于：</p><ul><li>自我认知和需求的满足 </li><li>社会交往需求  – 抖音不太能满足</li><li>获取利益的需求 – 平台盘子的扩大会增大每个人的盘子</li><li>情感归属 – 指跟随自己的偶像，明星，希望获取更多相关的信息</li></ul><p>首先，感到大部分人不习惯自己去主动寻求信息的，或者说，是不太清楚自己应该主动获取什么样的信息，因此app的主动推送，人被选择适时而生。（IOC 容器了解一下,hhh）</p><p>每个App都有自己的味道，抖音的味道能够吸引来追逐潮流的年轻人。可以在这里看到<strong>和自己类似的人</strong>拍的视频，看到的<strong>美好的世界</strong>。</p><p>抖音一定程度上满足了用户的自我认知的需求，会觉得抖音和自己很搭(用户画像和自我认知的部分重合)。</p><p>但在社交方面，有点不尽如人意，这也和抖音的整体 – 偏中心化的音乐短视频平台的初始定位有关了。当大部分的高质内容产出出自PGC, MCN的时候，潜在的内容创作者很可能会因为成为热门的高门槛而放弃。大家看自己向往的生活，而不是自己的生活。</p><p>热门视频大部分是有趣的段子，以及同样的素材音乐下的小哥哥小姐姐的表现，同质化有点严重，同时离日常生活的距离着实有点远，这也致使了用户之间的关联感比较差。  </p><p>一个超漂亮的小姐姐在跳舞，你会“哇，太好看了”，但你不知道该回什么，才能够不太尬的认识。因为这些小姐姐可能离你的物理距离还很远是吧~ 可看没法约 </p><p>抖音其实现在有基于地理位置的模块，有种想两手抓的感觉，不知道后台流量如何，只是当用户对于一个平台的定位是 – 去看好玩的搞笑的，去看小哥哥小姐姐的时候，想改变既定的认知，难度不小。想在保持当前定位的同时，加上一个社交属性，好像有些部分是相互有冲突的。</p><p>看到新闻在灰度测试，陌生人视频聊天，增强社交属性，看来是太不活跃，并没有灰度上。不知道具体是怎么样的过程，有没有足够多的对话题的引导，这种带点“阅后即焚”性质的尝试，会不会一不小心跨过监管允许的限制，lol  拭目以待</p><h2 id="3-2-others"><a href="#3-2-others" class="headerlink" title="3.2 others"></a>3.2 others</h2><ul><li>用户集中于一二线城市<ul><li>如何向三四线城市扩张？<ul><li>囧妈 很酷</li><li>大量的广告，代言<ul><li>这种打法在一二线城市很好用，三四线城市呢，联想趣头条 – 我们要最实在的！请给我钱，lol</li></ul></li><li>内容上的倾斜<ul><li>如何生产更多的小镇青年感兴趣的内容？  </li></ul></li></ul></li></ul></li><li>视频创作的门槛与参与热情<ul><li>刺激计划</li><li>培训平台 <ul><li>2019年11月26日上线创作者学院 </li></ul></li></ul></li><li>内容同质化，低俗化<ul><li>当在娱乐化做到很极致的时候(请看抖音app的极快的迭代频率，以及层出不穷的新道具，新玩法)，需要做更加深度的内容么？ </li><li>当知识付费成为新风口，巫师财经，半佛仙人成功出圈以后，有机会将内容浓缩到1-5min的视频当中，来点先导知识，然后再成功引流到长视频网站上？ </li></ul></li><li>弱社交平台<ul><li>社交是保证一个平台用户粘性的护城河，当抖音选择了沉浸式的无限下滑的交互方式的时候，一定程度上，我们可以说是舍弃了社交的 （对比快手的下滑留评，左滑回退的操作）。</li><li>弱社交也可以从留评数据当中可以看出，尽管抖音的日活月活遥遥领先，但留评，点赞是快手占据优势的，互动率要高出很多</li><li>做不做社交？<ul><li>一直无限想做，先出自己的专属app，没做起来，现在直接放到抖音这个国民app里做了</li></ul></li><li>为什么想做？<ul><li>社交，粘性，带货，看看快手的带货数据，贼酷炫</li><li>社交 - 附近的人 - 一张美丽的类似美团的外卖带动基于地理位置的其他业务的美妙构想</li></ul></li><li>concern<ul><li>社交注定是需要带点“平均人” 的理念的，这不仅仅需要接口，路径，交互方式的改变，更是内容分发逻辑，视频创作方式上的改变。那问题来了，社交有多重要，重要到改变整个平台的现有定位，重要到可能会降低一些格调，少一些fancy，多点生活气息么？ </li></ul></li></ul></li><li>算法 信息茧房<ul><li>用户喜欢的信息和信息广度的tradeoff，算法的单个方向上的相对极致优化，会缩减用户能够接受到的信息范围的</li><li>依旧是平台算法优化的问题了，到底给用户留出多少自己的空间呢？ </li></ul></li><li>政策的限制/要求 - 娱乐属性，社会属性，深入的思考性的东西很少<ul><li>嗯，是这样的~  </li></ul></li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="http://www.woshipm.com/evaluating/994454.html" target="_blank" rel="noopener">http://www.woshipm.com/evaluating/994454.html</a> </li><li><a href="https://tools.lancely.tech/apple/app-version/cn/1142110895" target="_blank" rel="noopener">https://tools.lancely.tech/apple/app-version/cn/1142110895</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Overview&quot;&gt;&lt;a href=&quot;#1-Overview&quot; class=&quot;headerlink&quot; title=&quot;1. Overview&quot;&gt;&lt;/a&gt;1. Overview&lt;/h1&gt;&lt;h2 id=&quot;1-1-外部环境背景&quot;&gt;&lt;a href=&quot;#1-1-外部环境背
      
    
    </summary>
    
    
      <category term="Notes" scheme="https://www.llchen60.com/categories/Notes/"/>
    
    
      <category term="thought" scheme="https://www.llchen60.com/tags/thought/"/>
    
      <category term="抖音" scheme="https://www.llchen60.com/tags/%E6%8A%96%E9%9F%B3/"/>
    
  </entry>
  
  <entry>
    <title>构建React的想法 - from sebmarkbage</title>
    <link href="https://www.llchen60.com/%E6%9E%84%E5%BB%BAReact%E7%9A%84%E6%83%B3%E6%B3%95-from-sebmarkbage/"/>
    <id>https://www.llchen60.com/%E6%9E%84%E5%BB%BAReact%E7%9A%84%E6%83%B3%E6%B3%95-from-sebmarkbage/</id>
    <published>2020-04-09T03:25:08.000Z</published>
    <updated>2020-04-09T03:31:08.065Z</updated>
    
    <content type="html"><![CDATA[<p>从github翻到的论述，是React设计者试图说明其构建React的整个逻辑。</p><h1 id="1-转换-Transformation"><a href="#1-转换-Transformation" class="headerlink" title="1. 转换 - Transformation"></a>1. 转换 - Transformation</h1><p>React的核心假定是UI层实际上是对数据的展现形式的一种转换。同样的输入会给出同样的输出结果，只是表现形式可能会有所区别。</p><pre><code>function NameBox(name) {  return { fontWeight: &#39;bold&#39;, labelContent: name };}&#39;Sebastian Markbåge&#39; -&gt;{ fontWeight: &#39;bold&#39;, labelContent: &#39;Sebastian Markbåge&#39; };</code></pre><h1 id="2-抽象-Abstraction"><a href="#2-抽象-Abstraction" class="headerlink" title="2. 抽象 - Abstraction"></a>2. 抽象 - Abstraction</h1><p>我们无法将一个复杂的UI放到一个方法当中的。将UI抽象到各个可以复用的组件当中就变得尤为重要。抽象成可复用的组件，并且隐藏实现的细节，是我们想要做的。</p><pre><code>function FancyUserBox(user) {  return {    borderStyle: &#39;1px solid blue&#39;,    childContent: [      &#39;Name: &#39;,      NameBox(user.firstName + &#39; &#39; + user.lastName)    ]  };}{ firstName: &#39;Sebastian&#39;, lastName: &#39;Markbåge&#39; } -&gt;{  borderStyle: &#39;1px solid blue&#39;,  childContent: [    &#39;Name: &#39;,    { fontWeight: &#39;bold&#39;, labelContent: &#39;Sebastian Markbåge&#39; }  ]};</code></pre><h1 id="3-组合-Composition"><a href="#3-组合-Composition" class="headerlink" title="3. 组合 - Composition"></a>3. 组合 - Composition</h1><p>为了实现真正可以复用的特性，仅仅使用细分的子功能，并且每次给他们构建容器是不太够的。我们需要能够建立中间层的抽象，即将几个子功能组件组合起来，形成另一层次的组件。这里的组合就是指将多个抽象融合成一个抽象的能力。</p><pre><code>function FancyBox(children) {  return {    borderStyle: &#39;1px solid blue&#39;,    children: children  };}function UserBox(user) {  return FancyBox([    &#39;Name: &#39;,    NameBox(user.firstName + &#39; &#39; + user.lastName)  ]);}</code></pre><h1 id="4-状态-State"><a href="#4-状态-State" class="headerlink" title="4. 状态 - State"></a>4. 状态 - State</h1><p>UI不仅仅是服务器以及商业逻辑的复制，实际上是有很多状态，是服务于特定的运行过程的。比如你在一个文本框输入内容，那么我们需要一些方式能够记录下这个文本框当前的状态，并且用这个状态去和后端进或者其他的方法进行交互。</p><p>我们希望我们的数据是immutable的</p><pre><code>function FancyNameBox(user, likes, onClick) {  return FancyBox([    &#39;Name: &#39;, NameBox(user.firstName + &#39; &#39; + user.lastName),    &#39;Likes: &#39;, LikeBox(likes),    LikeButton(onClick)  ]);}// Implementation Detailsvar likes = 0;function addOneMoreLike() {  likes++;  rerender();}// InitFancyNameBox(  { firstName: &#39;Sebastian&#39;, lastName: &#39;Markbåge&#39; },  likes,  addOneMoreLike);</code></pre><h1 id="5-记忆方法"><a href="#5-记忆方法" class="headerlink" title="5. 记忆方法"></a>5. 记忆方法</h1><p>如果我们知道这是个纯方法，并且还会重复的call它，那么我们可以设计一个记忆版本的方法，这样我们就不用在有相同的数据(输入)的时候还要重复执行了</p><pre><code>function memoize(fn) {  var cachedArg;  var cachedResult;  return function(arg) {    if (cachedArg === arg) {      return cachedResult;    }    cachedArg = arg;    cachedResult = fn(arg);    return cachedResult;  };}var MemoizedNameBox = memoize(NameBox);function NameAndAgeBox(user, currentTime) {  return FancyBox([    &#39;Name: &#39;,    MemoizedNameBox(user.firstName + &#39; &#39; + user.lastName),    &#39;Age in milliseconds: &#39;,    currentTime - user.dateOfBirth  ]);}// 我们同样可以不仅仅记一个值，也可以记一个mapfunction memoize(fn) {  return function(arg, memoizationCache) {    if (memoizationCache.arg === arg) {      return memoizationCache.result;    }    const result = fn(arg);    memoizationCache.arg = arg;    memoizationCache.result = result;    return result;  };}function FancyBoxWithState(  children,  stateMap,  updateState,  memoizationCache) {  return FancyBox(    children.map(child =&gt; child.continuation(      stateMap.get(child.key),      updateState,      memoizationCache.get(child.key)    ))  );}const MemoizedFancyNameBox = memoize(FancyNameBox);</code></pre><h1 id="6-列表"><a href="#6-列表" class="headerlink" title="6. 列表"></a>6. 列表</h1><p>大部分的UI都是一些形式的列表，然后为在列表中的每个元素产出不同的一系列的值。这就自然的产生了一个有层级的结构。</p><p>我们可以通过使用Map方法来管理每个列表当中的元素的状态。</p><pre><code>function UserList(users, likesPerUser, updateUserLikes) {  return users.map(user =&gt; FancyNameBox(    user,    likesPerUser.get(user.id),    () =&gt; updateUserLikes(user.id, likesPerUser.get(user.id) + 1)  ));}var likesPerUser = new Map();function updateUserLikes(id, likeCount) {  likesPerUser.set(id, likeCount);  rerender();}UserList(data.users, likesPerUser, updateUserLikes);</code></pre><h1 id="7-持续性"><a href="#7-持续性" class="headerlink" title="7. 持续性"></a>7. 持续性</h1><p>一些时候，我们在运行我们的核心商业逻辑的时候会大量的操作数据，这部分关于数据的操作会显得有些冗余，我们可以将其移出核心逻辑的代码块，比如使用bind，来绑定方法，在其他地方写具体的代码逻辑。</p><pre><code>function FancyUserList(users) {  return FancyBox(    UserList.bind(null, users)  );}const box = FancyUserList(data.users);const resolvedChildren = box.children(likesPerUser, updateUserLikes);const resolvedBox = {  ...box,  children: resolvedChildren};</code></pre><h1 id="8-状态Map"><a href="#8-状态Map" class="headerlink" title="8. 状态Map"></a>8. 状态Map</h1><p>我们可以用组合来将几个子组件放在一起来使用，同样的，对于他们需要的一些输入数据，我们可以通过state，来传到下层的方法处，供他们使用。</p><pre><code>function FancyBoxWithState(  children,  stateMap,  updateState) {  return FancyBox(    children.map(child =&gt; child.continuation(      stateMap.get(child.key),      updateState    ))  );}function UserList(users) {  return users.map(user =&gt; {    continuation: FancyNameBox.bind(null, user),    key: user.id  });}function FancyUserList(users) {  return FancyBoxWithState.bind(null,    UserList(users)  );}const continuation = FancyUserList(data.users);continuation(likesPerUser, updateUserLikes);</code></pre><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://github.com/reactjs/react-basic" target="_blank" rel="noopener">https://github.com/reactjs/react-basic</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从github翻到的论述，是React设计者试图说明其构建React的整个逻辑。&lt;/p&gt;
&lt;h1 id=&quot;1-转换-Transformation&quot;&gt;&lt;a href=&quot;#1-转换-Transformation&quot; class=&quot;headerlink&quot; title=&quot;1. 转换 
      
    
    </summary>
    
    
      <category term="FrontEnd" scheme="https://www.llchen60.com/categories/FrontEnd/"/>
    
    
      <category term="React" scheme="https://www.llchen60.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>如何知道用户是否在使用Adblocker</title>
    <link href="https://www.llchen60.com/%E5%A6%82%E4%BD%95%E7%9F%A5%E9%81%93%E7%94%A8%E6%88%B7%E6%98%AF%E5%90%A6%E5%9C%A8%E4%BD%BF%E7%94%A8Adblocker/"/>
    <id>https://www.llchen60.com/%E5%A6%82%E4%BD%95%E7%9F%A5%E9%81%93%E7%94%A8%E6%88%B7%E6%98%AF%E5%90%A6%E5%9C%A8%E4%BD%BF%E7%94%A8Adblocker/</id>
    <published>2020-04-07T18:58:04.000Z</published>
    <updated>2020-04-07T19:00:33.044Z</updated>
    
    <content type="html"><![CDATA[<p>广告监测和屏蔽是很好的功能，而Ad-blocker基本是市面上做屏蔽广告插件的翘楚了。根据GlobalWebIndex在2019年五月做的统计，现在有47% 的用户正在使用广告屏蔽的软件。</p><p>作为网站管理者，你可以做一个pop up 的信息框，希望用户能够停止对于广告的屏蔽，或者你可以直接不允许用户来访问页面，知道去除了广告屏蔽之后。</p><p>那么如何知道用户是否在使用AbBlocker呢，这里需要了解下adblocker的运行机制，广告屏蔽的运行依赖于过滤规则(filter rules)， adblock会将你正在访问的URL和过滤列表相比较，如果匹配，那么这个请求就会被屏蔽掉。</p><p>但是还有部分的广告是不会发起一个HTTP请求，相对应的，他们会使用<code>data:image/png</code>这种方式来加载广告，对于这种广告，AdBlock 在每个页面都会插入一个样式表，然后这个样式表包括选择器，来display:none 通过这种方式来隐藏页面上的广告</p><p>而这些屏蔽列表来自于一些过去的积累，譬如：</p><ul><li><a href="https://easylist.to/" target="_blank" rel="noopener">Easylist</a></li><li><a href="https://help.getadblock.com/support/solutions/articles/6000092027-why-am-i-suddenly-seeing-taboola-outbrain-and-google-ads-" target="_blank" rel="noopener">accesptable list</a></li></ul><p>除此以外，adblocker还会检测前端调用的js文件，如果还有ad关键词，也会直接屏蔽，所以我们可以直接使用命名，来做一个简单的判断。</p><pre><code>// 创建名为ads.js的文件isAdBlockActive = false;// 创建script.jsvar AdBlocker = (function () {    function showModal() {        $(&#39;#modal_ad_blocker&#39;).modal(); // show a message to the user when ads are blocked    }    setInterval(function () {        // Get the first AdSense ad unit on the page        var ad = document.querySelector(&quot;ins.adsbygoogle&quot;);        // If the ads.js or the Google ads are not loaded, show modal and track the event        if (typeof isAdBlockActive === &#39;undefined&#39;            || (ad &amp;&amp; ad.innerHTML.replace(/\s/g, &quot;&quot;).length === 0)) {            showModal();            if (typeof ga !== &#39;undefined&#39;) {                // Log an event in Universal Analytics                // but without affecting overall bounce rate                ga(&#39;send&#39;, &#39;event&#39;, &#39;Adblock&#39;, &#39;Yes&#39;, {&#39;nonInteraction&#39;: 1});            } else if (typeof _gaq !== &#39;undefined&#39;) {                // Log a non-interactive event in old Google Analytics                _gaq.push([&#39;_trackEvent&#39;, &#39;Adblock&#39;, &#39;Yes&#39;, undefined, undefined, true]);            }        }    }, 5000); // check every 5 seconds})();</code></pre><p>通过检测我们在ads.js当中定义的isAdBlockActive 是否能够被检测到(undefined or have some value)。我们就可以看出是否有adBlocker正在运行，然后根据检测结果我们可以给用户提醒，或者直接阻止访问。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://blog.rampatra.com/how-to-know-whether-a-user-is-using-an-adblocker" target="_blank" rel="noopener">https://blog.rampatra.com/how-to-know-whether-a-user-is-using-an-adblocker</a> </li><li><a href="https://help.getadblock.com/support/solutions/articles/6000087914-how-does-adblock-work-" target="_blank" rel="noopener">https://help.getadblock.com/support/solutions/articles/6000087914-how-does-adblock-work-</a> </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;广告监测和屏蔽是很好的功能，而Ad-blocker基本是市面上做屏蔽广告插件的翘楚了。根据GlobalWebIndex在2019年五月做的统计，现在有47% 的用户正在使用广告屏蔽的软件。&lt;/p&gt;
&lt;p&gt;作为网站管理者，你可以做一个pop up 的信息框，希望用户能够停止对
      
    
    </summary>
    
    
      <category term="Web" scheme="https://www.llchen60.com/categories/Web/"/>
    
    
      <category term="Tricks" scheme="https://www.llchen60.com/tags/Tricks/"/>
    
  </entry>
  
  <entry>
    <title>Log4j2 Tutorial </title>
    <link href="https://www.llchen60.com/Log4j2-Tutorial/"/>
    <id>https://www.llchen60.com/Log4j2-Tutorial/</id>
    <published>2020-04-02T05:27:56.000Z</published>
    <updated>2020-04-02T05:32:48.736Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Log4j2-overview"><a href="#1-Log4j2-overview" class="headerlink" title="1. Log4j2 overview"></a>1. Log4j2 overview</h1><h2 id="1-1-Why-log"><a href="#1-1-Why-log" class="headerlink" title="1.1 Why log?"></a>1.1 Why log?</h2><p>Logging is an important component of the development cycle. </p><ul><li>provides precise context about a run of the application </li><li>once inserted into code, the generation of logging output requires no human intervention </li><li>moreover, log output can be saved in persistent medium to be studied at a later time </li></ul><h2 id="1-2-Why-Log4j2"><a href="#1-2-Why-Log4j2" class="headerlink" title="1.2 Why Log4j2?"></a>1.2 Why Log4j2?</h2><ul><li>Designed to be usable as an audit logging framework , will not lose events while reconfiguring </li><li>Contains asynchrounous loggers, which is 10 times faster than log4j 1.x and logback </li><li>Garbage free for stand alone applications </li><li>Use a plugin system that makes it easy to extend the framework by adding new appenders, filters, layouts, lookups, and pattern converters</li><li>Support for custom log levels </li></ul><h2 id="1-3-Log4j-Architecture"><a href="#1-3-Log4j-Architecture" class="headerlink" title="1.3 Log4j Architecture"></a>1.3 Log4j Architecture</h2><p><img src="https://i.loli.net/2020/04/02/AsXomqJciUyPVKh.jpg" alt="Log4jClasses.jpg"> </p><p>Applications using the Log4j 2 API will request <strong>a Logger with a specific name from the LogManager</strong>. The LogManager will <strong>locate the appropriate LoggerContext</strong> and then obtain the Logger from it. If the Logger must be created it will <strong>be associated with the LoggerConfig</strong> that contains either a) the same name as the Logger, b) the name of a parent package, or c) the root LoggerConfig. LoggerConfig objects are created from Logger declarations in the configuration. The LoggerConfig is associated with the Appenders that actually deliver the LogEvents.</p><ul><li>Filter <ul><li>apply in different time point <ul><li>before control is passed to any loggerConfig</li><li>after control is passed to a LoggerConfig but before calling any Appenders</li><li>after control is passed to a LoggerConfig but before calling a specific Appender</li><li>on each Appender</li></ul></li></ul></li><li>Appender <ul><li>selectively enable or disable logging requests</li><li>allow logging requests to print to multiple destinations </li></ul></li><li>Layout <ul><li>Used to customize the output format </li><li>Associate a layout with an appender </li></ul></li></ul><h1 id="2-Migration-from-Log4j-to-Log4j2"><a href="#2-Migration-from-Log4j-to-Log4j2" class="headerlink" title="2. Migration from Log4j to Log4j2"></a>2. Migration from Log4j to Log4j2</h1><p>We usually use log4j/ log4j2 with Slf4j, Slf4j is kind of like a connecter, you could use slf4j as logging system, and slf4j could help you connect to logging framework you want to use: like logback, log4j2, commons-logging, etc. </p><p><a href="https://logging.apache.org/log4j/2.x/manual/migration.html" target="_blank" rel="noopener">https://logging.apache.org/log4j/2.x/manual/migration.html</a> </p><p>Look at sample 1 in above link for how to set up basic configuration </p><p>For some tips: </p><ul><li>The main package in version 1 is org.apache.log4j, in version 2 it is org.apache.logging.log4j</li><li>Calls to org.apache.log4j.Logger.getLogger() must be modified to org.apache.logging.log4j.LogManager.getLogger().</li><li>Calls to org.apache.log4j.Logger.getRootLogger() or org.apache.log4j.LogManager.getRootLogger() must be replaced with org.apache.logging.log4j.LogManager.getRootLogger().</li><li>Calls to org.apache.log4j.Logger.getLogger that accept a LoggerFactory must remove the org.apache.log4j.spi.LoggerFactory and use one of Log4j 2’s other extension mechanisms.</li><li>Replace calls to org.apache.log4j.Logger.getEffectiveLevel() with org.apache.logging.log4j.Logger.getLevel().</li><li>Remove calls to org.apache.log4j.LogManager.shutdown(), they are not needed in version 2 because the Log4j Core now automatically adds a JVM shutdown hook on start up to perform any Core clean ups.<ul><li>Starting in Log4j 2.1, you can specify a custom ShutdownCallbackRegistry to override the default JVM shutdown hook strategy.</li><li>Starting in Log4j 2.6, you can now use org.apache.logging.log4j.LogManager.shutdown() to initiate shutdown manually.</li></ul></li><li>Calls to org.apache.log4j.Logger.setLevel() or similar methods are not supported in the API. Applications should remove these. Equivalent functionality is provided in the Log4j 2 implementation classes, see org.apache.logging.log4j.core.config.Configurator.setLevel(), but may leave the application susceptible to changes in Log4j 2 internals.</li><li>Where appropriate, applications should convert to use parameterized messages instead of String concatenation.</li><li>org.apache.log4j.MDC and org.apache.log4j.NDC have been replaced by the Thread Context.</li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://logging.apache.org/log4j/2.x/manual/migration.html" target="_blank" rel="noopener">https://logging.apache.org/log4j/2.x/manual/migration.html</a> </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Log4j2-overview&quot;&gt;&lt;a href=&quot;#1-Log4j2-overview&quot; class=&quot;headerlink&quot; title=&quot;1. Log4j2 overview&quot;&gt;&lt;/a&gt;1. Log4j2 overview&lt;/h1&gt;&lt;h2 id=&quot;1-1
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="log" scheme="https://www.llchen60.com/tags/log/"/>
    
  </entry>
  
  <entry>
    <title>Amazon RDS Onboard - MySQL </title>
    <link href="https://www.llchen60.com/Amazon-RDS-Onboard-MySQL/"/>
    <id>https://www.llchen60.com/Amazon-RDS-Onboard-MySQL/</id>
    <published>2020-03-29T03:39:50.000Z</published>
    <updated>2020-04-05T22:47:32.274Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a>1. Overview</h1><p>Amazon Relational Databazse Service </p><ul><li>provide cost efficient, resizable capacity for relational database and manage common database administration tasks </li><li>CPU, memory, storage, IOPS can be scaled independently </li><li>help you manage backups, software patching, automatic failure detection, and recovery </li><li>Automated backups </li><li>Can get high availability with a primary instance and synchronous secondary instance that you can fail over to when problems occur.</li><li>Integrate with IAM and VPC settings</li></ul><h2 id="1-1-How-does-amazon-help-you-do-the-setup"><a href="#1-1-How-does-amazon-help-you-do-the-setup" class="headerlink" title="1.1 How does amazon help you do the setup?"></a>1.1 How does amazon help you do the setup?</h2><p>Overall, you control your database by using DB instance, you could select different kind of host with different configuration, AWS will help you to deploy it in your selected region, and it will be automatically deployed to different AZ, to increase availability. Let’s go through it in detail. </p><h3 id="1-1-1-DB-Instances"><a href="#1-1-1-DB-Instances" class="headerlink" title="1.1.1 DB Instances"></a>1.1.1 DB Instances</h3><ul><li><p>An isolated database env in the AWS Cloud </p></li><li><p>One instance can contain multiple user-created databases </p></li><li><p>Each DB instance runs one DB engine, for DB engine, we mean MySQL, MariaDB, PostgreSQL, etc. </p></li><li><p>You could change your selected computation and memory capacity by using <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.DBInstanceClass.html" target="_blank" rel="noopener">DB instance class</a>.</p></li><li><p>You could choose to use multiple availability zones, AZ is engineered to be isolated from failures in other AZs, by launching instances in separate AZs, you can protect your applications from the failure of a single location</p><h3 id="1-1-2-Basic-setup"><a href="#1-1-2-Basic-setup" class="headerlink" title="1.1.2 Basic setup"></a>1.1.2 Basic setup</h3></li><li><p>AWS account </p></li><li><p>IAM user </p></li></ul><h1 id="2-MySQL-on-RDS"><a href="#2-MySQL-on-RDS" class="headerlink" title="2. MySQL on RDS"></a>2. MySQL on RDS</h1><h2 id="2-1-Manage-security-for-DB-instance"><a href="#2-1-Manage-security-for-DB-instance" class="headerlink" title="2.1 Manage security for DB instance"></a>2.1 Manage security for DB instance</h2><h3 id="2-1-1-Security-Overview"><a href="#2-1-1-Security-Overview" class="headerlink" title="2.1.1 Security Overview"></a>2.1.1 Security Overview</h3><ul><li>Run DB instance in a vertual private cloud based on the Amazon VPC service </li><li>Use AWS Identity and Access Management policies to assign permissions that determine who is allowed to manage Amazon RDS resrouces </li><li>Use security groups to control what IP addresses or Amazon EC2 instances can connect to your databases on a DB instance</li><li>Use SSL or TLS connections with DB instances <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.SSL.html" target="_blank" rel="noopener">Instructions</a></li><li>Use Amazon RDS encryption to secure DB instances and snapshots at rest. It used AES-256 encryption algorithm to encrypt data on the server that hosts DB instance</li></ul><h3 id="2-1-2-Manage-access-with-Policies-resource-level"><a href="#2-1-2-Manage-access-with-Policies-resource-level" class="headerlink" title="2.1.2 Manage access with Policies - resource level"></a>2.1.2 Manage access with Policies - resource level</h3><ul><li>A poloicy is an object that associated with an identity or resource, defines their permissions. </li><li>An IAM administrator could use policies to specify who has access to AWS resources, and what actions they can perform on the resources </li></ul><h3 id="2-1-3-Access-control-in-DB-instance-level-security-group"><a href="#2-1-3-Access-control-in-DB-instance-level-security-group" class="headerlink" title="2.1.3 Access control in DB instance level - security group"></a>2.1.3 Access control in DB instance level - security group</h3><ul><li>Security groups control the access that traffic has in and out of a DB instance <ul><li>VPC security groups </li><li>DB security groups</li><li>EC2-classic security groups </li></ul></li><li>VPC security group<ul><li>enable a specific source to access a DB instance in a VPC in the security group </li><li>source could be: <ul><li>a range of addresses </li><li>another VPC security group </li></ul></li></ul></li><li>DB security group <ul><li>Used with DB instances that are not in a VPC and on the EC2 classic platform  </li><li>DB security group rules apply to inbound traffic only </li><li>You don’t need to specify port number or protocol when adding rules </li></ul></li></ul><h2 id="2-2-Connect-to-DB-instance"><a href="#2-2-Connect-to-DB-instance" class="headerlink" title="2.2 Connect to DB instance"></a>2.2 Connect to DB instance</h2><ul><li>Create DB instance as prerequisite </li><li>Use MySQL client application or utility to connect to the instance</li><li>Specify DNS address from the DB instance endpoint as the host parameter, specify the port number from DB instance endpoint as the port parameter </li><li>For endpoint, we could find in AWS console, on the “connectivity &amp; security” tab </li><li>To  connect from MySQL client, using command shown as below<ul><li><code>mysql -h mysql–instance1.123456789012.us-east-1.rds.amazonaws.com -P 3306 -u mymasteruser -p</code></li></ul></li><li>Amazon RDS creates an SSL certificate for your DB instance when the instance is created     + you could do it with native password or with IAM authentication <ul><li><code>mysql -h mysql–instance1.123456789012.us-east-1.rds.amazonaws.com --ssl-ca=rds-ca-2015-root.pem -p</code> </li></ul></li><li>we could also connect from MySQL workbench <ul><li>See instructions on <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_ConnectToInstance.html" target="_blank" rel="noopener">Connnecting from MySQL Workbench</a> </li></ul></li></ul><h2 id="2-3-Configure-high-availability-for-a-production-DB-instance"><a href="#2-3-Configure-high-availability-for-a-production-DB-instance" class="headerlink" title="2.3 Configure high availability for a production DB instance"></a>2.3 Configure high availability for a production DB instance</h2><p>Amazon help you do this with Multi-AZ deployments. SQL server DB instances use SQL server Database Mirroring or Always On Availability Groups. </p><p>In a Multi-AZ deployment, Amazon RDS automatically provisions and maintains a synchronous standby replica in a different Availability Zone. The primary DB instance is synchronously replicated across Availability Zones to a standby replica to provide data redundancy, eliminate I/O freezes, and minimize latency spikes during system backups. Running a DB instance with high availability can enhance availability during planned system maintenance, and help protect your databases against DB instance failure and Availability Zone disruption.</p><p>The high availability feature is not scaling solution for read-only scenarios, you cannot use a standby replica to serve read traffic. </p><p>NOTICE – DB instances using Multi-AZ deployments can have increased write and commit latency compared to a Single-AZ depolyment, due to the synchrounous data replication that occurs. </p><p>In the event of a planned or unplanned outage of your DB instance, Amazon RDS automatically switches to a standby replica in another Availability Zone if you have enabled Multi-AZ. The time it takes for the failover to complete depends on the database activity and other conditions at the time the primary DB instance became unavailable. Failover times are typically 60–120 seconds. However, large transactions or a lengthy recovery process can increase failover time. When the failover is complete, it can take additional time for the RDS console to reflect the new Availability Zone.</p><h2 id="2-4-Configure-a-DB-instance-in-VPC"><a href="#2-4-Configure-a-DB-instance-in-VPC" class="headerlink" title="2.4 Configure a DB instance in VPC"></a>2.4 Configure a DB instance in VPC</h2><ul><li>VPC is a virtual network that is logically isolated from other virtual networks in the AWS cloud. Amazon VPC lets you launch AWS resources into a VPC. </li><li>VPC must have at least 2 subnets. And those subnets must be in two different AZs </li><li>If you want DB instance in the VPC to be publicly accessible, you must enable the VPC attributes DNS hostnames and DNS resolution </li></ul><h2 id="2-5-Configure-MySQL-database-parameters-and-features"><a href="#2-5-Configure-MySQL-database-parameters-and-features" class="headerlink" title="2.5 Configure MySQL database parameters and features"></a>2.5 Configure MySQL database parameters and features</h2><ul><li>Manage DB engine configuration by associating DB instances with parameter groups. A DB parameter group act as a container for engine configuration values that are applied to one or more DB instances </li><li>For MySQL, AWS has memcached support </li></ul><h2 id="2-6-Modify-a-DB-instance-running-the-MySQL-database-engine"><a href="#2-6-Modify-a-DB-instance-running-the-MySQL-database-engine" class="headerlink" title="2.6 Modify a DB instance running the MySQL database engine"></a>2.6 Modify a DB instance running the MySQL database engine</h2><ul><li>We could change the settings of a DB instance to add additional storage or changing the DB instance class </li><li>Notice: some cahnges will result in an outage because Amazon RDS must reboot DB instance for the change to take effect <ul><li>We could either modify through AWS console</li><li>Or through AWS CLI</li><li>Or through RDS API </li></ul></li><li>we could do settings as follow:<ul><li>Allocate storage </li><li>Auto minor version upgrade </li><li>Backup retention period <ul><li>number of days that automatic backups are retained </li></ul></li><li>Backup window </li><li>Certificate Authority </li><li>Database port </li><li>DB engine version </li><li>DB instance class </li><li>DB parameter group </li><li>Delete protection <ul><li>prevent your DB from being deleted  </li></ul></li><li>Enhanced Monitoring </li><li>IAM DB authentication </li><li>Kerberos authentication </li><li>License Model </li><li>Log Exports <ul><li>We could publish Database logs to Amazon Cloudwatch logs </li></ul></li><li>Maintenance window </li><li>Multi-AZ deployment </li><li>Performance Insight </li><li>Processor features </li><li>Provisioned IOPS </li><li>Storage auto scaling </li><li>Subnet group </li></ul></li></ul><h2 id="2-7-Configure-database-backup-and-restore"><a href="#2-7-Configure-database-backup-and-restore" class="headerlink" title="2.7 Configure database backup and restore"></a>2.7 Configure database backup and restore</h2><ul><li>Amazon RDS creates and saves automated backups of your DB instance</li><li>RDS creates a storage volume snapshot of DB instance, backing up entire DB instance </li><li>The first snapshot of a DB instance contains the data for the full DB instance. Subsequent snapshots of the same DB instance are incremental, which means that only the data that has changed after your most recent snapshot is saved.</li><li><a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_CommonTasks.BackupRestore.html" target="_blank" rel="noopener">Guide for backup and restore an Amazon RDS DB instance</a></li></ul><h2 id="2-8-Monitor-a-MySQL-DB-instance"><a href="#2-8-Monitor-a-MySQL-DB-instance" class="headerlink" title="2.8 Monitor a MySQL DB instance"></a>2.8 Monitor a MySQL DB instance</h2><h3 id="2-8-1-Overview"><a href="#2-8-1-Overview" class="headerlink" title="2.8.1 Overview"></a>2.8.1 Overview</h3><ul><li><p>We should store historical monitoring data, the stored data will gove a baseline to compare against with current performance data</p></li><li><p>With Amazon RDS, you could monitor network throughput, I/O for read and write, metadata operations, client connections</p></li><li><p>Some adviced metrics </p><ul><li>High CPU or RAM consumption </li><li>Disk space consumption </li><li>Network traffic </li><li>Database connections </li><li>IOPS metrics </li></ul></li><li><p>Monitoring Tools </p><ul><li>Amazon RDS Events <ul><li>subscribe to events thus could be notified when changes occur with a DB instance </li></ul></li><li>Database log files</li><li>Amazon RDS Enhanced Monitoring<ul><li>Look at the metrics in real time for the operating system</li></ul></li><li>Amazon CloudWatch Metrics </li><li>Amazon CloudWatch Alarms</li><li>Amazon CloudWatch Logs </li><li>In RDS console, you could see: <ul><li>the number of connections to a DB instance </li><li>the amount of read and write operations to a DB instance </li><li>the amount of storage that a DB instance is currently utilizing </li><li>the amount of memory and CPU being utilized for a DB instance </li><li>the amount of network traffic to and from a DB instance </li></ul></li></ul></li><li><p>Amazon RDS Metrics </p><ul><li>CPUCreditUsage <ul><li>The number of CPU credits spent by the instance for CPU utilization. One CPU credit equals one vCPU running at 100 percent utilization for one minute or an equivalent combination of vCPUs, utilization, and time.</li></ul></li><li>DatabaseConnections</li><li>DiskQueueDepth <ul><li>the number of outstanding IOs waiting to access the disk</li></ul></li><li>FailedSQLServerAgentJobsCount <ul><li>the numebr of failed SQL server agent jobs during the last minute </li></ul></li><li>ReadIOPS <ul><li>the average number of disk read I/O operations per second</li></ul></li><li>ReadLatency <ul><li>the average amount to time taken per disk I/O operation  </li></ul></li></ul></li></ul><h3 id="2-8-2-Enhanced-Monitoring"><a href="#2-8-2-Enhanced-Monitoring" class="headerlink" title="2.8.2 Enhanced Monitoring"></a>2.8.2 Enhanced Monitoring</h3><p>Real time metrics for the operating system</p><p>CloudWatch gathers metrics about CPU utilization from the hypervisor for a DB instance, and Enhanced Monitoring gathers its metrics from an agent on the instance. As a result, you might find differences between the measurements, because the hypervisor layer performs a small amount of work. The differences can be greater if your DB instances use smaller instance classes, because then there are likely more virtual machines (VMs) that are managed by the hypervisor layer on a single physical instance. Enhanced Monitoring metrics are useful when you want to see how different processes or threads on a DB instance use the CPU</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://docs.aws.amazon.com/AmazonRDS" target="_blank" rel="noopener">https://docs.aws.amazon.com/AmazonRDS</a> </li><li><a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_MySQL.html" target="_blank" rel="noopener">https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_MySQL.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Overview&quot;&gt;&lt;a href=&quot;#1-Overview&quot; class=&quot;headerlink&quot; title=&quot;1. Overview&quot;&gt;&lt;/a&gt;1. Overview&lt;/h1&gt;&lt;p&gt;Amazon Relational Databazse Service 
      
    
    </summary>
    
    
      <category term="Cloud" scheme="https://www.llchen60.com/categories/Cloud/"/>
    
    
      <category term="AWS" scheme="https://www.llchen60.com/tags/AWS/"/>
    
      <category term="RDS" scheme="https://www.llchen60.com/tags/RDS/"/>
    
      <category term="MySQL" scheme="https://www.llchen60.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Spring @Transactional</title>
    <link href="https://www.llchen60.com/Spring-Transactional/"/>
    <id>https://www.llchen60.com/Spring-Transactional/</id>
    <published>2020-03-25T02:37:03.000Z</published>
    <updated>2020-03-25T02:40:00.334Z</updated>
    
    <content type="html"><![CDATA[<p>Spring的Transactional注解用来做事务管理</p><h1 id="1-使用方法"><a href="#1-使用方法" class="headerlink" title="1. 使用方法"></a>1. 使用方法</h1><p>首先我们需要在xml当中配置事务信息，定义transactionManager的bean，当然也可以使用注解来实现对于bean的定义，具体如下：</p><pre><code>&lt;tx:annotation-driven /&gt;&lt;bean id=&quot;transactionManager&quot;class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;&lt;/bean&gt;@EnableTransactionManagement</code></pre><p>而后，在具体的使用的时候，我们只需要将@Transactional注解添加到合适的方法当中，并且设置合适的属性信息</p><ul><li>name<ul><li>指定事务管理器</li></ul></li><li>propagation<ul><li>事务的传播行为，默认为REQUIRED</li></ul></li><li>isolation <ul><li>事务的隔离度，默认为DEFAULT</li></ul></li><li>timeout<ul><li>事务的超时时间，默认为-1，如果超过该时间限制但事务没有完成，就自动回滚</li></ul></li><li>read-only<ul><li>指定事务是否为只读事务，默认值为false</li><li>当要忽略那些不需要事务的方法的时候，可以设置read-only为true</li></ul></li><li>rollback-for<ul><li>指定能够触发事务回滚的异常类型，如果有多个异常类型需要指定，可以通过逗号来做分隔</li></ul></li><li>no-rollback-for<ul><li>对于在这里定义的exception，不回滚 </li></ul></li></ul><h1 id="2-Spring-注解方式的事务实现机制"><a href="#2-Spring-注解方式的事务实现机制" class="headerlink" title="2. Spring 注解方式的事务实现机制"></a>2. Spring 注解方式的事务实现机制</h1><p>在调用@Transactional的目标方法之后，Spring Framework会通过AOP代理，在代码运行时生成一个代理对象，根据注解的属性配置信息，决定该声明@Transactional的目标方法是否由拦截器 - TransactionInterceptor来拦截.</p><p>如果确定要被拦截，那么就会在目标方法开始执行之前创建并加入事务，并执行目标方法的逻辑，最后根据执行情况是否出现异常，利用抽象事务管理器提交或者回滚事务。</p><p><img src="https://i.loli.net/2020/03/25/cM5yEjbPAIogk1X.jpg" alt="Spring事务实现机制.jpg"></p><h1 id="3-Isolation-Level"><a href="#3-Isolation-Level" class="headerlink" title="3. Isolation Level"></a>3. Isolation Level</h1><p>Isolation是有不同的配置的，它主要是为了避免事务的一些副作用：</p><ul><li>脏读：读到同时进行的事务还没有提交上去的数据</li><li>不可重复的读：重复读的时候会读到不同的数据，因为有同时进行的事务对同一条数据进行了更新</li><li>幽灵读取：在做query的时候，再度执行拿到不同的行，因为有同时进行的事务在做更新</li></ul><p>针对不同级别的事务，Spring有如下的设置</p><ul><li>DEFAULT</li><li>READ_UNCOMMITTED<ul><li>最低的隔离水平 </li><li>允许大部分的同时的访问</li><li>有上述所有的弊端</li></ul></li><li>READ_COMMMITED<ul><li>阻止脏读 </li></ul></li><li>REPEATABLE_READ<ul><li>阻止脏读</li><li>阻止不可重复读取</li></ul></li><li>SERAILIZABLE<ul><li>最高程度的隔离</li><li>基本是单序列的执行</li></ul></li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/annotation/Transactional.html" target="_blank" rel="noopener">https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/annotation/Transactional.html</a></li><li><a href="https://dzone.com/articles/how-does-spring-transactional" target="_blank" rel="noopener">https://dzone.com/articles/how-does-spring-transactional</a></li><li><a href="https://www.ibm.com/developerworks/cn/java/j-master-spring-transactional-use/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-master-spring-transactional-use/index.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Spring的Transactional注解用来做事务管理&lt;/p&gt;
&lt;h1 id=&quot;1-使用方法&quot;&gt;&lt;a href=&quot;#1-使用方法&quot; class=&quot;headerlink&quot; title=&quot;1. 使用方法&quot;&gt;&lt;/a&gt;1. 使用方法&lt;/h1&gt;&lt;p&gt;首先我们需要在xml当中配置事
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
      <category term="Spring" scheme="https://www.llchen60.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>团队能力构建手册-新人Ramp Up</title>
    <link href="https://www.llchen60.com/%E5%9B%A2%E9%98%9F%E8%83%BD%E5%8A%9B%E6%9E%84%E5%BB%BA%E6%89%8B%E5%86%8C-%E6%96%B0%E4%BA%BARamp-Up/"/>
    <id>https://www.llchen60.com/%E5%9B%A2%E9%98%9F%E8%83%BD%E5%8A%9B%E6%9E%84%E5%BB%BA%E6%89%8B%E5%86%8C-%E6%96%B0%E4%BA%BARamp-Up/</id>
    <published>2020-03-24T03:37:58.000Z</published>
    <updated>2020-03-24T03:39:22.183Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博客引述了ThoughtWorks的<a href="https://insights.thoughtworks.cn/capacity-building-and-quality-assurance/" target="_blank" rel="noopener">capacity-building-and-quality-assurance</a>，里面讲得如何构建团队，如何让新人快速适应的方法指南非常实用。分享/ 思考/ 归纳如下。</p><p>自己所在的团队最近也经历了快速的增长，在带新人的过程当中，确实感觉到想一茬抓一茬是客观存在且经常性发生的事情，lol。需要一个更加清晰细致的上手指南，并把一些需要的前提条件先给到，然后给新人留下在正确的方向上足够的探索空间，这样大概才能加速他们的成长把。</p><p>我们当然需要每个个体的无上才能，但更需要一个好的平台，让他们能够专注的将自己的才能用在那个地方。而平台，意味着脚手架，意味着规则，意味着指南。</p><h1 id="1-常规新人成长方式-Mentor-Onboarding-Buddy"><a href="#1-常规新人成长方式-Mentor-Onboarding-Buddy" class="headerlink" title="1. 常规新人成长方式 Mentor/ Onboarding Buddy"></a>1. 常规新人成长方式 Mentor/ Onboarding Buddy</h1><p>为新人指派一名有经验的师傅，作为他的onboarding伙伴，平时可以做结对编程，在日常工作当中交换知识，学习并成长。新人onboarding的速度，取决于师傅的技能。</p><p>这么做当然有好处，一定比新人自己探索onboard要快的多，但是正如上面所说的那样，这种方式很依赖于师傅的能力，还有新人的沟通交流，搜集知识的能力。效果会因为每个成员的性格习惯能力等，有很大的不同。</p><h1 id="2-制定规则化的成长流程"><a href="#2-制定规则化的成长流程" class="headerlink" title="2. 制定规则化的成长流程"></a>2. 制定规则化的成长流程</h1><h2 id="2-1-CraftSkill-Map"><a href="#2-1-CraftSkill-Map" class="headerlink" title="2.1 CraftSkill Map"></a>2.1 CraftSkill Map</h2><p>能力地图是希望能够梳理完整的技术图谱，对技术人员需要掌握的能力进行可视化</p><p>新成员在加入项目的时候一般会有很多问题：</p><ul><li>这个项目是做什么的？ </li><li>这个项目是在解决什么样的问题？</li><li>这个项目使用了什么技术栈？</li><li>新成员应该从哪里开始？</li></ul><p>新人onboard，rampup需要的知识是可以分成可以自己学习的知识(通过各种文档，wiki, stackoverflow, etc.)以及需要老人的帮助的知识(需要上手实操的内容，比如设计原则，DRY,SOLID, LOD等等具体如何使用的问题)。</p><p>我们需要新人自己去探索，获取一些必要的前提性知识，也需要有人帮助，帮他迅速适应新的环境。</p><p>能力地图就是希望能够对所需要的知识，做一个清晰的梳理，形成一个脉络，能够使新人onboard的过程更有的放矢一些。</p><p><img src="https://i.loli.net/2020/03/24/JayeLmisObEpdTS.png" alt="craftskill map E.G.png"></p><h2 id="2-2-指定Onboarding流程"><a href="#2-2-指定Onboarding流程" class="headerlink" title="2.2 指定Onboarding流程"></a>2.2 指定Onboarding流程</h2><p>这里主要是要给一个比较详细的计划，告知新人每周要做的事情，更多的是时间上，任务上的安排。</p><p>根据任务，可以侧重学习前端，后端，或者QA方面的领域知识和技能，然后<strong>做一个meeting，将自己学到的完整的和组里的同事分享下，然后可以一起查漏补缺，完善新人的知识体系</strong>。</p><p>值得注意的是Onboarding的流程当中需要有里程碑和执行时间，由资深员工协助制定，然后就可以领取任务，保质保量的独立完成。</p><p>Onboard流程当中，关于自己看的知识，有很多方式可以来做，比如wiki，视频，甚至是音频，起到的作用就是更高速度的学习。这种相对来说比较被动，主动性的学习可以通过Unit test，将知识点转化成Unit test，然后通过单元测试迅速熟悉知识点。</p><h2 id="2-3-新成员状态看板"><a href="#2-3-新成员状态看板" class="headerlink" title="2.3 新成员状态看板"></a>2.3 新成员状态看板</h2><p>每周由mentor负责跟踪观察新人状态，会议追踪，确定新人是否能在一个月的ramp up以后自己独立负责一部分的任务。</p><h2 id="2-4-Case-by-case-针对性培训"><a href="#2-4-Case-by-case-针对性培训" class="headerlink" title="2.4 Case by case 针对性培训"></a>2.4 Case by case 针对性培训</h2><p>根据个人情况来探究如何做提高，是否可以提前交付项目，诸如此类。</p><p><a href="https://insights.thoughtworks.cn/capacity-building-and-quality-assurance/" target="_blank" rel="noopener">https://insights.thoughtworks.cn/capacity-building-and-quality-assurance/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这篇博客引述了ThoughtWorks的&lt;a href=&quot;https://insights.thoughtworks.cn/capacity-building-and-quality-assurance/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ca
      
    
    </summary>
    
    
      <category term="Notes" scheme="https://www.llchen60.com/categories/Notes/"/>
    
    
      <category term="Mentor" scheme="https://www.llchen60.com/tags/Mentor/"/>
    
  </entry>
  
  <entry>
    <title>迪米特法则 (LOD) — 高内聚，低耦合</title>
    <link href="https://www.llchen60.com/%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99-LOD-%E2%80%94-%E9%AB%98%E5%86%85%E8%81%9A%EF%BC%8C%E4%BD%8E%E8%80%A6%E5%90%88/"/>
    <id>https://www.llchen60.com/%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99-LOD-%E2%80%94-%E9%AB%98%E5%86%85%E8%81%9A%EF%BC%8C%E4%BD%8E%E8%80%A6%E5%90%88/</id>
    <published>2020-03-23T03:30:09.000Z</published>
    <updated>2020-03-23T03:30:50.426Z</updated>
    
    <content type="html"><![CDATA[<p>高内聚 低耦合是比较通用的设计思想，可以用来指导不同的粒度的代码的设计和开发的工作，比如系统，模块，类，甚至是函数。也可以去使用到不同的开发场景当中，比如微服务，框架，组件，类库等等。</p><p>在这个原则当中，高内聚指的是类本身的设计，低耦合指的是类和类之间的依赖关系的设计。</p><p>迪米特法则，可以称之为The least knowledge principle.<br>Each unit should have only limited knowledge about other units: only units “closely” related to the current unit. Or: Each unit should only talk to its friends; Don’t talk to strangers.</p><h1 id="1-什么是高内聚？"><a href="#1-什么是高内聚？" class="headerlink" title="1. 什么是高内聚？"></a>1. 什么是高内聚？</h1><p>指的是相近的功能应该放到同一个类当中，不相近的功能不要放在同一类。代码集中相对来说就会更加容易维护了。</p><h1 id="2-什么是低耦合？"><a href="#2-什么是低耦合？" class="headerlink" title="2. 什么是低耦合？"></a>2. 什么是低耦合？</h1><p>类和类之间的依赖关系简单清晰，即尽管两个类之间有依赖关系。一个类的代码的改动不会或者很少导致依赖类的代码的改动。</p><h1 id="3-内聚和耦合的关系"><a href="#3-内聚和耦合的关系" class="headerlink" title="3. 内聚和耦合的关系"></a>3. 内聚和耦合的关系</h1><p><img src="https://i.loli.net/2020/03/23/yZVTqaQSgvbtE4l.png" alt="内聚耦合关系.png"></p><p>如图所示，左侧就是很好的高内聚低耦合的范例，我们将类最小化，即每个类只做一件事情，这样子其他依赖就会少很多。在修改或增加功能的时候，就不会对其他的类造成很大的影响。</p><h1 id="4-实战"><a href="#4-实战" class="headerlink" title="4. 实战"></a>4. 实战</h1><pre><code>public class NetworkTransporter {    // 存在问题，NetworkTransporter作为一个底层类，不应该依赖于HtmlRequest类；与之相反的，因为其实他需要的是string address，以及byte的数组，那我们应该直接提供这些primitive type的数据    public Byte[] send(HtmlRequest htmlRequest) {      //...    }}public class HtmlDownloader {  private NetworkTransporter transporter;//通过构造函数或IOC注入  public Html downloadHtml(String url) {  // 根据上面NetworkTransporter我们希望做的改动，这里传入的不应该是HtmlRequest类的实例了    Byte[] rawHtml = transporter.send(new HtmlRequest(url));    return new Html(rawHtml);  }}public class Document {  private Html html;  private String url;  public Document(String url) {    this.url = url;    // downloader.downloadHtml逻辑复杂，不应该放在构造函数当中，也会很不好测试    // 构造函数中使用new来做实例，违反了基于接口而非实现编程的原则    HtmlDownloader downloader = new HtmlDownloader();    this.html = downloader.downloadHtml(url);  }  //...}</code></pre><p>修改以后的代码： </p><pre><code>public class NetworkTransporter {    // 省略属性和其他方法...    public Byte[] send(String address, Byte[] data) {      //...    }}public class HtmlDownloader {  private NetworkTransporter transporter;//通过构造函数或IOC注入  // HtmlDownloader这里也要有相应的修改  public Html downloadHtml(String url) {    HtmlRequest htmlRequest = new HtmlRequest(url);    Byte[] rawHtml = transporter.send(      htmlRequest.getAddress(), htmlRequest.getContent().getBytes());    return new Html(rawHtml);  }}public class Document {  private Html html;  private String url;  public Document(String url, Html html) {    this.html = html;    this.url = url;  }  //...}// 通过一个工厂方法来创建Documentpublic class DocumentFactory {  private HtmlDownloader downloader;  public DocumentFactory(HtmlDownloader downloader) {    this.downloader = downloader;  }  public Document createDocument(String url) {    Html html = downloader.downloadHtml(url);    return new Document(url, html);  }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;高内聚 低耦合是比较通用的设计思想，可以用来指导不同的粒度的代码的设计和开发的工作，比如系统，模块，类，甚至是函数。也可以去使用到不同的开发场景当中，比如微服务，框架，组件，类库等等。&lt;/p&gt;
&lt;p&gt;在这个原则当中，高内聚指的是类本身的设计，低耦合指的是类和类之间的依赖关系
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="高内聚" scheme="https://www.llchen60.com/tags/%E9%AB%98%E5%86%85%E8%81%9A/"/>
    
      <category term="低耦合" scheme="https://www.llchen60.com/tags/%E4%BD%8E%E8%80%A6%E5%90%88/"/>
    
      <category term="迪米特" scheme="https://www.llchen60.com/tags/%E8%BF%AA%E7%B1%B3%E7%89%B9/"/>
    
  </entry>
  
  <entry>
    <title>DRY 原则</title>
    <link href="https://www.llchen60.com/DRY-%E5%8E%9F%E5%88%99/"/>
    <id>https://www.llchen60.com/DRY-%E5%8E%9F%E5%88%99/</id>
    <published>2020-03-22T03:01:51.000Z</published>
    <updated>2020-03-22T03:02:11.787Z</updated>
    
    <content type="html"><![CDATA[<p>Don’t repeat yourself </p><h1 id="1-实现逻辑的重复"><a href="#1-实现逻辑的重复" class="headerlink" title="1. 实现逻辑的重复"></a>1. 实现逻辑的重复</h1><pre><code>public class UserAuthenticator {  public void authenticate(String username, String password) {    if (!isValidUsername(username)) {      // ...throw InvalidUsernameException...    }    if (!isValidPassword(password)) {      // ...throw InvalidPasswordException...    }    //...省略其他代码...  }  private boolean isValidUsername(String username) {    // check not null, not empty    if (StringUtils.isBlank(username)) {      return false;    }    // check length: 4~64    int length = username.length();    if (length &lt; 4 || length &gt; 64) {      return false;    }    // contains only lowcase characters    if (!StringUtils.isAllLowerCase(username)) {      return false;    }    // contains only a~z,0~9,dot    for (int i = 0; i &lt; length; ++i) {      char c = username.charAt(i);      if (!(c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;z&#39;) || (c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;) || c == &#39;.&#39;) {        return false;      }    }    return true;  }  private boolean isValidPassword(String password) {    // check not null, not empty    if (StringUtils.isBlank(password)) {      return false;    }    // check length: 4~64    int length = password.length();    if (length &lt; 4 || length &gt; 64) {      return false;    }    // contains only lowcase characters    if (!StringUtils.isAllLowerCase(password)) {      return false;    }    // contains only a~z,0~9,dot    for (int i = 0; i &lt; length; ++i) {      char c = password.charAt(i);      if (!(c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;z&#39;) || (c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;) || c == &#39;.&#39;) {        return false;      }    }    return true;  }}</code></pre><p>这里想强调的是不一定完全一样的代码就意味着他们是需要合并的，比如上述的代码当中，isValidPassword还有isValidUsername有着基本上相同的逻辑结构，但是他们本身代表的是不同的意思的，虽然一样的逻辑，但是我们无法保证在接下来的一段时间以内，他们还能这样子一致下去。</p><p>所以合并为isValidUserOrPassword是不可以的，逻辑上讲不通，但是我们可以将上面在这个函数内部调用的方法进行分割的方式，来复用一些代码。</p><p>其实有一些使用组合的味道在里面了。</p><h1 id="2-功能语义的重复"><a href="#2-功能语义的重复" class="headerlink" title="2. 功能语义的重复"></a>2. 功能语义的重复</h1><p>对于功能语义重复的理解，是指一个代码包里在多个地方为了实现同样的功能，设定了不同的方法体。这大部分情况下都是因为沟通等方面的问题，不管里面使用的方法有什么不同，如果他们都是为了达成一样的，那么我们认为其实违反了DRY原则的，是需要清除多余的方法体的。</p><h1 id="3-代码执行重复"><a href="#3-代码执行重复" class="headerlink" title="3. 代码执行重复"></a>3. 代码执行重复</h1><p>看代码的内部逻辑，减少多次重复调用的代码。</p><p>注意IO操作，因为IO非常费时…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Don’t repeat yourself &lt;/p&gt;
&lt;h1 id=&quot;1-实现逻辑的重复&quot;&gt;&lt;a href=&quot;#1-实现逻辑的重复&quot; class=&quot;headerlink&quot; title=&quot;1. 实现逻辑的重复&quot;&gt;&lt;/a&gt;1. 实现逻辑的重复&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;pu
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
  </entry>
  
  <entry>
    <title>KISS and YAGNI原则</title>
    <link href="https://www.llchen60.com/KISS-and-YAGNI%E5%8E%9F%E5%88%99/"/>
    <id>https://www.llchen60.com/KISS-and-YAGNI%E5%8E%9F%E5%88%99/</id>
    <published>2020-03-21T03:24:37.000Z</published>
    <updated>2020-03-21T03:25:05.413Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-KISS"><a href="#1-KISS" class="headerlink" title="1. KISS"></a>1. KISS</h1><p>Keep it simple and stupid. </p><p>这个原则相对比较范范，其实着重在说的还是从代码的可读性和可维护性两个角度来衡量代码的质量。</p><pre><code>// 第一种实现方式: 使用正则表达式public boolean isValidIpAddressV1(String ipAddress) {  if (StringUtils.isBlank(ipAddress)) return false;  String regex = &quot;^(1\\d{2}|2[0-4]\\d|25[0-5]|[1-9]\\d|[1-9])\\.&quot;          + &quot;(1\\d{2}|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)\\.&quot;          + &quot;(1\\d{2}|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)\\.&quot;          + &quot;(1\\d{2}|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)$&quot;;  return ipAddress.matches(regex);}// 第二种实现方式: 使用现成的工具类public boolean isValidIpAddressV2(String ipAddress) {  if (StringUtils.isBlank(ipAddress)) return false;  String[] ipUnits = StringUtils.split(ipAddress, &#39;.&#39;);  if (ipUnits.length != 4) {    return false;  }  for (int i = 0; i &lt; 4; ++i) {    int ipUnitIntValue;    try {      ipUnitIntValue = Integer.parseInt(ipUnits[i]);    } catch (NumberFormatException e) {      return false;    }    if (ipUnitIntValue &lt; 0 || ipUnitIntValue &gt; 255) {      return false;    }    if (i == 0 &amp;&amp; ipUnitIntValue == 0) {      return false;    }  }  return true;}// 第三种实现方式: 不使用任何工具类public boolean isValidIpAddressV3(String ipAddress) {  char[] ipChars = ipAddress.toCharArray();  int length = ipChars.length;  int ipUnitIntValue = -1;  boolean isFirstUnit = true;  int unitsCount = 0;  for (int i = 0; i &lt; length; ++i) {    char c = ipChars[i];    if (c == &#39;.&#39;) {      if (ipUnitIntValue &lt; 0 || ipUnitIntValue &gt; 255) return false;      if (isFirstUnit &amp;&amp; ipUnitIntValue == 0) return false;      if (isFirstUnit) isFirstUnit = false;      ipUnitIntValue = -1;      unitsCount++;      continue;    }    if (c &lt; &#39;0&#39; || c &gt; &#39;9&#39;) {      return false;    }    if (ipUnitIntValue == -1) ipUnitIntValue = 0;    ipUnitIntValue = ipUnitIntValue * 10 + (c - &#39;0&#39;);  }  if (ipUnitIntValue &lt; 0 || ipUnitIntValue &gt; 255) return false;  if (unitsCount != 3) return false;  return true;}</code></pre><p>相对来说，第二种实现方式会更好一些，因为细节被封装在工具类当中，可读性相对强很多；方法一直接使用正则表达式，可读性会差很多；第三种自己来处理底层的逻辑，虽然执行起来相对会快一些，但是很容易出错。</p><h1 id="2-YAGNI"><a href="#2-YAGNI" class="headerlink" title="2. YAGNI"></a>2. YAGNI</h1><p>You ain’t gonna need it. </p><p>你不会需要它。深有感触，很多时候我们想写很优雅的代码，会疯狂向后考虑，比如对于不常用的功能，有的时候哪怕就一个方法，也想搞个接口供后面的扩展来使用。过度设计，反而增加了代码的阅读成本和维护成本。</p><p>我们不应当去设计当前用不到的功能，也不应该编写现在用不到的代码。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-KISS&quot;&gt;&lt;a href=&quot;#1-KISS&quot; class=&quot;headerlink&quot; title=&quot;1. KISS&quot;&gt;&lt;/a&gt;1. KISS&lt;/h1&gt;&lt;p&gt;Keep it simple and stupid. &lt;/p&gt;
&lt;p&gt;这个原则相对比较范范，其实着重在说
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
  </entry>
  
  <entry>
    <title>SOLID - 依赖反转原则</title>
    <link href="https://www.llchen60.com/SOLID-%E4%BE%9D%E8%B5%96%E5%8F%8D%E8%BD%AC%E5%8E%9F%E5%88%99/"/>
    <id>https://www.llchen60.com/SOLID-%E4%BE%9D%E8%B5%96%E5%8F%8D%E8%BD%AC%E5%8E%9F%E5%88%99/</id>
    <published>2020-03-19T03:53:05.000Z</published>
    <updated>2020-03-19T03:53:34.823Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-控制反转-IOC-Inversion-of-Control"><a href="#1-控制反转-IOC-Inversion-of-Control" class="headerlink" title="1. 控制反转 IOC Inversion of Control"></a>1. 控制反转 IOC Inversion of Control</h1><pre><code>public class UserServiceTest {  public static boolean doTest() {    // ...   }  public static void main(String[] args) {//这部分逻辑可以放到框架中    if (doTest()) {      System.out.println(&quot;Test succeed.&quot;);    } else {      System.out.println(&quot;Test failed.&quot;);    }  }}</code></pre><p>上述代码程序员在自己控制整个代码的运行顺序和执行,可以看到如果我想增加test的话，就要在main函数里面添加，同时在UserServiceTest当中添加实例。而使用框架的话，代码就可以变成如下：</p><pre><code>public abstract class TestCase {  public void run() {    if (doTest()) {      System.out.println(&quot;Test succeed.&quot;);    } else {      System.out.println(&quot;Test failed.&quot;);    }  }  public abstract boolean doTest();}public class JunitApplication {  private static final List&lt;TestCase&gt; testCases = new ArrayList&lt;&gt;();  public static void register(TestCase testCase) {    testCases.add(testCase);  }  public static final void main(String[] args) {    for (TestCase case: testCases) {      case.run();    }  }</code></pre><p>上面的代码我们将测试的注册和运行都交给了JunitApplication了，然后我们要写新test，就让我们的concrete class extends TestCase类，来填充我们需要做的各种测试。</p><p>通过这种方式，我们实现了使用框架来控制整个代码的运转，我们使用框架来<strong>组装对象，管理整个执行流程</strong>。程序员利用框架进行开发的时候，只需要往预留的扩展点上，添加跟自己业务相关的代码，然后利用框架来驱动整个程序流程的执行。</p><p>控制反转是一种思想，有很多的具体的实现方式</p><h1 id="2-控制反转-–-依赖注入"><a href="#2-控制反转-–-依赖注入" class="headerlink" title="2. 控制反转 – 依赖注入"></a>2. 控制反转 – 依赖注入</h1><p>是控制反转的一种具体实现的方式，他的实际操作的指南是 – 不通过new（）的方式在类内部创建依赖类的对象，而是将依赖的类对象在外部创建好以后，通过构造函数，函数参数的方式传递进来给类使用。</p><pre><code>// 非依赖注入实现方式public class Notification {  private MessageSender messageSender;  public Notification() {    this.messageSender = new MessageSender(); //此处有点像hardcode  }  public void sendMessage(String cellphone, String message) {    //...省略校验逻辑等...    this.messageSender.send(cellphone, message);  }}public class MessageSender {  public void send(String cellphone, String message) {    //....  }}// 使用NotificationNotification notification = new Notification();// 依赖注入的实现方式public class Notification {  private MessageSender messageSender;  // 通过构造函数将messageSender传递进来  public Notification(MessageSender messageSender) {    this.messageSender = messageSender;  }  public void sendMessage(String cellphone, String message) {    //...省略校验逻辑等...    this.messageSender.send(cellphone, message);  }}//使用NotificationMessageSender messageSender = new MessageSender();Notification notification = new Notification(messageSender);</code></pre><p>使用依赖注入的最大好处就是，我们不需要在具体的类当中实例化其他的类，这样就实现了解耦，即他的具体实现我们可以在外部做其他方式的实例，这个时候多态也可以派上用场。可以想成我在类的内部占了个座，至于这个座具体要给谁坐，怎么坐，得等到节目要开始之前再来安排，这样我就可以举办不同的活动了。</p><pre><code>public class Notification {  private MessageSender messageSender;  public Notification(MessageSender messageSender) {    this.messageSender = messageSender;  }  public void sendMessage(String cellphone, String message) {    this.messageSender.send(cellphone, message);  }}public interface MessageSender {  void send(String cellphone, String message);}// 短信发送类public class SmsSender implements MessageSender {  @Override  public void send(String cellphone, String message) {    //....  }}// 站内信发送类public class InboxSender implements MessageSender {  @Override  public void send(String cellphone, String message) {    //....  }}//使用NotificationMessageSender messageSender = new SmsSender();Notification notification = new Notification(messageSender);</code></pre><h1 id="3-依赖反转原则"><a href="#3-依赖反转原则" class="headerlink" title="3. 依赖反转原则"></a>3. 依赖反转原则</h1><p>依赖反转 – Dependency Inversion Principle </p><blockquote><p>High-level modules shouldn’t depend on low-level modules. Both modules should depend on abstractions. In addition, abstractions shouldn’t depend on details. Details depend on abstractions.</p></blockquote><p>高层模块（high-level modules）不要依赖低层模块（low-level）。高层模块和低层模块应该通过抽象（abstractions）来互相依赖。除此之外，抽象（abstractions）不要依赖具体实现细节（details），具体实现细节（details）依赖抽象（abstractions）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-控制反转-IOC-Inversion-of-Control&quot;&gt;&lt;a href=&quot;#1-控制反转-IOC-Inversion-of-Control&quot; class=&quot;headerlink&quot; title=&quot;1. 控制反转 IOC Inversion of Contr
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="SOLID" scheme="https://www.llchen60.com/tags/SOLID/"/>
    
  </entry>
  
  <entry>
    <title>SOLID - 接口隔离原则</title>
    <link href="https://www.llchen60.com/SOLID-%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99/"/>
    <id>https://www.llchen60.com/SOLID-%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99/</id>
    <published>2020-03-17T01:26:08.000Z</published>
    <updated>2020-03-17T01:26:41.608Z</updated>
    
    <content type="html"><![CDATA[<p>接口隔离原则 – interface segregation principle </p><p>客户端不应该强迫依赖它不需要的接口。</p><h1 id="1-将接口视为一组API接口的集合"><a href="#1-将接口视为一组API接口的集合" class="headerlink" title="1. 将接口视为一组API接口的集合"></a>1. 将接口视为一组API接口的集合</h1><pre><code>public interface UserService {  boolean register(String cellphone, String password);  boolean login(String cellphone, String password);  UserInfo getUserInfoById(long id);  UserInfo getUserInfoByCellphone(String cellphone);}public class UserServiceImpl implements UserService {  //...}</code></pre><p>当我们要实现删除操作的时候，最好不要直接在UserService里面加上这个方法，因为用户服务实质上不应该被默认直接具有删除的权限，相对应的，我们应该去创建一个新的接口，里面实现有删除相关的方法，实现接口的隔离。</p><pre><code>public interface UserService {  boolean register(String cellphone, String password);  boolean login(String cellphone, String password);  UserInfo getUserInfoById(long id);  UserInfo getUserInfoByCellphone(String cellphone);}public interface RestrictedUserService {  boolean deleteUserByCellphone(String cellphone);  boolean deleteUserById(long id);}public class UserServiceImpl implements UserService, RestrictedUserService {  // ...省略实现代码...}</code></pre><h1 id="2-将接口理解为单个API接口或者函数"><a href="#2-将接口理解为单个API接口或者函数" class="headerlink" title="2. 将接口理解为单个API接口或者函数"></a>2. 将接口理解为单个API接口或者函数</h1><p>函数的设计需要功能单一，不要将多个不同的功能逻辑放在一个函数当中实现。</p><pre><code>public class Statistics {  private Long max;  private Long min;  private Long average;  private Long sum;  private Long percentile99;  private Long percentile999;  //...省略constructor/getter/setter等方法...}public Statistics count(Collection&lt;Long&gt; dataSet) {  Statistics statistics = new Statistics();  //...省略计算逻辑...  return statistics;}</code></pre><p>count方法算了太多不同的指标，应该将其分割开的。</p><pre><code>public Long max(Collection&lt;Long&gt; dataSet) { //... }public Long min(Collection&lt;Long&gt; dataSet) { //... } public Long average(Colletion&lt;Long&gt; dataSet) { //... }// ...省略其他统计函数...</code></pre><h1 id="3-将接口理解为OOP中的接口的概念"><a href="#3-将接口理解为OOP中的接口的概念" class="headerlink" title="3. 将接口理解为OOP中的接口的概念"></a>3. 将接口理解为OOP中的接口的概念</h1><p>即在设计接口的时候尽量减少大而全的接口的设计，每个接口都只做一件事情，这样子类在implement interface的时候，我们通过接口名也可以很清晰的知道在做什么，会有什么功能，也很大程度上提升了代码的复用性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;接口隔离原则 – interface segregation principle &lt;/p&gt;
&lt;p&gt;客户端不应该强迫依赖它不需要的接口。&lt;/p&gt;
&lt;h1 id=&quot;1-将接口视为一组API接口的集合&quot;&gt;&lt;a href=&quot;#1-将接口视为一组API接口的集合&quot; class=&quot;he
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="SOLID" scheme="https://www.llchen60.com/tags/SOLID/"/>
    
  </entry>
  
  <entry>
    <title>SOLID - 里氏替换原则</title>
    <link href="https://www.llchen60.com/SOLID-%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99/"/>
    <id>https://www.llchen60.com/SOLID-%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99/</id>
    <published>2020-03-14T04:33:36.000Z</published>
    <updated>2020-03-14T04:34:42.521Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Intro"><a href="#1-Intro" class="headerlink" title="1. Intro"></a>1. Intro</h1><p>里氏替代原则 - Liskov Substitution Principle </p><p>讲述的是子类对象需要能够替换程序当中父类对象出现的任何地方，并且保证原来程序的逻辑性为不变以及正确性不被破坏。</p><pre><code>public class Transporter {  private HttpClient httpClient;  public Transporter(HttpClient httpClient) {    this.httpClient = httpClient;  }  public Response sendRequest(Request request) {    // ...use httpClient to send request  }}public class SecurityTransporter extends Transporter {  private String appId;  private String appToken;  public SecurityTransporter(HttpClient httpClient, String appId, String appToken) {    super(httpClient);    this.appId = appId;    this.appToken = appToken;  }  @Override  public Response sendRequest(Request request) {    if (StringUtils.isNotBlank(appId) &amp;&amp; StringUtils.isNotBlank(appToken)) {      request.addPayload(&quot;app-id&quot;, appId);      request.addPayload(&quot;app-token&quot;, appToken);    }    return super.sendRequest(request);  }}public class Demo {      public void demoFunction(Transporter transporter) {        Reuqest request = new Request();    //...省略设置request中数据值的代码...    Response response = transporter.sendRequest(request);    //...省略其他逻辑...  }}// 里式替换原则Demo demo = new Demo();demo.demofunction(new SecurityTransporter(/*省略参数*/););</code></pre><h1 id="2-里氏替代原则-–-按照协议进行设计"><a href="#2-里氏替代原则-–-按照协议进行设计" class="headerlink" title="2. 里氏替代原则 – 按照协议进行设计"></a>2. 里氏替代原则 – 按照协议进行设计</h1><p>子类在设计的时候，应当遵守父类的行为约定。父类定义了函数的行为约定，那么子类可以改变函数的内部实现逻辑，但不能改变函数原有的行为约定。  </p><p>这里的行为约定指的是函数声明的要实现的功能；对于输入输出以及异常的约定</p><p>定义当中父类和子类之间的关系，也是可以替换成接口和实现类之间的关系的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Intro&quot;&gt;&lt;a href=&quot;#1-Intro&quot; class=&quot;headerlink&quot; title=&quot;1. Intro&quot;&gt;&lt;/a&gt;1. Intro&lt;/h1&gt;&lt;p&gt;里氏替代原则 - Liskov Substitution Principle &lt;/p&gt;
&lt;p&gt;讲
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="SOLID" scheme="https://www.llchen60.com/tags/SOLID/"/>
    
  </entry>
  
  <entry>
    <title>SOLID - 开闭原则</title>
    <link href="https://www.llchen60.com/SOLID-%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/"/>
    <id>https://www.llchen60.com/SOLID-%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/</id>
    <published>2020-03-11T03:52:23.000Z</published>
    <updated>2020-03-14T04:34:35.038Z</updated>
    
    <content type="html"><![CDATA[<p>开闭原则说的是对扩展开放，对修改关闭。我们希望做到的是使得代码有着比较好的扩展性，但是同时也不会影响到他的可读性。</p><h1 id="1-如何理解-对扩展开放，对修改关闭？"><a href="#1-如何理解-对扩展开放，对修改关闭？" class="headerlink" title="1. 如何理解 对扩展开放，对修改关闭？"></a>1. 如何理解 对扩展开放，对修改关闭？</h1><p>Open closed principle, Software entities (modules, classes, functions, etc) should be open for extension, but closed for modification. </p><p>添加一个新的功能应该是在已有代码基础上扩展代码，而非修改已有的代码。</p><h1 id="2-实例解释"><a href="#2-实例解释" class="headerlink" title="2. 实例解释"></a>2. 实例解释</h1><p>代码实现的功能就是当TPS超过某个预设的最大值的时候，或者是错误的数量超过允许的最大值，那么就会触发警报<br>    public class Alert {<br>      private AlertRule rule;<br>      private Notification notification;</p><pre><code>  public Alert(AlertRule rule, Notification notification) {    this.rule = rule;    this.notification = notification;  }  public void check(String api, long requestCount, long errorCount, long durationOfSeconds) {    long tps = requestCount / durationOfSeconds;    if (tps &gt; rule.getMatchedRule(api).getMaxTps()) {      notification.notify(NotificationEmergencyLevel.URGENCY, &quot;...&quot;);    }    if (errorCount &gt; rule.getMatchedRule(api).getMaxErrorCount()) {      notification.notify(NotificationEmergencyLevel.SEVERE, &quot;...&quot;);    }  }}</code></pre><p>现在我们需要添加一个功能，当每秒钟请求数量超过某个阈值的时候，我们也要触发警告，发送通知。</p><p>如果直接在上述代码中进行修改的话，我们主要是需要在check函数当中，添加一个新的输入参数，timeoutCount，表示超时的请求数量，然后再check函数里面加上对应的逻辑</p><pre><code>public class Alert {  // ...省略AlertRule/Notification属性和构造函数...  // 改动一：添加参数timeoutCount  public void check(String api, long requestCount, long errorCount, long timeoutCount, long durationOfSeconds) {    long tps = requestCount / durationOfSeconds;    if (tps &gt; rule.getMatchedRule(api).getMaxTps()) {      notification.notify(NotificationEmergencyLevel.URGENCY, &quot;...&quot;);    }    if (errorCount &gt; rule.getMatchedRule(api).getMaxErrorCount()) {      notification.notify(NotificationEmergencyLevel.SEVERE, &quot;...&quot;);    }    // 改动二：添加接口超时处理逻辑    long timeoutTps = timeoutCount / durationOfSeconds;    if (timeoutTps &gt; rule.getMatchedRule(api).getMaxTimeoutTps()) {      notification.notify(NotificationEmergencyLevel.URGENCY, &quot;...&quot;);    }  }}</code></pre><p>这样的改动是有不少问题的，比如我们对于传入参数做了改动，那所有调用这个函数的地方都需要进行修改，这就是个不小的问题了；而且在修改了check函数以后，所有的单元测试都需要进行修改，会很麻烦的。</p><p>为了提高这整个类的拓展性，我们可以做以下的重构操作：</p><ul><li>将check函数的多个入参封装成ApiStatInfo类</li><li>引入handler的概念，将if判断逻辑分散到各个handler当中</li></ul><pre><code>public class Alert {  private List&lt;AlertHandler&gt; alertHandlers = new ArrayList&lt;&gt;();  public void addAlertHandler(AlertHandler alertHandler) {    this.alertHandlers.add(alertHandler);  }  public void check(ApiStatInfo apiStatInfo) {    for (AlertHandler handler : alertHandlers) {      handler.check(apiStatInfo);    }  }}public class ApiStatInfo {//省略constructor/getter/setter方法  private String api;  private long requestCount;  private long errorCount;  private long durationOfSeconds;}public abstract class AlertHandler {  protected AlertRule rule;  protected Notification notification;  public AlertHandler(AlertRule rule, Notification notification) {    this.rule = rule;    this.notification = notification;  }  public abstract void check(ApiStatInfo apiStatInfo);}public class TpsAlertHandler extends AlertHandler {  public TpsAlertHandler(AlertRule rule, Notification notification) {    super(rule, notification);  }  @Override  public void check(ApiStatInfo apiStatInfo) {    long tps = apiStatInfo.getRequestCount()/ apiStatInfo.getDurationOfSeconds();    if (tps &gt; rule.getMatchedRule(apiStatInfo.getApi()).getMaxTps()) {      notification.notify(NotificationEmergencyLevel.URGENCY, &quot;...&quot;);    }  }}public class ErrorAlertHandler extends AlertHandler {  public ErrorAlertHandler(AlertRule rule, Notification notification){    super(rule, notification);  }  @Override  public void check(ApiStatInfo apiStatInfo) {    if (apiStatInfo.getErrorCount() &gt; rule.getMatchedRule(apiStatInfo.getApi()).getMaxErrorCount()) {      notification.notify(NotificationEmergencyLevel.SEVERE, &quot;...&quot;);    }  }}</code></pre><p>在使用的时候，如下：</p><pre><code>public class ApplicationContext {  private AlertRule alertRule;  private Notification notification;  private Alert alert;  public void initializeBeans() {    alertRule = new AlertRule(/*.省略参数.*/); //省略一些初始化代码    notification = new Notification(/*.省略参数.*/); //省略一些初始化代码    alert = new Alert();    alert.addAlertHandler(new TpsAlertHandler(alertRule, notification));    alert.addAlertHandler(new ErrorAlertHandler(alertRule, notification));  }  public Alert getAlert() { return alert; }  // 饿汉式单例  private static final ApplicationContext instance = new ApplicationContext();  private ApplicationContext() {    instance.initializeBeans();  }  public static ApplicationContext getInstance() {    return instance;  }}public class Demo {  public static void main(String[] args) {    ApiStatInfo apiStatInfo = new ApiStatInfo();    // ...省略设置apiStatInfo数据值的代码    ApplicationContext.getInstance().getAlert().check(apiStatInfo);  }}</code></pre><p>需要修改的地方：</p><pre><code>public class Alert { // 代码未改动... }public class ApiStatInfo {//省略constructor/getter/setter方法  private String api;  private long requestCount;  private long errorCount;  private long durationOfSeconds;  private long timeoutCount; // 改动一：添加新字段}public abstract class AlertHandler { //代码未改动... }public class TpsAlertHandler extends AlertHandler {//代码未改动...}public class ErrorAlertHandler extends AlertHandler {//代码未改动...}// 改动二：添加新的handlerpublic class TimeoutAlertHandler extends AlertHandler {//省略代码...}public class ApplicationContext {  private AlertRule alertRule;  private Notification notification;  private Alert alert;  public void initializeBeans() {    alertRule = new AlertRule(/*.省略参数.*/); //省略一些初始化代码    notification = new Notification(/*.省略参数.*/); //省略一些初始化代码    alert = new Alert();    alert.addAlertHandler(new TpsAlertHandler(alertRule, notification));    alert.addAlertHandler(new ErrorAlertHandler(alertRule, notification));    // 改动三：注册handler    alert.addAlertHandler(new TimeoutAlertHandler(alertRule, notification));  }  //...省略其他未改动代码...}public class Demo {  public static void main(String[] args) {    ApiStatInfo apiStatInfo = new ApiStatInfo();    // ...省略apiStatInfo的set字段代码    apiStatInfo.setTimeoutCount(289); // 改动四：设置tiemoutCount值    ApplicationContext.getInstance().getAlert().check(apiStatInfo);}</code></pre><h1 id="3-一些思考"><a href="#3-一些思考" class="headerlink" title="3. 一些思考"></a>3. 一些思考</h1><ul><li><p>写代码的时候就需要想想有可能会有哪些需求上的变更，如何设计代码的结构，留好扩展点。</p></li><li><p>在识别出可变部分之后，要将可变部分封装起来，隔离变化，提供抽象化的不可变接口，给上层系统来使用。当具体的实现发生变化的时候，我们只需要基于相同的抽象接口，扩展一个新的实现，这样子上游的代码就几乎不需要修改了</p></li><li><p>基于接口而非实现的编程， 对扩展开放，对修改关闭</p><p>  // 这一部分体现了抽象意识<br>  public interface MessageQueue { //… }<br>  public class KafkaMessageQueue implements MessageQueue { //… }<br>  public class RocketMQMessageQueue implements MessageQueue {//…}</p><p>  public interface MessageFormatter { //… }<br>  public class JsonMessageFormatter implements MessageFormatter {//…}<br>  public class MessageFormatter implements MessageFormatter {//…}</p><p>  public class Demo {</p><pre><code>private MessageQueue msgQueue; // 基于接口而非实现编程public Demo(MessageQueue msgQueue) { // 依赖注入  this.msgQueue = msgQueue;}// msgFormatter：多态、依赖注入public void sendNotification(Notification notification, MessageFormatter msgFormatter) {  //...    }</code></pre><p>  }</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;开闭原则说的是对扩展开放，对修改关闭。我们希望做到的是使得代码有着比较好的扩展性，但是同时也不会影响到他的可读性。&lt;/p&gt;
&lt;h1 id=&quot;1-如何理解-对扩展开放，对修改关闭？&quot;&gt;&lt;a href=&quot;#1-如何理解-对扩展开放，对修改关闭？&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="SOLID" scheme="https://www.llchen60.com/tags/SOLID/"/>
    
  </entry>
  
  <entry>
    <title>SOLID - 单一职责原则</title>
    <link href="https://www.llchen60.com/SOLID-%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99/"/>
    <id>https://www.llchen60.com/SOLID-%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99/</id>
    <published>2020-03-10T03:49:07.000Z</published>
    <updated>2020-03-10T03:50:07.853Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Intro"><a href="#1-Intro" class="headerlink" title="1. Intro"></a>1. Intro</h1><ul><li>Single Responsibility Principle - 单一职责原则<ul><li>我们希望对于一个类或者模块来说，他们都是只有一个职责的，即只完成一个功能</li><li>这个职责说的其实就是，不要设计大而全的类，应当设计粒度小，功能单一的类。</li><li>在同一个类当中的方法功能，应该是在同一个业务方向当中的</li></ul></li></ul><h1 id="2-如何判断类的职责是否单一"><a href="#2-如何判断类的职责是否单一" class="headerlink" title="2. 如何判断类的职责是否单一"></a>2. 如何判断类的职责是否单一</h1><ul><li><p>E.G</p><ul><li>如果一个类，既要处理和其他微服务的交互，又要到数据库query，那么这就是两个职责，我们就应该将这个类分割开，划分到两个不同的类当中去 </li></ul></li><li><p>E.G2</p></li></ul><pre><code>public class UserInfo {  private long userId;  private String username;  private String email;  private String telephone;  private long createTime;  private long lastLoginTime;  private String avatarUrl;  private String provinceOfAddress; // 省  private String cityOfAddress; // 市  private String regionOfAddress; // 区   private String detailedAddress; // 详细地址  // ...省略其他属性和方法...}</code></pre><p>对于上述UserInfo类来说，里面全是User的一些属性，但是其中有将近半数是关于地址的，我们有理由将其细分为UserAddress类以及UserInfo类，但是在实际应用场景当中，我们需要考虑我们到底是准备如何使用这些数据的。</p><p>如果应用场景就是拿出用户相关的信息，那放在一起无伤大雅，但是如果是要做物流，电商的场景，那么我们单独想拿出地址相关信息的场景就会比较多了，这种情况最好就分成两个不同的类了。</p><p>实际开发当中，实际上一般情况下都是先写一个粗粒度的类，以满足业务的需求，随着业务的发展，如果粗粒度的类越来越庞大，我们就可以将这个粗粒度的类拆分成几个更细粒度的类，即–持续重构。</p><h1 id="3-判断是否满足单一职责原则的判断准则"><a href="#3-判断是否满足单一职责原则的判断准则" class="headerlink" title="3. 判断是否满足单一职责原则的判断准则"></a>3. 判断是否满足单一职责原则的判断准则</h1><ul><li>类中代码的行数，函数或者属性过多，会影响代码的可读性和可维护性，需要考虑对类进行拆分了</li><li>类依赖的其他类过多，或者依赖类的其他类过多，不符合高内聚，低耦合的设计思想，我们需要对其考虑进行拆分</li><li>私有方法过多，我们需要考虑是否应该将私有方法独立到新的类当中，设置为public方法，供更多的类使用，从而提高代码的复用性</li><li>如果对于一个类，比较难取名字，只能用相对泛泛的名字，那很可能意味着这个类的职责有点过多了</li><li>类中的大量方法都是集中操作类中的某几个属性，那么就可以考虑将这几个属性和对应的方法拆分出来</li></ul><p>需要注意的一点是： 我们使用这些准则，亦或者是设计模式，最终的目的还是提高代码的可读性，可扩展性，复用性，可维护性等。这才应当是我们判断是否要采用SOLID准则，以及其他的原则的最终标准。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Intro&quot;&gt;&lt;a href=&quot;#1-Intro&quot; class=&quot;headerlink&quot; title=&quot;1. Intro&quot;&gt;&lt;/a&gt;1. Intro&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Single Responsibility Principle - 单一职责原则&lt;u
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="SOLID" scheme="https://www.llchen60.com/tags/SOLID/"/>
    
  </entry>
  
  <entry>
    <title>基于充血模型的DDD开发模型</title>
    <link href="https://www.llchen60.com/%E5%9F%BA%E4%BA%8E%E5%85%85%E8%A1%80%E6%A8%A1%E5%9E%8B%E7%9A%84DDD%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B/"/>
    <id>https://www.llchen60.com/%E5%9F%BA%E4%BA%8E%E5%85%85%E8%A1%80%E6%A8%A1%E5%9E%8B%E7%9A%84DDD%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B/</id>
    <published>2020-03-06T00:49:16.000Z</published>
    <updated>2020-03-08T17:05:14.373Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-传统基于MVC的开发模式"><a href="#1-传统基于MVC的开发模式" class="headerlink" title="1. 传统基于MVC的开发模式"></a>1. 传统基于MVC的开发模式</h1><p>MVC三层结构中的M表示Model，V表示View，C表示Controller。通过这三层将整个项目分为了三大部分，展示层，逻辑层，数据层</p><p>而贫血模型 - Anemic Domain Model，指的是我们将数据和操作分离，有专门的POJO类，即只包含数据的类，这实质上会破坏面向对象的封装特性，是一种面向过程的编程风格。</p><h1 id="2-基于充血模型的DDD开发模式"><a href="#2-基于充血模型的DDD开发模式" class="headerlink" title="2. 基于充血模型的DDD开发模式"></a>2. 基于充血模型的DDD开发模式</h1><p>充血模型 - rich domain model，旨在将数据和对应的业务逻辑封装在同一个类当中。</p><h1 id="3-实战-DDD-开发虚拟钱包系统"><a href="#3-实战-DDD-开发虚拟钱包系统" class="headerlink" title="3. 实战  DDD 开发虚拟钱包系统"></a>3. 实战  DDD 开发虚拟钱包系统</h1><h2 id="3-1-钱包业务背景介绍"><a href="#3-1-钱包业务背景介绍" class="headerlink" title="3.1 钱包业务背景介绍"></a>3.1 钱包业务背景介绍</h2><p>需要创建一个系统内的虚拟钱包账户，来支持用户的充值，提现，支付，冻结，透支，转赠，查询账户余额，查询交易流水等操作。</p><p>在这里，我们假定要去实现一个具备充值，提现, 支付，查询余额，还有查询交易流水五个功能的钱包。</p><p>其业务流程分别为：</p><ul><li>充值 <ul><li>用户通过第三方支付渠道，将自己银行卡里面的钱充值到虚拟钱包账号当中</li><li>操作流程<ul><li>从用户银行卡到应用的公共银行卡</li><li>用户虚拟钱包增加金额</li><li>记录刚刚这笔交易流水</li></ul></li></ul></li><li>支付<ul><li>实际上是一个转账的过程，从用户的虚拟钱包账户划钱到商家的虚拟钱包账户当中</li><li>记录流水信息</li></ul></li><li>提现<ul><li>用户虚拟钱包  减去对应的钱数</li><li>应用的公共银行卡 打钱 到用户的银行卡</li><li>记录交易</li></ul></li><li>查询余额<ul><li>看虚拟钱包的余额数字</li></ul></li><li>查询交易流水<ul><li>查询充值，支付，提现三种操作</li></ul></li></ul><h2 id="3-2-设计思路"><a href="#3-2-设计思路" class="headerlink" title="3.2 设计思路"></a>3.2 设计思路</h2><p>首先我们需要对系统进行解耦，即用相似特征和特性的功能放到同一个子系统当中。根据特性，我们可以分为虚拟钱包系统和三方支付系统两个部分。</p><ul><li>虚拟钱包<ul><li>用户虚拟钱包</li><li>商家虚拟钱包</li></ul></li><li>三方支付<ul><li>用户银行卡</li><li>商家银行卡</li><li>应用公共银行卡</li></ul></li></ul><p>虚拟钱包需要支持的操作基本上就是对于余额的加减，充值，提现，查询三种操作都是只涉及到一个账户的余额的加减操作；而支付功能涉及到两个账户的余额的加减操作。</p><p>而对于交易记录，应当记录的信息有：</p><ul><li>交易流水ID</li><li>交易时间</li><li>交易金额</li><li>交易类型<ul><li>充值</li><li>提现</li><li>支付</li></ul></li><li>入账钱包账号</li><li>出账钱包账号</li></ul><p>这么设计是有点浪费存储空间的，因为对于充值提现这种交易类型来说，我们只要记录一个钱包账户信息就好了。</p><p>另外一种方式就是在交易类型处，设计成支付和被支付两种类型，这样在对待转账的情况的时候，数据库写两条数据，来记录整个transaction。能够省空间，但是会有一些问题：</p><p>最重要的难点还是在数据的一致性方面，当我们在做转账操作的时候，我们必须保证加减两个操作要么都成功，要么都失败。如果一个成功，一个失败，那会完蛋的。关于钱的事情，发生一点错误就会对公司造成非常大的影响。</p><p>对于转账及类似的操作，合理的做法是在操作两个钱包的账户余额之前，先记录交易流水，并且标记为待执行，当两个钱包的加减金额都完成了之后，我们再回头将交易记录的状态标记为失败。然后我们通过后台的补漏job，拉取状态为失败或者长时间处于待执行状态的交易记录，重新执行或者人工介入处理。</p><p>另外一个点在我们会构建一个钱包系统，然后分出两个子系统，虚拟钱包还有第三方交易平台，那么我们的商业逻辑都应该放到钱包系统这一个层级上，我们希望我们的虚拟钱包还有交易平台尽量和我们的商业逻辑脱钩，更多的是事务上方法上的更泛化的东西。这样做的好处是我们的商业逻辑会经常发生变化，但是我们希望虚拟钱包，还有第三方交易平台两个模块不需要经常性的变动。这也是去做两个子系统的初衷之一。</p><h2 id="3-3-基于贫血模式的传统开发模式"><a href="#3-3-基于贫血模式的传统开发模式" class="headerlink" title="3.3 基于贫血模式的传统开发模式"></a>3.3 基于贫血模式的传统开发模式</h2><pre><code>public class VirtualWalletController {  // 通过构造函数或者IOC框架注入  private VirtualWalletService virtualWalletService;  public BigDecimal getBalance(Long walletId) { ... } //查询余额  public void debit(Long walletId, BigDecimal amount) { ... } //出账  public void credit(Long walletId, BigDecimal amount) { ... } //入账  public void transfer(Long fromWalletId, Long toWalletId, BigDecimal amount) { ...} //转账}public class VirtualWalletBo {//省略getter/setter/constructor方法  private Long id;  private Long createTime;  private BigDecimal balance;}public class VirtualWalletService {  // 通过构造函数或者IOC框架注入  private VirtualWalletRepository walletRepo;  private VirtualWalletTransactionRepository transactionRepo;  public VirtualWalletBo getVirtualWallet(Long walletId) {    VirtualWalletEntity walletEntity = walletRepo.getWalletEntity(walletId);    VirtualWalletBo walletBo = convert(walletEntity);    return walletBo;  }  public BigDecimal getBalance(Long walletId) {    return walletRepo.getBalance(walletId);  }  public void debit(Long walletId, BigDecimal amount) {    VirtualWalletEntity walletEntity = walletRepo.getWalletEntity(walletId);    BigDecimal balance = walletEntity.getBalance();    if (balance.compareTo(amount) &lt; 0) {      throw new NoSufficientBalanceException(...);    }    walletRepo.updateBalance(walletId, balance.subtract(amount));  }  public void credit(Long walletId, BigDecimal amount) {    VirtualWalletEntity walletEntity = walletRepo.getWalletEntity(walletId);    BigDecimal balance = walletEntity.getBalance();    walletRepo.updateBalance(walletId, balance.add(amount));  }  public void transfer(Long fromWalletId, Long toWalletId, BigDecimal amount) {    VirtualWalletTransactionEntity transactionEntity = new VirtualWalletTransactionEntity();    transactionEntity.setAmount(amount);    transactionEntity.setCreateTime(System.currentTimeMillis());    transactionEntity.setFromWalletId(fromWalletId);    transactionEntity.setToWalletId(toWalletId);    transactionEntity.setStatus(Status.TO_BE_EXECUTED);    Long transactionId = transactionRepo.saveTransaction(transactionEntity);    try {      debit(fromWalletId, amount);      credit(toWalletId, amount);    } catch (InsufficientBalanceException e) {      transactionRepo.updateStatus(transactionId, Status.CLOSED);      ...rethrow exception e...    } catch (Exception e) {      transactionRepo.updateStatus(transactionId, Status.FAILED);      ...rethrow exception e...    }    transactionRepo.updateStatus(transactionId, Status.EXECUTED);  }}</code></pre><h2 id="3-4-基于充血模式的DDD开发模式"><a href="#3-4-基于充血模式的DDD开发模式" class="headerlink" title="3.4 基于充血模式的DDD开发模式"></a>3.4 基于充血模式的DDD开发模式</h2><pre><code>public class VirtualWallet { // Domain领域模型(充血模型)  private Long id;  private Long createTime = System.currentTimeMillis();;  private BigDecimal balance = BigDecimal.ZERO;  public VirtualWallet(Long preAllocatedId) {    this.id = preAllocatedId;  }  public BigDecimal balance() {    return this.balance;  }  public void debit(BigDecimal amount) {    if (this.balance.compareTo(amount) &lt; 0) {      throw new InsufficientBalanceException(...);    }    this.balance.subtract(amount);  }  public void credit(BigDecimal amount) {    if (amount.compareTo(BigDecimal.ZERO) &lt; 0) {      throw new InvalidAmountException(...);    }    this.balance.add(amount);  }}public class VirtualWalletService {  // 通过构造函数或者IOC框架注入  private VirtualWalletRepository walletRepo;  private VirtualWalletTransactionRepository transactionRepo;  public VirtualWallet getVirtualWallet(Long walletId) {    VirtualWalletEntity walletEntity = walletRepo.getWalletEntity(walletId);    VirtualWallet wallet = convert(walletEntity);    return wallet;  }  public BigDecimal getBalance(Long walletId) {    return walletRepo.getBalance(walletId);  }  public void debit(Long walletId, BigDecimal amount) {    VirtualWalletEntity walletEntity = walletRepo.getWalletEntity(walletId);    VirtualWallet wallet = convert(walletEntity);    wallet.debit(amount);    walletRepo.updateBalance(walletId, wallet.balance());  }  public void credit(Long walletId, BigDecimal amount) {    VirtualWalletEntity walletEntity = walletRepo.getWalletEntity(walletId);    VirtualWallet wallet = convert(walletEntity);    wallet.credit(amount);    walletRepo.updateBalance(walletId, wallet.balance());  }  public void transfer(Long fromWalletId, Long toWalletId, BigDecimal amount) {    //...跟基于贫血模型的传统开发模式的代码一样...  }}</code></pre><p>一些思考： </p><ul><li>领域模型 希望其尽可能的独立，不包含任何其它层的代码，将流程性的代码逻辑和领域模型的业务逻辑解耦，让领域模型更加可以复用</li><li>Service类负责一些非功能性的和与第三方交互的工作 <ul><li>信息传送</li><li>metrics</li><li>日志</li></ul></li></ul><h1 id="4-实战-接口鉴权"><a href="#4-实战-接口鉴权" class="headerlink" title="4. 实战 - 接口鉴权"></a>4. 实战 - 接口鉴权</h1><p>目的是熟悉在拿到相对笼统的开发需求的时候，需要如何做需求分析，如何做职责划分，看需要定义哪些类，每个类应该具有哪些属性，方法；定义类和类的交互</p><h2 id="4-1-需求"><a href="#4-1-需求" class="headerlink" title="4.1 需求"></a>4.1 需求</h2><p>微服务系统，通过HTTP协议暴露接口给其他系统调用。需要实现一个接口鉴权系统，只有经过认证的系统才能调用我们的接口</p><ul><li>需求分析<ul><li>基础分析<ul><li>通过用户名加密码来做认证</li><li>每个允许访问的调用发都有应用ID还有秘钥，在做接口请求的时候，需要传进来应用ID和秘钥，然后我们在自己的服务器来进行验证比对。如果一致，说明认证成功，允许接口调用了否则，就拒绝</li></ul></li><li>二轮分析<ul><li>这种方式，明文传输，容易被拦截，并不安全</li><li>借助加密算法，对密码进行加密再传递到微服务端验证，同样不安全。因为还是可以被拦截，被拦截以后黑客可以直接拿着这个加密的密码加ID来假装是调用者向服务端发出请求</li><li>OAuth方式<ul><li>调用方生成token (id + appId + pwd)</li><li>调用方生成新的URL (id + appId + token)</li><li>Server解析出URL, appId, token</li><li>Server从数据库根据appId拿出pwd</li><li>Server利用Url，appId， pwd生成server端token</li><li>比较是否一致</li></ul></li></ul></li><li>三轮分析<ul><li>上述方式还是可能存在重放攻击，被拦截，然后来伪装成认证系统，调用这个URL对应的接口。</li><li>token生成过程加入时间戳，然后传递到微服务器端</li><li>微服务器收到这些数据之后，会验证当前时间戳跟传递过来的时间戳，是否在一定的时间窗口内。超过时间窗口，也会决绝请求</li></ul></li><li>四轮分析<ul><li>基本就是到这个程度，因为我们还要考虑性能方面的东西。这种方式对于性能的影响比较小，也考量到了安全性。</li><li>如何在微服务端存储每个授权调用方的appId和密码<ul><li>开发鉴权这种非业务功能，最好不要与具体的第三方系统有过度的耦合</li><li>最好能够支持多种不同的存储方式<ul><li>ZooKeeper</li><li>本地配置文件</li><li>自研配置中心</li><li>MySQL</li><li>Redis等</li></ul></li></ul></li></ul></li><li>最终需求的确定<ul><li>调用方进行接口请求的时候，将 URL、AppID、密码、时间戳拼接在一起，通过加密算法生成 token，并且将 token、AppID、时间戳拼接在 URL 中，一并发送到微服务端。</li><li>微服务端在接收到调用方的接口请求之后，从请求中拆解出 token、AppID、时间戳。</li><li>微服务端首先检查传递过来的时间戳跟当前时间，是否在 token 失效时间窗口内。如果已经超过失效时间，那就算接口调用鉴权失败，拒绝接口调用请求。</li><li>如果 token 验证没有过期失效，微服务端再从自己的存储中，取出 AppID 对应的密码，通过同样的 token 生成算法，生成另外一个 token，与调用方传递过来的 token 进行匹配；如果一致，则鉴权成功，允许接口调用，否则就拒绝接口调用。 </li></ul></li></ul></li></ul><h2 id="4-2-面向对象设计"><a href="#4-2-面向对象设计" class="headerlink" title="4.2 面向对象设计"></a>4.2 面向对象设计</h2><ul><li>进行职责划分，进而识别出都有哪些类<ul><li>将需求描述中的名词罗列出来，作为可能的候选类，然后进行筛选</li><li>或者根据需求描述，将其中涉及的功能点，一个一个罗列出来，然后再看哪些功能点职责相近，操作同样的属性，能否归到同一个类当中</li></ul></li><li>定义类，及其属性和方法</li><li>定义类和类之间的交互关系</li><li>将类组装起来并提供执行入口 </li></ul><ul><li>功能点列表<ul><li>把 URL、AppID、密码、时间戳拼接为一个字符串；</li><li>对字符串通过加密算法加密生成 token；</li><li>将 token、AppID、时间戳拼接到 URL 中，形成新的 URL；</li><li>解析 URL，得到 token、AppID、时间戳等信息；</li><li>从存储中取出 AppID 和对应的密码；</li><li>根据时间戳判断 token 是否过期失效；</li><li>验证两个 token 是否匹配； </li></ul></li></ul><p>从上面的功能列表中，我们发现，1、2、6、7 都是跟 token 有关，负责 token 的生成、验证；3、4 都是在处理 URL，负责 URL 的拼接、解析；5 是操作 AppID 和密码，负责从存储中读取 AppID 和密码。所以，我们可以粗略地得到三个核心的类：AuthToken、Url、CredentialStorage。AuthToken 负责实现 1、2、6、7 这四个操作；Url 负责 3、4 两个操作；CredentialStorage 负责 5 这个操作。</p><pre><code>// AuthToken类的实现private static final long DEFAULT_EXPIRED_TIME_INTERVAL = 1 * 60 * 1000;private String token;private long createTime;private long expiredTimeInterval = DEFAULT_EXPIRED_TIME_INTERVAL;public AuthToken(String token, long createTime);public AuthToken(String token, long createTime, long expredTImeInterval);public static AuthToken create(String baseUrl, long createTime, Map&lt;String, String&gt; params);public String getToken();public boolean isExpired();public boolean match(AuthToken authToken)</code></pre><ul><li>Tips<ul><li>并不是所有的需要的名词类的属性都会作为类的属性，有可能会作为方法的参数。选择的基准还是这个属性到底属不属于这个类，从这个角度来看的</li><li>我们有可能需要去挖掘一下在功能需求里面并没有体现的一些属性  还是需要从业务模型的角度上来看究竟需要怎么做才比较好</li></ul></li></ul><pre><code>public interface ApiAuthenticator {  void auth(String url);  void auth(ApiRequest apiRequest);}public class DefaultApiAuthenticatorImpl implements ApiAuthenticator {  private CredentialStorage credentialStorage;  public DefaultApiAuthenticator() {    this.credentialStorage = new MysqlCredentialStorage();  }  public DefaultApiAuthenticator(CredentialStorage credentialStorage) {    this.credentialStorage = credentialStorage;  }  @Override  public void auth(String url) {    ApiRequest apiRequest = ApiRequest.buildFromUrl(url);    auth(apiRequest);  }  @Override  public void auth(ApiRequest apiRequest) {    String appId = apiRequest.getAppId();    String token = apiRequest.getToken();    long timestamp = apiRequest.getTimestamp();    String originalUrl = apiRequest.getOriginalUrl();    AuthToken clientAuthToken = new AuthToken(token, timestamp);    if (clientAuthToken.isExpired()) {      throw new RuntimeException(&quot;Token is expired.&quot;);    }    String password = credentialStorage.getPasswordByAppId(appId);    AuthToken serverAuthToken = AuthToken.generate(originalUrl, appId, password, timestamp);    if (!serverAuthToken.match(clientAuthToken)) {      throw new RuntimeException(&quot;Token verfication failed.&quot;);    }  }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-传统基于MVC的开发模式&quot;&gt;&lt;a href=&quot;#1-传统基于MVC的开发模式&quot; class=&quot;headerlink&quot; title=&quot;1. 传统基于MVC的开发模式&quot;&gt;&lt;/a&gt;1. 传统基于MVC的开发模式&lt;/h1&gt;&lt;p&gt;MVC三层结构中的M表示Model，V表
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="DDD" scheme="https://www.llchen60.com/tags/DDD/"/>
    
  </entry>
  
  <entry>
    <title>组合 vs 继承</title>
    <link href="https://www.llchen60.com/%E7%BB%84%E5%90%88-vs-%E7%BB%A7%E6%89%BF/"/>
    <id>https://www.llchen60.com/%E7%BB%84%E5%90%88-vs-%E7%BB%A7%E6%89%BF/</id>
    <published>2020-03-04T04:21:56.000Z</published>
    <updated>2020-03-04T04:22:54.643Z</updated>
    
    <content type="html"><![CDATA[<p>组合还有继承都是面向对象的很重要的特性，但是有一条非常重要的设计原则说 – 组合优于继承，想在这篇博文当中分析一下为什么认为组合优于继承，以及什么情况下我们仍然应该使用继承。</p><p>继承可以表示类之间的is-a的关系，可以一定程度上解决代码复用性的问题，但是继承层次过深，也会影响到代码的可维护性。</p><h1 id="1-继承的劣势"><a href="#1-继承的劣势" class="headerlink" title="1. 继承的劣势"></a>1. 继承的劣势</h1><p>譬如 我们现在要实现一个关于哺乳动物的类，我们首先需要将哺乳动物定义为一个抽象的类</p><pre><code>public class Mammal {    public void breathWithLung() {    }}</code></pre><p>此时我们就可以实例化Monkey，Whale等一系列哺乳动物了。但是对于哺乳动物来说，他的属，科，目门类很多，海陆空都有，假设我们按照他们的行为来进行分类的话。可以分成会飞的，会游的，还有会跑的。所以就可以写如下的代码：</p><pre><code>public class flyableMammal extends Mammal {    public void fly() {    }}public class underwaterMammal extends Mammal {    public void swim() {    }}public class onLandMammal extends Mammal {    public void run() {    }}</code></pre><p>这个时候我们已经有两层的继承了，而后我们可以实例化一些哺乳动物，譬如鲸鱼，海豚，狮子等等来创建真的对象。然后问题来了，我们现在想探究会飞的动物当中，夜行的类目，那就意味着我们需要再创建一个新的层级来进行研究了。</p><p>长此以往，整个层级就会变得很深。而深度的层级意味着每当我们想真真切切去研究到底这个类做了什么的时候，我们需要去他的父类，去他的父类的父类，追本溯源，一个一个看其中定义的属性和方法，才能完全理解他做了什么。</p><p>这样子来做，首先造成了代码的可读性变得非常差，而对于类本身而言，破坏了其封装特性，将父类的实现细节暴露给了子类。在这种情况下，一旦父类代码修改，就会影响所有子类的逻辑。</p><h1 id="2-组合的优势"><a href="#2-组合的优势" class="headerlink" title="2. 组合的优势"></a>2. 组合的优势</h1><p>对于上述的场景，我们完全可以用组合的方式来实现。通过设立多个功能接口，来表示当前类的属性，譬如flyable, runnable, swimmable, etc. 通过这种方式，我们让concrete class直接implements对应的接口，并override写出自己的实现。这样子就能够解决这个问题了。</p><p>除了使用接口之外，我们也可以使用委托的方式，即仍然定于对应的接口，但是还定义了实现了接口方法的实现类，在实际使用的时候，调用实现类的方法直接使用，例子如下</p><pre><code>public interface Flyable {  void fly()；}public class FlyAbility implements Flyable {  @Override  public void fly() { //... }}//省略Tweetable/TweetAbility/EggLayable/EggLayAbilitypublic class Ostrich implements Tweetable, EggLayable {//鸵鸟  private TweetAbility tweetAbility = new TweetAbility(); //组合  private EggLayAbility eggLayAbility = new EggLayAbility(); //组合  //... 省略其他属性和方法...  @Override  public void tweet() {    tweetAbility.tweet(); // 委托  }  @Override  public void layEgg() {    eggLayAbility.layEgg(); // 委托  }}</code></pre><h1 id="3-如何判断该使用继承还是组合？"><a href="#3-如何判断该使用继承还是组合？" class="headerlink" title="3. 如何判断该使用继承还是组合？"></a>3. 如何判断该使用继承还是组合？</h1><p>组合也并不完美，组合需要对类做更细度的拆分，要定义更多的类和接口，因此在实际开发的过程当中，我们还是要根据具体的情况，来具体选择该使用继承还是组合。</p><p>如果类之间的继承结构稳定 – 不会轻易改变，继承关系比较浅 – 譬如两层到三层的继承关系，那么我们可以直接使用继承。反之，对于系统不够稳定，继承层次会很深，且关系复杂的，我们就应该尽量使用组合来替代继承了。</p><p>或者当我们想要使用多态的特性的时候，我们就需要使用继承了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;组合还有继承都是面向对象的很重要的特性，但是有一条非常重要的设计原则说 – 组合优于继承，想在这篇博文当中分析一下为什么认为组合优于继承，以及什么情况下我们仍然应该使用继承。&lt;/p&gt;
&lt;p&gt;继承可以表示类之间的is-a的关系，可以一定程度上解决代码复用性的问题，但是继承层次
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
      <category term="Composition" scheme="https://www.llchen60.com/tags/Composition/"/>
    
      <category term="Inheritance" scheme="https://www.llchen60.com/tags/Inheritance/"/>
    
  </entry>
  
  <entry>
    <title>Java 理解多态</title>
    <link href="https://www.llchen60.com/Java-%E7%90%86%E8%A7%A3%E5%A4%9A%E6%80%81/"/>
    <id>https://www.llchen60.com/Java-%E7%90%86%E8%A7%A3%E5%A4%9A%E6%80%81/</id>
    <published>2020-02-29T16:34:38.000Z</published>
    <updated>2020-02-29T16:35:36.929Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-什么是多态？"><a href="#1-什么是多态？" class="headerlink" title="1. 什么是多态？"></a>1. 什么是多态？</h1><p>多态目的是为了分离做什么和怎么做，从而实现接口和实现的分离。通过多态，可以改善代码的组织结构和可读性，最重要的是能够创建可扩展的程序。</p><p>有继承关系的类，子类重写父类的方法，然后父类的引用指向子类。通过这种方式，就可以对于父类的声明指向子类的实际对象，</p><h1 id="2-为什么需要多态？"><a href="#2-为什么需要多态？" class="headerlink" title="2. 为什么需要多态？"></a>2. 为什么需要多态？</h1><p>多态的好处很多，令代码可扩展，解耦接口与实现，让代码对于改动封闭，对于扩展开放, etc. 如果直接从代码的角度来看，我们可以比较直观的看到他的优势</p><pre><code>public class Animal {    public void move() {        System.out.println(&quot;Animal move&quot;);    }}public class Cat extends Animal {    @Override    public void move() {        System.out.println(&quot;cat climb&quot;);    }}public calss Dog entends Animal {    @Override    public void move() {        System.out.println(&quot;dog run&quot;);    }}public static void main(String [] args) {    Animal animal = new Cat();    animal.move();    // output: cat climb}</code></pre><p>通过这种方式可以实现接口与实现的解耦。</p><h1 id="3-多态和继承的关系"><a href="#3-多态和继承的关系" class="headerlink" title="3. 多态和继承的关系"></a>3. 多态和继承的关系</h1><p>继承指在子类当中使用父类的数据和方法</p><p>多态指在子类当中改变父类的行为。</p><h1 id="4-构造器内部的多态方法的行为"><a href="#4-构造器内部的多态方法的行为" class="headerlink" title="4. 构造器内部的多态方法的行为"></a>4. 构造器内部的多态方法的行为</h1><p>如果在一个构造器的内部调用正在构造的对象的某个动态绑定的方法，会出现一些不可知的错误。</p><p>因为构造器内部的动态绑定意味着要用到方法被覆盖以后的定义，而这意味着被覆盖的方法在对象被完全构造之前就会被调用了，</p><pre><code>class Graph {    void draw() {        print(&quot;Graph draw()&quot;);    }    Graph() {        print(&quot;Graph() before draw()&quot;);        draw();        print(&quot;Graph() after draw()&quot;);    }}class RoundGraph extends Graph {    private int radius = 1;    RoundGraph(int r) {        radius = r;        print(&quot;RoundGraph.RoundGraph(), radius = &quot; + radius);    }    void draw() {        print(&quot;RoundGraph.draw(), radius = &quot; + radius);    }}public class PolyConstructors {    public static void main(String[] args) {        new RoundGraph(5);    }}// All output Graph() before draw()RoundGraph.draw(), radius = 0Graph() after draw()ROundGraph,RoundGraph(), radius = 5</code></pre><p>有这样的输出的原因是当我们实例化R欧尼的Graph的时候，会调用基类的构造器，在Graph类的构造器当中调用了draw()方法，这个时候动态绑定，是要去调用RoundGraph类的draw方法的，但是这个时候还在构建Graph 的实例，RoundGraph还没有构建好，所以就出现了返回的Radius刚开始值为0的问题了</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li>Thinking in Java Ch.8 </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-什么是多态？&quot;&gt;&lt;a href=&quot;#1-什么是多态？&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是多态？&quot;&gt;&lt;/a&gt;1. 什么是多态？&lt;/h1&gt;&lt;p&gt;多态目的是为了分离做什么和怎么做，从而实现接口和实现的分离。通过多态，可以改善代码的组织
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
      <category term="Polymorphism" scheme="https://www.llchen60.com/tags/Polymorphism/"/>
    
  </entry>
  
  <entry>
    <title>理解面向对象</title>
    <link href="https://www.llchen60.com/%E7%90%86%E8%A7%A3%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>https://www.llchen60.com/%E7%90%86%E8%A7%A3%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</id>
    <published>2020-02-25T05:20:52.000Z</published>
    <updated>2020-03-04T01:43:08.660Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博文主要想说面向对象的几大特性：封装，抽象，继承，多态，以及我们究竟如何去使用。</p><h1 id="1-面向对象概述"><a href="#1-面向对象概述" class="headerlink" title="1. 面向对象概述"></a>1. 面向对象概述</h1><h2 id="1-1-面向对象编程"><a href="#1-1-面向对象编程" class="headerlink" title="1.1 面向对象编程"></a>1.1 面向对象编程</h2><p>一种编程范式/风格，以类或对象作为组织代码的基本单元，并将封装，抽象，继承，多态四个特性作为代码设计和实现的基石。</p><p>整个编程的过程：</p><ul><li>Object Oriented Analysis</li><li>Object Oriented Design</li><li>Object Oriented Programming </li></ul><h2 id="1-2-面向对象编程的四大特征"><a href="#1-2-面向对象编程的四大特征" class="headerlink" title="1.2 面向对象编程的四大特征"></a>1.2 面向对象编程的四大特征</h2><h3 id="1-2-1-封装-Encapsulation"><a href="#1-2-1-封装-Encapsulation" class="headerlink" title="1.2.1 封装 Encapsulation"></a>1.2.1 封装 Encapsulation</h3><pre><code>public class Wallet {  private String id;  private long createTime;  private BigDecimal balance;  private long balanceLastModifiedTime;  // ...省略其他属性...  public Wallet() {     this.id = IdGenerator.getInstance().generate();     this.createTime = System.currentTimeMillis();     this.balance = BigDecimal.ZERO;     this.balanceLastModifiedTime = System.currentTimeMillis();  }  // 注意：下面对get方法做了代码折叠，是为了减少代码所占文章的篇幅  public String getId() { return this.id; }  public long getCreateTime() { return this.createTime; }  public BigDecimal getBalance() { return this.balance; }  public long getBalanceLastModifiedTime() { return this.balanceLastModifiedTime;  }  public void increaseBalance(BigDecimal increasedAmount) {    if (increasedAmount.compareTo(BigDecimal.ZERO) &lt; 0) {      throw new InvalidAmountException(&quot;...&quot;);    }    this.balance.add(increasedAmount);    this.balanceLastModifiedTime = System.currentTimeMillis();  }  public void decreaseBalance(BigDecimal decreasedAmount) {    if (decreasedAmount.compareTo(BigDecimal.ZERO) &lt; 0) {      throw new InvalidAmountException(&quot;...&quot;);    }    if (decreasedAmount.compareTo(this.balance) &gt; 0) {      throw new InsufficientAmountException(&quot;...&quot;);    }    this.balance.subtract(decreasedAmount);    this.balanceLastModifiedTime = System.currentTimeMillis();  }}</code></pre><p>虚拟钱包，对于自身变量，用private来标注，然后通过对应的getter，setter方法允许外界来访问一部分变量，允许进行一定的修改。</p><p>没有封装则意味着不可控，即任何代码都可以被任何人访问，修改的代码可以遍布在包的任何角落，会影响代码的可读性，以及可维护性。只暴露出有限多的接口，供外界来使用。</p><p>总结： 封装是为了隐藏信息，保护数据</p><h3 id="1-2-2-继承-Inheritance"><a href="#1-2-2-继承-Inheritance" class="headerlink" title="1.2.2 继承 Inheritance"></a>1.2.2 继承 Inheritance</h3><p>用来表述is a的关系，java支持单继承。</p><p>继承最大的好处就是代码复用，比如两个子类的共同代码抽取到父类当中，然后父类来共同使用。</p><p>但是过度使用的话会容易导致层级数量太多，反而降低代码的可读性。</p><h3 id="1-2-3-多态-Polymorphism"><a href="#1-2-3-多态-Polymorphism" class="headerlink" title="1.2.3 多态 Polymorphism"></a>1.2.3 多态 Polymorphism</h3><ul><li>继承加方法重写实现</li></ul><pre><code>public class DynamicArray {  private static final int DEFAULT_CAPACITY = 10;  protected int size = 0;  protected int capacity = DEFAULT_CAPACITY;  protected Integer[] elements = new Integer[DEFAULT_CAPACITY];  public int size() { return this.size; }  public Integer get(int index) { return elements[index];}  //...省略n多方法...  public void add(Integer e) {    ensureCapacity();    elements[size++] = e;  }  protected void ensureCapacity() {    //...如果数组满了就扩容...代码省略...  }}public class SortedDynamicArray extends DynamicArray {  @Override  public void add(Integer e) {    ensureCapacity();    int i;    for (i = size-1; i&gt;=0; --i) { //保证数组中的数据有序      if (elements[i] &gt; e) {        elements[i+1] = elements[i];      } else {        break;      }    }    elements[i+1] = e;    ++size;  }}public class Example {  public static void test(DynamicArray dynamicArray) {    dynamicArray.add(5);    dynamicArray.add(1);    dynamicArray.add(3);    for (int i = 0; i &lt; dynamicArray.size(); ++i) {      System.out.println(dynamicArray.get(i));    }  }  public static void main(String args[]) {    DynamicArray dynamicArray = new SortedDynamicArray();    test(dynamicArray); // 打印结果：1、3、5  }}</code></pre><ul><li>利用接口类实现多态特性</li></ul><pre><code>public interface Iterator {  String hasNext();  String next();  String remove();}public class Array implements Iterator {  private String[] data;  public String hasNext() { ... }  public String next() { ... }  public String remove() { ... }  //...省略其他方法...}public class LinkedList implements Iterator {  private LinkedListNode head;  public String hasNext() { ... }  public String next() { ... }  public String remove() { ... }  //...省略其他方法... }public class Demo {  private static void print(Iterator iterator) {    while (iterator.hasNext()) {      System.out.println(iterator.next());    }  }  public static void main(String[] args) {    Iterator arrayIterator = new Array();    print(arrayIterator);    Iterator linkedListIterator = new LinkedList();    print(linkedListIterator);  }}</code></pre><p>多态可以很大程度上提高代码的可扩展性和复用性</p><h3 id="1-2-4-抽象-Abstraction"><a href="#1-2-4-抽象-Abstraction" class="headerlink" title="1.2.4 抽象 Abstraction"></a>1.2.4 抽象 Abstraction</h3><p>抽象，主要是为了隐藏方法的具体实现，让调用者只需要关心方法提供了哪些功能，并不需要知道这些方法具体是如何实现的。</p><pre><code>public interface IPictureStorage {  void savePicture(Picture picture);  Image getPicture(String pictureId);  void deletePicture(String pictureId);  void modifyMetaInfo(String pictureId, PictureMetaInfo metaInfo);}public class PictureStorage implements IPictureStorage {  // ...省略其他属性...  @Override  public void savePicture(Picture picture) { ... }  @Override  public Image getPicture(String pictureId) { ... }  @Override  public void deletePicture(String pictureId) { ... }  @Override  public void modifyMetaInfo(String pictureId, PictureMetaInfo metaInfo) { ... }}</code></pre><p>使用接口或者abstract class，然后调用者就只需要知道需要传入什么参数，传出什么参数，就可以试用了。</p><h1 id="2-面向对象-vs-面向过程"><a href="#2-面向对象-vs-面向过程" class="headerlink" title="2. 面向对象 vs 面向过程"></a>2. 面向对象 vs 面向过程</h1><p>需要对这两个概念有更深的理解，很多时候，我们是在用面向对象的语言写面向过程的代码，对于到底什么是面向对象，如何写真的面向对象的代码，我们还是有很多无法确定的地方。</p><p>面向过程的编程是一种编程范式，以过程(方法，函数，操作)作为组织代码的基本单元，以数据(可以理解为成员变量，属性)与方法相分离为最主要的特点。面向过程风格是一种流程化的编程风格，通过拼接一组顺序执行的方法来操作数据完成一项功能。</p><h2 id="2-1-面向对象编程的优势"><a href="#2-1-面向对象编程的优势" class="headerlink" title="2.1 面向对象编程的优势"></a>2.1 面向对象编程的优势</h2><h3 id="2-1-1-更能够应对大规模复杂程序的开发"><a href="#2-1-1-更能够应对大规模复杂程序的开发" class="headerlink" title="2.1.1 更能够应对大规模复杂程序的开发"></a>2.1.1 更能够应对大规模复杂程序的开发</h3><p>因为对于面向过程的编程风格来说，整个程序的处理流程会偏向于线性，流程化，但是实际应用场景中，关系错综复杂，会很难将程序拆解为一组顺序执行的方法。而面向对象的方式就可以比较好的解决这个问题了。</p><h3 id="2-1-2-更易复用，扩展和维护"><a href="#2-1-2-更易复用，扩展和维护" class="headerlink" title="2.1.2 更易复用，扩展和维护"></a>2.1.2 更易复用，扩展和维护</h3><p>面向对象通过类这种组织方式能够将数据和方法绑定在一起，通过访问权限控制，只允许外部调用者通过类暴露的有限方法访问数据，而不会像面向过程编程那样，数据可以被任意方法的随意修改</p><p>我们通过使用多态的特性，可以在需要修改一个功能实现的时候，通过实现一个新的子类的方式，在子类当中重写原来的功能逻辑，用子类替代父类。 —- 对修改关闭，对扩展开放。</p><h2 id="2-2-Warning-Bad-Smell-看似面向对象的面向过程的代码"><a href="#2-2-Warning-Bad-Smell-看似面向对象的面向过程的代码" class="headerlink" title="2.2 Warning/ Bad Smell - 看似面向对象的面向过程的代码"></a>2.2 Warning/ Bad Smell - 看似面向对象的面向过程的代码</h2><p>首先值得注意的是，这里提及的都是我们需要注意的地方，但并不是说我们完全不能这样子写。譬如util class，很多时候我们是需要的，因为确实可以不带数据的，只在input，output传递所有信息就够了。</p><h3 id="2-2-1-getter-setter方法的问题"><a href="#2-2-1-getter-setter方法的问题" class="headerlink" title="2.2.1 getter setter方法的问题"></a>2.2.1 getter setter方法的问题</h3><p>当我们习惯性的给所有的属性都加上getter， setter方法的时候，其实是破坏了Java的封装的特性的，我们使用private 标注属性，再适当的设置setter，getter方法是因为我们不想将对于代码/数据的控制权交给他人，而疯狂的getter，setter方法会让Java的封装优势荡然无存，只是从原来的直接访问属性变成通过getter，setter方法来访问。没有起到任何保障安全的作用。</p><p>注意如果是集合容器的话，要防范集合内部的数据被修改的危险。另外，setter方法的使用需要谨慎些，只有在必需的时候再用。</p><h3 id="2-2-2-全局变量和全局方法"><a href="#2-2-2-全局变量和全局方法" class="headerlink" title="2.2.2 全局变量和全局方法"></a>2.2.2 全局变量和全局方法</h3><p>常见的全局变量有：</p><ul><li>单例类对象</li><li>静态成员变量</li><li>常量</li></ul><p>常见的全局方法有：</p><ul><li>静态方法</li></ul><p>Constants类往往会越加越大，而且会很难维护。而且如果我们开发的其他项目需要复用这些constants，哪怕我们只使用一个，那么最终也会不得不将整个文件加载进去，没有必要，而且会变得非常的慢。我们可以将Constants类拆分为功能更加单一的多个类，或者直接将这些常量定义到对应的class当中。这也是个很好的选择。</p><h2 id="3-1-什么是接口？-什么是抽象类？"><a href="#3-1-什么是接口？-什么是抽象类？" class="headerlink" title="3.1 什么是接口？ 什么是抽象类？"></a>3.1 什么是接口？ 什么是抽象类？</h2><h3 id="3-1-1-抽象类定义"><a href="#3-1-1-抽象类定义" class="headerlink" title="3.1.1 抽象类定义"></a>3.1.1 抽象类定义</h3><p>下面是一个模板设计的实例，Logger被用来记录日志，FileLogger和MessageQueueLogger继承Logger，分别实现两种不同的日志记录方式</p><pre><code>// 抽象类public abstract class Logger {  private String name;  private boolean enabled;  private Level minPermittedLevel;  public Logger(String name, boolean enabled, Level minPermittedLevel) {    this.name = name;    this.enabled = enabled;    this.minPermittedLevel = minPermittedLevel;  }  public void log(Level level, String message) {    boolean loggable = enabled &amp;&amp; (minPermittedLevel.intValue() &lt;= level.intValue());    if (!loggable) return;    doLog(level, message);  }  protected abstract void doLog(Level level, String message);}// 抽象类的子类：输出日志到文件public class FileLogger extends Logger {  private Writer fileWriter;  public FileLogger(String name, boolean enabled,    Level minPermittedLevel, String filepath) {    super(name, enabled, minPermittedLevel);    this.fileWriter = new FileWriter(filepath);   }  @Override  public void doLog(Level level, String mesage) {    // 格式化level和message,输出到日志文件    fileWriter.write(...);  }}// 抽象类的子类: 输出日志到消息中间件(比如kafka)public class MessageQueueLogger extends Logger {  private MessageQueueClient msgQueueClient;  public MessageQueueLogger(String name, boolean enabled,    Level minPermittedLevel, MessageQueueClient msgQueueClient) {    super(name, enabled, minPermittedLevel);    this.msgQueueClient = msgQueueClient;  }  @Override  protected void doLog(Level level, String mesage) {    // 格式化level和message,输出到消息中间件    msgQueueClient.send(...);  }}</code></pre><p>抽象类的特性：</p><ul><li>抽象类不允许被实例化，只能被继承  </li><li>抽象类可以包含属性与方法，方法可以包含代码实现，也可以不包含，设计成抽象方法</li><li>子类继承抽象类，必须实现抽象类当中的所有抽象方法</li></ul><h3 id="3-1-2-接口定义"><a href="#3-1-2-接口定义" class="headerlink" title="3.1.2 接口定义"></a>3.1.2 接口定义</h3><pre><code>// 接口public interface Filter {  void doFilter(RpcRequest req) throws RpcException;}// 接口实现类：鉴权过滤器public class AuthencationFilter implements Filter {  @Override  public void doFilter(RpcRequest req) throws RpcException {    //...鉴权逻辑..  }}// 接口实现类：限流过滤器public class RateLimitFilter implements Filter {  @Override  public void doFilter(RpcRequest req) throws RpcException {    //...限流逻辑...  }}// 过滤器使用demopublic class Application {  // filters.add(new AuthencationFilter());  // filters.add(new RateLimitFilter());  private List&lt;Filter&gt; filters = new ArrayList&lt;&gt;();  public void handleRpcRequest(RpcRequest req) {    try {      for (Filter filter : fitlers) {        filter.doFilter(req);      }    } catch(RpcException e) {      // ...处理过滤结果...    }    // ...省略其他处理逻辑...  }}</code></pre><p>使用interface关键字实现一个Filter接口，AuthencationFilter和RatelimiterFilter分别实现对于RPC请求的鉴权和限流的过滤功能。</p><ul><li>接口不能包含属性</li><li>接口只能声明方法，方法不能包含代码实现</li><li>类实现接口的时候，必须实现接口当中声明的所有方法</li></ul><p>抽象类和继承类似，其实表征的是一种is-a的关系；而接口表征的是一种has-a的关系/ 协议，表示具有某些功能 </p><h2 id="3-2-区别-都能解决什么样的编程问题？"><a href="#3-2-区别-都能解决什么样的编程问题？" class="headerlink" title="3.2 区别/ 都能解决什么样的编程问题？"></a>3.2 区别/ 都能解决什么样的编程问题？</h2><h3 id="3-2-1-抽象类-存在的意义"><a href="#3-2-1-抽象类-存在的意义" class="headerlink" title="3.2.1 抽象类 存在的意义"></a>3.2.1 抽象类 存在的意义</h3><p>抽象类不能实例化，只能被继承。主要是用来解决代码复用的问题的。多个子类可以继承抽象类当中定义的属性和方法，避免在子类当中，重复编写相同的代码。</p><p>为什么必须是抽象类来做代码复用呢？ </p><ul><li>因为可以利用多态来做了</li><li>减少父类代码被错误的直接使用的风险</li><li>也可以增加代码的可读性</li></ul><h3 id="3-2-2-接口的存在意义"><a href="#3-2-2-接口的存在意义" class="headerlink" title="3.2.2 接口的存在意义"></a>3.2.2 接口的存在意义</h3><p>接口更侧重于解耦，接口是对行为的一种抽象，相当于一组协议或者契约。这样调用者只需要关注抽象的接口，不需要了解具体的实现</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://github.com/gdhucoder/Algorithms4/blob/master/designpattern/pic/umlcheatsheet.jpg" target="_blank" rel="noopener">https://github.com/gdhucoder/Algorithms4/blob/master/designpattern/pic/umlcheatsheet.jpg</a> </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这篇博文主要想说面向对象的几大特性：封装，抽象，继承，多态，以及我们究竟如何去使用。&lt;/p&gt;
&lt;h1 id=&quot;1-面向对象概述&quot;&gt;&lt;a href=&quot;#1-面向对象概述&quot; class=&quot;headerlink&quot; title=&quot;1. 面向对象概述&quot;&gt;&lt;/a&gt;1. 面向对象概述&lt;/
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="OOP" scheme="https://www.llchen60.com/tags/OOP/"/>
    
  </entry>
  
</feed>
