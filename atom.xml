<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Leilei&#39;s Blog | 磊磊的博客</title>
  
  <subtitle>Because it&#39;s there</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.llchen60.com/"/>
  <updated>2020-04-23T23:33:13.740Z</updated>
  <id>https://www.llchen60.com/</id>
  
  <author>
    <name>Leilei Chen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript Dependency Hell - 对于JS依赖树的分析</title>
    <link href="https://www.llchen60.com/JavaScript-Dependency-Hell-%E5%AF%B9%E4%BA%8EJS%E4%BE%9D%E8%B5%96%E6%A0%91%E7%9A%84%E5%88%86%E6%9E%90/"/>
    <id>https://www.llchen60.com/JavaScript-Dependency-Hell-%E5%AF%B9%E4%BA%8EJS%E4%BE%9D%E8%B5%96%E6%A0%91%E7%9A%84%E5%88%86%E6%9E%90/</id>
    <published>2020-04-23T23:32:31.000Z</published>
    <updated>2020-04-23T23:33:13.740Z</updated>
    
    <content type="html"><![CDATA[<p>做前端开发的同学肯定都对npm很熟悉，node package manager，一个非常受欢迎的包管理器。npm通过<code>package.json</code>来对项目当中的包进行管理，在这个json文件当中的包相当于就被npm注册了。</p><h1 id="1-什么是package-json"><a href="#1-什么是package-json" class="headerlink" title="1. 什么是package.json?"></a>1. 什么是package.json?</h1><ul><li><p>其定义了你的项目所依赖的所有包</p></li><li><p>并指定你的项目所用的包的版本号</p></li><li><p>让你的build是可以复制的，方便其他开发者来使用</p><h1 id="2-Package-json-中的依赖种类"><a href="#2-Package-json-中的依赖种类" class="headerlink" title="2. Package.json 中的依赖种类"></a>2. Package.json 中的依赖种类</h1></li><li><p>dependencies </p><ul><li>这里定义了你的代码所需要的关键依赖</li></ul></li><li><p>devDependencies </p><ul><li>这里定义了你的开发所使用的的依赖，比如给代码样式的perttier 库</li></ul></li><li><p>peerDependencies </p><ul><li>这里是告诉其他开发者，当使用了你的这个包以后，他们需要定义在这里的包的特定版本</li></ul></li><li><p>optionalDependencies </p><ul><li>可选的依赖，不安装他们不会毁坏安装的过程</li></ul></li><li><p>bundledDependencies </p><ul><li>这里包含的是一个列表的包，他们会被打包到一起来引入到你的项目当中。这个在你的依赖包不在npm当中的情况下是很有用的。    <h1 id="3-使用package-lock-json的目的"><a href="#3-使用package-lock-json的目的" class="headerlink" title="3. 使用package-lock.json的目的"></a>3. 使用package-lock.json的目的</h1>package-lock的使用目的，我们在前面的博文当中有详细的描述过 – <a href="https://llchen60.com/%E5%85%B3%E4%BA%8Epackage-lock-json/" target="_blank" rel="noopener">相关博文</a>。总的来说，有packge-lock.json 能够给我们更大的自由度，将commit的回退和依赖的回退分隔开，即我可以使用过去的依赖树运行当前的代码，这在没有lock json的时候是很难实现的。</li></ul></li></ul><h1 id="4-依赖树的例子与简化"><a href="#4-依赖树的例子与简化" class="headerlink" title="4. 依赖树的例子与简化"></a>4. 依赖树的例子与简化</h1><pre><code>// 以gatsby为例, know the size of your node_modules overall du -sh node_modules// list the size decending $ du -sh ./node_modules/* | sort -nr | grep &#39;\dM.*&#39; 17M    ./node_modules/rxjs8.4M    ./node_modules/@types7.4M    ./node_modules/core-js6.8M    ./node_modules/@babel5.4M    ./node_modules/gatsby5.2M    ./node_modules/eslint4.8M    ./node_modules/lodash3.6M    ./node_modules/graphql-compose3.6M    ./node_modules/@typescript-eslint3.5M    ./node_modules/webpack3.4M    ./node_modules/moment3.3M    ./node_modules/webpack-dev-server3.2M    ./node_modules/caniuse-lite3.1M    ./node_modules/graphql</code></pre><p>…</p><pre><code>// !!! moved unused modules and dependenciesnpm dedup </code></pre><p>解耦操作的运行机理，就是寻找不同依赖之间的公有的包，然后复用这些共有的包。</p><p>对于可视化，用一些现成的工具可以被用来观察整个包的依赖状态，譬如：</p><ul><li><a href="https://npm.anvaka.com/#/" target="_blank" rel="noopener">https://npm.anvaka.com/#/</a></li><li><a href="http://npm.broofa.com/" target="_blank" rel="noopener">http://npm.broofa.com/</a></li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://blog.appsignal.com/2020/04/09/ride-down-the-javascript-dependency-hell.html" target="_blank" rel="noopener">https://blog.appsignal.com/2020/04/09/ride-down-the-javascript-dependency-hell.html</a> </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;做前端开发的同学肯定都对npm很熟悉，node package manager，一个非常受欢迎的包管理器。npm通过&lt;code&gt;package.json&lt;/code&gt;来对项目当中的包进行管理，在这个json文件当中的包相当于就被npm注册了。&lt;/p&gt;
&lt;h1 id=&quot;1-什
      
    
    </summary>
    
    
      <category term="FrontEnd" scheme="https://www.llchen60.com/categories/FrontEnd/"/>
    
    
      <category term="JaveScript" scheme="https://www.llchen60.com/tags/JaveScript/"/>
    
      <category term="JS Dependency" scheme="https://www.llchen60.com/tags/JS-Dependency/"/>
    
  </entry>
  
  <entry>
    <title>Typescript学习笔记(二)</title>
    <link href="https://www.llchen60.com/Typescript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/"/>
    <id>https://www.llchen60.com/Typescript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/</id>
    <published>2020-04-21T03:25:57.000Z</published>
    <updated>2020-04-21T03:26:33.088Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>类型别名</p><ul><li>用来为一个类型起一个新名字</li></ul></li></ul><pre><code>type Name = string; </code></pre><ul><li>字符串字面量类型</li></ul><pre><code>type EventNames = &#39;click&#39; | &#39;scroll&#39; | &#39;mousemove&#39;;function handleEvent(ele: Element, event: EventNames) {    // do something}handleEvent(document.getElementById(&#39;hello&#39;), &#39;scroll&#39;);  // 没问题handleEvent(document.getElementById(&#39;world&#39;), &#39;dbclick&#39;); // 报错，event 不能为 &#39;dbclick&#39;// index.ts(7,47): error TS2345: Argument of type &#39;&quot;dbclick&quot;&#39; is not assignable to parameter of type &#39;EventNames&#39;.</code></pre><ul><li>元组  - Tuple<ul><li>Tuple可以用于合并不同类型的对象</li></ul></li></ul><pre><code>let tom: [string, number] = [&#39;Tom&#39;, 25];</code></pre><ul><li>枚举<ul><li>用于取值被限定在一定范围内的场景</li><li>使用enum进行定义的</li><li>枚举成员会被赋值为从0开始递增的数字，同时也会对枚举值到枚举名进行反向映射</li></ul></li></ul><pre><code>enum Days {Sun, Mon, Tue, Wed, Thu, Fri, Sat};console.log(Days[&quot;Sun&quot;] === 0); // trueconsole.log(Days[&quot;Mon&quot;] === 1); // trueconsole.log(Days[&quot;Tue&quot;] === 2); // trueconsole.log(Days[&quot;Sat&quot;] === 6); // trueconsole.log(Days[0] === &quot;Sun&quot;); // trueconsole.log(Days[1] === &quot;Mon&quot;); // trueconsole.log(Days[2] === &quot;Tue&quot;); // trueconsole.log(Days[6] === &quot;Sat&quot;); // true</code></pre><ul><li>类，类与接口<ul><li>使用class定义类，使用constructor定义构造函数，通过new生成新实例的时候，是会自动调用构造函数的</li></ul></li></ul><pre><code>class Animal {    constructor(name) {        this.name = name;    }    sayHi() {        return `My name is ${this.name}`;    }}let a = new Animal(&#39;Jack&#39;);console.log(a.sayHi()); // My name is Jack</code></pre><ul><li><p>类通过extends继承</p><ul><li><p>然后通过super关键词来调用父类的构造函数和方法</p><p>class Cat extends Animal {<br>  constructor(name) {</p><pre><code>  super(name); // 调用父类的 constructor(name)  console.log(this.name);</code></pre><p>  }<br>  sayHi() {</p><pre><code>  return &#39;Meow, &#39; + super.sayHi(); // 调用父类的 sayHi()</code></pre><p>  }<br>}</p><p>let c = new Cat(‘Tom’); // Tom<br>console.log(c.sayHi()); // Meow, My name is Tom</p></li></ul></li><li><p>泛型</p><p>  function createArray<T>(length: number, value: T): Array<T> {</p><pre><code>  let result: T[] = [];  for (let i = 0; i &lt; length; i++) {      result[i] = value;  }  return result;</code></pre><p>  }</p><p>  createArray(3, ‘x’); // [‘x’, ‘x’, ‘x’]</p></li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://ts.xcatliu.com/advanced/type-aliases" target="_blank" rel="noopener">https://ts.xcatliu.com/advanced/type-aliases</a> </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;类型别名&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用来为一个类型起一个新名字&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;type Name = string; &lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;字符串字面量类型&lt;/li&gt;
&lt;/ul&gt;

      
    
    </summary>
    
    
      <category term="FrontEnd" scheme="https://www.llchen60.com/categories/FrontEnd/"/>
    
    
      <category term="TypeScript" scheme="https://www.llchen60.com/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript笔记(一)</title>
    <link href="https://www.llchen60.com/TypeScript%E7%AC%94%E8%AE%B0-0/"/>
    <id>https://www.llchen60.com/TypeScript%E7%AC%94%E8%AE%B0-0/</id>
    <published>2020-04-19T17:44:45.000Z</published>
    <updated>2020-04-21T03:26:13.703Z</updated>
    
    <content type="html"><![CDATA[<p>Tl;dr </p><p>这会是一篇很长的博文，大部分内容都直接来自Reference当中的TypeScript教程和ES6教程，只是为了总结一些自己认为重要的知识点，以及一些认为需要深入理解的地方及其延伸的链接，希望有帮助。</p><h1 id="1-Intro"><a href="#1-Intro" class="headerlink" title="1. Intro"></a>1. Intro</h1><h2 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h2><ul><li>JavaScript超集，提供了类型系统和对ES6的支持，由Microsoft开发</li></ul><h2 id="1-2-优势"><a href="#1-2-优势" class="headerlink" title="1.2 优势"></a>1.2 优势</h2><ul><li>增加代码的可读性和可维护性<ul><li>类型系统是很好的文档，看类型的定义我们就能够知道如何使用了</li><li>可以在编译阶段发现大部分错误，比运行时出错好很多</li><li>增强编辑器的功能，包括代码补全，接口提示，跳转到定义，重构等</li></ul></li><li>兼容性好<ul><li>js文件实际上是可以直接重命名为ts文件的</li><li>及时不显式定义类型，也能够自动做出类型推论  </li></ul></li></ul><h2 id="1-3-相对劣势"><a href="#1-3-相对劣势" class="headerlink" title="1.3 相对劣势"></a>1.3 相对劣势</h2><ul><li>学习成本 <ul><li>接口 </li><li>泛型</li><li>类</li></ul></li><li>短期增加开发成本，要多写一些类型的定义，但是对于需要长期维护的项目，TypeScript能够减少其维护成本</li><li>集成到构建流程当中需要一些工作量的 </li></ul><h1 id="2-基础知识"><a href="#2-基础知识" class="headerlink" title="2. 基础知识"></a>2. 基础知识</h1><h2 id="2-1-原始数据类型"><a href="#2-1-原始数据类型" class="headerlink" title="2.1 原始数据类型"></a>2.1 原始数据类型</h2><ul><li><p>布尔值 - boolean</p><pre><code>  let isSuccessful: boolean = true;  let createdByNewBoolean: boolean = new Boolean(1);  // Type &#39;Boolean&#39; is not assignable to type &#39;boolean&#39;.  // &#39;boolean&#39; is a primitive, but &#39;Boolean&#39; is a wrapper object. Prefer using &#39;boolean&#39; when possible.  let createdByNewBoolean: Boolean = new Boolean(1);  // when you new Boolean, it will create a Boolean - a wrapper object  let createdByBoolean: boolean = Boolean(1);   // create a boolean </code></pre></li></ul><ul><li><p>数值 - number</p><pre><code>  let decLiteral: number = 6;</code></pre></li><li><p>字符串 - string</p></li></ul><pre><code>    let myName: string = &#39;Tom&#39;;    let myAge: number = 25;    // 模板字符串  `用来定义模板字符串，${}用来在模板字符串中嵌入表达式    let sentence: string = `Hello, my name is ${myName}.    I&#39;ll be ${myAge + 1} years old next month.`;</code></pre><ul><li>null &amp; undefined<ul><li>null 和 undefined是所有类型的子类型</li><li>void类型的变量不能赋值给number类型的变量</li></ul></li><li>symbol</li></ul><h2 id="2-2-任意值-Any"><a href="#2-2-任意值-Any" class="headerlink" title="2.2 任意值 - Any"></a>2.2 任意值 - Any</h2><p>任意值用来表示允许赋值为任意类型。在Typescript当中，普通类型在复制过程中改变类型是不被允许的，但是如果是any类型，则允许被赋值为任意类型。</p><pre><code>    let myFavoriteNumber: any = &#39;seven&#39;;    myFavoriteNumber = 7;</code></pre><ul><li>任意值上访问任何属性都是允许的，也允许调用任何方法</li><li>返回的类型都是任意值</li><li>对于未声明类型的变量<ul><li>未指定类型，那么会被识别为任意值类型</li></ul></li></ul><h2 id="2-3-类型推论"><a href="#2-3-类型推论" class="headerlink" title="2.3 类型推论"></a>2.3 类型推论</h2><p>如果没有明确的指定类型，那么TypeScript会按照类型推论 - Type Inference的规则推断出一个类型。</p><pre><code>let myFavoriteNumber = &#39;seven&#39;;myFavoriteNumber = 7;// index.ts(2,1): error TS2322: Type &#39;number&#39; is not assignable to type &#39;string&#39;.  编译的时候出错，因为TS自动做了类型推论，并且认定其为一个string类型</code></pre><p>但是如果定义的时候没有赋值，那么不管接下来是否会赋值，都会被推断成any类型而完全不被类型检查</p><pre><code>let myFavoriteNumber;myFavoriteNumber = &#39;seven&#39;;myFavoriteNumber = 7;</code></pre><h2 id="2-4-联合类型-Union-Types"><a href="#2-4-联合类型-Union-Types" class="headerlink" title="2.4 联合类型 - Union Types"></a>2.4 联合类型 - Union Types</h2><pre><code>let myFavoriteNumber: string | number;myFavoriteNumber = &#39;seven&#39;;myFavoriteNumber = 7;</code></pre><p>联合类型当中使用 <code>|</code>来分割每个类型</p><h2 id="2-5-接口"><a href="#2-5-接口" class="headerlink" title="2.5 接口"></a>2.5 接口</h2><ul><li><p>在TypeScript当中，使用接口定义对象的类型，除了可以对类的一部分行为进行抽象以外，也chang’yo个与对 对象的形状进行描述。</p><p>  interface Person {</p><pre><code>  name: string;  age: number;</code></pre><p>  }</p><p>  let tom: Person = {</p><pre><code>  name: &#39;Tom&#39;,  age: 25</code></pre><p>  };</p></li></ul><p>在做赋值的时候，定义的变量需要和接口有一样的属性。</p><ul><li><p>对于我们想要可选择的匹配的属性，我们可以用可选属性的方式：</p><p>  interface Person {</p><pre><code>  name: string;  age?: number;</code></pre><p>  }</p><p>  let tom: Person = {</p><pre><code>  name: &#39;Tom&#39;</code></pre><p>  };</p></li><li><p>也可以配置，是的接口能够接任意的属性： – <code>[propName: string] : any</code></p><ul><li><p>需要注意的是一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集 </p><p>interface Person {<br>  name: string;<br>  age?: number;<br>  [propName: string]: any;<br>}</p><p>let tom: Person = {<br>  name: ‘Tom’,<br>  gender: ‘male’<br>};</p></li></ul></li><li><p>只读属性</p><ul><li>有use case我们希望对象当中的一些字段只能在创建的时候被赋值，那么就可以通过使用readonly定义只读属性</li></ul></li></ul><h2 id="2-6-数组类型"><a href="#2-6-数组类型" class="headerlink" title="2.6 数组类型"></a>2.6 数组类型</h2><ul><li>使用类型+方括号来定义</li></ul><pre><code>let fibonacci: number[] = [1, 1, 2, 3, 5];</code></pre><ul><li>使用数组泛型来表示数组 – <code>Array&lt;elemType&gt;</code></li></ul><pre><code>let fibonacci: Array&lt;number&gt; = [1, 1, 2, 3, 5];</code></pre><ul><li>使用接口表示数组</li></ul><pre><code>interface NumberArray {    [index: number]: number;}let fibonacci: NumberArray = [1, 1, 2, 3, 5];</code></pre><h2 id="2-7-函数类型"><a href="#2-7-函数类型" class="headerlink" title="2.7 函数类型"></a>2.7 函数类型</h2><h3 id="2-7-1-函数声明"><a href="#2-7-1-函数声明" class="headerlink" title="2.7.1 函数声明"></a>2.7.1 函数声明</h3><pre><code>// 函数声明（Function Declaration）function sum(x, y) {    return x + y;}// 函数表达式（Function Expression）let mySum = function (x, y) {    return x + y;};// TypeScript下的函数声明function sum(x: number, y:number):number {    return x + y;}</code></pre><h3 id="2-7-2-函数表达式"><a href="#2-7-2-函数表达式" class="headerlink" title="2.7.2 函数表达式"></a>2.7.2 函数表达式</h3><pre><code>let mySum: (x: number, y: number) =&gt; number = function (x: number, y: number): number {    return x + y;};</code></pre><p>注意在上述代码当中，跟在mySum后面的是对于输入参数和输出参数的规定，中间用箭头来进行连接，这是TypeScript的规范。</p><p>另外我们也可以通过使用接口来定义函数的形状：</p><pre><code>interface SearchFunc {    (source: string, subString: string): boolean;}let mySearch: SearchFunc;mySearch = function(source: string, subString: string) {    return source.search(subString) !== -1;}</code></pre><h3 id="2-7-3-可选参数"><a href="#2-7-3-可选参数" class="headerlink" title="2.7.3 可选参数"></a>2.7.3 可选参数</h3><ul><li>使用问号跟在参数名字之后表示是可选的，注意可选参数需要在参数列表的末尾，其之后不能有必需参数了</li></ul><pre><code>function buildName(firstName: string, lastName?: string) {    if (lastName) {        return firstName + &#39; &#39; + lastName;    } else {        return firstName;    }}</code></pre><h3 id="2-7-4-参数默认与剩余参数"><a href="#2-7-4-参数默认与剩余参数" class="headerlink" title="2.7.4 参数默认与剩余参数"></a>2.7.4 参数默认与剩余参数</h3><pre><code>// 默认参数function buildName(firstName: string, lastName: string = &#39;Cat&#39;) {    return firstName + &#39; &#39; + lastName;}let tomcat = buildName(&#39;Tom&#39;, &#39;Cat&#39;);let tom = buildName(&#39;Tom&#39;);// 使用 ...来获取函数当中的剩余参数function push(array, ...items) {    items.forEach(function(item) {        array.push(item);    });}let a: any[] = [];push(a, 1, 2, 3);</code></pre><h2 id="2-8-声明文件"><a href="#2-8-声明文件" class="headerlink" title="2.8 声明文件"></a>2.8 声明文件</h2><p>当使用第三方库的时候，我们需要引用它的声明文件，以获得对应的代码补全，接口提示的功能</p><h3 id="2-8-1-声明语句"><a href="#2-8-1-声明语句" class="headerlink" title="2.8.1 声明语句"></a>2.8.1 声明语句</h3><p>比如我们想使用jquery，一般来说是加script标签，但是ts当中，我们需要使用declare var来定义其类型</p><pre><code>declare var jQuery: (selector: string) =&gt; any;jQuery(&#39;#foo&#39;);</code></pre><p>我们会将声明语句放到一个单独的文件当中，譬如对于上述的例子，就是放到jQuery.d.ts 当中<br>声明文件必须以<code>.d.ts</code>来结尾</p><p>ts会解析项目当中所有的*.ts文件，也包含了.d.ts结尾的文件，所以当我们定义.d.ts文件以后，里面的内容是会被整个项目共享的。</p><p>另外，我们可以通过@types 来统一管理第三方库的声明文件</p><h3 id="2-8-2-书写声明文件"><a href="#2-8-2-书写声明文件" class="headerlink" title="2.8.2 书写声明文件"></a>2.8.2 书写声明文件</h3><p>当第三方库没有提供声明文件的时候，我们就需要自己书写声明文件了。</p><p>库的使用场景主要有：</p><ul><li>全局变量 </li><li>npm包</li><li>UMD库</li><li>直接扩展全局变量</li></ul><p>详情看 <a href="https://ts.xcatliu.com/basics/declaration-files#xin-yu-fa-suo-yin" target="_blank" rel="noopener">link</a></p><h1 id="2-9-内置对象"><a href="#2-9-内置对象" class="headerlink" title="2.9 内置对象"></a>2.9 内置对象</h1><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects" target="_blank" rel="noopener">ECMAScript 内置对象</a></p><p><a href="https://github.com/Microsoft/TypeScript/tree/master/src/lib" target="_blank" rel="noopener">DOM DOM 内置对象</a></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://ts.xcatliu.com/" target="_blank" rel="noopener">https://ts.xcatliu.com/</a></li><li><a href="https://es6.ruanyifeng.com/" target="_blank" rel="noopener">https://es6.ruanyifeng.com/</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Tl;dr &lt;/p&gt;
&lt;p&gt;这会是一篇很长的博文，大部分内容都直接来自Reference当中的TypeScript教程和ES6教程，只是为了总结一些自己认为重要的知识点，以及一些认为需要深入理解的地方及其延伸的链接，希望有帮助。&lt;/p&gt;
&lt;h1 id=&quot;1-Intro&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="FrontEnd" scheme="https://www.llchen60.com/categories/FrontEnd/"/>
    
    
      <category term="TypeScript" scheme="https://www.llchen60.com/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>关于package-lock.json</title>
    <link href="https://www.llchen60.com/%E5%85%B3%E4%BA%8Epackage-lock-json/"/>
    <id>https://www.llchen60.com/%E5%85%B3%E4%BA%8Epackage-lock-json/</id>
    <published>2020-04-18T01:10:23.000Z</published>
    <updated>2020-04-18T01:11:57.173Z</updated>
    
    <content type="html"><![CDATA[<p>当我们将node package manager (npm) 升级到5.0以上的版本的时候，你会发现npm运行的时候会自动创建一个新文件 – package-lock.json。</p><p>里面包含的是我们的依赖关系，各种依赖的包和版本号。package-lock.json会在npm修改了node_modules 树或者修改了package.json之后自动生成。它精确的描述了整个生成的树，使得接下来任何一次的装配都可以生成完全一致的依赖树.这个生成的文件是需要commit 到remote branch上的，其目的在于：</p><ul><li>描述单个依赖树，使得其他人在做deploy的时候使用的是完全一致的依赖</li><li>使得使用人员有能力直接跳转回原先的依赖状态，而不需要将代码也回退到之前的版本</li><li>加强了依赖改变的阅读性，我们可以相对直观的看到每次的commit都有什么依赖被改变了</li><li>也可以通过是的npm跳过对于原先安装过的包的重复的元数据分析来优化整个安装的进程</li></ul><p>针对其特征，我们是应该将package-lock.json也提交上去的，这会给开发，同步带来不小的帮助。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://medium.com/coinmonks/everything-you-wanted-to-know-about-package-lock-json-b81911aa8ab8" target="_blank" rel="noopener">https://medium.com/coinmonks/everything-you-wanted-to-know-about-package-lock-json-b81911aa8ab8</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当我们将node package manager (npm) 升级到5.0以上的版本的时候，你会发现npm运行的时候会自动创建一个新文件 – package-lock.json。&lt;/p&gt;
&lt;p&gt;里面包含的是我们的依赖关系，各种依赖的包和版本号。package-lock.js
      
    
    </summary>
    
    
      <category term="FrontEnd" scheme="https://www.llchen60.com/categories/FrontEnd/"/>
    
    
      <category term="npm" scheme="https://www.llchen60.com/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>中台(二) - 略深入些的探究</title>
    <link href="https://www.llchen60.com/%E4%B8%AD%E5%8F%B0-%E4%BA%8C-%E7%95%A5%E6%B7%B1%E5%85%A5%E4%BA%9B%E7%9A%84%E6%8E%A2%E7%A9%B6/"/>
    <id>https://www.llchen60.com/%E4%B8%AD%E5%8F%B0-%E4%BA%8C-%E7%95%A5%E6%B7%B1%E5%85%A5%E4%BA%9B%E7%9A%84%E6%8E%A2%E7%A9%B6/</id>
    <published>2020-04-16T00:38:41.000Z</published>
    <updated>2020-04-16T00:39:21.588Z</updated>
    
    <content type="html"><![CDATA[<p>中台是企业级能力复用平台，整个中台的构建，实际上是将业务数据化，将数据业务化。是需要建立业务中台和数据中台的。业务中台通过抽象，封装可复用的逻辑，提升企业的响应力；数据中台通过打通企业的数据，构建自学习服务的数据能力，让企业更加智慧。</p><h1 id="1-通用化通用能力"><a href="#1-通用化通用能力" class="headerlink" title="1. 通用化通用能力"></a>1. 通用化通用能力</h1><p>目前大部分企业实现的中台，主要是将遗留下的后台系统，比如ERP MES CRM的公共部分进行拆解复用，形成类似交易中心，用户中心，订单中心这样的微服务集合供前台调用，从而保证<strong>逻辑的一致性</strong>同时更快响应前台的变化</p><p>Reference <a href="https://www.infoq.cn/article/wCZV6X5uujxDXFP0Eub9?utm_source=rss&utm_medium=article" target="_blank" rel="noopener">1</a> 当中举了订单服务的演进过程的例子，很值得一看。当平台需要开放多渠道来完成订单的时候，保证用户有着类似的体验是很重要的一项，包括整个系统的的scalability。</p><p>在这种情况下，一个数据中台能够使得用户可以看到在各个平台各个渠道自己下的订单。从平台角度来说，有了数据中台，维护成本，发生错误以后的修改成本都会减轻很多。</p><p>略微解释下，如果是分开的系统，那么每个系统都会有自己的数据库，我们需要做数据的join操作，然后返回给前端用户需要的正确的信息。当发生了逻辑上的错误以后，我们很有可能需要在分开的几个子系统当中来做修改，很容易出错，修改的整个时间消耗也会很长。而且数据仓库在多个系统的情况下，抽取数据，再进行分析是有比较大的时延的，一般都是加一天的样子，无法看到实时的数据。</p><h1 id="2-使用中台去ERP化"><a href="#2-使用中台去ERP化" class="headerlink" title="2. 使用中台去ERP化"></a>2. 使用中台去ERP化</h1><p>ERP， 即企业资源管理系统。最最开始的时候，企业的需求是将企业的流程梳理清晰，做到资源的集约化管理，本质上来讲是为了解决流程复用，业务能力化的问题。</p><p>但是当前ERP软件存在着如下的一些问题：</p><ol><li>商业软件，响应慢<br>企业只有使用权，这就导致企业的业务发生变化的时候，需要找到原厂重新配置或者重新开发，响应比较慢</li><li>封闭架构，不开放<br>套装ERP软件是封闭架构，技术不开放，导致企业无法对其进行大的功能上的扩展，只能像打补丁一样，构建一些外挂，而且效果往往不会很好</li><li>单体架构，弹性不够<br>单体架构，很难支持持续增长的各种需求</li><li>升级 维护成本<br>套装软件升级和维护成本非常高</li></ol><p>过去人们需要ERP更多的是因为我们需要流程，需要知道具体应该如何去组织。但是在互联网化的今天，原来静态化，标准化的业务流程已经不足以支撑企业的快速响应了。因此，诉求<strong>从原来的流程化变成了需要能够快速响应前台市场的变化</strong>。</p><p>企业组织结构从流程式协作走向了平台式协作。</p><p>ERP更像是一种计划式的经济，希望每个角色都按照分配的任务来走，共同完成一个任务，但是这种共同完成会导致不同角色之间的利益相互冲突。局部利益大于整体利益。</p><p>需要的转变是 —- 要开始学习以客户为中心去动态组织资源来提供服务，将原本<strong><em>以流程为独立单元的模块拆解为以客户价值为独立单元的模块</em></strong>。</p><p>以客户价值为独立单元，如何评定绩效就是个很关键也很困难的问题，尤其是对于那些为后端赋能的业务单元，如何将其关联到直接的客户价值当中。这需要数据中台提供这方面的能力，来利用全域的数据分析，建模，通过敏感性分析等算法技术来实时计算。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://www.infoq.cn/article/wCZV6X5uujxDXFP0Eub9?utm_source=rss&amp;utm_medium=article" target="_blank" rel="noopener">https://www.infoq.cn/article/wCZV6X5uujxDXFP0Eub9?utm_source=rss&amp;utm_medium=article</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;中台是企业级能力复用平台，整个中台的构建，实际上是将业务数据化，将数据业务化。是需要建立业务中台和数据中台的。业务中台通过抽象，封装可复用的逻辑，提升企业的响应力；数据中台通过打通企业的数据，构建自学习服务的数据能力，让企业更加智慧。&lt;/p&gt;
&lt;h1 id=&quot;1-通用化通用
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="中台" scheme="https://www.llchen60.com/tags/%E4%B8%AD%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>用户画像构建思路</title>
    <link href="https://www.llchen60.com/%E7%94%A8%E6%88%B7%E7%94%BB%E5%83%8F%E6%9E%84%E5%BB%BA%E6%80%9D%E8%B7%AF/"/>
    <id>https://www.llchen60.com/%E7%94%A8%E6%88%B7%E7%94%BB%E5%83%8F%E6%9E%84%E5%BB%BA%E6%80%9D%E8%B7%AF/</id>
    <published>2020-04-14T04:19:03.000Z</published>
    <updated>2020-04-14T04:19:47.832Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a>1. Overview</h1><p>用户画像指的是系统通过用户自己上传的信息以及自己的分析，记录了用户的大量的信息，而后为了便于去给各个系统来使用，将这些信息进行沉淀加工，形成一个标签树的整个过程。</p><p>画像是由标签树及末级标签的标签值构成的，全面定量刻画用户的结构化信息产品。画像是标签的总成，用户标签是具体刻画用户的结构化信息，以下简称标签。</p><p>用户画像对于公司的运营，盈利都有很大的好处：</p><ol><li>可以用于统计，使得对产品，对用户有基本认知</li><li>用于定向营销和精细化运营</li><li>还可以用于算法当中，在搜索推荐，风控广告等策略防线，标签被作为用户特征得以提取和使用</li></ol><h1 id="2-构建标签树"><a href="#2-构建标签树" class="headerlink" title="2. 构建标签树"></a>2. 构建标签树</h1><p>一个好的标签树需要具有高概括性和强延展性，高概括性意味着结构体系能够很好的包含一个用户的<strong>基本属性</strong>和<strong>产品交互的相关行为</strong>，同时对于业务重点单独强调，没有遗漏；“强延展性”意味着结构全面的同时也有一定的抽象概括能力，保证新增的标签可以很好的找到对应的分类，整个体系不会过于收敛局限。</p><p>按照这个原则，画像可以从以下维度进行组织： </p><ul><li><p>基本属性</p><ul><li>指一个用户的基本社会属性和变更频率比较低的特征<ul><li>真实社会年龄</li><li>性别</li><li>婚姻状况</li><li>昵称</li><li>号码</li><li>账号</li><li>lbs </li></ul></li></ul></li><li><p>平台属性</p><ul><li>平台属性是用户在平台上表现出的基本属性特征，是利用用户行为进行算法挖掘，标识用户真实属性的标签</li><li>譬如平台年龄标签  面向例如年龄为20岁，但是心理年龄50岁，穿衣风格50岁的人；反之亦然</li><li>平台属性和基本属性的区别如下：<ul><li>数据源与计算逻辑<ul><li>基础属性是利用用户自行上传的存储在用户基础信息表里的数据，平台属性则利用客户端或者服务端埋点上报采集的用户行为数据进行挖掘计算生成的。</li><li>基本属性是典型的直采型标签，平台属性是典型的算法挖掘型标签</li></ul></li><li>末级标签和输出标签值<ul><li>平台属性代表用户在性别维度上的偏好概率，可以生成类似<code>性别_女_0.80</code>这样的标签，0.8代表了用户的倾向程度</li></ul></li><li>应用场景<ul><li>平台属性通过用户行为进行挖掘，更能代表用户的真实倾向，输出结果比基本属性准确率更高</li></ul></li></ul></li></ul></li><li><p>行为属性</p><ul><li>行为属性记录用户的所有单个点的行为</li><li>包括<ul><li>启动</li><li>登录</li><li>浏览</li><li>点击</li><li>加车</li><li>下单</li></ul></li><li>是可以和不同的产品，不同的模块进行交互的，而且可以在不同的时间窗口进行选取，行为会相对复杂</li><li>按照 产品 x 功能模块 x 用户单点行为 x 时间  这四个要素来进行组织  </li></ul></li><li><p>产品偏好</p><ul><li>对用户使用某些产品，产品核心功能或者其他渠道的偏好程度的刻画，属于挖掘性的标签</li><li>产品可以包括自己公司的，竞品的</li><li>功能渠道包括站内产品功能，包括push、短信、开屏、弹窗等几大运营和产品方式 </li></ul></li><li><p>兴趣偏好</p><ul><li>品牌偏好  nike</li><li>类目偏好  运动</li><li>标签偏好  跑步_0.7</li></ul></li><li><p>敏感度</p><ul><li>营销活动中，会注意到有些用户不需要优惠也会下单，而有些用户一定要通过优惠券刺激才能实现转化，优惠券的额度也会影响用户下单的金额</li><li>需要识别对优惠敏感的用户，发放合理的券额，保证优惠券不浪费，使得整个促销活动的ROI最大</li><li>构建用户的敏感度标签<ul><li>优惠促销敏感度</li><li>活动敏感度</li><li>新品敏感度</li><li>爆款敏感度 </li></ul></li></ul></li><li><p>消费属性</p><ul><li>消费频次</li><li>消费金额</li><li>最近消费时间</li><li>消费能力</li><li>消费意愿 </li></ul></li><li><p>用户生命周期</p><ul><li>新手</li><li>成长</li><li>成熟</li><li>衰退</li><li>流失 </li></ul></li><li><p>用户价值</p><ul><li>活跃度</li><li>裂变拉新等 </li></ul></li></ul><h1 id="3-用户画像的范例"><a href="#3-用户画像的范例" class="headerlink" title="3. 用户画像的范例"></a>3. 用户画像的范例</h1><p><img src="https://i.loli.net/2020/04/14/XnJYc3ejRrMwdul.png" alt="用户画像导图.png"></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://www.infoq.cn/article/oUqJDlfstrYAmTBYzier?utm_source=rss&amp;utm_medium=article" target="_blank" rel="noopener">https://www.infoq.cn/article/oUqJDlfstrYAmTBYzier?utm_source=rss&amp;utm_medium=article</a> </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Overview&quot;&gt;&lt;a href=&quot;#1-Overview&quot; class=&quot;headerlink&quot; title=&quot;1. Overview&quot;&gt;&lt;/a&gt;1. Overview&lt;/h1&gt;&lt;p&gt;用户画像指的是系统通过用户自己上传的信息以及自己的分析，记录了用户的大量
      
    
    </summary>
    
    
      <category term="Notes" scheme="https://www.llchen60.com/categories/Notes/"/>
    
    
      <category term="用户画像" scheme="https://www.llchen60.com/tags/%E7%94%A8%E6%88%B7%E7%94%BB%E5%83%8F/"/>
    
      <category term="运营" scheme="https://www.llchen60.com/tags/%E8%BF%90%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>中台</title>
    <link href="https://www.llchen60.com/%E4%B8%AD%E5%8F%B0/"/>
    <id>https://www.llchen60.com/%E4%B8%AD%E5%8F%B0/</id>
    <published>2020-04-13T00:32:59.000Z</published>
    <updated>2020-04-13T00:34:29.013Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-什么是中台？"><a href="#1-什么是中台？" class="headerlink" title="1. 什么是中台？"></a>1. 什么是中台？</h1><p>看到几篇关于中台的博客，是国内提出的一个新的概念，稍微研究了下，很有意思的概念。</p><p>中台，在我看来，从业务上来讲，可以说是为了解决系统的复用性的问题而出现的。一个简单的例子，阿里刚刚开始的时候只有淘宝，但是后来出现了天猫，二者尽管顶层业务逻辑有不同，但是他们都是需要一套订单，商品，库存，仓储，物流的各种系统的。如果每次我们想做一个新的业务模块的时候，都要来实现这样一套系统，迭代速度会很慢，而且很容易在做改动的时候因为各个类似功能的系统的改动不一致产生错误。</p><p>因此，将这些公用的系统提升，做成–中台，统一来使得各个业务部门重复使用，将需要反复建设的功能和系统进行统一的规划和管理。</p><p>主要解决的问题实质上有两类： </p><ol><li>需要业务需求或者功能需求是高度类似的，通用化程度很高，但是由于没有专门的团队负责规划和开发，大量的系统重复开发、重复建设、导致复用性很低，效率低，研发资源被浪费，用户体验也不够统一</li><li>早起业务发展过程当中，为了解决当下的一些业务问题，垂直的个性化的业务逻辑与基础系统耦合太深，由于没有平台性质的规划，横向系统之间、上下游系统之间的交叉逻辑非常多，导致了在新业务新市场的拓展过程当中，市场没有办法直接复用，甚至没有办法快速迭代。</li></ol><h1 id="2-为什么要中台，为什么要平台化？"><a href="#2-为什么要中台，为什么要平台化？" class="headerlink" title="2. 为什么要中台，为什么要平台化？"></a>2. 为什么要中台，为什么要平台化？</h1><p>引述《白话中台战略》当中的内容，“因为在当今互联网时代，⽤户才是商业战场的中心，为了快速响应用户的需求，借助平台化的力量可以事半功倍”</p><blockquote><p>不断快速响应、探索、挖掘、引领⽤户的需求，才是企业得以⽣存和持续发展的关键因素。</p></blockquote><blockquote><p>那些真正尊重用户，甚⾄不惜调整⾃己颠覆⾃己来响应⽤户的企业将在这场以⽤户为中心的商业战争中得以⽣存和发展；⽽反之，那些在过去的成就上故步⾃封，存在侥幸⼼理希望⽤户会像之前一样继续追随⾃己的企业则会被用户淘汰。很残酷，但这就是这个时代最基本的企业⽣存法则。</p></blockquote><p>平台化能够赋予或加强企业在以用户为中心的现代商业战争当中最为核心的能力 –&gt; 用户响应力。 </p><p>中台，可以说是与前台，后台相对应的。</p><ul><li>前台<ul><li>由各类前台系统组成的前端平台。每个前台系统就是一个用户触点，即企业的最终用户直接使用或者交互的系统，是企业与最终用户的交点。</li></ul></li><li>后台<ul><li>后台系统组成的后端平台，宝具哦企业的核心资源 – 数据 + 计算 <ul><li>财务系统</li><li>产品系统</li><li>客户管理系统</li><li>仓库物流管理系统</li></ul></li></ul></li><li>中台<ul><li>因为企业后台往往不能很好的支撑前台快速创新，响应用户的需求</li><li>前台直接使用后台，会遇到处理复杂，迭代速度缓慢的问题</li><li>前台要处理的是快速响应用户的需求，但是后台拿着整个公司的数据，是需要越稳定越好的，随着公司的发展，按照对速度和稳定的追求的冲突会越来越多</li><li>有了中台以后就可以将前台系统当中的稳定通用业务能力沉降到中台层，恢复前台的响应力</li></ul></li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://www.infoq.cn/article/3tbJZ8aS5pYdWYX5bBfg?utm_source=rss&amp;utm_medium=article" target="_blank" rel="noopener">https://www.infoq.cn/article/3tbJZ8aS5pYdWYX5bBfg?utm_source=rss&amp;utm_medium=article</a></li><li><a href="https://mp.weixin.qq.com/s/yfhaEkO1DG_ihJMhwtkWjA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/yfhaEkO1DG_ihJMhwtkWjA</a></li><li><a href="https://www.infoq.cn/article/hfONAlDdhK3fD9JjduGR" target="_blank" rel="noopener">https://www.infoq.cn/article/hfONAlDdhK3fD9JjduGR</a></li><li><a href="https://www.zhihu.com/question/57717433" target="_blank" rel="noopener">https://www.zhihu.com/question/57717433</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-什么是中台？&quot;&gt;&lt;a href=&quot;#1-什么是中台？&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是中台？&quot;&gt;&lt;/a&gt;1. 什么是中台？&lt;/h1&gt;&lt;p&gt;看到几篇关于中台的博客，是国内提出的一个新的概念，稍微研究了下，很有意思的概念。&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="中台" scheme="https://www.llchen60.com/tags/%E4%B8%AD%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>关于抖音的一些分析</title>
    <link href="https://www.llchen60.com/%E5%85%B3%E4%BA%8E%E6%8A%96%E9%9F%B3%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E6%9E%90/"/>
    <id>https://www.llchen60.com/%E5%85%B3%E4%BA%8E%E6%8A%96%E9%9F%B3%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E6%9E%90/</id>
    <published>2020-04-11T21:29:43.000Z</published>
    <updated>2020-04-11T22:45:17.990Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a>1. Overview</h1><h2 id="1-1-外部环境背景"><a href="#1-1-外部环境背景" class="headerlink" title="1.1 外部环境背景"></a>1.1 外部环境背景</h2><p>短视频是当前超高速发展的赛道，流量持续迅猛增长，越来越多的公司进入这个赛道，头部的国内有抖音快手，主要着眼于1min以内的短视频，主要为UGC(User Generated Content)，少量PGC(Professional Generated Content)产出内容；美国有刚刚成立的quibi，着眼于制作10min左右的优质内容，完全走PGC的路线。</p><p>短视频的兴起是有一些需要的社会以及科技的基础背景的。 </p><ul><li>从经济发展角度<ul><li>经济的持续发展，刺激了人们的休闲娱乐的需求的增长</li></ul></li><li>从用户需求角度<ul><li>需要填补自己的碎片时间</li><li>需要更多的娱乐休闲</li><li>自我表达，自我实现，社会联结的需求</li><li>发泄情绪</li></ul></li><li>从用户使用习惯角度<ul><li>截止2019年6月<ul><li>全国手机网民数量达到8.47亿(根据第44次中国互联网发展状况统计报告)，互联网普及率达到61.2%</li><li>网络购物用户规模6.39亿 </li><li>手机网络购物用户规模6.22亿</li><li>网络视频用户7.59亿</li><li>移动互联网接入流量消费553.9亿GB 同比增长107.3% </li><li>网民平均每周上网时长 27.9小时</li><li>短视频时长占比 11.5%，使用高峰为12点以及21点左右  </li></ul></li></ul></li><li>从技术角度<ul><li>4G 5G兴起，高速网络建设</li><li>手机的广泛普及</li><li>云平台普及，企业架构的相对简化，成本的降低 </li></ul></li><li>政策影响<ul><li>推出《网络短视频平台管理规范》</li><li>推出《网络短视频内容审核标准细则》 </li></ul></li></ul><h2 id="1-2-时间线"><a href="#1-2-时间线" class="headerlink" title="1.2 时间线"></a>1.2 时间线</h2><ul><li>2016年9月上线 <ul><li>A.me 定位为音乐短视频社区 </li><li>年轻人的15秒音乐短视频社区 </li></ul></li><li>2016年11月<ul><li>查找通讯录，邀请QQ 微博好友</li></ul></li><li>2016年11月10日<ul><li>微博话题挑战</li><li>雇佣 召集大学生，舞蹈音乐达人，拍摄视频引流</li></ul></li><li>2016年12月10日<ul><li>抖音 – 音乐视频应用</li></ul></li><li>2016年12月22日<ul><li>推荐热门视频</li><li>捧红一部分人，再带动普通用户的理念 – 偏向于中心化的运营方式出现端倪    </li></ul></li><li>2017年3月<ul><li>邀请岳云鹏等诸多明星加入抖音</li><li>开始有大批用户从明星微博当中看到抖音水印，进入抖音平台</li></ul></li><li>2017年6月开始<ul><li>给视频创作者更多权限<ul><li>对评论的控制，删减</li></ul></li><li>附近 tab，增强社交属性</li><li>抖音故事<ul><li>可以设置只开放24小时，希望普通人可以在上面记录自己的生活</li></ul></li><li>可以绑定微博主页</li></ul></li><li>2017年8月<ul><li>Tik Tok出海</li><li>吴亦凡的抖音挑战</li><li>中国有嘻哈 官方推荐</li><li>抖音开始砸钱到各个节目，增加曝光度了</li></ul></li><li>2017年9月<ul><li>首次线下party，狂欢节</li><li>和汉堡王，摩拜单车等等公司展开合作，联名等</li><li>AR相机</li><li>开启信息流广告，开屏广告的尝试 </li></ul></li><li>2017年10月<ul><li>上线直播功能</li></ul></li><li>2017年11月<ul><li>全新滤镜</li><li>倒计时自动暂停</li><li>直播间优化，增加弹幕功能</li></ul></li><li>2017年12月<ul><li>全新尬舞机功能    </li></ul></li><li>2018年1月<ul><li>百万英雄</li><li>私信功能</li><li>优化举报 评论功能</li></ul></li><li>2018年3月<ul><li>大规模的广告接入和投放开始</li></ul></li><li>2018年8月  <ul><li>直达淘宝功能上线</li><li>反沉迷系统上线        </li><li>增加游戏贴纸</li></ul></li><li>2018年10月<ul><li>个人页背景设置，个性化主页</li></ul></li><li>2018年12月<ul><li>直播粉丝团任务体系</li></ul></li><li>2019年1月<ul><li>地点详情页上传视频图片，用抖音来记录生活</li><li>直播 礼物一键连送</li><li>随拍功能</li><li>春晚独家社交媒体传播平台，五亿现金分享</li></ul></li><li>2019年2月<ul><li>AR画笔功能</li></ul></li><li>2019年3月<ul><li>随拍支持发布纯文字内容</li><li>新增聚焦拍摄模式</li><li>私信可置顶</li><li>热血鼓手道具玩法</li><li>新增位置贴纸</li></ul></li><li>2019年4月   <ul><li>道具玩法 – 橙子脸 </li><li>道具玩法 – 漫画擦拭</li></ul></li><li>2019年5月<ul><li>道具玩法 - change face   </li><li>挡脸变男生</li><li>道具玩法 - LineDancer</li></ul></li><li>2019年6月<ul><li>合拍 测相似度</li><li>道具玩法 – 炫光衣服 </li><li>道具玩法 – 照片连拍</li></ul></li><li>2019年7月<ul><li>道具玩法 – 动感轮廓</li><li>道具玩法 – 擦拭隐身</li><li>增加文字功能，可以在视频上添加文字了</li></ul></li><li>2019年9月<ul><li>青少年模式</li><li>道具玩法 – 百变抖抖秀</li></ul></li><li>2019年10月<ul><li>新增贴纸</li><li>青少年模式优化</li><li>新增变声功能</li></ul></li><li>2020年1月 - 至今<ul><li>春节20亿现金等你拿  </li><li>新增贴纸</li><li>新增特效  <h1 id="2-平台分析"><a href="#2-平台分析" class="headerlink" title="2. 平台分析"></a>2. 平台分析</h1><h2 id="2-1-市场定位"><a href="#2-1-市场定位" class="headerlink" title="2.1 市场定位"></a>2.1 市场定位</h2>从1.1的整个时间轴，我们会发现整个抖音的发展很小步快跑，迅速迭代。刚开始出了产品原型，用初始用户群体开始迅速做迭代，在锚定自己的定位，目标人群之后，通过召集KOL，明星，通过微博，QQ微信引流，实现其迅速的增长。</li></ul></li></ul><p>抖音的slogan是<strong>记录美好生活</strong>，<strong>以一二线城市年轻潮人为目标用户，市场定位突出音乐与创意</strong>，是一个相对中心化的高热度高流量的聚集年轻人的音乐短视频平台。整体是以音乐为核心布局的，用户在拍摄视频前首先选择一首背景音乐，根据音乐内容进行动作编排和加工特效。</p><h2 id="2-2-产品设计"><a href="#2-2-产品设计" class="headerlink" title="2.2 产品设计"></a>2.2 产品设计</h2><h3 id="2-2-1-浏览体验"><a href="#2-2-1-浏览体验" class="headerlink" title="2.2.1 浏览体验"></a>2.2.1 浏览体验</h3><ul><li>整体以黑白灰三色为主，风格简洁，有潮流感</li><li>全屏沉浸式体验<ul><li>无限向下滑动</li></ul></li><li>竖屏播放 – 适用更多的场景(上班，通勤，吃饭，等等) – 也很符合于短视频碎片时间使用的定位</li><li>点击背景音乐会跳转到同款音乐其他的短视频集合</li><li>交互 任意位置双击点赞，上下滑浏览其他视频</li><li>长按 可以看到更多的一些选择<ul><li>不感兴趣</li><li>加到喜欢 </li></ul></li></ul><h3 id="2-2-2-拍摄"><a href="#2-2-2-拍摄" class="headerlink" title="2.2.2 拍摄"></a>2.2.2 拍摄</h3><p>抖音在拍摄方面下了很大功夫，从更新日志上也能很明显看出他在尝试着不断降低拍摄出高质量视频的门槛，通过大量的特效，各种道具，让短视频不至于单调，可以用比较简单的素材，加上特效，音乐，撑起来。</p><ul><li>多种类型音乐<ul><li>国风</li><li>流行</li><li>原创 </li><li>etc.</li></ul></li><li>视频制作的功能<ul><li>速度切换</li><li>多段混剪</li><li>贴纸道具</li><li>美化滤镜</li><li>特效滤镜<h3 id="2-2-3-特色功能"><a href="#2-2-3-特色功能" class="headerlink" title="2.2.3 特色功能"></a>2.2.3 特色功能</h3></li></ul></li><li>热搜榜</li><li>尬舞机</li><li>时间锁</li></ul><h2 id="2-3-内容生产与分发"><a href="#2-3-内容生产与分发" class="headerlink" title="2.3 内容生产与分发"></a>2.3 内容生产与分发</h2><h3 id="2-3-1-内容生产模式"><a href="#2-3-1-内容生产模式" class="headerlink" title="2.3.1 内容生产模式"></a>2.3.1 内容生产模式</h3><p>UGC + PGC模式</p><ul><li>UGC<ul><li>普通用户</li></ul></li><li>PGC<ul><li>明星</li><li>网红</li><li>专业垂直领域KOL</li></ul></li></ul><h3 id="2-3-2-内容分发模式"><a href="#2-3-2-内容分发模式" class="headerlink" title="2.3.2 内容分发模式"></a>2.3.2 内容分发模式</h3><ul><li>算法推荐+人工精选推荐<ul><li>根据用户的观看数据，计算用户内容标签，按照一定频率推送相似的视频内容 </li><li>推荐爆款内容，越优质的内容会得到越多的曝光机会</li><li>推荐机制不太在意内容的发布时间，只要足够精彩，可能<strong><em>已经发布了几个月的视频</em></strong>还会不断推给用户</li></ul></li></ul><h2 id="2-4-营销推广"><a href="#2-4-营销推广" class="headerlink" title="2.4 营销推广"></a>2.4 营销推广</h2><ul><li>开屏广告</li><li>信息流广告</li><li>定制挑战赛<ul><li>为品牌独家定制</li><li>保持剧情，自主拍摄权交给视频制作者</li></ul></li><li>聚合电商<ul><li>同淘宝的直接链接</li></ul></li></ul><h2 id="2-5-技术能力"><a href="#2-5-技术能力" class="headerlink" title="2.5 技术能力"></a>2.5 技术能力</h2><ul><li>监管<ul><li>人工为主，机器学习为辅 <ul><li>通过建立完善数据库，将用户上传的内容与数据库进行匹配，被识别为不良内容就予以直接删除</li></ul></li><li>用户举报  <ul><li><h1 id="3-Thoughts"><a href="#3-Thoughts" class="headerlink" title="3. Thoughts"></a>3. Thoughts</h1></li></ul></li></ul></li></ul><h2 id="3-1-用户的需求"><a href="#3-1-用户的需求" class="headerlink" title="3.1 用户的需求"></a>3.1 用户的需求</h2><p>用户参与到虚拟社区的动机，可以是基于：</p><ul><li>自我认知和需求的满足 </li><li>社会交往需求  – 抖音不太能满足</li><li>获取利益的需求 – 平台盘子的扩大会增大每个人的盘子</li><li>情感归属 – 指跟随自己的偶像，明星，希望获取更多相关的信息</li></ul><p>首先，感到大部分人不习惯自己去主动寻求信息的，或者说，是不太清楚自己应该主动获取什么样的信息，因此app的主动推送，人被选择适时而生。（IOC 容器了解一下,hhh）</p><p>每个App都有自己的味道，抖音的味道能够吸引来追逐潮流的年轻人。可以在这里看到<strong>和自己类似的人</strong>拍的视频，看到的<strong>美好的世界</strong>。</p><p>抖音一定程度上满足了用户的自我认知的需求，会觉得抖音和自己很搭(用户画像和自我认知的部分重合)。</p><p>但在社交方面，有点不尽如人意，这也和抖音的整体 – 偏中心化的音乐短视频平台的初始定位有关了。当大部分的高质内容产出出自PGC, MCN的时候，潜在的内容创作者很可能会因为成为热门的高门槛而放弃。大家看自己向往的生活，而不是自己的生活。</p><p>热门视频大部分是有趣的段子，以及同样的素材音乐下的小哥哥小姐姐的表现，同质化有点严重，同时离日常生活的距离着实有点远，这也致使了用户之间的关联感比较差。  </p><p>一个超漂亮的小姐姐在跳舞，你会“哇，太好看了”，但你不知道该回什么，才能够不太尬的认识。因为这些小姐姐可能离你的物理距离还很远是吧~ 可看没法约 </p><p>抖音其实现在有基于地理位置的模块，有种想两手抓的感觉，不知道后台流量如何，只是当用户对于一个平台的定位是 – 去看好玩的搞笑的，去看小哥哥小姐姐的时候，想改变既定的认知，难度不小。想在保持当前定位的同时，加上一个社交属性，好像有些部分是相互有冲突的。</p><p>看到新闻在灰度测试，陌生人视频聊天，增强社交属性，看来是太不活跃，并没有灰度上。不知道具体是怎么样的过程，有没有足够多的对话题的引导，这种带点“阅后即焚”性质的尝试，会不会一不小心跨过监管允许的限制，lol  拭目以待</p><h2 id="3-2-others"><a href="#3-2-others" class="headerlink" title="3.2 others"></a>3.2 others</h2><ul><li>用户集中于一二线城市<ul><li>如何向三四线城市扩张？<ul><li>囧妈 很酷</li><li>大量的广告，代言<ul><li>这种打法在一二线城市很好用，三四线城市呢，联想趣头条 – 我们要最实在的！请给我钱，lol</li></ul></li><li>内容上的倾斜<ul><li>如何生产更多的小镇青年感兴趣的内容？  </li></ul></li></ul></li></ul></li><li>视频创作的门槛与参与热情<ul><li>刺激计划</li><li>培训平台 <ul><li>2019年11月26日上线创作者学院 </li></ul></li></ul></li><li>内容同质化，低俗化<ul><li>当在娱乐化做到很极致的时候(请看抖音app的极快的迭代频率，以及层出不穷的新道具，新玩法)，需要做更加深度的内容么？ </li><li>当知识付费成为新风口，巫师财经，半佛仙人成功出圈以后，有机会将内容浓缩到1-5min的视频当中，来点先导知识，然后再成功引流到长视频网站上？ </li></ul></li><li>弱社交平台<ul><li>社交是保证一个平台用户粘性的护城河，当抖音选择了沉浸式的无限下滑的交互方式的时候，一定程度上，我们可以说是舍弃了社交的 （对比快手的下滑留评，左滑回退的操作）。</li><li>弱社交也可以从留评数据当中可以看出，尽管抖音的日活月活遥遥领先，但留评，点赞是快手占据优势的，互动率要高出很多</li><li>做不做社交？<ul><li>一直无限想做，先出自己的专属app，没做起来，现在直接放到抖音这个国民app里做了</li></ul></li><li>为什么想做？<ul><li>社交，粘性，带货，看看快手的带货数据，贼酷炫</li><li>社交 - 附近的人 - 一张美丽的类似美团的外卖带动基于地理位置的其他业务的美妙构想</li></ul></li><li>concern<ul><li>社交注定是需要带点“平均人” 的理念的，这不仅仅需要接口，路径，交互方式的改变，更是内容分发逻辑，视频创作方式上的改变。那问题来了，社交有多重要，重要到改变整个平台的现有定位，重要到可能会降低一些格调，少一些fancy，多点生活气息么？ </li></ul></li></ul></li><li>算法 信息茧房<ul><li>用户喜欢的信息和信息广度的tradeoff，算法的单个方向上的相对极致优化，会缩减用户能够接受到的信息范围的</li><li>依旧是平台算法优化的问题了，到底给用户留出多少自己的空间呢？ </li></ul></li><li>政策的限制/要求 - 娱乐属性，社会属性，深入的思考性的东西很少<ul><li>嗯，是这样的~  </li></ul></li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="http://www.woshipm.com/evaluating/994454.html" target="_blank" rel="noopener">http://www.woshipm.com/evaluating/994454.html</a> </li><li><a href="https://tools.lancely.tech/apple/app-version/cn/1142110895" target="_blank" rel="noopener">https://tools.lancely.tech/apple/app-version/cn/1142110895</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Overview&quot;&gt;&lt;a href=&quot;#1-Overview&quot; class=&quot;headerlink&quot; title=&quot;1. Overview&quot;&gt;&lt;/a&gt;1. Overview&lt;/h1&gt;&lt;h2 id=&quot;1-1-外部环境背景&quot;&gt;&lt;a href=&quot;#1-1-外部环境背
      
    
    </summary>
    
    
      <category term="Notes" scheme="https://www.llchen60.com/categories/Notes/"/>
    
    
      <category term="thought" scheme="https://www.llchen60.com/tags/thought/"/>
    
      <category term="抖音" scheme="https://www.llchen60.com/tags/%E6%8A%96%E9%9F%B3/"/>
    
  </entry>
  
  <entry>
    <title>构建React的想法 - from sebmarkbage</title>
    <link href="https://www.llchen60.com/%E6%9E%84%E5%BB%BAReact%E7%9A%84%E6%83%B3%E6%B3%95-from-sebmarkbage/"/>
    <id>https://www.llchen60.com/%E6%9E%84%E5%BB%BAReact%E7%9A%84%E6%83%B3%E6%B3%95-from-sebmarkbage/</id>
    <published>2020-04-09T03:25:08.000Z</published>
    <updated>2020-04-09T03:31:08.065Z</updated>
    
    <content type="html"><![CDATA[<p>从github翻到的论述，是React设计者试图说明其构建React的整个逻辑。</p><h1 id="1-转换-Transformation"><a href="#1-转换-Transformation" class="headerlink" title="1. 转换 - Transformation"></a>1. 转换 - Transformation</h1><p>React的核心假定是UI层实际上是对数据的展现形式的一种转换。同样的输入会给出同样的输出结果，只是表现形式可能会有所区别。</p><pre><code>function NameBox(name) {  return { fontWeight: &#39;bold&#39;, labelContent: name };}&#39;Sebastian Markbåge&#39; -&gt;{ fontWeight: &#39;bold&#39;, labelContent: &#39;Sebastian Markbåge&#39; };</code></pre><h1 id="2-抽象-Abstraction"><a href="#2-抽象-Abstraction" class="headerlink" title="2. 抽象 - Abstraction"></a>2. 抽象 - Abstraction</h1><p>我们无法将一个复杂的UI放到一个方法当中的。将UI抽象到各个可以复用的组件当中就变得尤为重要。抽象成可复用的组件，并且隐藏实现的细节，是我们想要做的。</p><pre><code>function FancyUserBox(user) {  return {    borderStyle: &#39;1px solid blue&#39;,    childContent: [      &#39;Name: &#39;,      NameBox(user.firstName + &#39; &#39; + user.lastName)    ]  };}{ firstName: &#39;Sebastian&#39;, lastName: &#39;Markbåge&#39; } -&gt;{  borderStyle: &#39;1px solid blue&#39;,  childContent: [    &#39;Name: &#39;,    { fontWeight: &#39;bold&#39;, labelContent: &#39;Sebastian Markbåge&#39; }  ]};</code></pre><h1 id="3-组合-Composition"><a href="#3-组合-Composition" class="headerlink" title="3. 组合 - Composition"></a>3. 组合 - Composition</h1><p>为了实现真正可以复用的特性，仅仅使用细分的子功能，并且每次给他们构建容器是不太够的。我们需要能够建立中间层的抽象，即将几个子功能组件组合起来，形成另一层次的组件。这里的组合就是指将多个抽象融合成一个抽象的能力。</p><pre><code>function FancyBox(children) {  return {    borderStyle: &#39;1px solid blue&#39;,    children: children  };}function UserBox(user) {  return FancyBox([    &#39;Name: &#39;,    NameBox(user.firstName + &#39; &#39; + user.lastName)  ]);}</code></pre><h1 id="4-状态-State"><a href="#4-状态-State" class="headerlink" title="4. 状态 - State"></a>4. 状态 - State</h1><p>UI不仅仅是服务器以及商业逻辑的复制，实际上是有很多状态，是服务于特定的运行过程的。比如你在一个文本框输入内容，那么我们需要一些方式能够记录下这个文本框当前的状态，并且用这个状态去和后端进或者其他的方法进行交互。</p><p>我们希望我们的数据是immutable的</p><pre><code>function FancyNameBox(user, likes, onClick) {  return FancyBox([    &#39;Name: &#39;, NameBox(user.firstName + &#39; &#39; + user.lastName),    &#39;Likes: &#39;, LikeBox(likes),    LikeButton(onClick)  ]);}// Implementation Detailsvar likes = 0;function addOneMoreLike() {  likes++;  rerender();}// InitFancyNameBox(  { firstName: &#39;Sebastian&#39;, lastName: &#39;Markbåge&#39; },  likes,  addOneMoreLike);</code></pre><h1 id="5-记忆方法"><a href="#5-记忆方法" class="headerlink" title="5. 记忆方法"></a>5. 记忆方法</h1><p>如果我们知道这是个纯方法，并且还会重复的call它，那么我们可以设计一个记忆版本的方法，这样我们就不用在有相同的数据(输入)的时候还要重复执行了</p><pre><code>function memoize(fn) {  var cachedArg;  var cachedResult;  return function(arg) {    if (cachedArg === arg) {      return cachedResult;    }    cachedArg = arg;    cachedResult = fn(arg);    return cachedResult;  };}var MemoizedNameBox = memoize(NameBox);function NameAndAgeBox(user, currentTime) {  return FancyBox([    &#39;Name: &#39;,    MemoizedNameBox(user.firstName + &#39; &#39; + user.lastName),    &#39;Age in milliseconds: &#39;,    currentTime - user.dateOfBirth  ]);}// 我们同样可以不仅仅记一个值，也可以记一个mapfunction memoize(fn) {  return function(arg, memoizationCache) {    if (memoizationCache.arg === arg) {      return memoizationCache.result;    }    const result = fn(arg);    memoizationCache.arg = arg;    memoizationCache.result = result;    return result;  };}function FancyBoxWithState(  children,  stateMap,  updateState,  memoizationCache) {  return FancyBox(    children.map(child =&gt; child.continuation(      stateMap.get(child.key),      updateState,      memoizationCache.get(child.key)    ))  );}const MemoizedFancyNameBox = memoize(FancyNameBox);</code></pre><h1 id="6-列表"><a href="#6-列表" class="headerlink" title="6. 列表"></a>6. 列表</h1><p>大部分的UI都是一些形式的列表，然后为在列表中的每个元素产出不同的一系列的值。这就自然的产生了一个有层级的结构。</p><p>我们可以通过使用Map方法来管理每个列表当中的元素的状态。</p><pre><code>function UserList(users, likesPerUser, updateUserLikes) {  return users.map(user =&gt; FancyNameBox(    user,    likesPerUser.get(user.id),    () =&gt; updateUserLikes(user.id, likesPerUser.get(user.id) + 1)  ));}var likesPerUser = new Map();function updateUserLikes(id, likeCount) {  likesPerUser.set(id, likeCount);  rerender();}UserList(data.users, likesPerUser, updateUserLikes);</code></pre><h1 id="7-持续性"><a href="#7-持续性" class="headerlink" title="7. 持续性"></a>7. 持续性</h1><p>一些时候，我们在运行我们的核心商业逻辑的时候会大量的操作数据，这部分关于数据的操作会显得有些冗余，我们可以将其移出核心逻辑的代码块，比如使用bind，来绑定方法，在其他地方写具体的代码逻辑。</p><pre><code>function FancyUserList(users) {  return FancyBox(    UserList.bind(null, users)  );}const box = FancyUserList(data.users);const resolvedChildren = box.children(likesPerUser, updateUserLikes);const resolvedBox = {  ...box,  children: resolvedChildren};</code></pre><h1 id="8-状态Map"><a href="#8-状态Map" class="headerlink" title="8. 状态Map"></a>8. 状态Map</h1><p>我们可以用组合来将几个子组件放在一起来使用，同样的，对于他们需要的一些输入数据，我们可以通过state，来传到下层的方法处，供他们使用。</p><pre><code>function FancyBoxWithState(  children,  stateMap,  updateState) {  return FancyBox(    children.map(child =&gt; child.continuation(      stateMap.get(child.key),      updateState    ))  );}function UserList(users) {  return users.map(user =&gt; {    continuation: FancyNameBox.bind(null, user),    key: user.id  });}function FancyUserList(users) {  return FancyBoxWithState.bind(null,    UserList(users)  );}const continuation = FancyUserList(data.users);continuation(likesPerUser, updateUserLikes);</code></pre><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://github.com/reactjs/react-basic" target="_blank" rel="noopener">https://github.com/reactjs/react-basic</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从github翻到的论述，是React设计者试图说明其构建React的整个逻辑。&lt;/p&gt;
&lt;h1 id=&quot;1-转换-Transformation&quot;&gt;&lt;a href=&quot;#1-转换-Transformation&quot; class=&quot;headerlink&quot; title=&quot;1. 转换 
      
    
    </summary>
    
    
      <category term="FrontEnd" scheme="https://www.llchen60.com/categories/FrontEnd/"/>
    
    
      <category term="React" scheme="https://www.llchen60.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>如何知道用户是否在使用Adblocker</title>
    <link href="https://www.llchen60.com/%E5%A6%82%E4%BD%95%E7%9F%A5%E9%81%93%E7%94%A8%E6%88%B7%E6%98%AF%E5%90%A6%E5%9C%A8%E4%BD%BF%E7%94%A8Adblocker/"/>
    <id>https://www.llchen60.com/%E5%A6%82%E4%BD%95%E7%9F%A5%E9%81%93%E7%94%A8%E6%88%B7%E6%98%AF%E5%90%A6%E5%9C%A8%E4%BD%BF%E7%94%A8Adblocker/</id>
    <published>2020-04-07T18:58:04.000Z</published>
    <updated>2020-04-07T19:00:33.044Z</updated>
    
    <content type="html"><![CDATA[<p>广告监测和屏蔽是很好的功能，而Ad-blocker基本是市面上做屏蔽广告插件的翘楚了。根据GlobalWebIndex在2019年五月做的统计，现在有47% 的用户正在使用广告屏蔽的软件。</p><p>作为网站管理者，你可以做一个pop up 的信息框，希望用户能够停止对于广告的屏蔽，或者你可以直接不允许用户来访问页面，知道去除了广告屏蔽之后。</p><p>那么如何知道用户是否在使用AbBlocker呢，这里需要了解下adblocker的运行机制，广告屏蔽的运行依赖于过滤规则(filter rules)， adblock会将你正在访问的URL和过滤列表相比较，如果匹配，那么这个请求就会被屏蔽掉。</p><p>但是还有部分的广告是不会发起一个HTTP请求，相对应的，他们会使用<code>data:image/png</code>这种方式来加载广告，对于这种广告，AdBlock 在每个页面都会插入一个样式表，然后这个样式表包括选择器，来display:none 通过这种方式来隐藏页面上的广告</p><p>而这些屏蔽列表来自于一些过去的积累，譬如：</p><ul><li><a href="https://easylist.to/" target="_blank" rel="noopener">Easylist</a></li><li><a href="https://help.getadblock.com/support/solutions/articles/6000092027-why-am-i-suddenly-seeing-taboola-outbrain-and-google-ads-" target="_blank" rel="noopener">accesptable list</a></li></ul><p>除此以外，adblocker还会检测前端调用的js文件，如果还有ad关键词，也会直接屏蔽，所以我们可以直接使用命名，来做一个简单的判断。</p><pre><code>// 创建名为ads.js的文件isAdBlockActive = false;// 创建script.jsvar AdBlocker = (function () {    function showModal() {        $(&#39;#modal_ad_blocker&#39;).modal(); // show a message to the user when ads are blocked    }    setInterval(function () {        // Get the first AdSense ad unit on the page        var ad = document.querySelector(&quot;ins.adsbygoogle&quot;);        // If the ads.js or the Google ads are not loaded, show modal and track the event        if (typeof isAdBlockActive === &#39;undefined&#39;            || (ad &amp;&amp; ad.innerHTML.replace(/\s/g, &quot;&quot;).length === 0)) {            showModal();            if (typeof ga !== &#39;undefined&#39;) {                // Log an event in Universal Analytics                // but without affecting overall bounce rate                ga(&#39;send&#39;, &#39;event&#39;, &#39;Adblock&#39;, &#39;Yes&#39;, {&#39;nonInteraction&#39;: 1});            } else if (typeof _gaq !== &#39;undefined&#39;) {                // Log a non-interactive event in old Google Analytics                _gaq.push([&#39;_trackEvent&#39;, &#39;Adblock&#39;, &#39;Yes&#39;, undefined, undefined, true]);            }        }    }, 5000); // check every 5 seconds})();</code></pre><p>通过检测我们在ads.js当中定义的isAdBlockActive 是否能够被检测到(undefined or have some value)。我们就可以看出是否有adBlocker正在运行，然后根据检测结果我们可以给用户提醒，或者直接阻止访问。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://blog.rampatra.com/how-to-know-whether-a-user-is-using-an-adblocker" target="_blank" rel="noopener">https://blog.rampatra.com/how-to-know-whether-a-user-is-using-an-adblocker</a> </li><li><a href="https://help.getadblock.com/support/solutions/articles/6000087914-how-does-adblock-work-" target="_blank" rel="noopener">https://help.getadblock.com/support/solutions/articles/6000087914-how-does-adblock-work-</a> </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;广告监测和屏蔽是很好的功能，而Ad-blocker基本是市面上做屏蔽广告插件的翘楚了。根据GlobalWebIndex在2019年五月做的统计，现在有47% 的用户正在使用广告屏蔽的软件。&lt;/p&gt;
&lt;p&gt;作为网站管理者，你可以做一个pop up 的信息框，希望用户能够停止对
      
    
    </summary>
    
    
      <category term="Web" scheme="https://www.llchen60.com/categories/Web/"/>
    
    
      <category term="Tricks" scheme="https://www.llchen60.com/tags/Tricks/"/>
    
  </entry>
  
  <entry>
    <title>Log4j2 Tutorial </title>
    <link href="https://www.llchen60.com/Log4j2-Tutorial/"/>
    <id>https://www.llchen60.com/Log4j2-Tutorial/</id>
    <published>2020-04-02T05:27:56.000Z</published>
    <updated>2020-04-02T05:32:48.736Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Log4j2-overview"><a href="#1-Log4j2-overview" class="headerlink" title="1. Log4j2 overview"></a>1. Log4j2 overview</h1><h2 id="1-1-Why-log"><a href="#1-1-Why-log" class="headerlink" title="1.1 Why log?"></a>1.1 Why log?</h2><p>Logging is an important component of the development cycle. </p><ul><li>provides precise context about a run of the application </li><li>once inserted into code, the generation of logging output requires no human intervention </li><li>moreover, log output can be saved in persistent medium to be studied at a later time </li></ul><h2 id="1-2-Why-Log4j2"><a href="#1-2-Why-Log4j2" class="headerlink" title="1.2 Why Log4j2?"></a>1.2 Why Log4j2?</h2><ul><li>Designed to be usable as an audit logging framework , will not lose events while reconfiguring </li><li>Contains asynchrounous loggers, which is 10 times faster than log4j 1.x and logback </li><li>Garbage free for stand alone applications </li><li>Use a plugin system that makes it easy to extend the framework by adding new appenders, filters, layouts, lookups, and pattern converters</li><li>Support for custom log levels </li></ul><h2 id="1-3-Log4j-Architecture"><a href="#1-3-Log4j-Architecture" class="headerlink" title="1.3 Log4j Architecture"></a>1.3 Log4j Architecture</h2><p><img src="https://i.loli.net/2020/04/02/AsXomqJciUyPVKh.jpg" alt="Log4jClasses.jpg"> </p><p>Applications using the Log4j 2 API will request <strong>a Logger with a specific name from the LogManager</strong>. The LogManager will <strong>locate the appropriate LoggerContext</strong> and then obtain the Logger from it. If the Logger must be created it will <strong>be associated with the LoggerConfig</strong> that contains either a) the same name as the Logger, b) the name of a parent package, or c) the root LoggerConfig. LoggerConfig objects are created from Logger declarations in the configuration. The LoggerConfig is associated with the Appenders that actually deliver the LogEvents.</p><ul><li>Filter <ul><li>apply in different time point <ul><li>before control is passed to any loggerConfig</li><li>after control is passed to a LoggerConfig but before calling any Appenders</li><li>after control is passed to a LoggerConfig but before calling a specific Appender</li><li>on each Appender</li></ul></li></ul></li><li>Appender <ul><li>selectively enable or disable logging requests</li><li>allow logging requests to print to multiple destinations </li></ul></li><li>Layout <ul><li>Used to customize the output format </li><li>Associate a layout with an appender </li></ul></li></ul><h1 id="2-Migration-from-Log4j-to-Log4j2"><a href="#2-Migration-from-Log4j-to-Log4j2" class="headerlink" title="2. Migration from Log4j to Log4j2"></a>2. Migration from Log4j to Log4j2</h1><p>We usually use log4j/ log4j2 with Slf4j, Slf4j is kind of like a connecter, you could use slf4j as logging system, and slf4j could help you connect to logging framework you want to use: like logback, log4j2, commons-logging, etc. </p><p><a href="https://logging.apache.org/log4j/2.x/manual/migration.html" target="_blank" rel="noopener">https://logging.apache.org/log4j/2.x/manual/migration.html</a> </p><p>Look at sample 1 in above link for how to set up basic configuration </p><p>For some tips: </p><ul><li>The main package in version 1 is org.apache.log4j, in version 2 it is org.apache.logging.log4j</li><li>Calls to org.apache.log4j.Logger.getLogger() must be modified to org.apache.logging.log4j.LogManager.getLogger().</li><li>Calls to org.apache.log4j.Logger.getRootLogger() or org.apache.log4j.LogManager.getRootLogger() must be replaced with org.apache.logging.log4j.LogManager.getRootLogger().</li><li>Calls to org.apache.log4j.Logger.getLogger that accept a LoggerFactory must remove the org.apache.log4j.spi.LoggerFactory and use one of Log4j 2’s other extension mechanisms.</li><li>Replace calls to org.apache.log4j.Logger.getEffectiveLevel() with org.apache.logging.log4j.Logger.getLevel().</li><li>Remove calls to org.apache.log4j.LogManager.shutdown(), they are not needed in version 2 because the Log4j Core now automatically adds a JVM shutdown hook on start up to perform any Core clean ups.<ul><li>Starting in Log4j 2.1, you can specify a custom ShutdownCallbackRegistry to override the default JVM shutdown hook strategy.</li><li>Starting in Log4j 2.6, you can now use org.apache.logging.log4j.LogManager.shutdown() to initiate shutdown manually.</li></ul></li><li>Calls to org.apache.log4j.Logger.setLevel() or similar methods are not supported in the API. Applications should remove these. Equivalent functionality is provided in the Log4j 2 implementation classes, see org.apache.logging.log4j.core.config.Configurator.setLevel(), but may leave the application susceptible to changes in Log4j 2 internals.</li><li>Where appropriate, applications should convert to use parameterized messages instead of String concatenation.</li><li>org.apache.log4j.MDC and org.apache.log4j.NDC have been replaced by the Thread Context.</li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://logging.apache.org/log4j/2.x/manual/migration.html" target="_blank" rel="noopener">https://logging.apache.org/log4j/2.x/manual/migration.html</a> </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Log4j2-overview&quot;&gt;&lt;a href=&quot;#1-Log4j2-overview&quot; class=&quot;headerlink&quot; title=&quot;1. Log4j2 overview&quot;&gt;&lt;/a&gt;1. Log4j2 overview&lt;/h1&gt;&lt;h2 id=&quot;1-1
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="log" scheme="https://www.llchen60.com/tags/log/"/>
    
  </entry>
  
  <entry>
    <title>Amazon RDS Onboard - MySQL </title>
    <link href="https://www.llchen60.com/Amazon-RDS-Onboard-MySQL/"/>
    <id>https://www.llchen60.com/Amazon-RDS-Onboard-MySQL/</id>
    <published>2020-03-29T03:39:50.000Z</published>
    <updated>2020-04-05T22:47:32.274Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a>1. Overview</h1><p>Amazon Relational Databazse Service </p><ul><li>provide cost efficient, resizable capacity for relational database and manage common database administration tasks </li><li>CPU, memory, storage, IOPS can be scaled independently </li><li>help you manage backups, software patching, automatic failure detection, and recovery </li><li>Automated backups </li><li>Can get high availability with a primary instance and synchronous secondary instance that you can fail over to when problems occur.</li><li>Integrate with IAM and VPC settings</li></ul><h2 id="1-1-How-does-amazon-help-you-do-the-setup"><a href="#1-1-How-does-amazon-help-you-do-the-setup" class="headerlink" title="1.1 How does amazon help you do the setup?"></a>1.1 How does amazon help you do the setup?</h2><p>Overall, you control your database by using DB instance, you could select different kind of host with different configuration, AWS will help you to deploy it in your selected region, and it will be automatically deployed to different AZ, to increase availability. Let’s go through it in detail. </p><h3 id="1-1-1-DB-Instances"><a href="#1-1-1-DB-Instances" class="headerlink" title="1.1.1 DB Instances"></a>1.1.1 DB Instances</h3><ul><li><p>An isolated database env in the AWS Cloud </p></li><li><p>One instance can contain multiple user-created databases </p></li><li><p>Each DB instance runs one DB engine, for DB engine, we mean MySQL, MariaDB, PostgreSQL, etc. </p></li><li><p>You could change your selected computation and memory capacity by using <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.DBInstanceClass.html" target="_blank" rel="noopener">DB instance class</a>.</p></li><li><p>You could choose to use multiple availability zones, AZ is engineered to be isolated from failures in other AZs, by launching instances in separate AZs, you can protect your applications from the failure of a single location</p><h3 id="1-1-2-Basic-setup"><a href="#1-1-2-Basic-setup" class="headerlink" title="1.1.2 Basic setup"></a>1.1.2 Basic setup</h3></li><li><p>AWS account </p></li><li><p>IAM user </p></li></ul><h1 id="2-MySQL-on-RDS"><a href="#2-MySQL-on-RDS" class="headerlink" title="2. MySQL on RDS"></a>2. MySQL on RDS</h1><h2 id="2-1-Manage-security-for-DB-instance"><a href="#2-1-Manage-security-for-DB-instance" class="headerlink" title="2.1 Manage security for DB instance"></a>2.1 Manage security for DB instance</h2><h3 id="2-1-1-Security-Overview"><a href="#2-1-1-Security-Overview" class="headerlink" title="2.1.1 Security Overview"></a>2.1.1 Security Overview</h3><ul><li>Run DB instance in a vertual private cloud based on the Amazon VPC service </li><li>Use AWS Identity and Access Management policies to assign permissions that determine who is allowed to manage Amazon RDS resrouces </li><li>Use security groups to control what IP addresses or Amazon EC2 instances can connect to your databases on a DB instance</li><li>Use SSL or TLS connections with DB instances <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.SSL.html" target="_blank" rel="noopener">Instructions</a></li><li>Use Amazon RDS encryption to secure DB instances and snapshots at rest. It used AES-256 encryption algorithm to encrypt data on the server that hosts DB instance</li></ul><h3 id="2-1-2-Manage-access-with-Policies-resource-level"><a href="#2-1-2-Manage-access-with-Policies-resource-level" class="headerlink" title="2.1.2 Manage access with Policies - resource level"></a>2.1.2 Manage access with Policies - resource level</h3><ul><li>A poloicy is an object that associated with an identity or resource, defines their permissions. </li><li>An IAM administrator could use policies to specify who has access to AWS resources, and what actions they can perform on the resources </li></ul><h3 id="2-1-3-Access-control-in-DB-instance-level-security-group"><a href="#2-1-3-Access-control-in-DB-instance-level-security-group" class="headerlink" title="2.1.3 Access control in DB instance level - security group"></a>2.1.3 Access control in DB instance level - security group</h3><ul><li>Security groups control the access that traffic has in and out of a DB instance <ul><li>VPC security groups </li><li>DB security groups</li><li>EC2-classic security groups </li></ul></li><li>VPC security group<ul><li>enable a specific source to access a DB instance in a VPC in the security group </li><li>source could be: <ul><li>a range of addresses </li><li>another VPC security group </li></ul></li></ul></li><li>DB security group <ul><li>Used with DB instances that are not in a VPC and on the EC2 classic platform  </li><li>DB security group rules apply to inbound traffic only </li><li>You don’t need to specify port number or protocol when adding rules </li></ul></li></ul><h2 id="2-2-Connect-to-DB-instance"><a href="#2-2-Connect-to-DB-instance" class="headerlink" title="2.2 Connect to DB instance"></a>2.2 Connect to DB instance</h2><ul><li>Create DB instance as prerequisite </li><li>Use MySQL client application or utility to connect to the instance</li><li>Specify DNS address from the DB instance endpoint as the host parameter, specify the port number from DB instance endpoint as the port parameter </li><li>For endpoint, we could find in AWS console, on the “connectivity &amp; security” tab </li><li>To  connect from MySQL client, using command shown as below<ul><li><code>mysql -h mysql–instance1.123456789012.us-east-1.rds.amazonaws.com -P 3306 -u mymasteruser -p</code></li></ul></li><li>Amazon RDS creates an SSL certificate for your DB instance when the instance is created     + you could do it with native password or with IAM authentication <ul><li><code>mysql -h mysql–instance1.123456789012.us-east-1.rds.amazonaws.com --ssl-ca=rds-ca-2015-root.pem -p</code> </li></ul></li><li>we could also connect from MySQL workbench <ul><li>See instructions on <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_ConnectToInstance.html" target="_blank" rel="noopener">Connnecting from MySQL Workbench</a> </li></ul></li></ul><h2 id="2-3-Configure-high-availability-for-a-production-DB-instance"><a href="#2-3-Configure-high-availability-for-a-production-DB-instance" class="headerlink" title="2.3 Configure high availability for a production DB instance"></a>2.3 Configure high availability for a production DB instance</h2><p>Amazon help you do this with Multi-AZ deployments. SQL server DB instances use SQL server Database Mirroring or Always On Availability Groups. </p><p>In a Multi-AZ deployment, Amazon RDS automatically provisions and maintains a synchronous standby replica in a different Availability Zone. The primary DB instance is synchronously replicated across Availability Zones to a standby replica to provide data redundancy, eliminate I/O freezes, and minimize latency spikes during system backups. Running a DB instance with high availability can enhance availability during planned system maintenance, and help protect your databases against DB instance failure and Availability Zone disruption.</p><p>The high availability feature is not scaling solution for read-only scenarios, you cannot use a standby replica to serve read traffic. </p><p>NOTICE – DB instances using Multi-AZ deployments can have increased write and commit latency compared to a Single-AZ depolyment, due to the synchrounous data replication that occurs. </p><p>In the event of a planned or unplanned outage of your DB instance, Amazon RDS automatically switches to a standby replica in another Availability Zone if you have enabled Multi-AZ. The time it takes for the failover to complete depends on the database activity and other conditions at the time the primary DB instance became unavailable. Failover times are typically 60–120 seconds. However, large transactions or a lengthy recovery process can increase failover time. When the failover is complete, it can take additional time for the RDS console to reflect the new Availability Zone.</p><h2 id="2-4-Configure-a-DB-instance-in-VPC"><a href="#2-4-Configure-a-DB-instance-in-VPC" class="headerlink" title="2.4 Configure a DB instance in VPC"></a>2.4 Configure a DB instance in VPC</h2><ul><li>VPC is a virtual network that is logically isolated from other virtual networks in the AWS cloud. Amazon VPC lets you launch AWS resources into a VPC. </li><li>VPC must have at least 2 subnets. And those subnets must be in two different AZs </li><li>If you want DB instance in the VPC to be publicly accessible, you must enable the VPC attributes DNS hostnames and DNS resolution </li></ul><h2 id="2-5-Configure-MySQL-database-parameters-and-features"><a href="#2-5-Configure-MySQL-database-parameters-and-features" class="headerlink" title="2.5 Configure MySQL database parameters and features"></a>2.5 Configure MySQL database parameters and features</h2><ul><li>Manage DB engine configuration by associating DB instances with parameter groups. A DB parameter group act as a container for engine configuration values that are applied to one or more DB instances </li><li>For MySQL, AWS has memcached support </li></ul><h2 id="2-6-Modify-a-DB-instance-running-the-MySQL-database-engine"><a href="#2-6-Modify-a-DB-instance-running-the-MySQL-database-engine" class="headerlink" title="2.6 Modify a DB instance running the MySQL database engine"></a>2.6 Modify a DB instance running the MySQL database engine</h2><ul><li>We could change the settings of a DB instance to add additional storage or changing the DB instance class </li><li>Notice: some cahnges will result in an outage because Amazon RDS must reboot DB instance for the change to take effect <ul><li>We could either modify through AWS console</li><li>Or through AWS CLI</li><li>Or through RDS API </li></ul></li><li>we could do settings as follow:<ul><li>Allocate storage </li><li>Auto minor version upgrade </li><li>Backup retention period <ul><li>number of days that automatic backups are retained </li></ul></li><li>Backup window </li><li>Certificate Authority </li><li>Database port </li><li>DB engine version </li><li>DB instance class </li><li>DB parameter group </li><li>Delete protection <ul><li>prevent your DB from being deleted  </li></ul></li><li>Enhanced Monitoring </li><li>IAM DB authentication </li><li>Kerberos authentication </li><li>License Model </li><li>Log Exports <ul><li>We could publish Database logs to Amazon Cloudwatch logs </li></ul></li><li>Maintenance window </li><li>Multi-AZ deployment </li><li>Performance Insight </li><li>Processor features </li><li>Provisioned IOPS </li><li>Storage auto scaling </li><li>Subnet group </li></ul></li></ul><h2 id="2-7-Configure-database-backup-and-restore"><a href="#2-7-Configure-database-backup-and-restore" class="headerlink" title="2.7 Configure database backup and restore"></a>2.7 Configure database backup and restore</h2><ul><li>Amazon RDS creates and saves automated backups of your DB instance</li><li>RDS creates a storage volume snapshot of DB instance, backing up entire DB instance </li><li>The first snapshot of a DB instance contains the data for the full DB instance. Subsequent snapshots of the same DB instance are incremental, which means that only the data that has changed after your most recent snapshot is saved.</li><li><a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_CommonTasks.BackupRestore.html" target="_blank" rel="noopener">Guide for backup and restore an Amazon RDS DB instance</a></li></ul><h2 id="2-8-Monitor-a-MySQL-DB-instance"><a href="#2-8-Monitor-a-MySQL-DB-instance" class="headerlink" title="2.8 Monitor a MySQL DB instance"></a>2.8 Monitor a MySQL DB instance</h2><h3 id="2-8-1-Overview"><a href="#2-8-1-Overview" class="headerlink" title="2.8.1 Overview"></a>2.8.1 Overview</h3><ul><li><p>We should store historical monitoring data, the stored data will gove a baseline to compare against with current performance data</p></li><li><p>With Amazon RDS, you could monitor network throughput, I/O for read and write, metadata operations, client connections</p></li><li><p>Some adviced metrics </p><ul><li>High CPU or RAM consumption </li><li>Disk space consumption </li><li>Network traffic </li><li>Database connections </li><li>IOPS metrics </li></ul></li><li><p>Monitoring Tools </p><ul><li>Amazon RDS Events <ul><li>subscribe to events thus could be notified when changes occur with a DB instance </li></ul></li><li>Database log files</li><li>Amazon RDS Enhanced Monitoring<ul><li>Look at the metrics in real time for the operating system</li></ul></li><li>Amazon CloudWatch Metrics </li><li>Amazon CloudWatch Alarms</li><li>Amazon CloudWatch Logs </li><li>In RDS console, you could see: <ul><li>the number of connections to a DB instance </li><li>the amount of read and write operations to a DB instance </li><li>the amount of storage that a DB instance is currently utilizing </li><li>the amount of memory and CPU being utilized for a DB instance </li><li>the amount of network traffic to and from a DB instance </li></ul></li></ul></li><li><p>Amazon RDS Metrics </p><ul><li>CPUCreditUsage <ul><li>The number of CPU credits spent by the instance for CPU utilization. One CPU credit equals one vCPU running at 100 percent utilization for one minute or an equivalent combination of vCPUs, utilization, and time.</li></ul></li><li>DatabaseConnections</li><li>DiskQueueDepth <ul><li>the number of outstanding IOs waiting to access the disk</li></ul></li><li>FailedSQLServerAgentJobsCount <ul><li>the numebr of failed SQL server agent jobs during the last minute </li></ul></li><li>ReadIOPS <ul><li>the average number of disk read I/O operations per second</li></ul></li><li>ReadLatency <ul><li>the average amount to time taken per disk I/O operation  </li></ul></li></ul></li></ul><h3 id="2-8-2-Enhanced-Monitoring"><a href="#2-8-2-Enhanced-Monitoring" class="headerlink" title="2.8.2 Enhanced Monitoring"></a>2.8.2 Enhanced Monitoring</h3><p>Real time metrics for the operating system</p><p>CloudWatch gathers metrics about CPU utilization from the hypervisor for a DB instance, and Enhanced Monitoring gathers its metrics from an agent on the instance. As a result, you might find differences between the measurements, because the hypervisor layer performs a small amount of work. The differences can be greater if your DB instances use smaller instance classes, because then there are likely more virtual machines (VMs) that are managed by the hypervisor layer on a single physical instance. Enhanced Monitoring metrics are useful when you want to see how different processes or threads on a DB instance use the CPU</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://docs.aws.amazon.com/AmazonRDS" target="_blank" rel="noopener">https://docs.aws.amazon.com/AmazonRDS</a> </li><li><a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_MySQL.html" target="_blank" rel="noopener">https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_MySQL.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Overview&quot;&gt;&lt;a href=&quot;#1-Overview&quot; class=&quot;headerlink&quot; title=&quot;1. Overview&quot;&gt;&lt;/a&gt;1. Overview&lt;/h1&gt;&lt;p&gt;Amazon Relational Databazse Service 
      
    
    </summary>
    
    
      <category term="Cloud" scheme="https://www.llchen60.com/categories/Cloud/"/>
    
    
      <category term="AWS" scheme="https://www.llchen60.com/tags/AWS/"/>
    
      <category term="RDS" scheme="https://www.llchen60.com/tags/RDS/"/>
    
      <category term="MySQL" scheme="https://www.llchen60.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Spring @Transactional</title>
    <link href="https://www.llchen60.com/Spring-Transactional/"/>
    <id>https://www.llchen60.com/Spring-Transactional/</id>
    <published>2020-03-25T02:37:03.000Z</published>
    <updated>2020-03-25T02:40:00.334Z</updated>
    
    <content type="html"><![CDATA[<p>Spring的Transactional注解用来做事务管理</p><h1 id="1-使用方法"><a href="#1-使用方法" class="headerlink" title="1. 使用方法"></a>1. 使用方法</h1><p>首先我们需要在xml当中配置事务信息，定义transactionManager的bean，当然也可以使用注解来实现对于bean的定义，具体如下：</p><pre><code>&lt;tx:annotation-driven /&gt;&lt;bean id=&quot;transactionManager&quot;class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;&lt;/bean&gt;@EnableTransactionManagement</code></pre><p>而后，在具体的使用的时候，我们只需要将@Transactional注解添加到合适的方法当中，并且设置合适的属性信息</p><ul><li>name<ul><li>指定事务管理器</li></ul></li><li>propagation<ul><li>事务的传播行为，默认为REQUIRED</li></ul></li><li>isolation <ul><li>事务的隔离度，默认为DEFAULT</li></ul></li><li>timeout<ul><li>事务的超时时间，默认为-1，如果超过该时间限制但事务没有完成，就自动回滚</li></ul></li><li>read-only<ul><li>指定事务是否为只读事务，默认值为false</li><li>当要忽略那些不需要事务的方法的时候，可以设置read-only为true</li></ul></li><li>rollback-for<ul><li>指定能够触发事务回滚的异常类型，如果有多个异常类型需要指定，可以通过逗号来做分隔</li></ul></li><li>no-rollback-for<ul><li>对于在这里定义的exception，不回滚 </li></ul></li></ul><h1 id="2-Spring-注解方式的事务实现机制"><a href="#2-Spring-注解方式的事务实现机制" class="headerlink" title="2. Spring 注解方式的事务实现机制"></a>2. Spring 注解方式的事务实现机制</h1><p>在调用@Transactional的目标方法之后，Spring Framework会通过AOP代理，在代码运行时生成一个代理对象，根据注解的属性配置信息，决定该声明@Transactional的目标方法是否由拦截器 - TransactionInterceptor来拦截.</p><p>如果确定要被拦截，那么就会在目标方法开始执行之前创建并加入事务，并执行目标方法的逻辑，最后根据执行情况是否出现异常，利用抽象事务管理器提交或者回滚事务。</p><p><img src="https://i.loli.net/2020/03/25/cM5yEjbPAIogk1X.jpg" alt="Spring事务实现机制.jpg"></p><h1 id="3-Isolation-Level"><a href="#3-Isolation-Level" class="headerlink" title="3. Isolation Level"></a>3. Isolation Level</h1><p>Isolation是有不同的配置的，它主要是为了避免事务的一些副作用：</p><ul><li>脏读：读到同时进行的事务还没有提交上去的数据</li><li>不可重复的读：重复读的时候会读到不同的数据，因为有同时进行的事务对同一条数据进行了更新</li><li>幽灵读取：在做query的时候，再度执行拿到不同的行，因为有同时进行的事务在做更新</li></ul><p>针对不同级别的事务，Spring有如下的设置</p><ul><li>DEFAULT</li><li>READ_UNCOMMITTED<ul><li>最低的隔离水平 </li><li>允许大部分的同时的访问</li><li>有上述所有的弊端</li></ul></li><li>READ_COMMMITED<ul><li>阻止脏读 </li></ul></li><li>REPEATABLE_READ<ul><li>阻止脏读</li><li>阻止不可重复读取</li></ul></li><li>SERAILIZABLE<ul><li>最高程度的隔离</li><li>基本是单序列的执行</li></ul></li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/annotation/Transactional.html" target="_blank" rel="noopener">https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/annotation/Transactional.html</a></li><li><a href="https://dzone.com/articles/how-does-spring-transactional" target="_blank" rel="noopener">https://dzone.com/articles/how-does-spring-transactional</a></li><li><a href="https://www.ibm.com/developerworks/cn/java/j-master-spring-transactional-use/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-master-spring-transactional-use/index.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Spring的Transactional注解用来做事务管理&lt;/p&gt;
&lt;h1 id=&quot;1-使用方法&quot;&gt;&lt;a href=&quot;#1-使用方法&quot; class=&quot;headerlink&quot; title=&quot;1. 使用方法&quot;&gt;&lt;/a&gt;1. 使用方法&lt;/h1&gt;&lt;p&gt;首先我们需要在xml当中配置事
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
      <category term="Spring" scheme="https://www.llchen60.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>团队能力构建手册-新人Ramp Up</title>
    <link href="https://www.llchen60.com/%E5%9B%A2%E9%98%9F%E8%83%BD%E5%8A%9B%E6%9E%84%E5%BB%BA%E6%89%8B%E5%86%8C-%E6%96%B0%E4%BA%BARamp-Up/"/>
    <id>https://www.llchen60.com/%E5%9B%A2%E9%98%9F%E8%83%BD%E5%8A%9B%E6%9E%84%E5%BB%BA%E6%89%8B%E5%86%8C-%E6%96%B0%E4%BA%BARamp-Up/</id>
    <published>2020-03-24T03:37:58.000Z</published>
    <updated>2020-03-24T03:39:22.183Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博客引述了ThoughtWorks的<a href="https://insights.thoughtworks.cn/capacity-building-and-quality-assurance/" target="_blank" rel="noopener">capacity-building-and-quality-assurance</a>，里面讲得如何构建团队，如何让新人快速适应的方法指南非常实用。分享/ 思考/ 归纳如下。</p><p>自己所在的团队最近也经历了快速的增长，在带新人的过程当中，确实感觉到想一茬抓一茬是客观存在且经常性发生的事情，lol。需要一个更加清晰细致的上手指南，并把一些需要的前提条件先给到，然后给新人留下在正确的方向上足够的探索空间，这样大概才能加速他们的成长把。</p><p>我们当然需要每个个体的无上才能，但更需要一个好的平台，让他们能够专注的将自己的才能用在那个地方。而平台，意味着脚手架，意味着规则，意味着指南。</p><h1 id="1-常规新人成长方式-Mentor-Onboarding-Buddy"><a href="#1-常规新人成长方式-Mentor-Onboarding-Buddy" class="headerlink" title="1. 常规新人成长方式 Mentor/ Onboarding Buddy"></a>1. 常规新人成长方式 Mentor/ Onboarding Buddy</h1><p>为新人指派一名有经验的师傅，作为他的onboarding伙伴，平时可以做结对编程，在日常工作当中交换知识，学习并成长。新人onboarding的速度，取决于师傅的技能。</p><p>这么做当然有好处，一定比新人自己探索onboard要快的多，但是正如上面所说的那样，这种方式很依赖于师傅的能力，还有新人的沟通交流，搜集知识的能力。效果会因为每个成员的性格习惯能力等，有很大的不同。</p><h1 id="2-制定规则化的成长流程"><a href="#2-制定规则化的成长流程" class="headerlink" title="2. 制定规则化的成长流程"></a>2. 制定规则化的成长流程</h1><h2 id="2-1-CraftSkill-Map"><a href="#2-1-CraftSkill-Map" class="headerlink" title="2.1 CraftSkill Map"></a>2.1 CraftSkill Map</h2><p>能力地图是希望能够梳理完整的技术图谱，对技术人员需要掌握的能力进行可视化</p><p>新成员在加入项目的时候一般会有很多问题：</p><ul><li>这个项目是做什么的？ </li><li>这个项目是在解决什么样的问题？</li><li>这个项目使用了什么技术栈？</li><li>新成员应该从哪里开始？</li></ul><p>新人onboard，rampup需要的知识是可以分成可以自己学习的知识(通过各种文档，wiki, stackoverflow, etc.)以及需要老人的帮助的知识(需要上手实操的内容，比如设计原则，DRY,SOLID, LOD等等具体如何使用的问题)。</p><p>我们需要新人自己去探索，获取一些必要的前提性知识，也需要有人帮助，帮他迅速适应新的环境。</p><p>能力地图就是希望能够对所需要的知识，做一个清晰的梳理，形成一个脉络，能够使新人onboard的过程更有的放矢一些。</p><p><img src="https://i.loli.net/2020/03/24/JayeLmisObEpdTS.png" alt="craftskill map E.G.png"></p><h2 id="2-2-指定Onboarding流程"><a href="#2-2-指定Onboarding流程" class="headerlink" title="2.2 指定Onboarding流程"></a>2.2 指定Onboarding流程</h2><p>这里主要是要给一个比较详细的计划，告知新人每周要做的事情，更多的是时间上，任务上的安排。</p><p>根据任务，可以侧重学习前端，后端，或者QA方面的领域知识和技能，然后<strong>做一个meeting，将自己学到的完整的和组里的同事分享下，然后可以一起查漏补缺，完善新人的知识体系</strong>。</p><p>值得注意的是Onboarding的流程当中需要有里程碑和执行时间，由资深员工协助制定，然后就可以领取任务，保质保量的独立完成。</p><p>Onboard流程当中，关于自己看的知识，有很多方式可以来做，比如wiki，视频，甚至是音频，起到的作用就是更高速度的学习。这种相对来说比较被动，主动性的学习可以通过Unit test，将知识点转化成Unit test，然后通过单元测试迅速熟悉知识点。</p><h2 id="2-3-新成员状态看板"><a href="#2-3-新成员状态看板" class="headerlink" title="2.3 新成员状态看板"></a>2.3 新成员状态看板</h2><p>每周由mentor负责跟踪观察新人状态，会议追踪，确定新人是否能在一个月的ramp up以后自己独立负责一部分的任务。</p><h2 id="2-4-Case-by-case-针对性培训"><a href="#2-4-Case-by-case-针对性培训" class="headerlink" title="2.4 Case by case 针对性培训"></a>2.4 Case by case 针对性培训</h2><p>根据个人情况来探究如何做提高，是否可以提前交付项目，诸如此类。</p><p><a href="https://insights.thoughtworks.cn/capacity-building-and-quality-assurance/" target="_blank" rel="noopener">https://insights.thoughtworks.cn/capacity-building-and-quality-assurance/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这篇博客引述了ThoughtWorks的&lt;a href=&quot;https://insights.thoughtworks.cn/capacity-building-and-quality-assurance/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ca
      
    
    </summary>
    
    
      <category term="Notes" scheme="https://www.llchen60.com/categories/Notes/"/>
    
    
      <category term="Mentor" scheme="https://www.llchen60.com/tags/Mentor/"/>
    
  </entry>
  
  <entry>
    <title>迪米特法则 (LOD) — 高内聚，低耦合</title>
    <link href="https://www.llchen60.com/%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99-LOD-%E2%80%94-%E9%AB%98%E5%86%85%E8%81%9A%EF%BC%8C%E4%BD%8E%E8%80%A6%E5%90%88/"/>
    <id>https://www.llchen60.com/%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99-LOD-%E2%80%94-%E9%AB%98%E5%86%85%E8%81%9A%EF%BC%8C%E4%BD%8E%E8%80%A6%E5%90%88/</id>
    <published>2020-03-23T03:30:09.000Z</published>
    <updated>2020-03-23T03:30:50.426Z</updated>
    
    <content type="html"><![CDATA[<p>高内聚 低耦合是比较通用的设计思想，可以用来指导不同的粒度的代码的设计和开发的工作，比如系统，模块，类，甚至是函数。也可以去使用到不同的开发场景当中，比如微服务，框架，组件，类库等等。</p><p>在这个原则当中，高内聚指的是类本身的设计，低耦合指的是类和类之间的依赖关系的设计。</p><p>迪米特法则，可以称之为The least knowledge principle.<br>Each unit should have only limited knowledge about other units: only units “closely” related to the current unit. Or: Each unit should only talk to its friends; Don’t talk to strangers.</p><h1 id="1-什么是高内聚？"><a href="#1-什么是高内聚？" class="headerlink" title="1. 什么是高内聚？"></a>1. 什么是高内聚？</h1><p>指的是相近的功能应该放到同一个类当中，不相近的功能不要放在同一类。代码集中相对来说就会更加容易维护了。</p><h1 id="2-什么是低耦合？"><a href="#2-什么是低耦合？" class="headerlink" title="2. 什么是低耦合？"></a>2. 什么是低耦合？</h1><p>类和类之间的依赖关系简单清晰，即尽管两个类之间有依赖关系。一个类的代码的改动不会或者很少导致依赖类的代码的改动。</p><h1 id="3-内聚和耦合的关系"><a href="#3-内聚和耦合的关系" class="headerlink" title="3. 内聚和耦合的关系"></a>3. 内聚和耦合的关系</h1><p><img src="https://i.loli.net/2020/03/23/yZVTqaQSgvbtE4l.png" alt="内聚耦合关系.png"></p><p>如图所示，左侧就是很好的高内聚低耦合的范例，我们将类最小化，即每个类只做一件事情，这样子其他依赖就会少很多。在修改或增加功能的时候，就不会对其他的类造成很大的影响。</p><h1 id="4-实战"><a href="#4-实战" class="headerlink" title="4. 实战"></a>4. 实战</h1><pre><code>public class NetworkTransporter {    // 存在问题，NetworkTransporter作为一个底层类，不应该依赖于HtmlRequest类；与之相反的，因为其实他需要的是string address，以及byte的数组，那我们应该直接提供这些primitive type的数据    public Byte[] send(HtmlRequest htmlRequest) {      //...    }}public class HtmlDownloader {  private NetworkTransporter transporter;//通过构造函数或IOC注入  public Html downloadHtml(String url) {  // 根据上面NetworkTransporter我们希望做的改动，这里传入的不应该是HtmlRequest类的实例了    Byte[] rawHtml = transporter.send(new HtmlRequest(url));    return new Html(rawHtml);  }}public class Document {  private Html html;  private String url;  public Document(String url) {    this.url = url;    // downloader.downloadHtml逻辑复杂，不应该放在构造函数当中，也会很不好测试    // 构造函数中使用new来做实例，违反了基于接口而非实现编程的原则    HtmlDownloader downloader = new HtmlDownloader();    this.html = downloader.downloadHtml(url);  }  //...}</code></pre><p>修改以后的代码： </p><pre><code>public class NetworkTransporter {    // 省略属性和其他方法...    public Byte[] send(String address, Byte[] data) {      //...    }}public class HtmlDownloader {  private NetworkTransporter transporter;//通过构造函数或IOC注入  // HtmlDownloader这里也要有相应的修改  public Html downloadHtml(String url) {    HtmlRequest htmlRequest = new HtmlRequest(url);    Byte[] rawHtml = transporter.send(      htmlRequest.getAddress(), htmlRequest.getContent().getBytes());    return new Html(rawHtml);  }}public class Document {  private Html html;  private String url;  public Document(String url, Html html) {    this.html = html;    this.url = url;  }  //...}// 通过一个工厂方法来创建Documentpublic class DocumentFactory {  private HtmlDownloader downloader;  public DocumentFactory(HtmlDownloader downloader) {    this.downloader = downloader;  }  public Document createDocument(String url) {    Html html = downloader.downloadHtml(url);    return new Document(url, html);  }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;高内聚 低耦合是比较通用的设计思想，可以用来指导不同的粒度的代码的设计和开发的工作，比如系统，模块，类，甚至是函数。也可以去使用到不同的开发场景当中，比如微服务，框架，组件，类库等等。&lt;/p&gt;
&lt;p&gt;在这个原则当中，高内聚指的是类本身的设计，低耦合指的是类和类之间的依赖关系
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="高内聚" scheme="https://www.llchen60.com/tags/%E9%AB%98%E5%86%85%E8%81%9A/"/>
    
      <category term="低耦合" scheme="https://www.llchen60.com/tags/%E4%BD%8E%E8%80%A6%E5%90%88/"/>
    
      <category term="迪米特" scheme="https://www.llchen60.com/tags/%E8%BF%AA%E7%B1%B3%E7%89%B9/"/>
    
  </entry>
  
  <entry>
    <title>DRY 原则</title>
    <link href="https://www.llchen60.com/DRY-%E5%8E%9F%E5%88%99/"/>
    <id>https://www.llchen60.com/DRY-%E5%8E%9F%E5%88%99/</id>
    <published>2020-03-22T03:01:51.000Z</published>
    <updated>2020-03-22T03:02:11.787Z</updated>
    
    <content type="html"><![CDATA[<p>Don’t repeat yourself </p><h1 id="1-实现逻辑的重复"><a href="#1-实现逻辑的重复" class="headerlink" title="1. 实现逻辑的重复"></a>1. 实现逻辑的重复</h1><pre><code>public class UserAuthenticator {  public void authenticate(String username, String password) {    if (!isValidUsername(username)) {      // ...throw InvalidUsernameException...    }    if (!isValidPassword(password)) {      // ...throw InvalidPasswordException...    }    //...省略其他代码...  }  private boolean isValidUsername(String username) {    // check not null, not empty    if (StringUtils.isBlank(username)) {      return false;    }    // check length: 4~64    int length = username.length();    if (length &lt; 4 || length &gt; 64) {      return false;    }    // contains only lowcase characters    if (!StringUtils.isAllLowerCase(username)) {      return false;    }    // contains only a~z,0~9,dot    for (int i = 0; i &lt; length; ++i) {      char c = username.charAt(i);      if (!(c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;z&#39;) || (c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;) || c == &#39;.&#39;) {        return false;      }    }    return true;  }  private boolean isValidPassword(String password) {    // check not null, not empty    if (StringUtils.isBlank(password)) {      return false;    }    // check length: 4~64    int length = password.length();    if (length &lt; 4 || length &gt; 64) {      return false;    }    // contains only lowcase characters    if (!StringUtils.isAllLowerCase(password)) {      return false;    }    // contains only a~z,0~9,dot    for (int i = 0; i &lt; length; ++i) {      char c = password.charAt(i);      if (!(c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;z&#39;) || (c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;) || c == &#39;.&#39;) {        return false;      }    }    return true;  }}</code></pre><p>这里想强调的是不一定完全一样的代码就意味着他们是需要合并的，比如上述的代码当中，isValidPassword还有isValidUsername有着基本上相同的逻辑结构，但是他们本身代表的是不同的意思的，虽然一样的逻辑，但是我们无法保证在接下来的一段时间以内，他们还能这样子一致下去。</p><p>所以合并为isValidUserOrPassword是不可以的，逻辑上讲不通，但是我们可以将上面在这个函数内部调用的方法进行分割的方式，来复用一些代码。</p><p>其实有一些使用组合的味道在里面了。</p><h1 id="2-功能语义的重复"><a href="#2-功能语义的重复" class="headerlink" title="2. 功能语义的重复"></a>2. 功能语义的重复</h1><p>对于功能语义重复的理解，是指一个代码包里在多个地方为了实现同样的功能，设定了不同的方法体。这大部分情况下都是因为沟通等方面的问题，不管里面使用的方法有什么不同，如果他们都是为了达成一样的，那么我们认为其实违反了DRY原则的，是需要清除多余的方法体的。</p><h1 id="3-代码执行重复"><a href="#3-代码执行重复" class="headerlink" title="3. 代码执行重复"></a>3. 代码执行重复</h1><p>看代码的内部逻辑，减少多次重复调用的代码。</p><p>注意IO操作，因为IO非常费时…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Don’t repeat yourself &lt;/p&gt;
&lt;h1 id=&quot;1-实现逻辑的重复&quot;&gt;&lt;a href=&quot;#1-实现逻辑的重复&quot; class=&quot;headerlink&quot; title=&quot;1. 实现逻辑的重复&quot;&gt;&lt;/a&gt;1. 实现逻辑的重复&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;pu
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
  </entry>
  
  <entry>
    <title>KISS and YAGNI原则</title>
    <link href="https://www.llchen60.com/KISS-and-YAGNI%E5%8E%9F%E5%88%99/"/>
    <id>https://www.llchen60.com/KISS-and-YAGNI%E5%8E%9F%E5%88%99/</id>
    <published>2020-03-21T03:24:37.000Z</published>
    <updated>2020-03-21T03:25:05.413Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-KISS"><a href="#1-KISS" class="headerlink" title="1. KISS"></a>1. KISS</h1><p>Keep it simple and stupid. </p><p>这个原则相对比较范范，其实着重在说的还是从代码的可读性和可维护性两个角度来衡量代码的质量。</p><pre><code>// 第一种实现方式: 使用正则表达式public boolean isValidIpAddressV1(String ipAddress) {  if (StringUtils.isBlank(ipAddress)) return false;  String regex = &quot;^(1\\d{2}|2[0-4]\\d|25[0-5]|[1-9]\\d|[1-9])\\.&quot;          + &quot;(1\\d{2}|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)\\.&quot;          + &quot;(1\\d{2}|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)\\.&quot;          + &quot;(1\\d{2}|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)$&quot;;  return ipAddress.matches(regex);}// 第二种实现方式: 使用现成的工具类public boolean isValidIpAddressV2(String ipAddress) {  if (StringUtils.isBlank(ipAddress)) return false;  String[] ipUnits = StringUtils.split(ipAddress, &#39;.&#39;);  if (ipUnits.length != 4) {    return false;  }  for (int i = 0; i &lt; 4; ++i) {    int ipUnitIntValue;    try {      ipUnitIntValue = Integer.parseInt(ipUnits[i]);    } catch (NumberFormatException e) {      return false;    }    if (ipUnitIntValue &lt; 0 || ipUnitIntValue &gt; 255) {      return false;    }    if (i == 0 &amp;&amp; ipUnitIntValue == 0) {      return false;    }  }  return true;}// 第三种实现方式: 不使用任何工具类public boolean isValidIpAddressV3(String ipAddress) {  char[] ipChars = ipAddress.toCharArray();  int length = ipChars.length;  int ipUnitIntValue = -1;  boolean isFirstUnit = true;  int unitsCount = 0;  for (int i = 0; i &lt; length; ++i) {    char c = ipChars[i];    if (c == &#39;.&#39;) {      if (ipUnitIntValue &lt; 0 || ipUnitIntValue &gt; 255) return false;      if (isFirstUnit &amp;&amp; ipUnitIntValue == 0) return false;      if (isFirstUnit) isFirstUnit = false;      ipUnitIntValue = -1;      unitsCount++;      continue;    }    if (c &lt; &#39;0&#39; || c &gt; &#39;9&#39;) {      return false;    }    if (ipUnitIntValue == -1) ipUnitIntValue = 0;    ipUnitIntValue = ipUnitIntValue * 10 + (c - &#39;0&#39;);  }  if (ipUnitIntValue &lt; 0 || ipUnitIntValue &gt; 255) return false;  if (unitsCount != 3) return false;  return true;}</code></pre><p>相对来说，第二种实现方式会更好一些，因为细节被封装在工具类当中，可读性相对强很多；方法一直接使用正则表达式，可读性会差很多；第三种自己来处理底层的逻辑，虽然执行起来相对会快一些，但是很容易出错。</p><h1 id="2-YAGNI"><a href="#2-YAGNI" class="headerlink" title="2. YAGNI"></a>2. YAGNI</h1><p>You ain’t gonna need it. </p><p>你不会需要它。深有感触，很多时候我们想写很优雅的代码，会疯狂向后考虑，比如对于不常用的功能，有的时候哪怕就一个方法，也想搞个接口供后面的扩展来使用。过度设计，反而增加了代码的阅读成本和维护成本。</p><p>我们不应当去设计当前用不到的功能，也不应该编写现在用不到的代码。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-KISS&quot;&gt;&lt;a href=&quot;#1-KISS&quot; class=&quot;headerlink&quot; title=&quot;1. KISS&quot;&gt;&lt;/a&gt;1. KISS&lt;/h1&gt;&lt;p&gt;Keep it simple and stupid. &lt;/p&gt;
&lt;p&gt;这个原则相对比较范范，其实着重在说
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
  </entry>
  
  <entry>
    <title>SOLID - 依赖反转原则</title>
    <link href="https://www.llchen60.com/SOLID-%E4%BE%9D%E8%B5%96%E5%8F%8D%E8%BD%AC%E5%8E%9F%E5%88%99/"/>
    <id>https://www.llchen60.com/SOLID-%E4%BE%9D%E8%B5%96%E5%8F%8D%E8%BD%AC%E5%8E%9F%E5%88%99/</id>
    <published>2020-03-19T03:53:05.000Z</published>
    <updated>2020-03-19T03:53:34.823Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-控制反转-IOC-Inversion-of-Control"><a href="#1-控制反转-IOC-Inversion-of-Control" class="headerlink" title="1. 控制反转 IOC Inversion of Control"></a>1. 控制反转 IOC Inversion of Control</h1><pre><code>public class UserServiceTest {  public static boolean doTest() {    // ...   }  public static void main(String[] args) {//这部分逻辑可以放到框架中    if (doTest()) {      System.out.println(&quot;Test succeed.&quot;);    } else {      System.out.println(&quot;Test failed.&quot;);    }  }}</code></pre><p>上述代码程序员在自己控制整个代码的运行顺序和执行,可以看到如果我想增加test的话，就要在main函数里面添加，同时在UserServiceTest当中添加实例。而使用框架的话，代码就可以变成如下：</p><pre><code>public abstract class TestCase {  public void run() {    if (doTest()) {      System.out.println(&quot;Test succeed.&quot;);    } else {      System.out.println(&quot;Test failed.&quot;);    }  }  public abstract boolean doTest();}public class JunitApplication {  private static final List&lt;TestCase&gt; testCases = new ArrayList&lt;&gt;();  public static void register(TestCase testCase) {    testCases.add(testCase);  }  public static final void main(String[] args) {    for (TestCase case: testCases) {      case.run();    }  }</code></pre><p>上面的代码我们将测试的注册和运行都交给了JunitApplication了，然后我们要写新test，就让我们的concrete class extends TestCase类，来填充我们需要做的各种测试。</p><p>通过这种方式，我们实现了使用框架来控制整个代码的运转，我们使用框架来<strong>组装对象，管理整个执行流程</strong>。程序员利用框架进行开发的时候，只需要往预留的扩展点上，添加跟自己业务相关的代码，然后利用框架来驱动整个程序流程的执行。</p><p>控制反转是一种思想，有很多的具体的实现方式</p><h1 id="2-控制反转-–-依赖注入"><a href="#2-控制反转-–-依赖注入" class="headerlink" title="2. 控制反转 – 依赖注入"></a>2. 控制反转 – 依赖注入</h1><p>是控制反转的一种具体实现的方式，他的实际操作的指南是 – 不通过new（）的方式在类内部创建依赖类的对象，而是将依赖的类对象在外部创建好以后，通过构造函数，函数参数的方式传递进来给类使用。</p><pre><code>// 非依赖注入实现方式public class Notification {  private MessageSender messageSender;  public Notification() {    this.messageSender = new MessageSender(); //此处有点像hardcode  }  public void sendMessage(String cellphone, String message) {    //...省略校验逻辑等...    this.messageSender.send(cellphone, message);  }}public class MessageSender {  public void send(String cellphone, String message) {    //....  }}// 使用NotificationNotification notification = new Notification();// 依赖注入的实现方式public class Notification {  private MessageSender messageSender;  // 通过构造函数将messageSender传递进来  public Notification(MessageSender messageSender) {    this.messageSender = messageSender;  }  public void sendMessage(String cellphone, String message) {    //...省略校验逻辑等...    this.messageSender.send(cellphone, message);  }}//使用NotificationMessageSender messageSender = new MessageSender();Notification notification = new Notification(messageSender);</code></pre><p>使用依赖注入的最大好处就是，我们不需要在具体的类当中实例化其他的类，这样就实现了解耦，即他的具体实现我们可以在外部做其他方式的实例，这个时候多态也可以派上用场。可以想成我在类的内部占了个座，至于这个座具体要给谁坐，怎么坐，得等到节目要开始之前再来安排，这样我就可以举办不同的活动了。</p><pre><code>public class Notification {  private MessageSender messageSender;  public Notification(MessageSender messageSender) {    this.messageSender = messageSender;  }  public void sendMessage(String cellphone, String message) {    this.messageSender.send(cellphone, message);  }}public interface MessageSender {  void send(String cellphone, String message);}// 短信发送类public class SmsSender implements MessageSender {  @Override  public void send(String cellphone, String message) {    //....  }}// 站内信发送类public class InboxSender implements MessageSender {  @Override  public void send(String cellphone, String message) {    //....  }}//使用NotificationMessageSender messageSender = new SmsSender();Notification notification = new Notification(messageSender);</code></pre><h1 id="3-依赖反转原则"><a href="#3-依赖反转原则" class="headerlink" title="3. 依赖反转原则"></a>3. 依赖反转原则</h1><p>依赖反转 – Dependency Inversion Principle </p><blockquote><p>High-level modules shouldn’t depend on low-level modules. Both modules should depend on abstractions. In addition, abstractions shouldn’t depend on details. Details depend on abstractions.</p></blockquote><p>高层模块（high-level modules）不要依赖低层模块（low-level）。高层模块和低层模块应该通过抽象（abstractions）来互相依赖。除此之外，抽象（abstractions）不要依赖具体实现细节（details），具体实现细节（details）依赖抽象（abstractions）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-控制反转-IOC-Inversion-of-Control&quot;&gt;&lt;a href=&quot;#1-控制反转-IOC-Inversion-of-Control&quot; class=&quot;headerlink&quot; title=&quot;1. 控制反转 IOC Inversion of Contr
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="SOLID" scheme="https://www.llchen60.com/tags/SOLID/"/>
    
  </entry>
  
  <entry>
    <title>SOLID - 接口隔离原则</title>
    <link href="https://www.llchen60.com/SOLID-%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99/"/>
    <id>https://www.llchen60.com/SOLID-%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99/</id>
    <published>2020-03-17T01:26:08.000Z</published>
    <updated>2020-03-17T01:26:41.608Z</updated>
    
    <content type="html"><![CDATA[<p>接口隔离原则 – interface segregation principle </p><p>客户端不应该强迫依赖它不需要的接口。</p><h1 id="1-将接口视为一组API接口的集合"><a href="#1-将接口视为一组API接口的集合" class="headerlink" title="1. 将接口视为一组API接口的集合"></a>1. 将接口视为一组API接口的集合</h1><pre><code>public interface UserService {  boolean register(String cellphone, String password);  boolean login(String cellphone, String password);  UserInfo getUserInfoById(long id);  UserInfo getUserInfoByCellphone(String cellphone);}public class UserServiceImpl implements UserService {  //...}</code></pre><p>当我们要实现删除操作的时候，最好不要直接在UserService里面加上这个方法，因为用户服务实质上不应该被默认直接具有删除的权限，相对应的，我们应该去创建一个新的接口，里面实现有删除相关的方法，实现接口的隔离。</p><pre><code>public interface UserService {  boolean register(String cellphone, String password);  boolean login(String cellphone, String password);  UserInfo getUserInfoById(long id);  UserInfo getUserInfoByCellphone(String cellphone);}public interface RestrictedUserService {  boolean deleteUserByCellphone(String cellphone);  boolean deleteUserById(long id);}public class UserServiceImpl implements UserService, RestrictedUserService {  // ...省略实现代码...}</code></pre><h1 id="2-将接口理解为单个API接口或者函数"><a href="#2-将接口理解为单个API接口或者函数" class="headerlink" title="2. 将接口理解为单个API接口或者函数"></a>2. 将接口理解为单个API接口或者函数</h1><p>函数的设计需要功能单一，不要将多个不同的功能逻辑放在一个函数当中实现。</p><pre><code>public class Statistics {  private Long max;  private Long min;  private Long average;  private Long sum;  private Long percentile99;  private Long percentile999;  //...省略constructor/getter/setter等方法...}public Statistics count(Collection&lt;Long&gt; dataSet) {  Statistics statistics = new Statistics();  //...省略计算逻辑...  return statistics;}</code></pre><p>count方法算了太多不同的指标，应该将其分割开的。</p><pre><code>public Long max(Collection&lt;Long&gt; dataSet) { //... }public Long min(Collection&lt;Long&gt; dataSet) { //... } public Long average(Colletion&lt;Long&gt; dataSet) { //... }// ...省略其他统计函数...</code></pre><h1 id="3-将接口理解为OOP中的接口的概念"><a href="#3-将接口理解为OOP中的接口的概念" class="headerlink" title="3. 将接口理解为OOP中的接口的概念"></a>3. 将接口理解为OOP中的接口的概念</h1><p>即在设计接口的时候尽量减少大而全的接口的设计，每个接口都只做一件事情，这样子类在implement interface的时候，我们通过接口名也可以很清晰的知道在做什么，会有什么功能，也很大程度上提升了代码的复用性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;接口隔离原则 – interface segregation principle &lt;/p&gt;
&lt;p&gt;客户端不应该强迫依赖它不需要的接口。&lt;/p&gt;
&lt;h1 id=&quot;1-将接口视为一组API接口的集合&quot;&gt;&lt;a href=&quot;#1-将接口视为一组API接口的集合&quot; class=&quot;he
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="SOLID" scheme="https://www.llchen60.com/tags/SOLID/"/>
    
  </entry>
  
  <entry>
    <title>SOLID - 里氏替换原则</title>
    <link href="https://www.llchen60.com/SOLID-%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99/"/>
    <id>https://www.llchen60.com/SOLID-%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99/</id>
    <published>2020-03-14T04:33:36.000Z</published>
    <updated>2020-03-14T04:34:42.521Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Intro"><a href="#1-Intro" class="headerlink" title="1. Intro"></a>1. Intro</h1><p>里氏替代原则 - Liskov Substitution Principle </p><p>讲述的是子类对象需要能够替换程序当中父类对象出现的任何地方，并且保证原来程序的逻辑性为不变以及正确性不被破坏。</p><pre><code>public class Transporter {  private HttpClient httpClient;  public Transporter(HttpClient httpClient) {    this.httpClient = httpClient;  }  public Response sendRequest(Request request) {    // ...use httpClient to send request  }}public class SecurityTransporter extends Transporter {  private String appId;  private String appToken;  public SecurityTransporter(HttpClient httpClient, String appId, String appToken) {    super(httpClient);    this.appId = appId;    this.appToken = appToken;  }  @Override  public Response sendRequest(Request request) {    if (StringUtils.isNotBlank(appId) &amp;&amp; StringUtils.isNotBlank(appToken)) {      request.addPayload(&quot;app-id&quot;, appId);      request.addPayload(&quot;app-token&quot;, appToken);    }    return super.sendRequest(request);  }}public class Demo {      public void demoFunction(Transporter transporter) {        Reuqest request = new Request();    //...省略设置request中数据值的代码...    Response response = transporter.sendRequest(request);    //...省略其他逻辑...  }}// 里式替换原则Demo demo = new Demo();demo.demofunction(new SecurityTransporter(/*省略参数*/););</code></pre><h1 id="2-里氏替代原则-–-按照协议进行设计"><a href="#2-里氏替代原则-–-按照协议进行设计" class="headerlink" title="2. 里氏替代原则 – 按照协议进行设计"></a>2. 里氏替代原则 – 按照协议进行设计</h1><p>子类在设计的时候，应当遵守父类的行为约定。父类定义了函数的行为约定，那么子类可以改变函数的内部实现逻辑，但不能改变函数原有的行为约定。  </p><p>这里的行为约定指的是函数声明的要实现的功能；对于输入输出以及异常的约定</p><p>定义当中父类和子类之间的关系，也是可以替换成接口和实现类之间的关系的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Intro&quot;&gt;&lt;a href=&quot;#1-Intro&quot; class=&quot;headerlink&quot; title=&quot;1. Intro&quot;&gt;&lt;/a&gt;1. Intro&lt;/h1&gt;&lt;p&gt;里氏替代原则 - Liskov Substitution Principle &lt;/p&gt;
&lt;p&gt;讲
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="SOLID" scheme="https://www.llchen60.com/tags/SOLID/"/>
    
  </entry>
  
</feed>
