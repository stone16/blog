<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Leilei&#39;s Blog | 磊磊的博客</title>
  
  <subtitle>Because it&#39;s there</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.llchen60.com/"/>
  <updated>2020-02-04T17:14:06.176Z</updated>
  <id>https://www.llchen60.com/</id>
  
  <author>
    <name>Leilei Chen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Handling overload effectively with load balancers</title>
    <link href="https://www.llchen60.com/Handling-overload-effectively-with-load-balancers/"/>
    <id>https://www.llchen60.com/Handling-overload-effectively-with-load-balancers/</id>
    <published>2020-02-04T17:13:39.000Z</published>
    <updated>2020-02-04T17:14:06.176Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Fail-Smarter"><a href="#1-Fail-Smarter" class="headerlink" title="1. Fail Smarter"></a>1. Fail Smarter</h1><ul><li>Average latency has a spike, availability down</li><li>reasons <ul><li>dependencies </li><li>cascading effect </li><li>client change   peak </li></ul></li></ul><h1 id="2-Load-balancers"><a href="#2-Load-balancers" class="headerlink" title="2. Load balancers"></a>2. Load balancers</h1><ul><li>clients - load balancers - servers </li><li>hardware devices </li><li>multi tenant - use VIP - for efficiency </li><li>used for (features)<ul><li>scaling </li><li>even traffic distribution </li><li>overload protection</li></ul></li><li>how<ul><li>how to pick a server <ul><li>random dice </li><li>round robin </li><li>least conns </li></ul></li><li>desired algorithm - we use least conns <ul><li>simple </li><li>reliable </li><li>even </li></ul></li><li>max conns? </li><li>how to deal with overload? <ul><li>attributes <ul><li>cheap </li><li>local </li><li>buffering - having capacity soon </li><li>priority </li></ul></li><li>reject requests  - spillover - choose! <ul><li>close the TCP connection </li><li>no buffer </li></ul></li><li>hang on, wait in a queue - surge queue <ul><li>may mkes it take longer</li></ul></li></ul></li></ul></li><li>some default we set - maxConns - perhost setting <ul><li>little’s law <ul><li>arrival rate * time shopping = people in the store </li></ul></li><li>see load balancers how many services we have </li><li>fleet-wide concurrent requests / host count = <strong>avg conns</strong></li></ul></li></ul><ul><li>metrics matter <ul><li>latency netwrok latency + 25% <ul><li>client side </li><li>server side </li></ul></li><li>request rate </li></ul></li><li>coral server <ul><li>concurrent requests - outstanding request - in one host </li></ul></li><li>33% overhead room - dependency failures </li></ul><h1 id="3-Actual-behave"><a href="#3-Actual-behave" class="headerlink" title="3. Actual behave"></a>3. Actual behave</h1><ul><li>increase load to see average latency </li><li>run actual test </li><li>generate graph with outstanding requests <ul><li>see the cross of client timeout and p99 </li></ul></li></ul><h1 id="4-Abnormal-cases"><a href="#4-Abnormal-cases" class="headerlink" title="4. Abnormal cases"></a>4. Abnormal cases</h1><ul><li>dependency latency, timeout </li><li>network  packet loss </li></ul><ul><li>let server decide what’s the maxCon should be </li><li>coral has<ul><li>connection </li><li>worker  work thread </li></ul></li><li>classify requests <ul><li>importance <ul><li>droppable </li></ul></li><li>priority <ul><li>order  </li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Fail-Smarter&quot;&gt;&lt;a href=&quot;#1-Fail-Smarter&quot; class=&quot;headerlink&quot; title=&quot;1. Fail Smarter&quot;&gt;&lt;/a&gt;1. Fail Smarter&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Average latenc
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Load Balancers" scheme="https://www.llchen60.com/tags/Load-Balancers/"/>
    
  </entry>
  
  <entry>
    <title>Google Dagger Tutorial</title>
    <link href="https://www.llchen60.com/Google-Dagger-Tutorial/"/>
    <id>https://www.llchen60.com/Google-Dagger-Tutorial/</id>
    <published>2020-02-04T17:12:52.000Z</published>
    <updated>2020-02-04T17:14:18.480Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Comparisons"><a href="#1-Comparisons" class="headerlink" title="1. Comparisons"></a>1. Comparisons</h1><p>Spring is a giant collection of libraries and utilities. with a lot of integration, an XML configuration, runtime/ reflective bindings. Application already using Spring can use its dependency injection smoothly. </p><p>Dependency is only a small part of it. Guice and Dagger is lightweight and only a dependency injection framework</p><p>Dagger is very lightweight framework with very few integrations, java interface/ annotation configuration, and compile-time code generated bindings. </p><p>For dependency injection and IOC container, there is <a href="https://llchen60.com/IOC%E5%AE%B9%E5%99%A8%E5%92%8CDependency-Injection%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">a post in Chinese</a> wrote last year.</p><p>Also a big difference between those DI framework is when does the injection happen, compile time or runtime? </p><p>Run-time DI is <strong>based on reflection</strong> which is simpler to use but slower at run-time —- Spring, Guice </p><p>Compile-time DI is <strong>based on code generation</strong>. This means that all the heavy-weight operations are performed during compilation. It adds complexity but generally performs faster</p><h1 id="2-Implementation"><a href="#2-Implementation" class="headerlink" title="2. Implementation"></a>2. Implementation</h1><ul><li>POJO</li><li>Module<ul><li>a class provides or builds the objects’ dependencies </li></ul></li><li>Component<ul><li>an interface used to generate the injector </li></ul></li></ul><h2 id="2-1-POJO"><a href="#2-1-POJO" class="headerlink" title="2.1 POJO"></a>2.1 POJO</h2><pre><code>public class Car {    private Engine engine;    private Brand brand;    @Inject    public Car(Engine engine, Brand brand) {        this.engine = engine;        this.brand = brand;    }    // getters and setters}</code></pre><h2 id="2-2-Module"><a href="#2-2-Module" class="headerlink" title="2.2 Module"></a>2.2 Module</h2><pre><code>@Module // similar to @Controller  @Service public class VehiclesModule {    @Provides // similar to @Bean     public Engine provideEngine() {        return new Engine();    }    @Provides    @Singleton    public Brand provideBrand() {         return new Brand(&quot;lol&quot;);     }}</code></pre><h2 id="2-3-Component"><a href="#2-3-Component" class="headerlink" title="2.3 Component"></a>2.3 Component</h2><p>here we could return the real object we want to be the starting point of the whole mechanism:</p><p>Dagger will start from here, go through all the @Inject and satisfy those dependencies. In our example, will create engine and brand object. </p><pre><code>@Singleton@Component(modules = VehiclesModule.class)public interface VehiclesComponent {    Car buildCar();}</code></pre><h2 id="2-4-client-side"><a href="#2-4-client-side" class="headerlink" title="2.4 client side"></a>2.4 client side</h2><p>Notice: <code>DaggerVehiclesComponent</code> is created by dagger automatically. </p><pre><code>VehiclesComponent component = DaggerVehiclesComponent.create();Car eg = component.buildCar();</code></pre><h1 id="3-Dagger-User-Guide"><a href="#3-Dagger-User-Guide" class="headerlink" title="3. Dagger User Guide"></a>3. Dagger User Guide</h1><h2 id="3-1-Declaring-Dependencies"><a href="#3-1-Declaring-Dependencies" class="headerlink" title="3.1 Declaring Dependencies"></a>3.1 Declaring Dependencies</h2><p>Dagger constructs instances of application classes and satisfies their dependencies. It uses @Inject annotation to identify which constructors and fields it is interested in. </p><h2 id="3-2-Satisfying-Dependencies"><a href="#3-2-Satisfying-Dependencies" class="headerlink" title="3.2 Satisfying Dependencies"></a>3.2 Satisfying Dependencies</h2><p>By default, Dagger satisfies each dependency by constructing an instance of the requested type. It call <code>new SomeObject()</code> and setting its injectable fields. </p><ul><li>@Inject <ul><li>interfaces cannot be constructed </li><li>third party classes cannot be annotated </li><li>configurable objects must be configured </li></ul></li><li>Instead, use @provides <ul><li>all @provides methods should be named with a provide prefix and module classes are named with a Module suffix </li></ul></li></ul><h2 id="3-3-Building-the-Graph"><a href="#3-3-Building-the-Graph" class="headerlink" title="3.3 Building the Graph"></a>3.3 Building the Graph</h2><p>The @Inject and @Provides annotated classes form a graph of objects, linked by their dependencies. Build the application by <strong>an interface with methods that have no arguments and return the desired type</strong>. </p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://stackoverflow.com/questions/39688830/why-use-develop-guice-when-you-have-spring-and-dagger" target="_blank" rel="noopener">https://stackoverflow.com/questions/39688830/why-use-develop-guice-when-you-have-spring-and-dagger</a></li><li><a href="https://www.baeldung.com/dagger-2" target="_blank" rel="noopener">https://www.baeldung.com/dagger-2</a></li><li><a href="https://rskupnik.github.io/dependency-injection-in-pet-project-dagger2" target="_blank" rel="noopener">https://rskupnik.github.io/dependency-injection-in-pet-project-dagger2</a></li><li><a href="https://dagger.dev/" target="_blank" rel="noopener">https://dagger.dev/</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Comparisons&quot;&gt;&lt;a href=&quot;#1-Comparisons&quot; class=&quot;headerlink&quot; title=&quot;1. Comparisons&quot;&gt;&lt;/a&gt;1. Comparisons&lt;/h1&gt;&lt;p&gt;Spring is a giant collec
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
      <category term="Dagger" scheme="https://www.llchen60.com/tags/Dagger/"/>
    
      <category term="DI" scheme="https://www.llchen60.com/tags/DI/"/>
    
  </entry>
  
  <entry>
    <title>Executor, ExecutorService and Executors</title>
    <link href="https://www.llchen60.com/Executor-ExecutorService-and-Executors/"/>
    <id>https://www.llchen60.com/Executor-ExecutorService-and-Executors/</id>
    <published>2020-02-04T17:11:48.000Z</published>
    <updated>2020-02-04T17:12:16.419Z</updated>
    
    <content type="html"><![CDATA[<p>Executor, ExecutorService and Executors, they are all part of Java’s Executor framework, this framework offers a threadpool. Thus we don’t need to manage threads on our own, the pool can help us manage themselves. </p><p>A thread pool which is created when an application is a startup solves both of these problems. It has <strong>ready threads</strong> to serve clients when needed and it also has a bound on how many threads to create under load.</p><h1 id="1-Executor"><a href="#1-Executor" class="headerlink" title="1. Executor"></a>1. Executor</h1><p><strong>the core interface</strong> which is an abstraction for parallel execution</p><p>It separates task from execution, this is different from java.lang.Thread class which <strong>combines both task and its execution</strong>. </p><h1 id="2-ExecutorService"><a href="#2-ExecutorService" class="headerlink" title="2. ExecutorService"></a>2. ExecutorService</h1><p>ExecutorService is an extension of Executor interface and provides a facility for returning a Future object and terminate, or shut down the thread pool. Once the shutdown is called, the thread pool will not accept new task but complete any pending task. It also provides a submit() method which extends Executor.execute() method and returns a Future.</p><p>The Future object provides the facility of asynchronous execution, which means you don’t need to wait until the execution finishes, you can just submit the task and go around, come back and check if Future object has the result, if execution is completed then it would have result which you can access by using the Future.get() method. Just remember that this method is a <strong>blocking method</strong> i.e. it will wait until execution finish and the result is available if it’s not finished already.</p><p>By using the Future object returned by ExecutorService.submit() method, you can also cancel the execution if you are not interested anymore. It provides cancel() method to cancel any pending execution.</p><h1 id="3-Executors"><a href="#3-Executors" class="headerlink" title="3. Executors"></a>3. Executors</h1><p>Third one Executors is a utility class similar to Collections, which provides <strong>factory methods</strong> to create different types of thread pools e.g. fixed and cached thread pools. Let’s see some more difference between these three classes.</p><h1 id="4-Difference"><a href="#4-Difference" class="headerlink" title="4. Difference"></a>4. Difference</h1><p>1) One of the key difference between Executor and ExecutorService interface is that <strong>former is a parent interface while ExecutorService extends Executor</strong> i.e. it’s a sub-interface of Executor.</p><p>2) Another important difference between ExecutorService and Executor is that Executor defines execute() method which accepts an object of the Runnable interface, while submit() method can accept objects of both Runnable and Callable interfaces.</p><p>3) The third difference between Executor and ExecutorService interface is that execute() method doesn’t return any result, its return type is void but submit() method returns the result of computation via a Future object. This is also the key difference between submit() and execute() method, which is one of the frequently asked Java concurrency interview questions.</p><p>4) The fourth difference between ExecutorService and Executor interface is that apart from allowing a client to submit a task, <strong>ExecutorService also provides methods to control the thread pool</strong> e.g. terminate the thread pool by calling the shutDown() method. You should also read “Java Concurrency in Practice” to learn more about the graceful shutdown of a thread-pool and how to handle pending tasks.</p><p>5) Executors class provides factory methods to create different kinds of thread pools e.g. newSingleThreadExecutor() creates a thread pool of just one thread, newFixedThreadPool(int numOfThreads) creates a thread pool of fixed number of threads and newCachedThreadPool() creates new threads when needed but reuse the existing threads if they are available.</p><h1 id="5-Differences-between-Executor-and-Thread"><a href="#5-Differences-between-Executor-and-Thread" class="headerlink" title="5. Differences between Executor and Thread"></a>5. Differences between Executor and Thread</h1><ol><li>Executor provides a thread pool in java, while Thread not. </li><li>java.lang.Thread is a class in Java while java.util.concurrent.Executor is an interface.</li><li>The Executor concept is actually an abstraction over parallel computation. It allows concurrent code to be run in managed way. On the other hand, Thread is a concrete way to run the code in parallel.</li><li>Executor decouples a task (the code which needs to be executed in parallel) from execution, while in the case of a Thread, both task and execution are tightly coupled.</li><li>The Executor concept allows your task is to be executed by a worker thread from the thread pool, while Thread itself execute your task</li><li>a Thread can only execute one Runnable task but an Executor can execute any number of Runnable task.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Executor, ExecutorService and Executors, they are all part of Java’s Executor framework, this framework offers a threadpool. Thus we don’
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>EnumMap vs HashMap</title>
    <link href="https://www.llchen60.com/EnumMap-vs-HashMap/"/>
    <id>https://www.llchen60.com/EnumMap-vs-HashMap/</id>
    <published>2020-02-04T17:10:34.000Z</published>
    <updated>2020-02-04T17:11:21.139Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-EnumMap"><a href="#1-EnumMap" class="headerlink" title="1. EnumMap"></a>1. EnumMap</h1><ul><li>Can only be used with <strong>enum type</strong> keys </li><li>It’s specialized implementation of Map Interface for use with enum type keys</li><li>Internally using <strong>arrays</strong> </li><li>stored in <strong>natural order</strong></li><li>not possible for collision </li><li>much efficient compared with HashMap </li></ul><h1 id="2-HashMap"><a href="#2-HashMap" class="headerlink" title="2. HashMap"></a>2. HashMap</h1><ul><li>Extends AbstrctMap and implement Map interface </li><li>Internally using hashTable</li><li>Possible for collision </li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://www.geeksforgeeks.org/enummap-class-java-example/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/enummap-class-java-example/</a> </li><li><a href="https://walkingtechie.blogspot.com/2017/03/difference-between-enummap-and-hashmap.html" target="_blank" rel="noopener">https://walkingtechie.blogspot.com/2017/03/difference-between-enummap-and-hashmap.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-EnumMap&quot;&gt;&lt;a href=&quot;#1-EnumMap&quot; class=&quot;headerlink&quot; title=&quot;1. EnumMap&quot;&gt;&lt;/a&gt;1. EnumMap&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Can only be used with &lt;strong&gt;enum
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Effective Java</title>
    <link href="https://www.llchen60.com/Effective-Java/"/>
    <id>https://www.llchen60.com/Effective-Java/</id>
    <published>2020-02-04T17:09:44.000Z</published>
    <updated>2020-02-04T17:10:04.050Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-General-Programming"><a href="#1-General-Programming" class="headerlink" title="1. General Programming"></a>1. General Programming</h1><h2 id="1-1-Scope-of-Local-variables"><a href="#1-1-Scope-of-Local-variables" class="headerlink" title="1.1 Scope of Local variables"></a>1.1 Scope of Local variables</h2><pre><code>for (Iterator&lt;Element&gt; i = c.iterator(); i.hasNext(); ) {    Element e = i.next();    ... // Do something with e and i}// code with bugIterator&lt;Element&gt; i2 = c2.iterator();while (i.hasNext()) {    Element e2 = i2.next();    ... // Do something with e2 and i2}</code></pre><p>i - i2. causing a runtime bug. This bug can be caught at compile time if you <strong>use local variable with minimal scope</strong>. </p><ol><li>Declare the scope of a local variable where it is first used </li><li>initialize every local variable</li><li>prefer for loops to while loops </li><li>keep methods small and focused on a single task </li></ol><h2 id="1-2-Use-library"><a href="#1-2-Use-library" class="headerlink" title="1.2 Use library"></a>1.2 Use library</h2><p>Use library will give you some advantages:</p><ul><li>The knowledge of experts who implemented it and the experience of others who used it before you. </li><li>Better performance that is implemented by experts.</li><li>New features that are added to the libraries in every major release. </li></ul><h2 id="1-3-Float-Double-and-Exact-Calculations"><a href="#1-3-Float-Double-and-Exact-Calculations" class="headerlink" title="1.3 Float, Double and Exact Calculations"></a>1.3 Float, Double and Exact Calculations</h2><pre><code>int getPossibleBoughtItems() {    double dollarFunds = 1.0;    int numItems = 0;    for (double price = 0.10; dollarFunds &gt;= price; price += 0.10) {        dollarFunds -= price;        numItems++;    }    return numItems;}</code></pre><p>We should use BigDecimal, int or long for exact calculations. We should avoid using float and double for exact calculations because they are carefully designed for accurate approximations in scientific and engineering calculations. </p><p>Note that the first method above will return 3, which is wrong, with funds left of $0.3999999999999999. The correct return should be 4, with funds left 0 (see the second implementation).</p><h2 id="1-4-Primitive-Types-and-Boxed-Primitives"><a href="#1-4-Primitive-Types-and-Boxed-Primitives" class="headerlink" title="1.4 Primitive Types and Boxed Primitives"></a>1.4 Primitive Types and Boxed Primitives</h2><p>When possible, you should use primitives, instead of boxed primitives, because: </p><ol><li>Unnecessary use of boxed primitives may result in a hideously slow program because of repeated boxed and unboxed operations. </li><li>whenboxes primitives are used, applying <code>==</code> operator is almost always wrong and can lead to deadly bugs that are difficult to discover. </li></ol><h2 id="1-5-Use-of-Strings-and-Other-Types"><a href="#1-5-Use-of-Strings-and-Other-Types" class="headerlink" title="1.5 Use of Strings and Other Types"></a>1.5 Use of Strings and Other Types</h2><pre><code>// goodpublic final class ThreadLocal&lt;T&gt; {    public ThreadLocal() {};    public void set (T value) {...};    public T get() {...};}// not good public final class ThreadLocal {    private ThreadLocal() {};    public static void set (String key, Object value) {...};    public static Object get(String key) {...};}</code></pre><p>We should avoid using String, because it is poor substitutes for other value types, or aggregate types, or capacity types. It is cumbersome, slower, error-prone and inflexible than other types. </p><h2 id="1-6-String-Builder-and-String-Concatenation"><a href="#1-6-String-Builder-and-String-Concatenation" class="headerlink" title="1.6 String Builder and String Concatenation"></a>1.6 String Builder and String Concatenation</h2><p>Use String Builder instead of String Concatenation, due to its poor performance. </p><pre><code>// Good public String firstNamesToString(List&lt;Person&gt; members) {    StringBuilder sb = new StringBuilder();    for (Person p : members) {        sb.append(&quot;[&quot;);        sb.append(p.firstName);        sb.append(&quot;]&quot;);    }    return sb.toString();}// Bad public String firstNamesToString(List&lt;Person&gt; members) {    String s = &quot;&quot;;    for (Person p : members) {        s += &quot;[&quot; + p.firstName + &quot;]&quot;;    }    return s;}</code></pre><h2 id="1-7-Interface-and-Class-reference"><a href="#1-7-Interface-and-Class-reference" class="headerlink" title="1.7 Interface and Class reference"></a>1.7 Interface and Class reference</h2><p>Use of interface reference </p><pre><code>public List&lt;Person&gt; getPeopleByFirstName(List&lt;Person&gt; members, String firstName) {}</code></pre><p>It would be desirable, more flexible and more backward-compatible to use interface types to refer to parameters, return values, variables and fields if appropriate interface types exist. If appropriate interface types do not exist, use least specific class types to refer to parameters, return values, variables and fields if appropriate interface types do not exist. </p><h1 id="2-Objects"><a href="#2-Objects" class="headerlink" title="2. Objects"></a>2. Objects</h1><h2 id="2-1-Static-Factory-Methods-and-Constructors"><a href="#2-1-Static-Factory-Methods-and-Constructors" class="headerlink" title="2.1 Static Factory Methods and Constructors"></a>2.1 Static Factory Methods and Constructors</h2><p>You are designing a class such as Date and you want to allow a client to obtain an instance of the class, given some input such as instant.</p><p>We should use static factory methods because Factory method has following advantages: </p><ol><li>have names </li><li>not required to create a new object each time invoked </li><li>can return an object of any subtype of their return type </li><li>decouple service provider frameworks </li></ol><h2 id="2-2-Builders-and-Constructors"><a href="#2-2-Builders-and-Constructors" class="headerlink" title="2.2 Builders and Constructors"></a>2.2 Builders and Constructors</h2><p>Use builders since it makes code easier for reading</p><h2 id="2-3-Singleton"><a href="#2-3-Singleton" class="headerlink" title="2.3 Singleton"></a>2.3 Singleton</h2><h3 id="2-3-1-Use-of-enum"><a href="#2-3-1-Use-of-enum" class="headerlink" title="2.3.1 Use of enum"></a>2.3.1 Use of enum</h3><pre><code>public enum MySingleton {    INSTANCE;    public void getDataByMarketplaceId(MarketplaceId id) { ... }}</code></pre><h3 id="2-3-2-Use-of-static-factory"><a href="#2-3-2-Use-of-static-factory" class="headerlink" title="2.3.2 Use of static factory"></a>2.3.2 Use of static factory</h3><pre><code>public class MySingleton {    private static final MySingleton INSTANCE = new MySingleton();    private MySingleton() { ... }    public static MySingleton getInstance() { return INSTANCE; }    public void getDataByMarketplaceId(MarketplaceId id) { ... }}</code></pre><h2 id="2-4-Reusable-Objects"><a href="#2-4-Reusable-Objects" class="headerlink" title="2.4 Reusable Objects"></a>2.4 Reusable Objects</h2><pre><code>public class RomanNumber {    private static Pattern ROMAN = Pattern.compile(&quot;^(?=.)M*(C[MD]|D?C{0,3})(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$&quot;);    static boolean isRomanNumber(String s) {        return ROMAN.matcher(s).matches();    }}</code></pre><p>Reuse the expensive objects(here is Pattern), in performace critical situations. </p><h1 id="3-Classes"><a href="#3-Classes" class="headerlink" title="3. Classes"></a>3. Classes</h1><h2 id="3-1-Accessibility-of-Classes-and-Members"><a href="#3-1-Accessibility-of-Classes-and-Members" class="headerlink" title="3.1 Accessibility of Classes and Members"></a>3.1 Accessibility of Classes and Members</h2><p>Avoid using a public array because a nonzero length array is always mutable, and thus clients will be able to modify the elements of the array. </p><h2 id="3-2-Mutability"><a href="#3-2-Mutability" class="headerlink" title="3.2 Mutability"></a>3.2 Mutability</h2><p>In general, classes should be immutable unless there’s a very good reason to make them mutable; and if so, you should minimize mutability when designing and implementing classes. Rules to make a class immutable: </p><ol><li>Don’t provide methods that modify the state of objects that you want to be immutable. </li><li>Ensure that the class cann’t be extended.</li><li>Make all fields final to express your intent clearly</li><li>Make all fields private to prevent clients from obtaining access to mutable objects </li><li>Ensure exclusive access to any mutable components</li></ol><p>Try to use more immutability, since it offers benefits byu nature: </p><ol><li>Immutable objects are simple: providing failure atomicity </li><li>Inherently thread-safe, require no synchronization </li><li>Can share immutable objects freely</li><li>Immutable objects make great building blocks for other objects. </li></ol><h2 id="3-3-Interfaces-and-Abstract-Classes"><a href="#3-3-Interfaces-and-Abstract-Classes" class="headerlink" title="3.3 Interfaces and Abstract Classes"></a>3.3 Interfaces and Abstract Classes</h2><p>In general, use of interfaces is the best way to define a type that permits multiple implementations because a class can implement multiple interfaces whereas it cannot extend multiple abstract classes. </p><h2 id="3-4-Static-Member-Classes"><a href="#3-4-Static-Member-Classes" class="headerlink" title="3.4 Static Member Classes"></a>3.4 Static Member Classes</h2><pre><code>public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable {    ...    static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {        final int hash;        final K key;        V value;        Node&lt;K,V&gt; next;        ...        public final K getKey()        { return key; }        public final V getValue()      { return value; }        ...    }}</code></pre><p>A nested class is a class defined within another class, the former should exist only to serve the latter. If you declare a member class that doesn’t require access to its enclosing instance then always put static modifier in its declaration. </p><p>If you omit this modifier then each instance will have a hidden extraneous reference to its enclosing instance, and storing this reference takes time and space. More seriously, it can result in the enclosing instance being retained when it would be otherwise be eligible for garbage collection, causing catastrophic memory leak.</p><h1 id="4-Methods-and-Generics"><a href="#4-Methods-and-Generics" class="headerlink" title="4. Methods and Generics"></a>4. Methods and Generics</h1><h2 id="4-1-Empty-and-Null-returns"><a href="#4-1-Empty-and-Null-returns" class="headerlink" title="4.1 Empty and Null returns"></a>4.1 Empty and Null returns</h2><p>Never return null in place of an empty array or collection because it will require clients to check null return for all method calls, ugly!</p><h2 id="4-2-Optional-Returns"><a href="#4-2-Optional-Returns" class="headerlink" title="4.2 Optional Returns"></a>4.2 Optional Returns</h2><pre><code>public static &lt;E extends Comparable&lt;E&gt;&gt; Optional&lt;E&gt; max(Collection&lt;E&gt; c) {    if (c.isEmpty()) {        return Optional.empty();    }    E result = null;    for (E e : c) {        if (result == null || e.compareTo(result) &gt; 0) {            result = Objects.requireNonNull(e);        }    }    return Optional.of(result);}</code></pre><p>Since Java 8, an Optional-returning method is possible, more flexible, and easier to use than one that throws an exception; it is also less error-prone than one that returns  null . Here are some best practices when using   Optional :</p><ul><li>Never return a null value from an optinal-returning method because doing so defeats the entire purpose of the facility.</li><li>Use helpers provided by the facility</li></ul><pre><code> String lastWordInLexicon = max(words).orElse(&quot;No words...&quot;); ,   Toy myToy = max(toys).orElseThrow(ToyException::new); </code></pre><ul><li>Container types, including collections, maps, streams, arrays, and optionals, should not be wrapped in optionals, because they have already provided facility to handle empty values.</li><li>Never return an optional of a boxed primitive type, with possible exception of  Boolean ,  Byte ,   Character ,  Short ,  Float . For other boxed primitive types, use  OptionalInt ,   OptionalLong ,  OptionalDouble  instead.</li></ul><h2 id="4-3-Generics-and-Unchecked-Warnings"><a href="#4-3-Generics-and-Unchecked-Warnings" class="headerlink" title="4.3 Generics and Unchecked Warnings"></a>4.3 Generics and Unchecked Warnings</h2><pre><code>public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable {    ...    public &lt;T&gt; T[] toArray(T[] a) {        if (a.length &lt; size) {            @SuppressWarnings(&quot;unchecked&quot;) T[] result = (T[]) Arrays.copyOf(elementData, size, a.getClass());            return result;        }        System.arraycopy(elementData, 0, a, 0, size);        if (a.length &gt; size) {            a[size] = null;        }        return a;    }    ...} </code></pre><p>Unchecked warnings are important; don’t ignore them because every unchecked warning has the potential to throw a   ClassCastException  at runtime. You should do your best to eliminate as many of them as possible. If you can’t, however, get rid of an unchecked warning, but you can prove that the code that provoke it is typesafe then suppress it with the corresponding annotation in the <strong>narrowest possible scope</strong>.</p><p>@SupressWarning: An anotation to surpress compile warnings about unchecked generic operations. </p><h2 id="4-4-Generics-and-Wildcards"><a href="#4-4-Generics-and-Wildcards" class="headerlink" title="4.4 Generics and Wildcards"></a>4.4 Generics and Wildcards</h2><pre><code>public class Stack&lt;E&gt; {    ...    public Stack() { ... }    public void push(E e) { ... }    public E pop() { ... }    public boolean isEmpty { ... }    public void pushAll(Iterable&lt;? extends E&gt; src) {        for (E e : src) {            push(e);        }    }    public void popAll(Collection&lt;? super E&gt; dst) {        while (!isEmpty()) {            dst.add(pop());        }    }}</code></pre><p>It is clear that for maximum flexibility you should use wildcard types on input parameters that represent producers or consumers.</p><ul><li>Remember PECS, which stands for <strong>Producer-Extends and Consumer-Super</strong>. Note that  Comparable  and   Comparator  are always consumers.</li></ul><h1 id="5-Exceptions"><a href="#5-Exceptions" class="headerlink" title="5. Exceptions"></a>5. Exceptions</h1><h2 id="5-1-Checked-Exceptions-and-Unchecked-Exceptions"><a href="#5-1-Checked-Exceptions-and-Unchecked-Exceptions" class="headerlink" title="5.1 Checked Exceptions and Unchecked Exceptions"></a>5.1 Checked Exceptions and Unchecked Exceptions</h2><pre><code>/** * Returns MarketplaceInfo of a given marketplace. * @throws NotFoundException if marketplaceId is not found; do not retry. * @throws ServiceUnavailableException if MarketplaceService does not respond after 3 retries. */public MarketplaceInfo getMarketplaceInfoById(MarketplaceId marketplaceId) {    try {        return getMarketplaceInfoByIdFromLocalCache(marketplaceId);    } catch (IOException e) {        try {            MarketplaceInfo info = getMarketplaceInfoByIdFromRemoteCache(marketplaceId);            putMarketplaceInfoToLocalCache(marketplaceId, info);            return info;        } catch (IOException e) {            for (int numRetries = 0; numRetries &lt; 3; numRetries++) {                try {                    // Call dependent service to get marketplace info                    MarketplaceInfo info = marketplaceService.getMarketplaceInfoById(marketplaceId);                    putMarketplaceInfoToLocalCache(marketplaceId, info);                    putMarketplaceInfoToRemoteCache(marketplaceId, info);                                    return info;                } catch (ServiceUnavailableException e) {                    sleep(5); // sleep 5 seconds before retry                } catch (NotFoundException e) {                    LOG.error(&quot;Unable to get marketplace info because marketplace id {} is not found.&quot;, marketplaceId);                    throw e;                }            }            throw new ServiceUnavailableException(&quot;Unable to get marketplace info after 3 retries.&quot;);        }    }}</code></pre><p>We should: </p><ul><li>throw checked exceptions, a subclass of Exception <ul><li>for recoverable conditions</li></ul></li><li>throw unchecked exceptions, a subclass of runtimeException <ul><li>for programming errors </li></ul></li></ul><p>When in doubt, throw unchecked exceptions. When throwing checked exceptions, add methods to aid in recovery for clients. </p><p>You should declare checked exceptions individually and document precisely the conditions under which each exception is thrown, by using Javadoc  @throws  tag. If the same exception is thrown by many methods in a class for the same reason then you can document it in the class’s documentation comment. In addition, it is particularly important to document unchecked exceptions of methods in interfaces they may throw</p><h2 id="5-2-Exception-Implementation"><a href="#5-2-Exception-Implementation" class="headerlink" title="5.2 Exception Implementation"></a>5.2 Exception Implementation</h2><ul><li>Provide detail as much as possible</li><li>detail msg should contain the values of all parameters and fields that have contributed to the exception </li><li>No sensitive information contained </li></ul><h1 id="6-Lambdas-and-Streams"><a href="#6-Lambdas-and-Streams" class="headerlink" title="6. Lambdas and Streams"></a>6. Lambdas and Streams</h1><h2 id="6-1-Method-references"><a href="#6-1-Method-references" class="headerlink" title="6.1 Method references"></a>6.1 Method references</h2><ul><li><code>Integer::parseInt</code> -&gt; a static method reference for <code>str -&gt; Integer.parseInt(str)</code></li><li><code>Instant.now()::isAfter</code> -&gt; a bound method reference for <code>Instance i = Instant.now(); t -&gt; i.isAfter(t)</code></li><li><code>String::toLowerCase</code> -&gt; an unbound method reference for <code>str -&gt; str.toLowerCase()</code></li><li><code>TreeMap&lt;K, V&gt;::new</code> -&gt; A class constructor for <code>() -&gt; new TreeMap&lt;K, V&gt;</code></li></ul><h1 id="7-Concurrency"><a href="#7-Concurrency" class="headerlink" title="7. Concurrency"></a>7. Concurrency</h1><h2 id="7-1-Synchronize-Access-to-Sharable-Mutable-Data"><a href="#7-1-Synchronize-Access-to-Sharable-Mutable-Data" class="headerlink" title="7.1 Synchronize Access to Sharable Mutable Data"></a>7.1 Synchronize Access to Sharable Mutable Data</h2><p>When multiple threads share mutable data, each thread that reads or writes the data must <strong>perform synchronization</strong>, otherwise there is no guarantee that one thread’s changes of the data will be visible to other threads, and therefore may cause liveness and safety failures. These failures are among the most difficult to debug.<br><code>var ++</code><br>It performs two operations on var : (1) it reads the value, (2) it writes back a new value that is equal to the old value plus one. If a second thread reads the field between the time the first thread reads the old value and writes back the new one, then both threads will see the same value and thus return the same serial number, OUCH; this is a safety failure.</p><p>Note that the best way to avoid safety failure is <strong>not to share mutable data</strong>, meaning share only immutable data or don’t share at all — confine mutable data to a single thread. If you adopt this policy then you should document it carefully, so that the policy is maintained as your program evolves. It is also crucial to have a deep understanding of the frameworks and libraries you’re using because they may introduce threads that you are unaware of.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-General-Programming&quot;&gt;&lt;a href=&quot;#1-General-Programming&quot; class=&quot;headerlink&quot; title=&quot;1. General Programming&quot;&gt;&lt;/a&gt;1. General Programming
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Cost of abstraction</title>
    <link href="https://www.llchen60.com/Cost-of-abstraction/"/>
    <id>https://www.llchen60.com/Cost-of-abstraction/</id>
    <published>2020-02-04T17:08:47.000Z</published>
    <updated>2020-02-04T17:09:17.706Z</updated>
    
    <content type="html"><![CDATA[<p>Duplicate is definitely something we are trying to get rid of, however, what’s the cost of abstraction? It seems some problem we could think for a while. </p><p>We should think of the tradeoff between code duplication and increased level of abstraction. </p><h1 id="1-Definition-cost-of-abstraction"><a href="#1-Definition-cost-of-abstraction" class="headerlink" title="1. Definition - cost of abstraction"></a>1. Definition - cost of abstraction</h1><ul><li>An abstraction is adding to the cognitive load of whoever works with the code </li><li>The main cost of abstraction: separating the implementation from the specification. Or we say separate the letter of function from the spirit of the function</li><li>The former being what the function does, the latter being what everybody believes it should do </li><li>Should involve everybody to consider what the code does, or we say what the function does </li></ul><h1 id="2-Thought"><a href="#2-Thought" class="headerlink" title="2. Thought"></a>2. Thought</h1><ul><li>The decision about creating an abstraction should not be taken lightly.</li><li>There’s a large social cost to every abstraction, may lead the project to be unmaintainable.</li><li>lambda is also a way to reduce the abstraction layers in some way </li><li>Abstraction is a good way to get rid of verbose code, but itself may bring uncertainty to some extent. Only implement <strong><em>necessary</em></strong> abstraction. </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Duplicate is definitely something we are trying to get rid of, however, what’s the cost of abstraction? It seems some problem we could th
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>CacheLoader 教程</title>
    <link href="https://www.llchen60.com/CacheLoader-%E6%95%99%E7%A8%8B/"/>
    <id>https://www.llchen60.com/CacheLoader-%E6%95%99%E7%A8%8B/</id>
    <published>2020-02-04T17:07:09.000Z</published>
    <updated>2020-02-04T17:07:32.984Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-LoadingCache"><a href="#1-LoadingCache" class="headerlink" title="1. LoadingCache"></a>1. LoadingCache</h1><p>LoadingCache是指用CacheLoader建立的缓存。想要使用LoadingCache的话，就是使用方法<code>get(K)</code>。如果不在LoadingCache里面的话，就会使用CacheLoader做一次加载；如果有的话就直接拿回结果了。</p><h1 id="2-使用CacheLoader以及LoadingCache"><a href="#2-使用CacheLoader以及LoadingCache" class="headerlink" title="2. 使用CacheLoader以及LoadingCache"></a>2. 使用CacheLoader以及LoadingCache</h1><pre><code>LoadingCache&lt;String, String&gt; loadingCache = CacheBuilder.newBuilder()    .build(new CacheLoader&lt;String, String&gt;() {        @Override        public String load(final String s) throws Exception {            return response;        }    });</code></pre><ul><li>CacheLoader在使用newBuilder()创造新实例的时候还可以做很多的设置，比如<ul><li><code>expireAfterAccess(long duration, TimeUnit unit)</code><ul><li>在每个entry被创建以后，经过一段固定的时间做自动移除操作</li></ul></li><li><code>maximumSize(long size)</code><ul><li>定义cache能有的最大entry数量 </li></ul></li></ul></li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://www.baeldung.com/guava-cacheloader" target="_blank" rel="noopener">https://www.baeldung.com/guava-cacheloader</a> </li><li><a href="https://stackoverflow.com/questions/43993731/what-is-a-loadingcache" target="_blank" rel="noopener">https://stackoverflow.com/questions/43993731/what-is-a-loadingcache</a></li><li><a href="https://guava.dev/releases/21.0/api/docs/com/google/common/cache/LoadingCache.html" target="_blank" rel="noopener">https://guava.dev/releases/21.0/api/docs/com/google/common/cache/LoadingCache.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-LoadingCache&quot;&gt;&lt;a href=&quot;#1-LoadingCache&quot; class=&quot;headerlink&quot; title=&quot;1. LoadingCache&quot;&gt;&lt;/a&gt;1. LoadingCache&lt;/h1&gt;&lt;p&gt;LoadingCache是指用Cache
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
      <category term="Cache" scheme="https://www.llchen60.com/tags/Cache/"/>
    
  </entry>
  
  <entry>
    <title>Apache-Ant</title>
    <link href="https://www.llchen60.com/Apache-Ant/"/>
    <id>https://www.llchen60.com/Apache-Ant/</id>
    <published>2020-02-04T16:32:50.000Z</published>
    <updated>2020-02-04T16:33:18.973Z</updated>
    
    <content type="html"><![CDATA[<p>Apache Ant is a Java-based build tool. A java library and command line tool, which aims to drive processes described in build files as targets and extension points dependent upon each other. </p><p>Main usage: build java applications. It can pilot any type of processes which can be described <strong>in terms of targets and tasks.</strong></p><h1 id="1-Writing-a-Simple-BuildFile"><a href="#1-Writing-a-Simple-BuildFile" class="headerlink" title="1. Writing a Simple BuildFile"></a>1. Writing a Simple BuildFile</h1><h2 id="1-1-Intro"><a href="#1-1-Intro" class="headerlink" title="1.1 Intro"></a>1.1 Intro</h2><p>Ant’s buildfile are written in XML. Each buildfile contains one project and as least one target. Targets contain task elements. Each task element of the build file can have an id attribute and can later be referred to by the value supplied to this. </p><p>The structure comes to be: </p><ul><li>project </li><li>target<ul><li>task elements<ul><li>id attribute </li></ul></li></ul></li></ul><h2 id="1-2-Projects"><a href="#1-2-Projects" class="headerlink" title="1.2 Projects"></a>1.2 Projects</h2><p>A project has three attributes: </p><ul><li>name <ul><li>the name of project</li></ul></li><li>default<ul><li>the default target to use when no target is supplied </li></ul></li><li>basedir<ul><li>the base directory from which all path calculations are done. A relative path is resolved relative to the directory containing the buildfile. </li><li>defaults to the parent directory of the buildfile </li></ul></li></ul><h2 id="1-3-Targets"><a href="#1-3-Targets" class="headerlink" title="1.3 Targets"></a>1.3 <a href="https://ant.apache.org/manual/targets.html" target="_blank" rel="noopener">Targets</a></h2><p>It’s a container of tasks that cooperate to reach a desired state during the build process. </p><p>A target can depend on other targets. **You might have a target for compiling, for example, and a target for creating a distributable. You can only build a distributable when you have compiled first, so the “distribute” target depends on the “compile” target. Ant resolves these dependencies</p><pre><code>&lt;target name=&quot;A&quot;/&gt;&lt;target name=&quot;B&quot; depends=&quot;A&quot;/&gt;&lt;target name=&quot;C&quot; depends=&quot;B&quot;/&gt;&lt;target name=&quot;D&quot; depends=&quot;C,B,A&quot;/&gt;</code></pre><p>Suppose we want to execute target D. From its depends attribute, you might think that first target C, then B and then A is executed. Wrong! C depends on B, and B depends on A, so first A is executed, then B, then C, and finally D.</p><p>A target also has the ability to perform its execution if(or unless) a property has been set. </p><pre><code>&lt;target name=&quot;myTarget&quot; depends=&quot;myTarget.check&quot; if=&quot;myTarget.run&quot;&gt;    &lt;echo&gt;Files foo.txt and bar.txt are present.&lt;/echo&gt;&lt;/target&gt;&lt;target name=&quot;myTarget.check&quot;&gt;    &lt;condition property=&quot;myTarget.run&quot;&gt;        &lt;and&gt;            &lt;available file=&quot;foo.txt&quot;/&gt;            &lt;available file=&quot;bar.txt&quot;/&gt;        &lt;/and&gt;    &lt;/condition&gt;&lt;/target&gt;</code></pre><h2 id="1-4-Tasks"><a href="#1-4-Tasks" class="headerlink" title="1.4 Tasks"></a>1.4 Tasks</h2><h3 id="1-4-1-Intro"><a href="#1-4-1-Intro" class="headerlink" title="1.4.1 Intro"></a>1.4.1 Intro</h3><p>Task is a piece of code that can be executed. </p><p>A task can have multiple attributes. The value of an attribute might contain reference to a property. These references will be resolved before the task is executed. </p><p>Task has a common structure: </p><pre><code>&lt;name attribute1=&quot;value1&quot; attribute2=&quot;value2&quot; ... /&gt;</code></pre><p>where name is the name of the task, attributeN is the attribute name, and valueN is the value for this attribute.</p><p>All tasks can have a name attribute, which will be used in the logging messages generated by Ant. </p><h3 id="1-4-2-Built-in-tasks"><a href="#1-4-2-Built-in-tasks" class="headerlink" title="1.4.2 Built-in tasks"></a>1.4.2 Built-in tasks</h3><p><a href="https://ant.apache.org/manual/tasklist.html" target="_blank" rel="noopener">https://ant.apache.org/manual/tasklist.html</a> </p><h3 id="1-4-3-Write-your-own-tasks"><a href="#1-4-3-Write-your-own-tasks" class="headerlink" title="1.4.3 Write your own tasks"></a>1.4.3 Write your own tasks</h3><p><a href="https://ant.apache.org/manual/develop.html#writingowntask" target="_blank" rel="noopener">https://ant.apache.org/manual/develop.html#writingowntask</a></p><h2 id="1-5-Properties"><a href="#1-5-Properties" class="headerlink" title="1.5 Properties"></a>1.5 <a href="https://ant.apache.org/manual/properties.html#if+unless" target="_blank" rel="noopener">Properties</a></h2><p>Properties are an important way to customize a build process or to just provide shortcuts for strings that are used repeatedly inside a buildfile.</p><p>In its most simple form properties are defined in the buildfile (for example by the property task) or might be set outside Ant. <strong>A property has a name and a value</strong>; the name is case-sensitive. Properties may be used in the value of task attributes or in the nested text of tasks that support them. This is done by <strong>placing the property name between “${“ and “}” in the attribute value</strong>. For example, if there is a builddir property with the value “build”, then this could be used in an attribute like this: ${builddir}/classes. This is resolved at run-time as build/classes.</p><pre><code>&lt;project name=&quot;MyProject&quot; default=&quot;dist&quot; basedir=&quot;.&quot;&gt;  &lt;description&gt;    simple example build file  &lt;/description&gt;  &lt;!-- set global properties for this build --&gt;  &lt;property name=&quot;src&quot; location=&quot;src&quot;/&gt;  &lt;property name=&quot;build&quot; location=&quot;build&quot;/&gt;  &lt;property name=&quot;dist&quot; location=&quot;dist&quot;/&gt;  &lt;target name=&quot;init&quot;&gt;    &lt;!-- Create the time stamp --&gt;    &lt;tstamp/&gt;    &lt;!-- Create the build directory structure used by compile --&gt;    &lt;mkdir dir=&quot;${build}&quot;/&gt;  &lt;/target&gt;  &lt;target name=&quot;compile&quot; depends=&quot;init&quot;        description=&quot;compile the source&quot;&gt;    &lt;!-- Compile the Java code from ${src} into ${build} --&gt;    &lt;javac srcdir=&quot;${src}&quot; destdir=&quot;${build}&quot;/&gt;  &lt;/target&gt;  &lt;target name=&quot;dist&quot; depends=&quot;compile&quot;        description=&quot;generate the distribution&quot;&gt;    &lt;!-- Create the distribution directory --&gt;    &lt;mkdir dir=&quot;${dist}/lib&quot;/&gt;    &lt;!-- Put everything in ${build} into the MyProject-${DSTAMP}.jar file --&gt;    &lt;jar jarfile=&quot;${dist}/lib/MyProject-${DSTAMP}.jar&quot; basedir=&quot;${build}&quot;/&gt;  &lt;/target&gt;  &lt;target name=&quot;clean&quot;        description=&quot;clean up&quot;&gt;    &lt;!-- Delete the ${build} and ${dist} directory trees --&gt;    &lt;delete dir=&quot;${build}&quot;/&gt;    &lt;delete dir=&quot;${dist}&quot;/&gt;  &lt;/target&gt;&lt;/project&gt;</code></pre><p>Properties are key-value pair where Apache Ant tries to expand ${key} to value at run time.  In general properties are of global scope, i.e., once they have been defined they are available for any task or target invoked subsequently—it is not possible to set a property in a child build process created via the ant, antcall or subant tasks and make it available to the calling build process, though. </p><h3 id="1-5-2-Built-in-Properties"><a href="#1-5-2-Built-in-Properties" class="headerlink" title="1.5.2 Built-in Properties"></a>1.5.2 Built-in Properties</h3><p>Ant provides access to all system properties as if they had been defined using a <property> task. </p><ul><li>javadoc of <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/System.html#getProperties--" target="_blank" rel="noopener">System.getProperties</a></li><li>basedir: the absolute path of the project’s basedir </li><li>ant.file: the absolute path of the buildfile</li><li>ant.version</li><li>ant.project.name </li></ul><h1 id="2-Concepts-and-Types"><a href="#2-Concepts-and-Types" class="headerlink" title="2. Concepts and Types"></a>2. Concepts and Types</h1><h2 id="2-1-Concepts"><a href="#2-1-Concepts" class="headerlink" title="2.1 Concepts"></a>2.1 Concepts</h2><ul><li>targets and Extension-points </li><li>Properties and PropertyHelpers</li></ul><h2 id="2-2-List-of-Types"><a href="#2-2-List-of-Types" class="headerlink" title="2.2 List of Types"></a>2.2 List of Types</h2><p><a href="https://ant.apache.org/manual/index.html" target="_blank" rel="noopener">https://ant.apache.org/manual/index.html</a> </p><ul><li>Class Fileset </li><li>Description Type </li><li>Directory based Tasks</li><li>Dirset</li><li>Extension Package </li><li>Set of Extension Packages</li><li>FileList</li><li>FileSet </li><li>File Mappers </li><li>FilterChains and FilterReaders</li><li>FilterSet </li><li>MultiRootFileSet </li><li>PatternSet </li><li>Path-like Structures</li><li>Permissions</li><li>PropertySet </li><li>I/O redirectors </li><li>Regexp</li><li>Resources </li><li>Resource Collections </li><li>Selectors </li><li>TarFileSet </li><li>XMLCatalog </li><li>ZipFileSet </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Apache Ant is a Java-based build tool. A java library and command line tool, which aims to drive processes described in build files as ta
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
      <category term="Apache" scheme="https://www.llchen60.com/tags/Apache/"/>
    
  </entry>
  
  <entry>
    <title>编程范式系列-面向对象编程</title>
    <link href="https://www.llchen60.com/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F%E7%B3%BB%E5%88%97-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
    <id>https://www.llchen60.com/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F%E7%B3%BB%E5%88%97-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</id>
    <published>2020-02-04T04:32:33.000Z</published>
    <updated>2020-02-04T04:32:55.523Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-函数式编程-vs-面向对象编程"><a href="#1-函数式编程-vs-面向对象编程" class="headerlink" title="1. 函数式编程 vs 面向对象编程"></a>1. 函数式编程 vs 面向对象编程</h1><p>函数式编程主要是把一些功能或逻辑代码通过函数的拼装方式来组织。尽量无状态，但是状态总归是需要一些地方来存放的。</p><p>对于状态和数据的处理，常用面向对象编程这个范式。</p><p>面向对象编程三大特性： </p><ul><li>封装</li><li>继承</li><li>多态</li></ul><h1 id="2-面向对象编程"><a href="#2-面向对象编程" class="headerlink" title="2. 面向对象编程"></a>2. 面向对象编程</h1><p>对象是类的实例，将对象作为程序的基本单元。对象里的程序可以访问及修改对象相关联的数据。</p><p>在程序中包含各种独立又相互调用的对象的思想。面向对象设计中的每一个对象都应该能够<strong>接受数据，处理数据并将数据传达给其它对象</strong>。</p><h2 id="2-1-面向对象的核心理念"><a href="#2-1-面向对象的核心理念" class="headerlink" title="2.1 面向对象的核心理念"></a>2.1 面向对象的核心理念</h2><ol><li>Program to an interface, not an implementation </li></ol><ul><li>使用者不需要知道数据类型，结构，算法的细节</li><li>使用者不需要知道实现细节，只需要知道提供的接口</li><li>利于抽象、封装、动态绑定、多态</li></ul><ol start="2"><li>Favor object composition over class inheritance <ul><li>继承需要给子类暴露一些父类的设计和实现细节</li><li>父类的改变会造成子类也需要改变</li><li>继承更多是为了多态</li></ul></li></ol><h2 id="2-2-tips"><a href="#2-2-tips" class="headerlink" title="2.2 tips"></a>2.2 tips</h2><ol><li>使用接口实现具体类</li><li>其他类耦合的是接口而不是实现类。这就是多态，其增加了程序的可扩展性</li><li>接口编程</li></ol><h2 id="2-3-缺点"><a href="#2-3-缺点" class="headerlink" title="2.3 缺点"></a>2.3 缺点</h2><p>超级重的代码粘合层，大量的封装</p><h1 id="3-控制反转"><a href="#3-控制反转" class="headerlink" title="3. 控制反转"></a>3. 控制反转</h1><p>Ioc—Inversion of Control，即“控制反转”，不是什么技术，而是一种设计思想。在Java开发中，Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。</p><p>传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对象的创建；IoC容器控制了对象；主要控制了外部资源获取。</p><p>有了IoC容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-函数式编程-vs-面向对象编程&quot;&gt;&lt;a href=&quot;#1-函数式编程-vs-面向对象编程&quot; class=&quot;headerlink&quot; title=&quot;1. 函数式编程 vs 面向对象编程&quot;&gt;&lt;/a&gt;1. 函数式编程 vs 面向对象编程&lt;/h1&gt;&lt;p&gt;函数式编程主要是
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="编程范式" scheme="https://www.llchen60.com/tags/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>编程范式系列-泛型编程</title>
    <link href="https://www.llchen60.com/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F%E7%B3%BB%E5%88%97-%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/"/>
    <id>https://www.llchen60.com/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F%E7%B3%BB%E5%88%97-%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/</id>
    <published>2020-02-04T04:31:42.000Z</published>
    <updated>2020-02-04T04:32:02.474Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-起源"><a href="#1-起源" class="headerlink" title="1. 起源"></a>1. 起源</h1><p>编程范式, programming paradigm，是一类典型的编程风格。</p><p>将主流编程语言分为三部分，加上对于编程本质的理解。共四篇文章。</p><ul><li>泛型编程</li><li>函数式编程</li><li>面向对象编程</li><li>编程本质和逻辑编程</li></ul><h1 id="1-1-C语言"><a href="#1-1-C语言" class="headerlink" title="1.1 C语言"></a>1.1 C语言</h1><ul><li>几乎现行的所有编程语言都是从c语言拓展来的，简述c语言的特性：</li></ul><ol><li>静态弱类型语言，使用变量时需要声明变量类型，但类型之间有隐式转换</li><li>typedef 定义类型的别名，达到变量类型的抽象</li><li>不同变量类型可以用结构体组合在一起</li></ol><ul><li>c语言的类型抽象带来的复杂度的提升： </li></ul><pre><code>void swap(void* x, void* y, size_t size){     char tmp[size];     memcpy(tmp, y, size);     memcpy(y, x, size);     memcpy(x, tmp, size);}</code></pre><ul><li>利用宏定义来做泛型</li></ul><pre><code>#define swap(x, y, size) {\    char temp[size]; \    memcpy(temp, &amp;y, size); \    memcpy(&amp;y,   &amp;x, size); \    memcpy(&amp;x, temp, size); \}</code></pre><ul><li>比较大小的宏定义</li></ul><pre><code>#define min(x, y)  （(x)&gt;(y) ? (y) : (x)）</code></pre><p>这里如果比较<code>min(x++, y++)</code>的话，各自会加两次</p><ul><li>小结<br>如果说程序 = 算法 + 数据， C语言会有这几个问题</li></ul><ol><li>一个通用的算法，需要对所处理的数据的数据类型进行适配。但在适配数据类型的过程中，C 语言只能使用 <code>void *</code> 或宏替换的方式。这两种方式导致了类型过于宽松，并带来很多其它问题。</li><li>适配数据类型，需要 C 语言在泛型中加入一个类型的 size，这是因为我们识别不了被泛型后的数据类型，而 C 语言没有运行时的类型识别，所以，只能将这个工作抛给调用泛型算法的程序员来做了</li><li>算法其实是在操作数据结构，而数据则是放到数据结构中的。所以，真正的泛型除了适配数据类型外，还要适配数据结构。最后这个事情导致泛型算法的复杂急剧上升。比如容器内存的分配和释放，不同的数据体可能有非常不一样的内存分配和释放模型，再比如对象之间的复制，要把它存进来我需要有一个复制，这其中又涉及到是深拷贝，还是浅拷贝。</li><li>最后，在实现泛型算法的时候，你会发现自己在纠结哪些东西应该抛给调用者处理，哪些又是可以封装起来。如何平衡和选择，并没有定论，也不好解决。</li></ol><p>比如 C 语言就是过程式的编程语言，像C语言这样的过程式编程语言优点是底层灵活而且高效，特别适合开发运行较快且对系统资源利用率要求较高的程序，但我上面抛出的问题它在后来也没有试图去解决，因为<strong>编程范式</strong>的选择基本已经决定了它的“命运”。</p><h1 id="2-泛型编程"><a href="#2-泛型编程" class="headerlink" title="2. 泛型编程"></a>2. 泛型编程</h1><h2 id="2-1-C-语言"><a href="#2-1-C-语言" class="headerlink" title="2.1 C++ 语言"></a>2.1 C++ 语言</h2><p>C++ 很大程度上是来解决C语言中的各种问题和各种不方便。</p><ul><li>用引用来解决指针的问题。</li><li>用 namespace 来解决名字空间冲突的问题。</li><li>通过 try-catch 来解决检查返回值编程的问题。</li><li>用 class 来解决对象的创建、复制、销毁的问题，从而可以达到在结构体嵌套时可以深度复制的内存安全问题。</li><li>通过重载操作符来达到操作上的泛型</li><li>通过模板 template 和虚函数的多态以及运行时识别来达到更高层次的泛型和多态。</li><li>用 RAII、智能指针的方式，解决了 C 语言中因为需要释放资源而出现的那些非常 ugly 也很容易出错的代码的问题。</li><li>用 STL 解决了 C 语言中算法和数据结构的 N 多种坑。</li></ul><h2 id="2-2-C-语言的泛型编程"><a href="#2-2-C-语言的泛型编程" class="headerlink" title="2.2 C++ 语言的泛型编程"></a>2.2 C++ 语言的泛型编程</h2><p>理想情况下，算法应该与数据结构和类型无关的。各种特殊的数据结构应该能自己做好泛型处理，算法是一个标准的实现。</p><p>对于泛型的抽象，<strong>需要回答的问题是： 如果我们的数据类型符合通用算法，那么对数据类型的最小需求是什么？？？</strong></p><h3 id="2-2-1-C-如何解决泛型问题的？"><a href="#2-2-1-C-如何解决泛型问题的？" class="headerlink" title="2.2.1 C++ 如何解决泛型问题的？"></a>2.2.1 C++ 如何解决泛型问题的？</h3><ol><li>通过类的方式解决</li></ol><ul><li>类里面会有构造函数、析构函数表示这个类的分配和释放。</li><li>还有它的拷贝构造函数，表示了对内存的复制。</li><li>还有重载操作符，像我们要去比较大于、等于、不等于。</li></ul><ol start="2"><li>通过模板达到类型和算法的妥协</li></ol><ul><li>模板有点像 DSL，模板的特化会根据使用者的类型在编译时期生成那个模板的代码。</li><li>模板可以通过一个虚拟类型来做类型绑定，这样不会导致类型转换时的问题。</li></ul><ol start="3"><li>通过虚函数和运行时类识别</li></ol><ul><li>虚函数带来的多态在语义上可以让“同一类”的类型进行泛型。</li><li>运行时类型识别技术可以做到在泛型时对具体类型的特殊处理。</li></ul><p>一个良好的泛型编程需要解决 1） 算法的泛型 2） 类型的泛型  3） 数据结构的泛型</p><h3 id="2-2-2-泛型编程实例"><a href="#2-2-2-泛型编程实例" class="headerlink" title="2.2.2 泛型编程实例"></a>2.2.2 泛型编程实例</h3><ol><li>Search 函数</li></ol><p>不是所有的数据结构都是顺序型的，不能用 <code>for(int i = 0; i &lt; len; i++)</code> 来做抽象的，比如hashtable，二叉树，图就是非顺序型的。这种写法对他们来说没有意义。</p><pre><code>template&lt;typename T, typename Iter&gt; Iter search(Iter pStart, Iter pEnd, T target) {    for(Iter p = pStart; p != pEnd; p++) {        if ( *p == target )             return p;    }    return NULL;}</code></pre><p>可以看到： </p><ul><li>使用 <code>typename T</code> 抽象了数据结构中存储数据的类型</li><li>使用 <code>typename Iter</code>，让不同的数据结构实现自己的迭代器，用这种方式抽象掉了不同类型的数据结构。</li><li>然后，我们对数据容器的遍历使用了Iter中的++方法，这是数据容器需要重载的操作符，这样通过操作符重载也就泛型掉了遍历。</li><li>使用<code>*Iter</code>来取得指针的内容，这也是通过重载*取值操作符来达到的泛型。</li><li>tips: <code>Iter</code> 在实际代码中，是类似于<code>vector&lt;int&gt;::iterator</code> <code>map&lt;int, String&gt;::iterator</code>。是由相应的数据容器来实现和提供的。</li></ul><ol start="2"><li>迭代器</li></ol><pre><code>template &lt;class T&gt;class container {public:    class iterator {    public:        typedef iterator self_type;        typedef T   value_type;        typedef T*  pointer;        typedef T&amp;     reference;        reference operator*();        pointer operator-&gt;();        bool operator==(const self_type&amp; rhs)；        bool operator!=(const self_type&amp; rhs)；        self_type operator++() { self_type i = *this; ptr_++; return i; }        self_type operator++(int junk) { ptr_++; return *this; }        ...        ...    private:        pointer _ptr;    };    iterator begin();    iterator end();    ...    ...};</code></pre><ul><li>一个迭代器需要与一个容器在一起，因为里面是对这个容器的具体的代码实现</li><li>需要重载一些操作符</li><li>需要typedef一些类型，搞死容器内的数据的实际类型是什么样子的</li><li>begin() end()基本操作</li></ul><ol start="3"><li>Sum（）</li></ol><pre><code>template &lt;class Iter&gt; typename Iter::value_type sum(Iter start, Iter end, T init) {    typename Iter::value_type result = init;    while (start != end) {        result = result + *start;        start++;    }    return result;}</code></pre><ol start="4"><li>reduce()</li></ol><pre><code>template&lt;class Iter, class T, class Op&gt; T reduce (Iter start, Iter end, T init, Op op) {    T result = init;    while ( start != end ) {        result = op( result, *start );        start++;    }    return result;}</code></pre><h2 id="2-2-动态类型语言的泛型编程"><a href="#2-2-动态类型语言的泛型编程" class="headerlink" title="2.2 动态类型语言的泛型编程"></a>2.2 动态类型语言的泛型编程</h2><p>在编程世界，我们需要处理好两件事情： </p><ol><li>编程语言中的类型问题</li><li>对真实世界中业务代码的抽象、重用和拼装</li></ol><h3 id="2-2-1-类型系统"><a href="#2-2-1-类型系统" class="headerlink" title="2.2.1 类型系统"></a>2.2.1 类型系统</h3><p>在计算机科学中，类型系统用于定义如何将编程语言中的数值和表达式归类为许多不同的类型，以及如何操作这些类型，还有这些类型如何互相作用。类型可以确认一个值或者一组值具有特定的意义和目的。</p><p>类型系统在各种语言之间很不同，存在于编译时期的语法，以及运行时期的操作实现方式。</p><p>程序语言的类型系统主要提供如下功能： </p><ul><li>程序语言的安全性</li></ul><p>使用类型可以让编译器侦测一些代码的错误。例如：可以识别出一个错误无效的表达式。如：<code>“Hello, World” + 3</code>这样的不同数据类型间操作的问题。强类型语言提供更多的安全性，但是并不能保证绝对的安全。</p><ul><li>利于编译器的优化</li></ul><p>静态类型语言的类型声明，可以让编译器明确地知道程序员的意图。因此，编译器就可以利用这一信息做很多代码优化工作。例如：如果我们指定一个类型是int,那么编译就知道，这个类型会以4个字节的倍数进行对齐，编译器就可以非常有效地利用更有效率的机器指令。 </p><ul><li>代码的可读性</li></ul><p>有类型的编程语言，可以让代码更易读和更易维护。代码的语义也更清楚，代码模块的接口（如函数）也更丰富和更清楚。</p><ul><li>抽象化</li></ul><p>类型允许程序设计者对程序以较高层次的方式思考，而不是烦人的低层次实现。例如，我们使用整型或是浮点型来取代底层的字节实现，我们可以将字符串设计成一个值，而不是底层的字节的数组。从高层上来说，类型可以用来定义不同模块间的交互协议，比如函数的入参类型和返回类型，从而可以让接口更有语义，而且不同的模块数据交换更为直观和易懂。</p><p>在动态语言中，一个变量的类型是由运行时的解释器来动态标记的，这样就可以动态地和底层的计算机指令或内存布局对应起来。</p><h1 id="3-泛型的本质"><a href="#3-泛型的本质" class="headerlink" title="3. 泛型的本质"></a>3. 泛型的本质</h1><ul><li>类型是对内存的一种抽象。不同的类型，会有不同的内存布局和内存分配的策略。</li><li>不同的类型，有不同的操作。所以，对于特定的类型，也有特定的一组操作。</li></ul><blockquote><p>Generic programming centers around the idea of abstracting from concrete, efficient algorithms to obtain generic algorithms that can be combined with different data representations to produce a wide variety of useful software.</p></blockquote><p>屏蔽掉数据和操作数据的细节，让算法更为通用，让编程者更多地关注算法结构，而不是在算法中处理不同的数据类型。</p><p>要做到泛型，我们需要： </p><ul><li>标准化掉类型的内存分配、释放和访问。</li><li>标准化掉类型的操作。比如：比较操作，I/O 操作，复制操作……</li><li>标准化掉数据容器的操作。比如：查找算法、过滤算法、聚合算法……</li><li>标准化掉类型上特有的操作。需要有标准化的接口来回调不同类型的具体操作……</li></ul><h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><p><a href="https://time.geekbang.org/column/48" target="_blank" rel="noopener">左耳听风的极客时间专栏</a></p><p><a href="https://blog.csdn.net/Hackbuteer1/article/details/7558868" target="_blank" rel="noopener">虚函数</a></p><p><a href="https://lxwei.github.io/posts/262.html" target="_blank" rel="noopener">从源代码到可执行文件</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-起源&quot;&gt;&lt;a href=&quot;#1-起源&quot; class=&quot;headerlink&quot; title=&quot;1. 起源&quot;&gt;&lt;/a&gt;1. 起源&lt;/h1&gt;&lt;p&gt;编程范式, programming paradigm，是一类典型的编程风格。&lt;/p&gt;
&lt;p&gt;将主流编程语言分为三部分，加
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="编程范式" scheme="https://www.llchen60.com/tags/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>编程范式系列-基于原型的编程</title>
    <link href="https://www.llchen60.com/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F%E7%B3%BB%E5%88%97-%E5%9F%BA%E4%BA%8E%E5%8E%9F%E5%9E%8B%E7%9A%84%E7%BC%96%E7%A8%8B/"/>
    <id>https://www.llchen60.com/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F%E7%B3%BB%E5%88%97-%E5%9F%BA%E4%BA%8E%E5%8E%9F%E5%9E%8B%E7%9A%84%E7%BC%96%E7%A8%8B/</id>
    <published>2020-02-04T04:30:57.000Z</published>
    <updated>2020-02-04T04:31:16.073Z</updated>
    
    <content type="html"><![CDATA[<p>基于原型的编程，是指没有class化，直接使用对象的编程方式。又叫做基于实例的编程，主流语言是JavaScript。 </p><h1 id="1-与传统面向对象编程的比较"><a href="#1-与传统面向对象编程的比较" class="headerlink" title="1. 与传统面向对象编程的比较"></a>1. 与传统面向对象编程的比较</h1><h2 id="1-1-关注对象实例行为，而后对类进行划分"><a href="#1-1-关注对象实例行为，而后对类进行划分" class="headerlink" title="1.1 关注对象实例行为，而后对类进行划分"></a>1.1 关注对象实例行为，而后对类进行划分</h2><p>在基于类的编程当中，对象总共有两种类型。</p><ol><li>类</li></ol><p>定义了对象的基本布局，函数特性。—-&gt; 是行为和结构的集合，对所有的接口来说这些类的行为和结构都是相同的。</p><ol start="2"><li>接口</li></ol><p>是可以使用的对象,定义了一些行为，基于特定类的样式。</p><p>在这种模式下，类的划分是基于行为和结构，而不是状态。原型编程的主张者提倡关注一系列对象实例的行为，而后关注将其划分到使用方式相似的原型对象。实际上说，不同之处在于对于状态的看重程度。</p><h2 id="1-2-创建实例的时间"><a href="#1-2-创建实例的时间" class="headerlink" title="1.2 创建实例的时间"></a>1.2 创建实例的时间</h2><p>对于基于类的系统，新的实例是通过类构造器以及参数来构造，实例是由类的行为和结构来定义的。</p><p>对于基于原型的系统，可以通过复制已有的对象或者通过扩展空对象来创建，是在<strong>运行时</strong>对原型进行修改的。</p><h1 id="2-JavaScript-原型的概念"><a href="#2-JavaScript-原型的概念" class="headerlink" title="2. JavaScript 原型的概念"></a>2. JavaScript 原型的概念</h1><pre><code>var foo = {name: &quot;foo&quot;, one: 1, two: 2};var bar = {three: 3};bar.__proto__ = foo; // foo is...// If we try to access foo&#39;s properties from bar // from now on, we&#39;ll succeed. bar.one // Resolves to 1.// The child object&#39;s properties are also accessible.bar.three // Resolves to 3.// Own properties shadow prototype propertiesbar.name = &quot;bar&quot;;foo.name; // unaffected, resolves to &quot;foo&quot;bar.name; // Resolves to &quot;bar&quot;</code></pre><p>每个对象都有个<code>_proto_</code>属性，通过赋值操作，bar的原型现在是foo了。因此我们可以在bar里面访问foo的属性。</p><h2 id="2-1-区分-proto-以及prototype"><a href="#2-1-区分-proto-以及prototype" class="headerlink" title="2.1 区分_proto_以及prototype"></a>2.1 区分<code>_proto_</code>以及<code>prototype</code></h2><ul><li><p><code>_proto_</code><br>主要安放在一个实际的对象当中，用它来产生一个链接，用于寻找方法名或属性。用于链接原型的一个指针。</p></li><li><p><code>prototype</code><br>当用new来构造一个新的对象的时候构造<code>_proto_</code>的时候用的，是构造函数的一个属性。</p></li></ul><h2 id="2-2-对象的表现形式"><a href="#2-2-对象的表现形式" class="headerlink" title="2.2 对象的表现形式"></a>2.2 对象的表现形式</h2><ul><li>Object </li><li>Function </li></ul><h1 id="3-Conclusion"><a href="#3-Conclusion" class="headerlink" title="3. Conclusion"></a>3. Conclusion</h1><p>其实是一种委托方式，通过一个序列的指针来定位属性，寻找数据。可以带来运行时的灵活性，数据方法都可以进行修改了。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;基于原型的编程，是指没有class化，直接使用对象的编程方式。又叫做基于实例的编程，主流语言是JavaScript。 &lt;/p&gt;
&lt;h1 id=&quot;1-与传统面向对象编程的比较&quot;&gt;&lt;a href=&quot;#1-与传统面向对象编程的比较&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="编程范式" scheme="https://www.llchen60.com/tags/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>编程范式系列-函数式编程</title>
    <link href="https://www.llchen60.com/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F%E7%B3%BB%E5%88%97-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>https://www.llchen60.com/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F%E7%B3%BB%E5%88%97-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</id>
    <published>2020-02-04T04:29:45.000Z</published>
    <updated>2020-02-04T04:30:21.107Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-从c-到函数式编程"><a href="#1-从c-到函数式编程" class="headerlink" title="1. 从c++到函数式编程"></a>1. 从c++到函数式编程</h1><p>C++很大程度上解决了C语言中的各种问题和不便，尤其是通过类、模板、虚函数和运行时识别，解决了C语言的泛型编程问题。函数式编程 -&gt; 更为抽象的泛型。</p><h1 id="2-函数式编程"><a href="#2-函数式编程" class="headerlink" title="2. 函数式编程"></a>2. 函数式编程</h1><h2 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h2><p>函数式编程只关心**定义的输入数据和输出数据相关的关系，数学表达式里面其实是在做一种映射(mapping)，输入的数据和输出的数据关系是什么样子的，是用函数来定义的。</p><h2 id="2-2-特征"><a href="#2-2-特征" class="headerlink" title="2.2 特征"></a>2.2 特征</h2><h3 id="2-2-1-优势"><a href="#2-2-1-优势" class="headerlink" title="2.2.1 优势"></a>2.2.1 优势</h3><ul><li>stateless </li></ul><p>不维护任何状态，给数据，我做处理，然后给你处理完的数据，中间的过程量用完就没了</p><p>无状态的话并行执行无害了，重构代码无伤害</p><ul><li>immutable</li></ul><p>输入数据动了，输出数据也会变，意味着新的数据集会被返回</p><ul><li>惰性求值</li></ul><p>表达式不在它被绑定到变量之后立即求值，而是在该值被取用的时候求值。</p><ul><li><p>确定性</p><p>f(x)=y, 这个函数无论在什么场景下，都会得到同样的结果，这个我们称之为函数的确定性。而不是像程序中的很多函数那样，同一个参数，却会在不同的场景下计算出不同的结果。所谓不同的场景，就是我们的函数会根据运行中的状态信息的不同而发生变化。</p><h3 id="2-2-2-劣势"><a href="#2-2-2-劣势" class="headerlink" title="2.2.2 劣势"></a>2.2.2 劣势</h3><ul><li>数据复制很严重</li><li>函数式编程抽象度更高，实现方式上，函数套函数，函数返回函数，函数里定义函数… </li></ul></li></ul><h2 id="2-3-函数式编程用到的技术"><a href="#2-3-函数式编程用到的技术" class="headerlink" title="2.3 函数式编程用到的技术"></a>2.3 函数式编程用到的技术</h2><ul><li>first class function 头等函数</li></ul><p>把函数当成变量来使用。可以像变量一样被创建、修改，并当成变量一样传递、返回，或者是在函数中嵌套函数 </p><ul><li>tail recursion optimization 尾递归优化</li></ul><p>如果递归很深的话，stack受不了，会导致性能大幅度下降。因此我们使用尾递归优化技术，每次递归的时候都会重用stack</p><ul><li><p>map &amp; reduce</p></li><li><p>pipeline </p></li></ul><p>将函数实例成一个个action，然后将一组action放到一个数组或列表中，再把数据传给这个action list，数据就被各个函数所操作，最终得到我们想要的结果。</p><ul><li>recursing</li></ul><p>将复杂问题用简单的代码描述出来。</p><ul><li>currying 颗粒化</li></ul><p>将一个函数的多个参数分解成多个函数，然后将函数多层封装起来，每层函数都返回一个函数去接收下一个参数，这可以简化函数的多个参数。</p><ul><li>higher order function 高阶函数</li></ul><p>函数当参数，把传入的函数做一个封装，然后返回这个封装函数</p><h2 id="2-4-函数式编程的理念"><a href="#2-4-函数式编程的理念" class="headerlink" title="2.4 函数式编程的理念"></a>2.4 函数式编程的理念</h2><pre><code>// 非函数式，有状态的int cnt;void increment() {    cnt ++;}// 函数式， 无状态的int increment(int cnt) {    return cnt + 1;}</code></pre><ul><li>把函数当成变量来用，关注描述问题而不是怎么实现的，可以让代码更易读</li><li>因为函数返回里面的这个函数，所以函数关注的是表达式，关注的是描述这个问题，而不是如何实现的</li></ul><h3 id="2-4-1-函数式编程例子"><a href="#2-4-1-函数式编程例子" class="headerlink" title="2.4.1  函数式编程例子"></a>2.4.1  函数式编程例子</h3><p>下面我们看一下相关的示例。比如，我们有 3 辆车比赛，简单起见，我们分别给这 3 辆车有 70% 的概率可以往前走一步，一共有 5 次机会，然后打出每一次这 3 辆车的前行状态。</p><pre><code>// Imperative Programming from random import randomtime = 5car_positions = [1, 1, 1]while time:    # decrease time    time -= 1    print &#39;&#39;    for i in range(len(car_positions)):        # move car        if random() &gt; 0.3:            car_positions[i] += 1        # draw car        print &#39;-&#39; * car_positions[i]</code></pre><p>下面这个例子是将循环分成了几个小函数，但是相互之间的参数是共享的，函数是有状态的。</p><pre><code>// make it to some function model from random import randomdef move_cars():    for i, _ in enumerate(car_positions):        if random() &gt; 0.3:            car_positions[i] += 1def draw_car(car_position):    print &#39;-&#39; * car_positiondef run_step_of_race():    global time    time -= 1    move_cars()def draw():    print &#39;&#39;    for car_position in car_positions:        draw_car(car_position)time = 5car_positions = [1, 1, 1]while time:    run_step_of_race()    draw()</code></pre><p>函数式写法</p><pre><code>from random import randomdef move_cars(car_positions):    return map(lambda x: x + 1 if random() &gt; 0.3 else x, car_positions)def output_car(car_position):    return &#39;-&#39; * car_positiondef run_step_of_race(state):    return {&#39;time&#39;: state[&#39;time&#39;] - 1, &#39;car_positions&#39;: move_cars(state[&#39;car_positions&#39;])}def draw(state):    print &#39;&#39;    print &#39;\n&#39;.join(map(output_car, state[&#39;car_positions&#39;]))def race(state):    draw(state)    if state[&#39;time&#39;]:        race(run_step_of_race(state))race({&#39;time&#39;: 5,      &#39;car_positions&#39;: [1, 1, 1]})</code></pre><p>上面的代码依然把程序的逻辑分成了函数。不过这些函数都是函数式的，它们有三个特点：它们之间没有共享的变量；函数间通过参数和返回值来传递数据；在函数里没有临时变量。</p><h2 id="2-5-函数式语言常用函数"><a href="#2-5-函数式语言常用函数" class="headerlink" title="2.5 函数式语言常用函数"></a>2.5 函数式语言常用函数</h2><ol><li>map()</li><li>reduce()</li><li>filter()</li></ol><p>好处： </p><ol><li>数据集、对数据的操作和返回值都放在了一起。</li><li>没有了循环体，就可以少了些临时用来控制程序执行逻辑的变量，也少了把数据倒来倒去的控制逻辑。</li><li>代码变成了在描述你要干什么，而不是怎么干</li></ol><h3 id="2-5-1-E-G"><a href="#2-5-1-E-G" class="headerlink" title="2.5.1 E.G"></a>2.5.1 E.G</h3><p>process: </p><ol><li>找出偶数</li><li>乘3</li><li>转成字符串</li></ol><pre><code>def process(num):# filter out non-evensif num % 2 != 0:    returnnum = num * 3num = &#39;The Number: %s&#39; % numreturn numnums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]for num in nums:    print process(num)# 输出：# None# The Number: 6# None# The Number: 12# None# The Number: 18# None# The Number: 24# None# The Number: 30</code></pre><p>pipeline way</p><p>使用了yield关键字，返回generator，一个可迭代对象 ，并没有真正的执行函数。意味着只有其返回的迭代对象被迭代时，yield函数才会真正运行</p><pre><code>def even_filter(nums):for num in nums:    if num % 2 == 0:        yield numdef multiply_by_three(nums):    for num in nums:        yield num * 3def convert_to_string(nums):    for num in nums:        yield &#39;The Number: %s&#39; % numnums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]pipeline = convert_to_string(multiply_by_three(even_filter(nums)))for num in pipeline:    print num# 输出：# The Number: 6# The Number: 12# The Number: 18# The Number: 24# The Number: 30</code></pre><p>使用map &amp; reduce</p><pre><code>def even_filter(nums):return filter(lambda x: x%2==0, nums)def multiply_by_three(nums):    return map(lambda x: x*3, nums)def convert_to_string(nums):    return map(lambda x: &#39;The Number: %s&#39; % x,  nums)nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]pipeline = convert_to_string(               multiply_by_three(                   even_filter(nums)               )            )for num in pipeline:    print num</code></pre><p>pipeline model </p><pre><code>class Pipe(object):def __init__(self, func):    self.func = funcdef __ror__(self, other):    def generator():        for obj in other:            if obj is not None:                yield self.func(obj)    return generator()@Pipedef even_filter(num):    return num if num % 2 == 0 else None@Pipedef multiply_by_three(num):    return num*3@Pipedef convert_to_string(num):    return &#39;The Number: %s&#39; % num@Pipedef echo(item):    print item    return itemdef force(sqs):    for item in sqs: passnums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]force(nums | even_filter | multiply_by_three | convert_to_string | echo)</code></pre><h2 id="3-修饰器模式-decorator"><a href="#3-修饰器模式-decorator" class="headerlink" title="3. 修饰器模式 decorator"></a>3. 修饰器模式 decorator</h2><p>Python 用一个函数来构造另一个函数</p><pre><code>def hello(fn):    def wrapper():        print &quot;hello, %s&quot; % fn.__name__        fn()        print &quot;goodbye, %s&quot; % fn.__name__    return wrapper@hellodef Hao():    print &quot;i am Hao Chen&quot;Hao()// code result:$ python hello.pyhello, Haoi am Hao Chengoodbye, Hao</code></pre><p>Hello 注解就是我们前面定义的hello函数，hello函数中需要一个参数fn，用来做回调，hello函数中返回了一个inner函数wrapper，回调了传进来的fn</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>函数式编程，将运算过程尽量写成一系列嵌套的函数调用，关注的是做什么而不是怎么做，被称为声明式编程。以stateless和immutable为主要特点。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-从c-到函数式编程&quot;&gt;&lt;a href=&quot;#1-从c-到函数式编程&quot; class=&quot;headerlink&quot; title=&quot;1. 从c++到函数式编程&quot;&gt;&lt;/a&gt;1. 从c++到函数式编程&lt;/h1&gt;&lt;p&gt;C++很大程度上解决了C语言中的各种问题和不便，尤其是通过类
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="编程范式" scheme="https://www.llchen60.com/tags/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>笔记 - 领域驱动设计 by Eric Evans</title>
    <link href="https://www.llchen60.com/%E7%AC%94%E8%AE%B0-%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1-by-Eric-Evans/"/>
    <id>https://www.llchen60.com/%E7%AC%94%E8%AE%B0-%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1-by-Eric-Evans/</id>
    <published>2020-02-04T04:28:36.000Z</published>
    <updated>2020-02-04T04:29:00.240Z</updated>
    
    <content type="html"><![CDATA[<p>在看博文的时候看到了关于DDD的内容，确实发现在工程上碰到了一些些问题，关于核心领域，关于领域驱动，毕竟技术是为了解决实际问题的，只有在对某个领域有着较深的理解的前提下，才能做出更有利于维护，更容易扩展的软件。</p><p>本书想说的就是在大规模工程上，如何来控制整体的复杂性，我们需要有一个良好的领域模型，不仅仅停留在领域的表面，而是要透过表象抓住领域的实质结构，从而为软件开发人员提供他们所需要的支持。</p><p>软件的负责性并不仅仅在技术上，而是来自领域本身，用户的活动或业务。这种复杂性我们需要在设计上考虑到的。</p><p>领域涉及的前提： </p><ol><li>在大多数软件项目当中，主要的焦点应该是领域和领域逻辑</li><li>复杂的领域设计应该基于模型</li></ol><p>领域驱动设计的实质是<strong>消化吸收大量知识，最后产生一个反映深层次领域知识并聚焦于关键概念的模型</strong></p><h1 id="1-让领域模型发挥作用-领域驱动开发的基本目标"><a href="#1-让领域模型发挥作用-领域驱动开发的基本目标" class="headerlink" title="1. 让领域模型发挥作用 - 领域驱动开发的基本目标"></a>1. 让领域模型发挥作用 - 领域驱动开发的基本目标</h1><h2 id="1-1-几个基本问题"><a href="#1-1-几个基本问题" class="headerlink" title="1.1 几个基本问题"></a>1.1 几个基本问题</h2><ul><li>什么是模型？ <ul><li>模型是一种简化，是对现实的解释，并把与解决问题密切相关的方面抽象出来，而忽略无关的细节。  </li><li>模型是为了解决信息超载问题的工具</li><li>模型是一种知识形式，它对知识进行有选择的简化和有目的的结构化 </li></ul></li><li>如何界定领域？<ul><li>每个软件程序的目的都是为了执行某项活动，或者满足用户的某种需求。用户会将软件程序应用在某个主题区域当中，这个区域就叫做软件的领域。</li></ul></li><li>软件的核心是什么？ <ul><li>用户解决领域相关的问题的能力 </li></ul></li></ul><h2 id="1-2-如何有效消化知识？"><a href="#1-2-如何有效消化知识？" class="headerlink" title="1.2 如何有效消化知识？"></a>1.2 如何有效消化知识？</h2><h3 id="1-2-1-有效建模的要素"><a href="#1-2-1-有效建模的要素" class="headerlink" title="1.2.1 有效建模的要素"></a>1.2.1 有效建模的要素</h3><ul><li>模型与实现的绑定  <ul><li>在模型与实现之间建立早期连接，在后续的所有迭代当中维护该原型</li></ul></li><li>获得一种基于模型的语言<ul><li>业务和技术上的对应的模型的熟悉，对于名词的意思达成一致</li></ul></li><li>开发一个蕴含丰富知识的模型</li><li>提炼模型 - 保证模型整体结构的精炼</li></ul><h3 id="1-2-2-知识消化"><a href="#1-2-2-知识消化" class="headerlink" title="1.2.2 知识消化"></a>1.2.2 知识消化</h3><p>在大量信息当中探寻有用的部分，由开发人员和领域专家组成的团队共同协作，收集信息并寻找对信息有意义的简化视图。</p><p>在你的架构当中应当本身就有领域的特征，即某部分需要能够清晰的反应商业上的可能需求和可能的拓展。这种东西如果在刚刚开始的时候就能被研究到，那以后就会很方便了。</p><p>开发出来的软件是需要能够反应出领域专家的思考方式的，我们用自己的技术来解决他们的问题，用代码构建他们的思维体系。</p><h2 id="1-3-语言的交流和使用"><a href="#1-3-语言的交流和使用" class="headerlink" title="1.3 语言的交流和使用"></a>1.3 语言的交流和使用</h2><ul><li>模型 <ul><li>头脑中形成的与项目有关的概念集合，用术语和关系反映了领域的深层含义。这些术语和关系提供了模型语言的语义</li><li>不仅仅限于UML图，需要充分利用各种交流手段，以提高代码本身和测试的沟通能力</li></ul></li></ul><h3 id="1-3-1-模式：-Ubiquitous-Language"><a href="#1-3-1-模式：-Ubiquitous-Language" class="headerlink" title="1.3.1 模式： Ubiquitous Language"></a>1.3.1 模式： Ubiquitous Language</h3><p>需要一种通用的，共享的团队语言，这种语言应该是时刻进行检验的。语言上的鸿沟，即我们对同样的词语是没有同样的认识的，这就导致了当我们对某个领域不够熟悉的时候，对于各种概念的理解是有很大量的欠缺的。而各类人在工作的时候也很容易为了方便创建小范围达成共识的语言，但是在这个小范围之外是没有人知道和了解这究竟是什么意思的。</p><ul><li>为什么需要这种公共语言？<ul><li>将团队的沟通和软件实现紧密联系起来</li><li>避免因为对于概念不同理解带来的交流沟通成本陡增的问题</li></ul></li><li>词汇表<ul><li>类名称</li><li>主要操作</li><li>术语 <ul><li>讨论模型当中已经明确的规则</li><li>或者是模型上的高级组织原则</li></ul></li></ul></li><li>tips<ul><li>模型作为语言的中心，确保团队在所有交流活动和代码中坚持使用这种语言</li><li>通过尝试不同的表示方法来消除难点，然后重构代码，并对类、方法和模块重新命名，以便与新模型一致。</li><li>需要对各种词语，无论是在工程上的，还是在商业上的，都有更好的理解</li><li>要认识到Uniquitous Language当中的更改就是对模型的更改。</li></ul></li></ul><h3 id="1-3-2-文档和图"><a href="#1-3-2-文档和图" class="headerlink" title="1.3.2 文档和图"></a>1.3.2 文档和图</h3><ul><li>UML图有用，但是会容易是你陷入细节当中</li><li>图应该是一种直观的给你综合概念和视角的工具，而不是落于细节当中。</li><li>设计的重要细节应该在代码当中体现出来</li></ul><ul><li>书面设计文档<ul><li>提供稳定和共享的交流</li><li>文档应该作为代码和口头交流的补充</li></ul></li><li>解释性模型<ul><li>没有UML 没有类</li><li>就是单纯的用图来描述商业上的使用案例</li></ul></li></ul><h1 id="2-模型驱动设计的构造块-阐述核心最佳实践"><a href="#2-模型驱动设计的构造块-阐述核心最佳实践" class="headerlink" title="2. 模型驱动设计的构造块 - 阐述核心最佳实践"></a>2. 模型驱动设计的构造块 - 阐述核心最佳实践</h1><h1 id="3-通过重构加深理解-如何将构造块装配为实用的模型"><a href="#3-通过重构加深理解-如何将构造块装配为实用的模型" class="headerlink" title="3. 通过重构加深理解 - 如何将构造块装配为实用的模型"></a>3. 通过重构加深理解 - 如何将构造块装配为实用的模型</h1><h1 id="4-战略设计-讨论在复杂系统交互中的情况"><a href="#4-战略设计-讨论在复杂系统交互中的情况" class="headerlink" title="4. 战略设计 - 讨论在复杂系统交互中的情况"></a>4. 战略设计 - 讨论在复杂系统交互中的情况</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在看博文的时候看到了关于DDD的内容，确实发现在工程上碰到了一些些问题，关于核心领域，关于领域驱动，毕竟技术是为了解决实际问题的，只有在对某个领域有着较深的理解的前提下，才能做出更有利于维护，更容易扩展的软件。&lt;/p&gt;
&lt;p&gt;本书想说的就是在大规模工程上，如何来控制整体的复
      
    
    </summary>
    
    
      <category term="Notes" scheme="https://www.llchen60.com/categories/Notes/"/>
    
    
      <category term="System Design" scheme="https://www.llchen60.com/tags/System-Design/"/>
    
      <category term="BackEnd" scheme="https://www.llchen60.com/tags/BackEnd/"/>
    
      <category term="DDD" scheme="https://www.llchen60.com/tags/DDD/"/>
    
  </entry>
  
  <entry>
    <title>架构学习-高性能架构模式</title>
    <link href="https://www.llchen60.com/%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.llchen60.com/%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-02-04T04:25:06.000Z</published>
    <updated>2020-02-04T04:27:50.684Z</updated>
    
    <content type="html"><![CDATA[<p>高性能架构模式，本文会总结业界相对比较成熟的各种架构模式，大部分情况下，我们会基于这些已有的成熟模式，结合业务和团队的具体情况来进行一定的优化或调整。</p><p>很多情况下高性能的设计最核心的部分就是关系数据库的设计。单个数据库在当前情况下是很难满足业务需求的了，必须考虑<strong>数据库集群</strong>的方式来提升性能。高性能架构，其关键点就在于数据库层如何实现高性能，有很多种方式，先来介绍读写分离原理。</p><h1 id="1-高性能数据库集群-读写分离"><a href="#1-高性能数据库集群-读写分离" class="headerlink" title="1. 高性能数据库集群 - 读写分离"></a>1. 高性能数据库集群 - 读写分离</h1><p>读写分离的基本原理就是将数据库读写操作分散到不同的节点上。<br><img src="https://i.loli.net/2020/02/04/DHT92UafyWt4hZx.png" alt="fig1.png"></p><h2 id="1-1-基本实现-主从集群"><a href="#1-1-基本实现-主从集群" class="headerlink" title="1.1 基本实现 - 主从集群"></a>1.1 基本实现 - 主从集群</h2><ul><li>数据库服务器搭建主从集群，一主一从到一主多从皆可。</li><li>数据库主机负责读写操作，从机只负责读操作</li><li>数据库主机通过复制将数据同步到从机，每台数据库服务器都存储了所有的业务数据</li><li>业务服务器将写操作发给数据库主机，将读操作发给数据库从机</li></ul><p>注意这里实现的主从集群，而不是主备集群，主从，从属的还是要接收请求的，主备中的备是完全的备用目的，基本不会有流量。</p><h2 id="1-2-主从复制延迟"><a href="#1-2-主从复制延迟" class="headerlink" title="1.2 主从复制延迟"></a>1.2 主从复制延迟</h2><p>以 MySQL 为例，主从复制延迟可能达到 1 秒，如果有大量数据同步，延迟 1 分钟也是有可能的。主从复制延迟会带来一个问题：如果业务服务器将数据写入到数据库主服务器后立刻（1 秒内）进行读取，此时读操作访问的是从机，主机还没有将数据复制过来，到从机读取数据是读不到最新数据的，业务上就可能出现问题。例如，用户刚注册完后立刻登录，业务服务器会提示他“你还没有注册”，而用户明明刚才已经注册成功了。</p><p>解决复制延迟的常见方法：</p><ul><li>写操作以后的读操作指定发给数据库主服务器<ul><li>和业务强绑定，容易发生bug</li></ul></li><li>读从机失败之后再读一次主机<ul><li>二次读取和业务无绑定，只需要对底层数据库访问的API进行封装即可，实现代价小</li><li>不足之处是如果有大量二次读取，那么主机压力会很大，可能会导致崩溃</li><li>关键业务读写操作全部指向主机，非关键业务采用读写分离</li></ul></li></ul><h2 id="1-3-分配机制-如何区分读写操作，访问不同的数据库服务器"><a href="#1-3-分配机制-如何区分读写操作，访问不同的数据库服务器" class="headerlink" title="1.3 分配机制 - 如何区分读写操作，访问不同的数据库服务器"></a>1.3 分配机制 - 如何区分读写操作，访问不同的数据库服务器</h2><h3 id="1-3-1-程序代码封装"><a href="#1-3-1-程序代码封装" class="headerlink" title="1.3.1 程序代码封装"></a>1.3.1 程序代码封装</h3><p>指在代码中抽象出一个数据访问层，实现读写分离的操作和数据库服务器的连接管理。例如基于Hibernate进行简单封装</p><p><img src="https://i.loli.net/2020/02/04/MjT7sUolRfiI1x4.png" alt="fig2.png"></p><ul><li>实现简单，可以根据业务做较多的定制化功能</li><li>每个编程语言都要自己实现一次，没法通用，如果一个业务包含多个编程语言的多个子系统，那么重复开发工作量比较大</li><li>故障情况下，如果主从切换，那么所有系统都很可能需要修改配置并重启</li></ul><h3 id="1-3-2-中间件封装"><a href="#1-3-2-中间件封装" class="headerlink" title="1.3.2 中间件封装"></a>1.3.2 中间件封装</h3><p>指独立出一套系统来，实现读写操作分离和数据库服务器连接的管理。中间件对业务服务器提供SQL兼容的协议，业务服务器无须自己进行读写分离。对于业务服务器来说，访问中间件</p><p><img src="https://i.loli.net/2020/02/04/26cDtZv1Ia5rSye.png" alt="fig3.png"></p><ul><li>能够支持多种编程语言，因为中间件对业务服务器提供的是标准SQL接口</li><li>中间件要支持完整的SQL语法和数据库服务器的协议，实现复杂，bug会比较多，需要较长时间才可以稳定下来</li><li>中间件自己不执行读写，但是所有数据库的操作请求都要经过中间件，所以对于性能有很高的要求</li><li>数据库主从切换对业务服务器无感知，数据库中间件可以探测数据库服务器的主从状态</li></ul><p>现在市面上有的中间件，MySQL Router, Atlas </p><h1 id="2-分库分表"><a href="#2-分库分表" class="headerlink" title="2. 分库分表"></a>2. 分库分表</h1><p>读写分离可以分散数据库读写操作的压力，但没有分散存储压力，当数据量达到千万级别的时候，单台数据库服务器的存储能力会成为系统的瓶颈, 这体现在：</p><ul><li>数据量过大，读写性能会下降；即使有索引，索引也会变大，性能同样会下降</li><li>数据文件会变得很大，数据库北非和恢复需要耗费很长时间</li><li>数据文件越大，极端情况下丢失数据的风险就越高</li></ul><p>基于上述原因，单个数据库服务器存储的数据量不能太大，需要控制在一定的范围内。将存储分散到多台数据库服务器上。</p><h2 id="2-1-业务分库"><a href="#2-1-业务分库" class="headerlink" title="2.1 业务分库"></a>2.1 业务分库</h2><blockquote><p>业务分库指的是按照业务模块将数据分散到不同的数据库服务器。</p></blockquote><p>譬如一个电商网站，将用户数据，商品数据，订单数据分开放到三台不同的数据库服务器上。虽然业务分库能够分散存储和访问的压力，但是也带来了新的问题。</p><h3 id="2-1-1-join操作问题"><a href="#2-1-1-join操作问题" class="headerlink" title="2.1.1 join操作问题"></a>2.1.1 join操作问题</h3><p>原先在一个表里的数据现在分散到了多个表当中，这就导致无法使用SQL的join来进行查询了。</p><h3 id="2-1-2-事务问题"><a href="#2-1-2-事务问题" class="headerlink" title="2.1.2 事务问题"></a>2.1.2 事务问题</h3><p>原本在同一个数据库中不同的表可以在同一个事务中修改，业务分库以后，表分散到了不同的数据库当中，无法通过事务统一修改。 尽管有一个分布式事务的解决方案，但性能太低，与高性能的存储的目标是相违背的。</p><h3 id="2-1-3-成本问题"><a href="#2-1-3-成本问题" class="headerlink" title="2.1.3 成本问题"></a>2.1.3 成本问题</h3><p>一台变多台</p><h2 id="2-2-业务分表"><a href="#2-2-业务分表" class="headerlink" title="2.2 业务分表"></a>2.2 业务分表</h2><p>将不同业务数据分散存储到不同的数据库服务器，能够支撑百万甚至千万用户规模的业务，但如果业务继续发展，同一业务的单表数据也会达到单台数据库服务器的处理瓶颈。例如，淘宝的几亿用户数据，如果全部存放在一台数据库服务器的一张表中，肯定是无法满足性能要求的，此时就需要对单表数据进行拆分。</p><p>单表数据的拆分有两种方式： 垂直分表和水平分表</p><h3 id="2-2-1-垂直分表"><a href="#2-2-1-垂直分表" class="headerlink" title="2.2.1 垂直分表"></a>2.2.1 垂直分表</h3><p>原先比如是id, name, age, sex, nickname, 垂直分表以后可以变成</p><ul><li>id, name, age</li><li>id, sex, nickname </li></ul><p>也会带来复杂性，即表操作的数量要增加，原来的一次查询现在要变成多次查询了</p><h3 id="2-2-2-水平分表"><a href="#2-2-2-水平分表" class="headerlink" title="2.2.2 水平分表"></a>2.2.2 水平分表</h3><p>用2.2.1的例子来说明的话，会包含一样的attributes，只是总共行数变le</p><p>水平分表以后，某条数据具体属于哪个切分以后的子表，需要依靠路由算法来进行计算</p><ul><li>范围路由<ul><li>使用用户ID等分段</li><li>好处<ul><li>随数据增加平滑的扩充新表</li></ul></li><li>坏处<ul><li>分布不均</li></ul></li></ul></li><li>Hash路由<ul><li>选取某个列的值进行Hash运算，然后根据Hash结果分散到不同的数据表当中</li><li>复杂点<ul><li>初始表的数量选取，太多维护麻烦，太少可能会让单表性能存在问题</li><li>用了Hash以后重Hash(增加表数量)会非常麻烦</li></ul></li><li>好处  分布均匀</li></ul></li><li>配置路由<ul><li>路由表，用独立的表来记录路由信息 </li><li>缺点就是会多查询一次，先看了一眼路由表嘛</li></ul></li></ul><h1 id="3-高性能NoSQL"><a href="#3-高性能NoSQL" class="headerlink" title="3. 高性能NoSQL"></a>3. 高性能NoSQL</h1><p>关系型数据库存在问题：</p><ul><li>关系数据库存储的是行记录，无法存储数据结构</li><li>关系数据库的schema扩展不方便<ul><li>schema是强约束的，操作不存在的列会报错，业务变化时扩充列也会比较麻烦，需要执行DDL (data definition language  create, alter, drop等) 语句修改，而且修改时可能会长时间锁表</li></ul></li><li>关系数据库在大数据场景下I/O较高<ul><li>对于每一行数据量都很大的表做统计之类的运算的时候I/O会很高，因为即使只针对其中某一列进行运算，关系数据库也会将整行数据从存储设备读入内存。 </li></ul></li><li>关系数据库的全文搜索功能比较弱</li></ul><p>针对上面的问题，产生了不同的NoSQL解决方案，在某一方面会有更好的表现。此外，NoSQL的方案带来的优势，本质上是牺牲ACID中的某个或者某几个特性，因此我们不能盲目地迷信NoSQL是银弹，应该将NoSQl作为SQL的一个有力补充。</p><p>常见NoSQL分类：</p><ul><li>K-V 存储: 解决SQL无法存储数据结构的问题</li><li>文档数据库：解决SQL强schema约束的问题</li><li>列式数据库：解决SQL大数据场景下的I/O问题，以HBase为代表</li><li>全文搜索引擎：解决关系数据库的全文搜索性能问题， ElasticSearch </li></ul><h2 id="3-1-Key-Value存储"><a href="#3-1-Key-Value存储" class="headerlink" title="3.1 Key - Value存储"></a>3.1 Key - Value存储</h2><p>Redis 是 K-V 存储的典型代表，它是一款开源（基于 BSD 许可）的高性能 K-V 缓存和存储系统。Redis 的 Value 是具体的数据结构，包括 string、hash、list、set、sorted set、bitmap 和 hyperloglog，所以常常被称为数据结构服务器。</p><p>更灵活的对数据的操作：</p><ul><li>LPOP key 从队列的左边出队一个元素。</li><li>LINDEX key index 获取一个元素，通过其索引列表。</li><li>LLEN key 获得队列（List）的长度。</li></ul><p>Redis 的缺点主要体现在并不支持完整的 ACID 事务，Redis 虽然提供事务功能，但 Redis 的事务和关系数据库的事务不可同日而语，Redis 的事务只能保证隔离性和一致性（I 和 C），无法保证原子性和持久性（A 和 D）。</p><h2 id="3-2-文档数据库"><a href="#3-2-文档数据库" class="headerlink" title="3.2 文档数据库"></a>3.2 文档数据库</h2><p>最大特点是no-schema，可以存储和读取任意的数据。带来优势：</p><ul><li>新增字段简单</li><li>历史数据不会出错</li><li>可以很容易存储复杂数据</li></ul><p>缺陷</p><ul><li>事务</li><li>没有join操作</li></ul><h2 id="3-3-列式数据库"><a href="#3-3-列式数据库" class="headerlink" title="3.3 列式数据库"></a>3.3 列式数据库</h2><p>按照列来存储数据，典型场景海量数据统计，只需要其中的一两列的数据即可。I/O相对低一些。</p><p>列式存储有更高的存储压缩比，因为单个列的数据相似度一般来说比行更高，能够达到更高的压缩率。</p><p>一般将其用在离线的大数据分析和统计的场景当中，因为这种场景经常是针对部分单列来进行操作的，数据写入以后无须更新删除。</p><h2 id="3-4-全文搜索引擎"><a href="#3-4-全文搜索引擎" class="headerlink" title="3.4 全文搜索引擎"></a>3.4 全文搜索引擎</h2><ul><li>全文搜索的条件可以随意排列组合，如果通过索引来满足，则索引的数量会非常多</li><li>全文搜索的模糊匹配方式，索引无法满足，只能用like，而like是整表扫描，很慢</li></ul><h3 id="3-4-1-基本原理"><a href="#3-4-1-基本原理" class="headerlink" title="3.4.1 基本原理"></a>3.4.1 基本原理</h3><ul><li>倒排索引/ 反向索引<ul><li>建立单词到文档的索引 </li><li>即用关键词来查，显示出出现的地方</li></ul></li></ul><h3 id="3-4-2-使用方式"><a href="#3-4-2-使用方式" class="headerlink" title="3.4.2 使用方式"></a>3.4.2 使用方式</h3><p>将数据库里面的内容转成JSON格式，然后输入全文搜索引擎进行搜索。 ES能够以实时化的方式，存储和检索复杂的数据结构，并令每个字段都默认可以被索引。</p><h1 id="4-高性能缓存结构"><a href="#4-高性能缓存结构" class="headerlink" title="4. 高性能缓存结构"></a>4. 高性能缓存结构</h1><p>存储系统的能力有的时候并不够用，比如</p><ul><li>需要经过复杂运算得出的数据  – 比如实时在线人数</li><li>读多写少的数据</li></ul><p>缓存就是为了弥补存储系统在这些复杂业务场景下的不足，其基本原理就是将可能重复使用的数据放到内存当中，一次生成，多次使用，避免每次使用都去访问存储系统。</p><p>缓存能够带来性能的大幅提升，以memcache为例，单台就可以达到TPS50000以上，基本架构就是第一次从数据库拿数据，第二次及以后就可以从memcached中来取得数据了。</p><h2 id="4-1-缓存穿透"><a href="#4-1-缓存穿透" class="headerlink" title="4.1 缓存穿透"></a>4.1 缓存穿透</h2><p>指缓存没有发挥作用，虽然去查询了缓存数据，但是不在那里面，业务系统就需要再次去存储系统查询数据，这种情况的出现通常是因为：</p><ul><li>存储数据不存在</li></ul><p>黑客攻击，故意大量访问某些读取不存在数据的业务。解决方案就是设置一个默认值，放到缓存里面，这样第二次读取缓存的时候就会获取默认值，而不会继续访问存储系统。</p><ul><li>缓存数据生成耗费大量的时间或者资源</li></ul><p>第二种情况是存储系统中存在数据，但生成缓存数据需要耗费较长时间或者耗费大量资源。如果刚好在业务访问的时候缓存失效了，那么也会出现缓存没有发挥作用，访问压力全部集中在存储系统上的情况。</p><p>典型的就是电商的商品分页，假设我们在某个电商平台上选择“手机”这个类别查看，由于数据巨大，不能把所有数据都缓存起来，只能按照分页来进行缓存，由于难以预测用户到底会访问哪些分页，因此业务上最简单的就是每次点击分页的时候按分页计算和生成缓存。通常情况下这样实现是基本满足要求的，但是如果被竞争对手用爬虫来遍历的时候，系统性能就可能出现问题。</p><h2 id="4-2-缓存雪崩"><a href="#4-2-缓存雪崩" class="headerlink" title="4.2 缓存雪崩"></a>4.2 缓存雪崩</h2><p>是指当缓存失效（过期）后引起系统性能急剧下降的情况。当缓存过期被清除后，业务系统需要重新生成缓存，因此需要再次访问存储系统，再次进行运算，这个处理步骤耗时几十毫秒甚至上百毫秒。而对于一个高并发的业务系统来说，几百毫秒内可能会接到几百上千个请求。由于旧的缓存已经被清除，新的缓存还未生成，并且处理这些请求的线程都不知道另外有一个线程正在生成缓存，因此所有的请求都会去重新生成缓存，都会去访问存储系统，从而对存储系统造成巨大的性能压力。这些压力又会拖慢整个系统，严重的会造成数据库宕机，从而形成一系列连锁反应，造成整个系统崩溃。</p><p>为了解决，通常可以采用两种方案： 更新锁机制和后台更新机制。</p><h3 id="4-2-1-更新锁"><a href="#4-2-1-更新锁" class="headerlink" title="4.2.1 更新锁"></a>4.2.1 更新锁</h3><p>对缓存更新操作进行加锁保护，保证只有一个线程能够进行缓存更新，未能获取更新锁的线程要么等待锁释放以后重新读取缓存，要么就返回空值或者默认值。</p><p>对于采用分布式集群的业务系统，由于存在几十上百台服务器，即使单台服务器只有一个线程更新缓存，但几十上百台服务器一起算下来也会有几十上百个线程同时来更新缓存，同样存在雪崩的问题。因此分布式集群的业务系统要实现更新锁机制，需要用到分布式锁，如 ZooKeeper。</p><h3 id="4-2-2-后台更新"><a href="#4-2-2-后台更新" class="headerlink" title="4.2.2 后台更新"></a>4.2.2 后台更新</h3><p>由后台线程来更新缓存，而不是业务线程。缓存本身的有效期设置为永久，后台线程定时更新缓存。</p><p>后台定时机制需要考虑一种特殊的场景，当缓存系统内存不够时，会“踢掉”一些缓存数据，从缓存被“踢掉”到下一次定时更新缓存的这段时间内，业务线程读取缓存返回空值，而业务线程本身又不会去更新缓存，因此业务上看到的现象就是数据丢了。解决的方式有两种：</p><ul><li>后台线程除了定时更新缓存，还要频繁地去读取缓存（例如，1 秒或者 100 毫秒读取一次），如果发现缓存被“踢了”就立刻更新缓存，这种方式实现简单，但读取时间间隔不能设置太长，因为如果缓存被踢了，缓存读取间隔时间又太长，这段时间内业务访问都拿不到真正的数据而是一个空的缓存值，用户体验一般。</li><li>业务线程发现缓存失效后，通过消息队列发送一条消息通知后台线程更新缓存。可能会出现多个业务线程都发送了缓存更新消息，但其实对后台线程没有影响，后台线程收到消息后更新缓存前可以判断缓存是否存在，存在就不执行更新操作。这种方式实现依赖消息队列，复杂度会高一些，但缓存更新更及时，用户体验更好。</li></ul><h2 id="4-3-缓存热点"><a href="#4-3-缓存热点" class="headerlink" title="4.3 缓存热点"></a>4.3 缓存热点</h2><p>复制多份缓存副本，将请求分散到多个缓存服务器上，减轻缓存热点导致的单台缓存服务器的压力。</p><p>注意不同的缓存副本不要设置统一的过期时间，否则会出现所有缓存副本同时生成同时失效的情况，从而引发缓存雪崩效应。正确的做法是设定一个过期的时间范围，不同的缓存副本的过期时间是指定范围内的随机值。</p><h1 id="5-单服务器高性能模式-并发模型"><a href="#5-单服务器高性能模式-并发模型" class="headerlink" title="5. 单服务器高性能模式 - 并发模型"></a>5. 单服务器高性能模式 - 并发模型</h1><ul><li>影响高性能效果的因素<ul><li>磁盘</li><li>操作系统</li><li>CPU</li><li>内存</li><li>缓存</li><li>网络</li><li>编程语言</li><li>架构</li></ul></li></ul><p>高性能架构设计主要集中在两个方面：</p><ul><li>尽量提升单服务器的性能，将单服务器的性能发挥到极致</li><li>如果单服务器无法支撑性能，设计服务器集群方案</li></ul><ul><li><p>关键设计点</p><ul><li>服务器如何管理连接</li><li>服务器如何处理请求</li></ul></li><li><p>常见分类</p><ul><li>海量连接海量请求：双十一</li><li>常量连接海量请求：中间件</li><li>海量连接常量请求：门户网站</li><li>常量连接常量请求：内部运营系统，管理系统<br>这两个设计点都和操作系统的I/O模型以及进程模型相关。</li></ul></li><li><p>BIO: 一个线程处理一个请求</p></li><li><p>NIO：利用多路复用技术，通过少量的线程处理大量的请求</p></li><li><p>I/O 模型</p><ul><li>阻塞</li><li>非阻塞</li><li>同步</li><li>异步</li></ul></li><li><p>进程模型</p><ul><li>单进程</li><li>多进程</li><li>多线程</li></ul></li></ul><h2 id="5-1-PPC-Process-Per-Connection"><a href="#5-1-PPC-Process-Per-Connection" class="headerlink" title="5.1 PPC - Process Per Connection"></a>5.1 PPC - Process Per Connection</h2><p>每次有新的连接就新建一个进程去专门处理这个连接的请求，这也是传统的UNIX网络服务器锁采用的模型。</p><p><img src="https://i.loli.net/2020/02/04/NDdUCRi3klst8qM.png" alt="fig4.png"></p><ul><li>父进程接受连接</li><li>父进程fork子进程</li><li>子进程处理连接的读写请求</li><li>子进程关闭连接</li></ul><p>PPC 模式实现简单，比较适合服务器的连接数没那么多的情况，例如数据库服务器。对于普通的业务服务器，在互联网兴起之前，由于服务器的访问量和并发量并没有那么大，这种模式其实运作得也挺好，世界上第一个 web 服务器 CERN httpd 就采用了这种模式。但随着互联网星期，服务器的并发量和访问量都有了很大的提高，这种方法就涌现出了不少弊端</p><ul><li>fork代价比较高，要分配很多内核资源，需要将内存映像从父进程复制到子进程。</li><li>父子进程通信复杂，父进程fork子进程时，文件描述符可以通过内存映像复制从父进程传到子进程，但fork完成之后，父子进程通信就比较麻烦了，需要采用IPC(Interprocess Communication)之类的进程通信方案。</li><li>支持的并发连接数量有限，如果每个连接存活时间比较长，而且新的连接又源源不断的来，则进程数量会越来越多，操作系统进程调度和切换的频率也会越来越高，系统的压力也会越来越大。一般来说，PPC方案最大的并发连接数就几百的样子。</li></ul><h2 id="5-2-prefork-提前创建进程"><a href="#5-2-prefork-提前创建进程" class="headerlink" title="5.2 prefork 提前创建进程"></a>5.2 prefork 提前创建进程</h2><p>在启动的时候就预先创建好进程，然后开始接受用户的请求。当有新的连接进来的时候，就可以省去fork进程的操作，让用户访问更快，体验更好。</p><p><img src="https://i.loli.net/2020/02/04/2ukZmRXP8cWyolE.jpg" alt="fig5.jpg"></p><p>实现关键点在多个子进程都accept同一个socket，当有新的连接接入时，操作系统保证只有一个进程能最后accept成功。</p><p>prefork还是和PPC一样，存在父子进程通信复杂，支持的并发连接数量有限的问题。</p><h2 id="5-3-TPC-Thread-Per-Connection"><a href="#5-3-TPC-Thread-Per-Connection" class="headerlink" title="5.3 TPC - Thread Per Connection"></a>5.3 TPC - Thread Per Connection</h2><p>每次有新的连接，就建立一个新的线程去专门处理这个连接的请求。与进程相比，线程更轻量级，创建线程的消耗比进程要少得多；同时因为多线程共享进程内存空间，就可以简化线程之间通信的复杂程度。</p><p><img src="https://i.loli.net/2020/02/04/3qdx1ofOb8sLW4k.png" alt="fig6.png"></p><ul><li>父进程接受连接</li><li>父进程创建子线程</li><li>子线程处理连接的读写请求</li><li>子线程关闭连接</li></ul><p>和PPC相比，主进程不用close了，原因是子线程是共享主进程的进程空间的，连接的文件描述符并没有被复制，因此只需要一次close即可。</p><p>TPC引入了新的问题：</p><ul><li>创建线程依然有耗损，性能问题</li><li>线程间的互斥和共享的复杂度</li><li>多线程会互相影响，某个线程出现异常的时候，可能导致整个进程的退出</li></ul><p>在并发几百的情况下，还是会更多采用PPC的方案，因为无死锁的风险，也不会有多进程之间的相互影响，稳定性更高。</p><h2 id="5-4-prethread"><a href="#5-4-prethread" class="headerlink" title="5.4 prethread"></a>5.4 prethread</h2><p>预先创建线程，然后才开始接受用户的请求，当有新的连接进来的时候，就可以省去创建线程的操作，让用户感觉更快。常用的实现方式：</p><ul><li>主进程accept，然后将连接交给某个线程处理</li><li>子线程都尝试去accept，最终只有一个线程accept成功</li></ul><p><img src="https://i.loli.net/2020/02/04/8GsTH1Fokv2PLYf.jpg" alt="fig7.jpg"></p><h2 id="5-5-Reactor"><a href="#5-5-Reactor" class="headerlink" title="5.5 Reactor"></a>5.5 Reactor</h2><p>PPC模式的问题是每个连接都要创建进程，连接结束进程就被销毁了。为了解决这个问题，瞄准资源复用，即不再单独为每个连接创建进程，而是创建一个进程池，将连接分配给进程，一个进程可以处理多个连接的业务。</p><blockquote><p>一个进程处理多个连接的业务</p></blockquote><p>引入资源池的处理方式后，会引出一个新的问题：进程如何才能高效地处理多个连接的业务？当一个连接一个进程时，进程可以采用“read -&gt; 业务处理 -&gt; write”的处理流程，如果当前连接没有数据可以读，则进程就阻塞在 read 操作上。这种阻塞的方式在一个连接一个进程的场景下没有问题，但如果一个进程处理多个连接，进程阻塞在某个连接的 read 操作上，此时即使其他连接有数据可读，进程也无法去处理，很显然这样是无法做到高性能的。</p><p>为了解决这个问题，可以将read操作改为非阻塞的，然后进程不断轮询多个连接。但是这样做，不好的地方在于轮询耗费CPU资源；其次，如果一个进程处理成千上万的连接，轮询的效率是很低的。</p><blockquote><p>更好的解决办法，只有当连接上有数据的时候进程才去处理，这就是I/O多路复用的技术的来源</p></blockquote><ul><li>当多条连接共用一个阻塞对象后，进程只需要在一个阻塞对象上等待，而无须再轮询所有连接，常见的连接方式有select\epoll\kqueue等。</li><li>当某条连接有新的数据可以处理时，操作系统会通知进程，进程从阻塞状态返回，开始进行业务处理</li></ul><p>I/O多路复用结合线程池，就是我们说的Reactor了，即事件反应的意思</p><p>Reactor会根据事件类型来调用相应的代码进行处理，也成为dispatcher模式，指的是I/O多路复用统一监听事件，收到事件后分配给某个进程的过程。 </p><ul><li>Reactor模式的benefits<ul><li>reactor数量可以变化</li><li>资源池的数量可以变化: 以进程为例，可以是单进程的，也可以是多个进程的</li></ul></li></ul><ul><li>常见的使用方式<ul><li>单 Reactor 单进程 / 线程。</li><li>单 Reactor 多线程。</li><li>多 Reactor 多进程 / 线程。</li></ul></li></ul><p>上述方案选择进程还是线程，更多和平台以及编程语言相关。例如Java一般使用线程 - Netty, Nginx选择进程</p><h3 id="5-5-1-单Reactor-单进程-线程"><a href="#5-5-1-单Reactor-单进程-线程" class="headerlink" title="5.5.1 单Reactor 单进程/ 线程"></a>5.5.1 单Reactor 单进程/ 线程</h3><p><img src="https://i.loli.net/2020/02/04/YW2N7ZBcuirMUAb.png" alt="fig8.png"></p><ul><li>select, accept, read, send是标准的网络编程API</li><li>dispatch和业务处理是需要完成的操作</li><li>Reactor对象通过select监控连接时间，收到事件以后通过dispatch来进行转发</li><li>如果是连接建立事件，就交给Acceptor，来接受连接，并创建一个Handler来处理接下来的各种事件</li><li>如果不是连接事件，就会用上面已经建好的handler来处理请求，做出响应</li><li>Handler会完成read - 业务处理 -send的完整业务流程</li></ul><ul><li>Benefits<ul><li>无进程间通信</li><li>无进程竞争</li></ul></li><li>Weakness<ul><li>只有一个进程，无法发挥出多核CPU的性能</li><li>handler在处理某个连接上的业务时，整个进程就无法处理</li></ul></li></ul><p>只适用于业务处理非常快速的场景，目前比较著名的使用这个的开源软件是Redis</p><h3 id="5-5-2-单Reactor-多线程"><a href="#5-5-2-单Reactor-多线程" class="headerlink" title="5.5.2 单Reactor 多线程"></a>5.5.2 单Reactor 多线程</h3><p><img src="https://i.loli.net/2020/02/04/GlJTpkZ4DojR9HN.png" alt="fig9.png"></p><ul><li>主线程当中，Reactor对象通过select监控连接时间，收到事件后通过dispatch进行分发</li><li>blabla… similar to above</li><li>Handler只负责响应事件，不进行业务处理；Handler通过read读取到数据后，会发给processor进行业务处理</li><li>Processor会在独立的子线程当中完成真正的业务处理，然后将响应结果发给主进程的Handler处理；Handler收到响应以后通过send将响应结果返回给client </li><li>Benefits<ul><li>能够充分利用多核多CPU的处理能力</li></ul></li><li>Weakness<ul><li>多线程数据共享和访问比较复杂</li><li>reactor承担所有事件的监听和响应，只在主线程中进行，瞬间高并发会成为性能瓶颈</li></ul></li></ul><h3 id="5-5-3-多Reactor-多进程-线程"><a href="#5-5-3-多Reactor-多进程-线程" class="headerlink" title="5.5.3 多Reactor 多进程/ 线程"></a>5.5.3 多Reactor 多进程/ 线程</h3><p><img src="https://i.loli.net/2020/02/04/wfyzTL47eUjQaBY.png" alt="fig10.png"></p><ul><li>父进程中mainReactor对象通过select监控连接建立事件，收到事件后通过Acceptor接收，将新的连接分配给某个子进程。</li><li>子进程的subReactor将mainReactor分配的连接加入连接队列进行监听，并创建一个Handler用于处理连接的各种事件</li><li>当有新的事件发生时，subReactor会调用连接对应的handler来进行响应</li><li>handler完成read - 业务处理 -send的流程</li><li>Benefits<ul><li>父进程和子进程的职责非常明确，父进程只负责接收新连接，子进程负责完成后续的业务处理。</li><li>父进程和子进程的交互很简单，父进程只需要把新连接传给子进程，子进程无须返回数据。</li><li>子进程之间是互相独立的，无须同步共享之类的处理（这里仅限于网络模型相关的 select、read、send 等无须同步共享，“业务处理”还是有可能需要同步共享的）。</li></ul></li></ul><h2 id="5-6-Proactor"><a href="#5-6-Proactor" class="headerlink" title="5.6 Proactor"></a>5.6 Proactor</h2><p>Reactor是非阻塞同步网络模型，因为真正的read和send操作都需要用户进程同步操作，proactor将其异步化，</p><p><img src="https://i.loli.net/2020/02/04/gV6YdJM3CLloBiA.png" alt="fig11.png"></p><ul><li>Proactor Initiator 负责创建 Proactor 和 Handler，并将 Proactor 和 Handler 都通过 Asynchronous Operation Processor 注册到内核。</li><li>Asynchronous Operation Processor 负责处理注册请求，并完成 I/O 操作。</li><li>Asynchronous Operation Processor 完成 I/O 操作后通知 Proactor。</li><li>Proactor 根据不同的事件类型回调不同的 Handler 进行业务处理。</li><li>Handler 完成业务处理，Handler 也可以注册新的 Handler 到内核进程。</li></ul><h2 id="5-7-同步阻塞IO-vs-同步非阻塞IO-vs-异步非阻塞IO"><a href="#5-7-同步阻塞IO-vs-同步非阻塞IO-vs-异步非阻塞IO" class="headerlink" title="5.7 同步阻塞IO vs 同步非阻塞IO vs 异步非阻塞IO"></a>5.7 同步阻塞IO vs 同步非阻塞IO vs 异步非阻塞IO</h2><table><thead><tr><th>-</th><th>等待数据准备好的阶段（读到内核缓存）</th><th>将数据从内核读到用户空间</th></tr></thead><tbody><tr><td>同步阻塞IO</td><td>阻塞</td><td>阻塞</td></tr><tr><td>同步非阻塞IO</td><td>非阻塞</td><td>阻塞</td></tr><tr><td>异步非阻塞IO</td><td>非阻塞</td><td>非阻塞</td></tr></tbody></table><h1 id="6-高性能负载均衡-分类及架构-高性能集群"><a href="#6-高性能负载均衡-分类及架构-高性能集群" class="headerlink" title="6. 高性能负载均衡 - 分类及架构 - 高性能集群"></a>6. 高性能负载均衡 - 分类及架构 - 高性能集群</h1><p>高性能集群的本质： 通过增加更多的服务器来提升系统整体的计算能力。</p><p>由于计算本身的特点，即同样的输入数据和逻辑，无论在哪台服务器上执行，都应该得到相同的输出。因此高性能集群设计的复杂度主要体现在<strong>任务分配</strong>这部分，需要设计合理的任务分配策略，将计算任务分配到多台服务器上来执行。</p><p>即复杂性主要体现在需要增加一个任务分配器，以及为任务选择一个合适的任务分配算法。</p><ul><li>任务分配算法的考虑因素<ul><li>计算单元的负载均衡</li><li>基于负载考虑</li><li>基于性能(吞吐量、响应时间)考虑</li><li>基于业务考虑</li></ul></li></ul><h2 id="6-1-负载均衡分类"><a href="#6-1-负载均衡分类" class="headerlink" title="6.1 负载均衡分类"></a>6.1 负载均衡分类</h2><h3 id="6-1-1-DNS负载均衡"><a href="#6-1-1-DNS负载均衡" class="headerlink" title="6.1.1 DNS负载均衡"></a>6.1.1 DNS负载均衡</h3><p>用于实现地理级别的均衡，其原理是DNS解析同一个域名，可以返回不同的IP地址。<br><img src="https://i.loli.net/2020/02/04/9Srot2PfYW35pux.jpg" alt="fig12.jpg"></p><ul><li>Benefits <ul><li>简单，成本低</li><li>负载均衡工作交给DNS服务器来处理，无须自己开发或者维护负载均衡设备</li><li>就近访问，提升访问速度</li></ul></li><li>weakness<ul><li>更新不及时，DNS缓存时间比较长，更新缓存以后，还有很多用户会访问修改前的IP，这样的访问会失败的</li><li>扩展性差，DNS负载均衡控制权在域名商那里，无法根据业务特点针对其做更多的定制化功能和特性的拓展</li><li>分配策略比较简单: DNS负载均衡的支持算法少，不能区分服务器的差异(不能根据系统与服务的状态来判断负载)，也无法感知后端服务器的状态。</li></ul></li></ul><h3 id="6-1-2-硬件负载均衡"><a href="#6-1-2-硬件负载均衡" class="headerlink" title="6.1.2 硬件负载均衡"></a>6.1.2 硬件负载均衡</h3><p>指通过单独的硬件设备来实现负载均衡的功能，类似路由器交换机，可以理解为一个用于负载均衡的基础网络设备。</p><ul><li><p>benefits </p><ul><li>功能强大，支持各层级负载均衡</li><li>性能强大，100万以上的并发</li><li>稳定性高</li><li>支持安全防护  DDos</li></ul></li><li><p>weakness</p><ul><li>价格昂贵</li><li>扩展能力差</li></ul></li></ul><h3 id="6-1-3-软件负载均衡"><a href="#6-1-3-软件负载均衡" class="headerlink" title="6.1.3 软件负载均衡"></a>6.1.3 软件负载均衡</h3><p>通过负载均衡软件来实现负载均衡的功能，常见的有Nginx - 软件的7层负载均衡和LVS - Linux内核的4层负载均衡。</p><p>Nginx支持HTTP，Email协议; 而LVS是4层负载均衡，和协议无关，几乎所有的应用都可以做。</p><p>软硬件最主要的区别在于性能，硬件负载均衡性能要远远高于软件的复杂均衡性能，但是软件的会便宜很多。</p><p><img src="https://i.loli.net/2020/02/04/3of7nFr6Ou1XsHg.jpg" alt="fig13.jpg"></p><ul><li>benefits<ul><li>部署维护简单</li><li>便宜</li><li>灵活，可扩展</li></ul></li></ul><h3 id="6-1-4-负载均衡的典型架构"><a href="#6-1-4-负载均衡的典型架构" class="headerlink" title="6.1.4 负载均衡的典型架构"></a>6.1.4 负载均衡的典型架构</h3><p>是结合起来一起用的，DNS负载均衡用于实现地理级别的负载均衡，硬件负载均衡用于实现集群级别的负载均衡，软件负载均衡用于实现机器级别的负载均衡。</p><p>整个系统的负载均衡分为三层：</p><ul><li>地理级别负载均衡</li><li>集群级别负载均衡  用硬件设备来做平均</li><li>机器级别的负载均衡  用nginx，收到用户的请求之后，将用户的请求发送给集群里面的某台服务器，服务器处理用户的业务请求并返回业务响应</li></ul><h2 id="6-2-高性能负载均衡-算法"><a href="#6-2-高性能负载均衡-算法" class="headerlink" title="6.2 高性能负载均衡 - 算法"></a>6.2 高性能负载均衡 - 算法</h2><h3 id="6-2-1-分类"><a href="#6-2-1-分类" class="headerlink" title="6.2.1 分类"></a>6.2.1 分类</h3><ul><li>任务平分类：负载均衡系统将收到的任务平均分配给服务器进行处理，这里的“平均”可以是绝对数量的平均，也可以是比例或者权重上的平均。</li><li>负载均衡类：负载均衡系统根据服务器的负载来进行分配，这里的负载并不一定是通常意义上我们说的“CPU 负载”，而是系统当前的压力，可以用 CPU 负载来衡量，也可以用连接数、I/O 使用率、网卡吞吐量等来衡量系统的压力。</li><li>性能最优类：负载均衡系统根据服务器的响应时间来进行任务分配，优先将新任务分配给响应最快的服务器。</li><li>Hash 类：负载均衡系统根据任务中的某些关键信息进行 Hash 运算，将相同 Hash 值的请求分配到同一台服务器上。常见的有源地址 Hash、目标地址 Hash、session id hash、用户 ID Hash 等。</li></ul><h3 id="6-2-2-轮询"><a href="#6-2-2-轮询" class="headerlink" title="6.2.2 轮询"></a>6.2.2 轮询</h3><p>负载均衡系统收到请求后，按照顺序轮流分配到服务器上。</p><p>需要注意的是负载均衡系统无须关注“服务器本身状态”，这里的关键词是“本身”。也就是说，只要服务器在运行，运行状态是不关注的。但如果服务器直接宕机了，或者服务器和负载均衡系统断连了，这时负载均衡系统是能够感知的，也需要做出相应的处理。例如，将服务器从可分配服务器列表中删除，否则就会出现服务器都宕机了，任务还不断地分配给它，这明显是不合理的。</p><h3 id="6-2-3-加权轮询"><a href="#6-2-3-加权轮询" class="headerlink" title="6.2.3 加权轮询"></a>6.2.3 加权轮询</h3><p>负载均衡系统根据服务器权重进行任务分配，这里的权重一般是根据硬件配置进行静态配置的，采用动态的方式计算会更加契合业务，但复杂度也会更高。加权轮询主要为了解决不同服务器的处理能力有差异的问题。</p><h3 id="6-2-4-负载最低优先"><a href="#6-2-4-负载最低优先" class="headerlink" title="6.2.4 负载最低优先"></a>6.2.4 负载最低优先</h3><p>从服务器的角度出发来看如何进行负载分配</p><p>负载均衡系统将任务分配给当前负载最低的服务器，这里的负载根据不同的任务类型和业务场景，可以用不同的指标来衡量。例如：</p><ul><li>LVS 这种 4 层网络负载均衡设备，可以以“连接数”来判断服务器的状态，服务器连接数越大，表明服务器压力越大。</li><li>Nginx 这种 7 层网络负载系统，可以以“HTTP 请求数”来判断服务器状态（Nginx 内置的负载均衡算法不支持这种方式，需要进行扩展）。</li><li>如果我们自己开发负载均衡系统，可以根据业务特点来选择指标衡量系统压力。如果是 CPU 密集型，可以以“CPU 负载”来衡量系统压力；如果是 I/O 密集型，可以以“I/O 负载”来衡量系统压力。</li></ul><p>负载最低优先算法解决了轮询算法中无法感知服务器状态的问题，但复杂度会增加很多。</p><ul><li>最少连接数优先的算法要求负载均衡系统统计每个服务器当前建立的连接，其应用场景仅限于负载均衡接收的任何连接请求都会转发给服务器进行处理，否则如果负载均衡系统和服务器之间是固定的连接池方式，就不适合采取这种算法。例如，LVS 可以采取这种算法进行负载均衡，而一个通过连接池的方式连接 MySQL 集群的负载均衡系统就不适合采取这种算法进行负载均衡。</li><li>CPU 负载最低优先的算法要求负载均衡系统以某种方式收集每个服务器的 CPU 负载，而且要确定是以 1 分钟的负载为标准，还是以 15 分钟的负载为标准，不存在 1 分钟肯定比 15 分钟要好或者差。不同业务最优的时间间隔是不一样的，时间间隔太短容易造成频繁波动，时间间隔太长又可能造成峰值来临时响应缓慢。</li></ul><h3 id="6-2-5-性能最优类"><a href="#6-2-5-性能最优类" class="headerlink" title="6.2.5 性能最优类"></a>6.2.5 性能最优类</h3><p>从客户端的角度，和负载最低优先类算法类似，性能最优优先类算法本质上也是感知了服务器的状态，只是通过响应时间这个外部标准来衡量服务器状态而已。因此性能最优优先类算法存在的问题和负载最低优先类算法类似，复杂度都很高，主要体现在：</p><ul><li>负载均衡系统需要收集和分析每个服务器每个任务的响应时间，在大量任务处理的场景下，这种收集和统计本身也会消耗较多的性能。</li><li>为了减少这种统计上的消耗，可以采取采样的方式来统计，即不统计所有任务的响应时间，而是抽样统计部分任务的响应时间来估算整体任务的响应时间。采样统计虽然能够减少性能消耗，但使得复杂度进一步上升，因为要确定合适的采样率</li><li>采样周期，要10s性能最优还是1min性能最优</li></ul><h3 id="6-2-6-Hash类"><a href="#6-2-6-Hash类" class="headerlink" title="6.2.6 Hash类"></a>6.2.6 Hash类</h3><p>负载均衡系统根据任务中的某些关键信息进行 Hash 运算，将相同 Hash 值的请求分配到同一台服务器上，这样做的目的主要是为了满足特定的业务需求。</p><ul><li>源地址Hash<ul><li>将来源于同一个源 IP 地址的任务分配给同一个服务器进行处理，适合于存在事务、会话的业务。例如，当我们通过浏览器登录网上银行时，会生成一个会话信息，这个会话是临时的，关闭浏览器后就失效。网上银行后台无须持久化会话信息，只需要在某台服务器上临时保存这个会话就可以了，但需要保证用户在会话存在期间，每次都能访问到同一个服务器，这种业务场景就可以用源地址 Hash 来实现。</li></ul></li><li>ID Hash<ul><li>将某个 ID 标识的业务分配到同一个服务器中进行处理，这里的 ID 一般是临时性数据的 ID（如 session id）。例如，上述的网上银行登录的例子，用 session id hash 同样可以实现同一个会话期间，用户每次都是访问到同一台服务器的目的。 </li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;高性能架构模式，本文会总结业界相对比较成熟的各种架构模式，大部分情况下，我们会基于这些已有的成熟模式，结合业务和团队的具体情况来进行一定的优化或调整。&lt;/p&gt;
&lt;p&gt;很多情况下高性能的设计最核心的部分就是关系数据库的设计。单个数据库在当前情况下是很难满足业务需求的了，必须考
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="架构" scheme="https://www.llchen60.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>架构学习-高可用架构模式</title>
    <link href="https://www.llchen60.com/%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0-%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.llchen60.com/%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0-%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-02-04T04:21:29.000Z</published>
    <updated>2020-02-04T04:24:26.977Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-CAP-原理"><a href="#1-CAP-原理" class="headerlink" title="1. CAP 原理"></a>1. CAP 原理</h1><p>CAP原理讨论得是对于数据的读写操作，并不是在讨论整个系统的各个方面的功能。并且讨论得是在互联和分享数据过程当中出现的问题</p><ul><li>Consistency  一致性<ul><li>where all nodes see the same data at the same time </li><li>a read is guaranteed to return the most recent write for a given client </li></ul></li><li>Availability 可用性<ul><li>guarantee that every request receives a response about whether it succeed or fail </li><li>a non-faling node will return a reasonable response within a reasonable amount of time (no error or timeout)</li></ul></li><li>Partition tolerance  分区容错性 <ul><li>the system continues to operate even if any one part of the system is lost or fails  </li><li>the system will continue to function when network partitions occur </li></ul></li></ul><h2 id="1-1-CAP的选择"><a href="#1-1-CAP的选择" class="headerlink" title="1.1. CAP的选择"></a>1.1. CAP的选择</h2><p>分布式系统理论上来说无法选择CA架构，因为P是客观存在的，当网络分区发生的时候，为了保证C，那么只能回报错误给Client，这实质上就违反了A了。</p><h3 id="1-1-1-CP架构"><a href="#1-1-1-CP架构" class="headerlink" title="1.1.1 CP架构"></a>1.1.1 CP架构</h3><p>如下图所示，为了保证一致性，当发生分区现象后，N1 节点上的数据已经更新到 y，但由于 N1 和 N2 之间的复制通道中断，数据 y 无法同步到 N2，N2 节点上的数据还是 x。这时客户端 C 访问 N2 时，N2 需要返回 Error，提示客户端 C“系统现在发生了错误”，这种处理方式违背了可用性（Availability）的要求，因此 CAP 三者只能满足 CP。</p><p><img src="https://i.loli.net/2020/02/04/xXwWelYMtLu2hVv.png" alt="fig1.png"></p><h3 id="1-1-2-AP架构"><a href="#1-1-2-AP架构" class="headerlink" title="1.1.2 AP架构"></a>1.1.2 AP架构</h3><p>为了保证可用性，当发生分区现象后，N1 节点上的数据已经更新到 y，但由于 N1 和 N2 之间的复制通道中断，数据 y 无法同步到 N2，N2 节点上的数据还是 x。这时客户端 C 访问 N2 时，N2 将当前自己拥有的数据 x 返回给客户端 C 了，而实际上当前最新的数据已经是 y 了，这就不满足一致性（Consistency）的要求了，因此 CAP 三者只能满足 AP。注意：这里 N2 节点返回 x，虽然不是一个“正确”的结果，但是一个“合理”的结果，因为 x 是旧的数据，并不是一个错乱的值，只是不是最新的数据而已。</p><h2 id="1-2-CAP-细节"><a href="#1-2-CAP-细节" class="headerlink" title="1.2 CAP 细节"></a>1.2 CAP 细节</h2><h3 id="1-2-1-关注粒度-数据"><a href="#1-2-1-关注粒度-数据" class="headerlink" title="1.2.1 关注粒度 - 数据"></a>1.2.1 关注粒度 - 数据</h3><p>每个系统都不可能只处理一种数据，而是包含多种类型的数据，有的数据必须选择CP，有的数据必须选择AP。如果我们从整个系统的角度上去选择CP还是AP，很容易顾此失彼，无论怎么做都有问题。</p><p>比如用户管理系统，那么用户账户数据会选择CP，而用户信息数据会选择AP。因为在真的对CAP做应用的时候，我们需要将系统内的数据按照不同的应用场景和要求来进行分类，每类数据选择不同的策略，而不是限定整个系统的所有数据都是同一个策略。</p><h3 id="1-2-2-CAP是忽略网络延迟的"><a href="#1-2-2-CAP是忽略网络延迟的" class="headerlink" title="1.2.2 CAP是忽略网络延迟的"></a>1.2.2 CAP是忽略网络延迟的</h3><p>从节点A到节点B的复制，一定是需要花费一定的时间的，从几毫秒到几十毫秒不等。这意味着，CAP的理论当中的C在实践中是不可能完美实现的。</p><p>因此对于和金钱相关的，或者是和抢购相关的商品库存，技术上是无法做到分布式场景下完美的一致性的。而业务上又必须要求一致性，因此单个用户的余额，商品库存等只能单点写入，然后让其他节点做备份，无法做到分布式情况下的多点写入。</p><p><img src="https://i.loli.net/2020/02/04/FkRpQHwIXcj5hCW.png" alt="fig3.png"></p><p>这种设计的问题在于某个节点故障的时候，这个节点上的用户就无法进行读写操作了，但站在整体上来看，这种设计可以降低故障时受影响的用户的数量和范围。</p><h3 id="1-2-3-分区处理"><a href="#1-2-3-分区处理" class="headerlink" title="1.2.3 分区处理"></a>1.2.3 分区处理</h3><p>如果出现了分区，那么就需要在分区期间记录足够多的日志，当分区故障解决之后，系统根据日志进行数据恢复，使得重新达到CA的状态</p><h2 id="1-3-BASE"><a href="#1-3-BASE" class="headerlink" title="1.3 BASE"></a>1.3 BASE</h2><ul><li>basically available 基本可用<ul><li>出现故障的时候，允许损失部分可用性，即保证核心可用</li></ul></li><li>soft state 软状态<ul><li>允许系统存在中间状态，而该中间状态不会影响系统的整体可用性。这里的中间状态是CAP理论中的数据不一致 </li></ul></li><li>eventual consistency  最终一致性 <ul><li>系统的所有数据副本经过一定时间之后，最终能够达到一致的状态。</li></ul></li></ul><h2 id="2-3-FMEA分析表"><a href="#2-3-FMEA分析表" class="headerlink" title="2.3 FMEA分析表"></a>2.3 FMEA分析表</h2><h3 id="2-3-1-功能点"><a href="#2-3-1-功能点" class="headerlink" title="2.3.1 功能点"></a>2.3.1 功能点</h3><ul><li>从用户角度看涉及到的功能点<ul><li>用户角度，即登录注册这种功能</li><li>而不是数据库缓存这种</li></ul></li></ul><h3 id="2-3-2-故障模式"><a href="#2-3-2-故障模式" class="headerlink" title="2.3.2 故障模式"></a>2.3.2 故障模式</h3><ul><li>系统会出现什么样的故障<ul><li>包括故障点</li><li>故障模式<ul><li>假设某种故障现象即可</li></ul></li></ul></li><li>故障模式的描述要尽量精确，多使用量化的值来进行描述，避免泛化的方式。比如说慢，慢到3秒比说单纯的慢要好得多。</li></ul><h3 id="2-3-3-故障影响"><a href="#2-3-3-故障影响" class="headerlink" title="2.3.3 故障影响"></a>2.3.3 故障影响</h3><p>当发生故障模式中描述的故障时，功能点具体会受到什么影响。常见的影响有：</p><ul><li>功能点完全不可用</li><li>部分不可用</li><li>响应缓慢</li><li>功能出错</li></ul><p>故障影响也应该尽量准确描述，比如可能影响20%的用户之类的。</p><h3 id="2-3-4-严重程度"><a href="#2-3-4-严重程度" class="headerlink" title="2.3.4 严重程度"></a>2.3.4 严重程度</h3><p>站在业务的角度来看故障的影响程度，一般分为致命/ 高/ 中/ 低/ 无 五个档次。</p><p>严重程度 = 功能点重要程度 x 故障影响范围 x 功能点受损程度</p><h3 id="2-3-5-故障原因"><a href="#2-3-5-故障原因" class="headerlink" title="2.3.5 故障原因"></a>2.3.5 故障原因</h3><p>列出故障原因，是为了</p><ul><li>故障原因都具有不同的概率，这会影响我们的解决方案</li><li>不同故障原因检测手段不同</li><li>处理措施不同</li></ul><h3 id="2-3-6-故障概率"><a href="#2-3-6-故障概率" class="headerlink" title="2.3.6 故障概率"></a>2.3.6 故障概率</h3><ul><li>硬件</li><li>开源系统</li><li>自研系统</li></ul><h3 id="2-3-7-风险程度"><a href="#2-3-7-风险程度" class="headerlink" title="2.3.7 风险程度"></a>2.3.7 风险程度</h3><p>风险程度 = 严重程度 x 故障概率</p><h3 id="2-3-8-已有措施"><a href="#2-3-8-已有措施" class="headerlink" title="2.3.8 已有措施"></a>2.3.8 已有措施</h3><ul><li>检测告警<ul><li>检测故障，告警，人工干预</li></ul></li><li>容错<ul><li>系统通过备份手段来应对</li></ul></li><li>自恢复<ul><li>检测到故障以后，系统能够自动恢复。比如，Hadoop检测到某台机器故障之后，将存储在这台机器的副本重新分配到别的机器上。 </li></ul></li></ul><h3 id="2-3-9-规避措施"><a href="#2-3-9-规避措施" class="headerlink" title="2.3.9 规避措施"></a>2.3.9 规避措施</h3><ul><li>技术手段<ul><li>冗余备份等 </li></ul></li><li>管理手段<ul><li>硬件定期更新 </li></ul></li></ul><h3 id="2-3-10-解决措施"><a href="#2-3-10-解决措施" class="headerlink" title="2.3.10 解决措施"></a>2.3.10 解决措施</h3><p>为了能够解决问题而给出的方案，往往是技术手段</p><h3 id="2-3-11-后续规划"><a href="#2-3-11-后续规划" class="headerlink" title="2.3.11 后续规划"></a>2.3.11 后续规划</h3><p>综合前面的分析，就可以看出哪些故障我们目前还缺乏对应的措施，哪些已有措施还不够，针对这些不足的地方，再结合风险程度进行排序，给出后续的改进规划。这些规划既可以是技术手段，也可以是管理手段；可以是规避措施，也可以是解决措施。同时需要考虑资源的投入情况，优先将风险程度高的系统隐患解决。</p><h1 id="3-高可用存储架构"><a href="#3-高可用存储架构" class="headerlink" title="3. 高可用存储架构"></a>3. 高可用存储架构</h1><p>存储高可用方案 – 本质 – <strong><em>将数据复制到多个存储设备当中，通过数据冗余的方式来实现高可用</em></strong>， 其复杂性主要体现在如何应对复制延迟和中断导致的数据不一致的问题。因此，对任何一个高可用存储方案，我们需要考虑以下几个问题：</p><ul><li>数据如何复制的</li><li>各个节点的职责是什么</li><li>如何应对复制延迟</li><li>如何应对复制中断</li></ul><h2 id="3-1-双机架构"><a href="#3-1-双机架构" class="headerlink" title="3.1 双机架构"></a>3.1 双机架构</h2><h3 id="3-1-1-主备复制"><a href="#3-1-1-主备复制" class="headerlink" title="3.1.1 主备复制"></a>3.1.1 主备复制</h3><p><img src="https://i.loli.net/2020/02/04/CgcTbUFLiJDKE6u.jpg" alt="fig4.jpg"></p><p>主备架构的备机起到一个备份的作用，并不承担实际的业务读写操作，如果将备机改为主机，是需要进行人工操作的。</p><ul><li>优势<ul><li>足够简单</li><li>对于客户端来说，不需要感知备机的存在</li><li>对于主备之间，只需要进行数据复制，无须进行状态判断和主备切换这类复杂操作</li></ul></li><li>劣势<ul><li>备份无读写的流量，因此硬件成本上是有浪费的</li><li>故障之后需要人工干预，无法做自动恢复</li></ul></li></ul><h3 id="3-1-2-主从复制"><a href="#3-1-2-主从复制" class="headerlink" title="3.1.2 主从复制"></a>3.1.2 主从复制</h3><p><img src="https://i.loli.net/2020/02/04/JyKOIvYmc78Ut2Q.jpg" alt="fig5.jpg"></p><ul><li>优势<ul><li>主从复制在主机故障时，读操作相关的业务可以继续运行</li><li>主从复制架构的从机提供读操作，发挥了硬件的性能</li></ul></li><li>劣势<ul><li>主从复制当中，客户端需要感知主从关系，并将不同的操作发给不同的机器进行处理，复杂度比主备的要高</li><li>主从复制架构当中，从机提供读业务，如果主从复制延迟比较大，业务会因为数据不一致出现问题</li><li>故障时需要人工干预</li></ul></li></ul><h3 id="3-1-3-主备-主从切换"><a href="#3-1-3-主备-主从切换" class="headerlink" title="3.1.3 主备/ 主从切换"></a>3.1.3 主备/ 主从切换</h3><p>系统自动决定主机角色，并完成角色的切换。</p><p>以主备为例，需要考虑的问题有：</p><h4 id="3-1-3-1-主备间状态判断"><a href="#3-1-3-1-主备间状态判断" class="headerlink" title="3.1.3.1 主备间状态判断"></a>3.1.3.1 主备间状态判断</h4><ul><li>状态传递渠道<ul><li>相互之间的连接</li><li>第三方仲裁</li></ul></li><li>状态检测的内容<ul><li>机器是否掉电</li><li>进程是否存在</li><li>响应是否缓慢</li></ul></li></ul><h4 id="3-1-3-2-切换决策"><a href="#3-1-3-2-切换决策" class="headerlink" title="3.1.3.2 切换决策"></a>3.1.3.2 切换决策</h4><ul><li>切换时机</li><li>切换策略</li><li>自动程度</li></ul><h4 id="3-1-3-3-数据冲突解决"><a href="#3-1-3-3-数据冲突解决" class="headerlink" title="3.1.3.3 数据冲突解决"></a>3.1.3.3 数据冲突解决</h4><ul><li>需要做具体的应用场景的具体分析了</li></ul><h4 id="3-1-3-4-常见主备切换架构"><a href="#3-1-3-4-常见主备切换架构" class="headerlink" title="3.1.3.4 常见主备切换架构"></a>3.1.3.4 常见主备切换架构</h4><ul><li>互连式<ul><li>主备之间进行状态传递</li><li>缺点<ul><li>状态传递通道本身存在问题的话，备机也会自动升级为主机，造成有两个主机的结果</li></ul></li></ul></li><li>中介式<ul><li>引入第三方中介，主备间不直接连接，而是去连接中介，并且通过中介来传递状态信息</li><li>连接管理以及状态决策都更简单一些了</li></ul></li><li>模拟式<ul><li>主备之间不传递任何状态数据，而是备机模拟成一个客户端，向主机发起模拟的读写操作，根据读写操作的响应情况来判断主机的状态。 </li></ul></li></ul><h3 id="3-1-4-主主复制"><a href="#3-1-4-主主复制" class="headerlink" title="3.1.4 主主复制"></a>3.1.4 主主复制</h3><p><img src="https://i.loli.net/2020/02/04/o8ZKUvW4VEeY1nQ.png" alt="fig6.png"></p><ul><li>两台都是主机，不存在切换的概念</li><li>客户端无须区分不同角色的主机，随便讲读写操作发送给哪台主机都是可以的</li><li>双向复制本身的难以实现<ul><li>比如数据库同步，ID如何做更新等</li><li>一般适合于临时性，可丢失，可覆盖的数据场景</li></ul></li></ul><h2 id="3-2-集群和分区"><a href="#3-2-集群和分区" class="headerlink" title="3.2 集群和分区"></a>3.2 集群和分区</h2><h3 id="3-2-1-数据集群"><a href="#3-2-1-数据集群" class="headerlink" title="3.2.1 数据集群"></a>3.2.1 数据集群</h3><p>主备，主从，主主都有一个隐含的假设，主机能够存储所有数据。但是在实际场景当中，一台主机的存储和处理能力都是十分有限的，单台服务器一定是无法存储和处理的，我们必须使用多台服务器来存储数据，实现一个数据集群架构。</p><p>数据集群又可以分为数据集中集群，数据分散集群</p><h4 id="3-2-1-1-数据集中集群"><a href="#3-2-1-1-数据集中集群" class="headerlink" title="3.2.1.1 数据集中集群"></a>3.2.1.1 数据集中集群</h4><p><img src="https://i.loli.net/2020/02/04/93XQRrAHzuItK86.png" alt="fig7.png"></p><p> 客户端与主机进行交流，主机进行数据复制到各个备机上去。Zookeeper解决了大部分数据集中集群中会出现的问题。</p><ul><li>多条复制通道，会增大主机复制的压力，需要考虑如何降低主机复制压力</li><li>多条复制通道会导致多个备机之间数据不一致，我们需要对备机之间的数据一致性进行检查和修正</li><li>备机如何检查主机的状态，如何处理不同备机对主机状态的不同判断</li><li>主机故障以后，如何决定新的主机</li></ul><h4 id="3-2-1-2-数据分散集群"><a href="#3-2-1-2-数据分散集群" class="headerlink" title="3.2.1.2 数据分散集群"></a>3.2.1.2 数据分散集群</h4><ul><li><p>多个服务器组成一个集群，每台服务器都会负责存储一部分数据；同时为了提升硬件利用率，每台服务器又会备份一部分数据。</p></li><li><p>数据分配算法需要考虑到：</p><ul><li>均衡性 – 数据分区，数据容量基本上相同</li><li>容错性 – 当服务器故障时，算法需要将原来分配给故障服务器的数据分区分配给其他服务器</li><li>可伸缩性 – 集群容量不够，扩充了新的服务器之后，算法能够自动将部分数据分区迁移到新服务器上，并保证扩容后所有服务器的均衡性</li></ul></li><li><p>需要有一台机器来执行数据分配算法</p></li></ul><h3 id="3-2-2-数据分区"><a href="#3-2-2-数据分区" class="headerlink" title="3.2.2 数据分区"></a>3.2.2 数据分区</h3><p>针对于影响很大的事故或者灾难来说，有可能会使得所有硬件全部故障。数据分区指的是按照一定规则进行分区，分布到不同的地理位置上，每个分区存储一部分数据，通过这种方式来规避地理级别的故障所造成的的影响。</p><ul><li>数据分区的考虑因素<ul><li>数据量</li><li>分区规则</li><li>复制规则<ul><li>集中式<ul><li>总的备份中心，所有分区将数据备份到备份中心</li><li>设计简单，可互不影响</li><li>扩展容易</li><li>成本较高，需要建立一个独立的备份中心</li></ul></li><li>互备式<ul><li>每个分区备份另外一个分区的数据</li><li>复杂度高，相互之间强关联</li><li>成本低</li></ul></li><li>独立式<ul><li>每个分区都有自己的独立的备份中心</li><li>扩展容易，设计简单</li><li>成本很高</li></ul></li></ul></li></ul></li></ul><h1 id="4-计算高可用架构"><a href="#4-计算高可用架构" class="headerlink" title="4. 计算高可用架构"></a>4. 计算高可用架构</h1><p>当部分硬件损坏时，计算任务能够继续正常运行。因此计算高可用的本质是通过冗余来规避部分故障的风险。即通过增加更多的服务器来达到计算高可用。</p><p>设计复杂度主要体现在任务管理上，即当任务在某台服务器上执行失败以后，如何将任务重新分配到新的服务器进行执行。</p><h2 id="4-1-哪些服务器可以执行任务"><a href="#4-1-哪些服务器可以执行任务" class="headerlink" title="4.1 哪些服务器可以执行任务"></a>4.1 哪些服务器可以执行任务</h2><ul><li>特定服务器</li><li>每个服务器</li></ul><h2 id="4-2-任务如何重新执行"><a href="#4-2-任务如何重新执行" class="headerlink" title="4.2 任务如何重新执行"></a>4.2 任务如何重新执行</h2><ul><li>对已经分配的任务即使执行失败也不做任何处理，系统只需要保证新的任务能够分配到其他非故障的服务器上执行即可</li><li>设计一个任务管理器来管理需要执行的计算任务，服务器执行任务后，需要向任务管理器反馈任务执行的结果，任务管理器根据任务执行结果来决定是否需要将任务重新分配到另外的服务器上执行。</li></ul><h2 id="4-3-常见的计算高可用架构"><a href="#4-3-常见的计算高可用架构" class="headerlink" title="4.3 常见的计算高可用架构"></a>4.3 常见的计算高可用架构</h2><h3 id="4-3-1-主备"><a href="#4-3-1-主备" class="headerlink" title="4.3.1 主备"></a>4.3.1 主备</h3><p><img src="https://i.loli.net/2020/02/04/mGLY492oBbOqitu.png" alt="fig8.png"></p><ul><li>和存储高可用类似，不过更简单，因为不需要做数据复制的</li><li>主机执行所有计算任务</li><li>主机故障，任务分配器不会自动将计算任务发给备机，系统此时是不可用状态</li><li>如果主机恢复(人工或自动)，任务分配器继续将任务发送给主机</li><li>如果主机不能够恢复，则需要人工操作，将备机升为主机，然后让任务分配器将任务发送给新的主机</li></ul><h3 id="4-3-2-主从"><a href="#4-3-2-主从" class="headerlink" title="4.3.2 主从"></a>4.3.2 主从</h3><p><img src="https://i.loli.net/2020/02/04/Z4yh5EUqFCBPokT.png" alt="fig9.png"></p><ul><li>主机执行部分计算任务，备机也执行一部分</li><li>主机故障时，任务分配器还是会发给主机</li><li>不能恢复，人工操作，备机变主机，增加新的备机</li><li>好处是从机执行任务，发挥了硬件性能；缺点是需要将任务分类，任务分配器会复杂一些</li></ul><h3 id="4-3-3-集群"><a href="#4-3-3-集群" class="headerlink" title="4.3.3 集群"></a>4.3.3 集群</h3><p>系统需要能够自动完成切换操作，这是高可用集群方案。根据节点的角色，可以分成对称集群，集群内的每个服务器都有一样的角色，都可以执行所有的任务；另一类是非对称集群，集群中服务器分为多个不同角色，执行不同的任务。</p><h4 id="4-3-3-1-对称集群-负载均衡集群"><a href="#4-3-3-1-对称集群-负载均衡集群" class="headerlink" title="4.3.3.1 对称集群 - 负载均衡集群"></a>4.3.3.1 对称集群 - 负载均衡集群</h4><p><img src="https://i.loli.net/2020/02/04/hIbCsuAmKclkiqT.png" alt="fig10.png"></p><ul><li>任务分配器采取某种策略(随机、轮询等)将计算任务分配给集群当中的不同服务器</li><li>当集群中的某台服务器出现故障以后，任务分配器不再将任务分配给它，而是将任务分配给其他服务器执行</li><li>当故障的服务器恢复之后，任务分配器重新将任务分配给它执行</li></ul><ul><li>难点<ul><li>分配策略<ul><li>轮询</li><li>随机</li></ul></li><li>检测服务器状态<ul><li>服务器本身状态<ul><li>是否宕机</li><li>网络是否正常</li></ul></li><li>任务执行状态<ul><li>任务卡死</li><li>执行时间过长等</li></ul></li><li>一般来说是通过在任务分配器和服务器之间通过心跳来传递信息，包括服务器信息和任务信息，然后根据实际情况来确定状态，判断条件</li></ul></li></ul></li></ul><h4 id="4-3-3-2-非对称集群"><a href="#4-3-3-2-非对称集群" class="headerlink" title="4.3.3.2 非对称集群"></a>4.3.3.2 非对称集群</h4><ul><li>集群通过某种方式来区分不同的服务器角色<ul><li>ZAB 算法</li></ul></li><li>当指定类型的服务器故障时，需要重新分配角色 </li><li>比均衡负载更复杂<ul><li>任务分配策略更加复杂 - 需要将任务划分为不同类型并分配给不同角色的集群节点</li><li>角色分配策略实现更复杂      </li></ul></li></ul><h1 id="5-异地多活架构"><a href="#5-异地多活架构" class="headerlink" title="5. 异地多活架构"></a>5. 异地多活架构</h1><ul><li>异地 - 地理位置上的不同</li><li>多活 - 不同地理位置上的系统都能提供业务服务</li><li>异地多活标准<ul><li>用户无论访问哪一个地点的业务系统，都能够得到正确的业务服务</li><li>某个地方业务异常的时候，用户访问其他地方正常的业务系统，能够得到正确的业务服务</li></ul></li><li>异地多活实现代价非常高<ul><li>系统复杂度显著上升</li><li>成本上升</li></ul></li><li>需要异地多活的场景<ul><li>滴滴</li><li>微信</li><li>支付宝等</li></ul></li></ul><h2 id="5-1-架构模式"><a href="#5-1-架构模式" class="headerlink" title="5.1 架构模式"></a>5.1 架构模式</h2><h3 id="5-1-1-同城异区"><a href="#5-1-1-同城异区" class="headerlink" title="5.1.1 同城异区"></a>5.1.1 同城异区</h3><p>将业务部署在同一个城市不同区的多个机房当中。虽然还是无法在地震海啸等大灾害面前存活，但是同城异区通过光纤的设定，可以实现几乎和同一个机房相同的网络传输速度。这样尽管是多个机房，但我们可以将其作为一个机房来看待。</p><p>还是个看概率的问题，和地震海啸相比，机房火灾停电这种事情更有可能发生，对于此类故障，同城异区架构都可以很好地解决。</p><h3 id="5-1-2-跨城异地"><a href="#5-1-2-跨城异地" class="headerlink" title="5.1.2 跨城异地"></a>5.1.2 跨城异地</h3><p>将业务部署在不同城市的多个机房当中。距离要足够远，以应对极端灾难事件。但是与之相对的是，两个机房就几乎无法实现同步了。</p><p>正因为无法同步，所以对于十分敏感的数据，比如说账户余额这类，就不会使用跨城异地这种方式了。</p><h3 id="5-1-3-跨国异地"><a href="#5-1-3-跨国异地" class="headerlink" title="5.1.3 跨国异地"></a>5.1.3 跨国异地</h3><ul><li>主要为了为不同地区的用户提供服务</li><li>或者是只读类业务做多活</li></ul><h2 id="5-2-异地多活设计技巧"><a href="#5-2-异地多活设计技巧" class="headerlink" title="5.2 异地多活设计技巧"></a>5.2 异地多活设计技巧</h2><h3 id="5-2-1-保证核心业务的异地多活"><a href="#5-2-1-保证核心业务的异地多活" class="headerlink" title="5.2.1 保证核心业务的异地多活"></a>5.2.1 保证核心业务的异地多活</h3><p>因为保证所有业务的异地多活是不现实的，比如注册，登录，用户信息都要保持同步。注册不应该保持异地多活，因为一般都有单个手机号的限制，如果异地服务器，就无法检测是否已经注册过了，这是一个商业逻辑上的很大的悖论了，不可以这样做。</p><p>同理对于用户信息也是，根据更新时间的激活和识别也很可能会因为不同的机器时间的问题，而导致最终是不准确的，会带来很不好的用户体验。</p><p>登录才是最最需要保证异地多活的功能。</p><h3 id="5-2-2-保证核心数据最终一致性"><a href="#5-2-2-保证核心数据最终一致性" class="headerlink" title="5.2.2 保证核心数据最终一致性"></a>5.2.2 保证核心数据最终一致性</h3><p>异地多活本质上是通过异地的数据冗余，来保证在极端的异常情况下，业务也能正常提供给用户。即需要实现<strong>数据的快速同步</strong>。</p><ul><li>尽量减少异地多活机房的距离，搭建高速网络</li><li>尽量减少数据同步，只同步核心业务相关的数据</li><li>保证最终一致性，不保证实时的</li></ul><h2 id="5-3-如何应对接口级的故障"><a href="#5-3-如何应对接口级的故障" class="headerlink" title="5.3 如何应对接口级的故障"></a>5.3 如何应对接口级的故障</h2><p>接口级故障的典型表现就是系统并没有宕机，网络也没中断，但业务却出现了问题。例如：</p><ul><li>业务响应缓慢</li><li>访问大量超时</li><li>大量访问出现异常</li></ul><p>这类问题的主要原因在于系统压力太大，负载太高，导致无法快速处理业务请求，由此引发了更多的后续问题。常见的比如说数据库慢查询，将数据库的服务器资源耗尽了，导致读写超时，业务读写数据库要么超时，无法连接；从用户的角度来说，就是访问很慢，或者抛出异常。 </p><h3 id="5-3-1-接口级故障的原因"><a href="#5-3-1-接口级故障的原因" class="headerlink" title="5.3.1 接口级故障的原因"></a>5.3.1 接口级故障的原因</h3><ul><li>内部原因<ul><li>程序bug导致死循环</li><li>某个接口导致数据库慢查询</li><li>程序逻辑不完善导致耗尽内存</li></ul></li><li>外部原因<ul><li>黑客攻击</li><li>促销，抢购引入远超平时的用户</li><li>第三方系统大量请求</li><li>第三方系统响应缓慢</li></ul></li><li>解决的核心思想<ul><li>优先保证核心业务</li><li>优先保证绝大部分用户</li></ul></li></ul><h3 id="5-3-2-降级"><a href="#5-3-2-降级" class="headerlink" title="5.3.2 降级"></a>5.3.2 降级</h3><p>系统将某些业务或者接口的功能降低，只提供部分功能或者完全停掉所有功能</p><ul><li>系统后门降级<ul><li>比如提供一个降级URL，当访问这个URL的时候，就相当于提供了一个降级操作</li></ul></li><li>独立降级系统<ul><li>独立出系统，实现权限管理批量操作等功能。</li></ul></li></ul><h3 id="5-3-3-熔断"><a href="#5-3-3-熔断" class="headerlink" title="5.3.3 熔断"></a>5.3.3 熔断</h3><ul><li>和降级做对比<ul><li>降级是用来处理系统自身的故障</li><li>熔断是应对依赖的外部系统的故障的情况</li></ul></li><li>熔断机制的关键在于一个统一的API调用层，由API调用层来进行采样或者统计</li><li>另一个关键是阈值的设计，一般是根据分析确定阈值，然后上线观察效果，再进行调优</li></ul><h3 id="5-3-4-限流"><a href="#5-3-4-限流" class="headerlink" title="5.3.4 限流"></a>5.3.4 限流</h3><p>从用户访问压力的角度来考虑，只允许系统能够承载的访问量来访问，超出系统访问能力的请求将被丢弃。</p><ul><li>基于请求限流<ul><li>常用方式<ul><li>限制总量<ul><li>比如限制总用户的上限 </li></ul></li><li>限制时间量<ul><li>限制一段时间内某个指标的上限  比如请求tps</li></ul></li></ul></li><li>这种方式更多是英语业务功能比较简单的系统，因为很可能阈值需要不断调整的</li></ul></li><li>基于资源限流<ul><li>找到系统内部影响性能的关键资源，对其使用上限进行限制<ul><li>连接数</li><li>文件句柄</li><li>线程数</li><li>请求队列</li></ul></li></ul></li></ul><h3 id="5-3-5-排队"><a href="#5-3-5-排队" class="headerlink" title="5.3.5 排队"></a>5.3.5 排队</h3><ul><li>不直接扔掉请求，排队</li><li>排队模块<ul><li>将请求以先进先出的方式保存下来</li></ul></li><li>调度模块<ul><li>负责排队模块到服务模块的动态调度</li></ul></li><li>服务模块<ul><li>调用真正业务来处理服务，并返回处理结果，调用排队模块的接口回写处理结果。 </li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-CAP-原理&quot;&gt;&lt;a href=&quot;#1-CAP-原理&quot; class=&quot;headerlink&quot; title=&quot;1. CAP 原理&quot;&gt;&lt;/a&gt;1. CAP 原理&lt;/h1&gt;&lt;p&gt;CAP原理讨论得是对于数据的读写操作，并不是在讨论整个系统的各个方面的功能。并且讨论得是
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="架构" scheme="https://www.llchen60.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="CAP" scheme="https://www.llchen60.com/tags/CAP/"/>
    
  </entry>
  
  <entry>
    <title>架构学习-架构设计流程</title>
    <link href="https://www.llchen60.com/%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%B5%81%E7%A8%8B/"/>
    <id>https://www.llchen60.com/%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%B5%81%E7%A8%8B/</id>
    <published>2020-02-04T04:14:02.000Z</published>
    <updated>2020-02-04T04:14:25.557Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-识别复杂度"><a href="#1-识别复杂度" class="headerlink" title="1. 识别复杂度"></a>1. 识别复杂度</h1><p>具体情况需要具体分析，即这个系统的复杂度体现在哪一个方面。一个系统的复杂度主要来源于高性能，高可用，可扩展这几个方面。</p><p>正确的做法是将主要的复杂度问题列出来，然后根据业务、技术、团队等综合情况进行排序，优先解决当前面临的最主要的复杂问题。</p><p>多个系统之间的强耦合，可以通过信息队列来解耦。要注意从高可用，高性能，可扩展几个维度对其进行分析，看整个架构调整的复杂度在哪里，然后做针对性的提升。</p><p>平均TPS， QPS，峰值TPS (average x 3)，</p><h1 id="2-设计备选方案"><a href="#2-设计备选方案" class="headerlink" title="2. 设计备选方案"></a>2. 设计备选方案</h1><p>架构师需要对已经存在的技术非常熟悉，对已经经过验证的架构模式烂熟于心，然后根据自己对于业务的理解，挑选合适的架构模式进行组合，再对组合之后的方案进行修改和调整。</p><p>目前，只要明确了应用场景，复杂度上的限制因素，我们往往能找到相对成熟的技术来直接使用。例如</p><ul><li>高可用主备方案</li><li>集群方案</li><li>高性能负载均衡</li><li>多路复用</li><li>可拓展的分层</li><li>插件化技术</li></ul><p>设计备选方案的tips</p><ul><li>多设计几个备选方法，3-5个为宜</li><li>方案之间的差异要比较明显</li><li>备选方案的技术不要只局限于已经熟悉的技术</li><li>备选方案不需要太过于详细的，关注的是技术选型，而不是技术细节</li></ul><p>对于高性能写入</p><ul><li>集群</li><li>直接写入一台正常的服务器即可<br>高可用存储</li><li>已经写入的信息在单台服务器宕机的情况下不丢失</li><li>使用MySQL的主备复制功能<br>高可用读取</li><li>要求已经写入的消息在单台服务器宕机的情况下可以继续读取</li><li>服务器的主备方案</li></ul><h1 id="3-评估和选择备选方案"><a href="#3-评估和选择备选方案" class="headerlink" title="3. 评估和选择备选方案"></a>3. 评估和选择备选方案</h1><ul><li>多角度环评<ul><li>列出需要关注的质量属性点</li><li>分别从这些质量属性的维度去评估每个方案，再综合挑选适合当时情况的最优方案</li></ul></li><li>方案质量属性点<ul><li>性能</li><li>可用性</li><li>硬件成本</li><li>项目投入</li><li>复杂度</li><li>安全性</li><li>可拓展性</li></ul></li><li>对于需要评估未来业务发展的规模时，一般可以将当前的业务规模乘以2-4 即可。</li><li>将质量属性按照优先级排序</li></ul><h1 id="4-详细方案设计"><a href="#4-详细方案设计" class="headerlink" title="4. 详细方案设计"></a>4. 详细方案设计</h1><p>将方案涉及的关键技术细节给确定下来。</p><ul><li>假如我们确定使用 Elasticsearch 来做全文搜索，那么就需要确定 Elasticsearch 的索引是按照业务划分，还是一个大索引就可以了；副本数量是 2 个、3 个还是 4 个，集群节点数量是 3 个还是 6 个等。</li><li>假如我们确定使用 MySQL 分库分表，那么就需要确定哪些表要分库分表，按照什么维度来分库分表，分库分表后联合查询怎么处理等。</li><li>假如我们确定引入 Nginx 来做负载均衡，那么 Nginx 的主备怎么做，Nginx 的负载均衡策略用哪个（权重分配？轮询？ip_hash？）等。<ul><li>轮询</li><li>加权轮询 - 后端服务器性能不均</li><li>ip_hash - 每个方可固定访问同一个后端服务器，解决session的问题</li><li>fair - 按照响应时间来分配请求，响应时间短的优先分配，能够最大化平衡各后端服务器的压力，可以适用于后端服务器性能不均衡的情况</li><li>url_hash - 每个url定向到同一个后端服务器，适用于后端服务器能够将url的响应结果缓存的情况</li></ul></li></ul><ul><li>通过分步骤，分阶段，分系统等方式，尽量降低方案的复杂度。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-识别复杂度&quot;&gt;&lt;a href=&quot;#1-识别复杂度&quot; class=&quot;headerlink&quot; title=&quot;1. 识别复杂度&quot;&gt;&lt;/a&gt;1. 识别复杂度&lt;/h1&gt;&lt;p&gt;具体情况需要具体分析，即这个系统的复杂度体现在哪一个方面。一个系统的复杂度主要来源于高性能，高可
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="架构" scheme="https://www.llchen60.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>架构学习 - 架构设计文档模板</title>
    <link href="https://www.llchen60.com/%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3%E6%A8%A1%E6%9D%BF/"/>
    <id>https://www.llchen60.com/%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3%E6%A8%A1%E6%9D%BF/</id>
    <published>2020-02-04T04:12:55.000Z</published>
    <updated>2020-02-04T04:13:14.588Z</updated>
    
    <content type="html"><![CDATA[<p>整个流程应当是在刚开始的时候有几个方案，然后在经过讨论和分析以后整理出唯一可以的方案，然后再创建架构设计的详细文档，这个时候理论上应该</p><h1 id="1-备选方案模板"><a href="#1-备选方案模板" class="headerlink" title="1. 备选方案模板"></a>1. 备选方案模板</h1><h2 id="1-1-需求介绍"><a href="#1-1-需求介绍" class="headerlink" title="1.1 需求介绍"></a>1.1 需求介绍</h2><ul><li>需求的背景</li><li>需求的目标</li><li>需求的范围</li></ul><h2 id="1-2-需求分析"><a href="#1-2-需求分析" class="headerlink" title="1.2 需求分析"></a>1.2 需求分析</h2><h3 id="1-2-1-5W"><a href="#1-2-1-5W" class="headerlink" title="1.2.1 5W"></a>1.2.1 5W</h3><ul><li>Who 开发者 使用者 购买者 决策者等</li><li>When 需求使用时间，包括季节，时间，里程碑等</li><li>What 需求的产出是什么，包括系统，数据，文件，开发库，平台等</li><li>Where  需求的应用场景，包括国家，地点，环境等</li><li>Why  需求需要解决的问题，通常和需求背景相关</li></ul><h3 id="1-2-2-1H"><a href="#1-2-2-1H" class="headerlink" title="1.2.2 1H"></a>1.2.2 1H</h3><p>How指的是关键业务流程</p><h3 id="1-2-3-8C"><a href="#1-2-3-8C" class="headerlink" title="1.2.3 8C"></a>1.2.3 8C</h3><p>8个约束和限制，包括</p><ul><li>performance</li><li>cost</li><li>time</li><li>reliability</li><li>security</li><li>compliance</li><li>technology</li><li>compatibility</li></ul><h2 id="1-3-复杂度分析"><a href="#1-3-复杂度分析" class="headerlink" title="1.3 复杂度分析"></a>1.3 复杂度分析</h2><h3 id="1-3-1-高可用"><a href="#1-3-1-高可用" class="headerlink" title="1.3.1 高可用"></a>1.3.1 高可用</h3><h3 id="1-3-2-高性能"><a href="#1-3-2-高性能" class="headerlink" title="1.3.2 高性能"></a>1.3.2 高性能</h3><h3 id="1-3-3-可扩展"><a href="#1-3-3-可扩展" class="headerlink" title="1.3.3 可扩展"></a>1.3.3 可扩展</h3><h2 id="1-4-其他备选方案及评估"><a href="#1-4-其他备选方案及评估" class="headerlink" title="1.4 其他备选方案及评估"></a>1.4 其他备选方案及评估</h2><h1 id="2-架构设计模板"><a href="#2-架构设计模板" class="headerlink" title="2. 架构设计模板"></a>2. 架构设计模板</h1><h2 id="2-1-总体方案"><a href="#2-1-总体方案" class="headerlink" title="2.1 总体方案"></a>2.1 总体方案</h2><p>整体描述方案的结构，架构图，以及针对架构图的描述，包括模块或者子系统的职责描述，核心流程</p><h2 id="2-2-架构总览"><a href="#2-2-架构总览" class="headerlink" title="2.2 架构总览"></a>2.2 架构总览</h2><p>架构图以及架构的描述</p><h2 id="2-3-核心流程"><a href="#2-3-核心流程" class="headerlink" title="2.3 核心流程"></a>2.3 核心流程</h2><h2 id="2-4-详细设计"><a href="#2-4-详细设计" class="headerlink" title="2.4 详细设计"></a>2.4 详细设计</h2><h3 id="2-4-1-高可用设计"><a href="#2-4-1-高可用设计" class="headerlink" title="2.4.1 高可用设计"></a>2.4.1 高可用设计</h3><h3 id="2-4-2-高性能设计"><a href="#2-4-2-高性能设计" class="headerlink" title="2.4.2 高性能设计"></a>2.4.2 高性能设计</h3><h3 id="2-4-3-可扩展设计"><a href="#2-4-3-可扩展设计" class="headerlink" title="2.4.3 可扩展设计"></a>2.4.3 可扩展设计</h3><h3 id="2-4-4-安全设计"><a href="#2-4-4-安全设计" class="headerlink" title="2.4.4 安全设计"></a>2.4.4 安全设计</h3><h2 id="2-5-部署方案"><a href="#2-5-部署方案" class="headerlink" title="2.5 部署方案"></a>2.5 部署方案</h2><ul><li>硬件要求</li><li>服务器部署方式</li><li>组网方式</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;整个流程应当是在刚开始的时候有几个方案，然后在经过讨论和分析以后整理出唯一可以的方案，然后再创建架构设计的详细文档，这个时候理论上应该&lt;/p&gt;
&lt;h1 id=&quot;1-备选方案模板&quot;&gt;&lt;a href=&quot;#1-备选方案模板&quot; class=&quot;headerlink&quot; title=&quot;1
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="架构" scheme="https://www.llchen60.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>架构学习 - 实战</title>
    <link href="https://www.llchen60.com/%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0-%E5%AE%9E%E6%88%98/"/>
    <id>https://www.llchen60.com/%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0-%E5%AE%9E%E6%88%98/</id>
    <published>2020-02-04T04:10:07.000Z</published>
    <updated>2020-02-04T04:11:33.749Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-技术演进的动力-企业发展"><a href="#1-技术演进的动力-企业发展" class="headerlink" title="1. 技术演进的动力 - 企业发展"></a>1. 技术演进的动力 - 企业发展</h1><h2 id="1-1-业务和技术之间的关系"><a href="#1-1-业务和技术之间的关系" class="headerlink" title="1.1 业务和技术之间的关系"></a>1.1 业务和技术之间的关系</h2><ul><li>产品类<ul><li>技术创新推动业务发展 </li><li>用户选择产品的根本驱动力是功能</li></ul></li><li>服务类<ul><li>业务发展推动技术创新 </li><li>用户选择服务的根本驱动力是规模</li></ul></li></ul><h1 id="2-技术演进的模式-（复杂性，用户规模）"><a href="#2-技术演进的模式-（复杂性，用户规模）" class="headerlink" title="2. 技术演进的模式 （复杂性，用户规模）"></a>2. 技术演进的模式 （复杂性，用户规模）</h1><ul><li>业务时期分类<ul><li>初创期</li><li>发展期</li><li>竞争期</li><li>成熟期</li></ul></li></ul><h2 id="2-1-初创期"><a href="#2-1-初创期" class="headerlink" title="2.1 初创期"></a>2.1 初创期</h2><p>创新出新的理念，通过用户使用，快速迭代，不断完善。对于业务的要求就是快。</p><h2 id="2-2-发展期"><a href="#2-2-发展期" class="headerlink" title="2.2 发展期"></a>2.2 发展期</h2><p>大量加入功能，技术方面的核心工作就是快速实现各种需求。</p><ul><li>堆功能</li><li>优化 vs 重新架构</li><li>架构期 - 拆分</li></ul><h2 id="2-3-竞争期"><a href="#2-3-竞争期" class="headerlink" title="2.3 竞争期"></a>2.3 竞争期</h2><p>更迅速的发展，但是很容易出现重复造轮子，以及系统交互很乱等问题</p><p>因此一般都是做平台化以及服务化的操作。</p><ul><li>平台化<ul><li>存储平台化</li><li>数据库平台化</li><li>缓存平台化</li></ul></li></ul><h2 id="2-4-成熟期"><a href="#2-4-成熟期" class="headerlink" title="2.4 成熟期"></a>2.4 成熟期</h2><p>系统性的针对性优化</p><h1 id="3-General"><a href="#3-General" class="headerlink" title="3. General"></a>3. General</h1><p><img src="https://i.loli.net/2020/02/04/ViqLHs2aExQUAru.png" alt="fig1.png"></p><ul><li>纵向排列<ul><li>测试平台</li><li>运维平台</li><li>数据平台</li><li>管理平台</li></ul></li><li>横向<ul><li>业务层</li><li>用户层<ul><li>用户管理</li><li>消息推送</li><li>存储云</li><li>图片云</li></ul></li><li>网络层<ul><li>负载均衡</li><li>CDN</li></ul></li><li>服务层<ul><li>配置中心</li><li>服务中心</li><li>消息队列</li></ul></li><li>开发层<ul><li>开发框架</li><li>服务器</li><li>容器</li></ul></li><li>存储层<ul><li>SQL</li><li>NoSQL</li><li>小文件</li><li>大文件</li></ul></li></ul></li></ul><h1 id="4-存储层技术"><a href="#4-存储层技术" class="headerlink" title="4. 存储层技术"></a>4. 存储层技术</h1><h2 id="4-1-SQL"><a href="#4-1-SQL" class="headerlink" title="4.1 SQL"></a>4.1 SQL</h2><ul><li>NoSQL - Not only SQL </li><li>数据库拆分满足性能要求，但是会带来复杂度问题<ul><li>数据如何拆分</li><li>数据如何组合</li></ul></li><li>当业务发展到一定阶段之后，会将这部分功能独立成中间件</li><li>而后在SQL集群上构建SQL存储平台，以对业务透明的形式提供资源分配、数据备份、迁移、容灾、读写分离、分库分表等一系列服务</li></ul><h2 id="4-2-NoSQL"><a href="#4-2-NoSQL" class="headerlink" title="4.2 NoSQL"></a>4.2 NoSQL</h2><p>在NoSQL集群的基础上实现统一的存储平台，实现以下的功能：</p><ul><li>资源按需动态分配</li><li>资源自动化管理</li><li>故障自动化管理</li></ul><h2 id="4-3-小文件存储"><a href="#4-3-小文件存储" class="headerlink" title="4.3 小文件存储"></a>4.3 小文件存储</h2><p>展示性质的数据，比如商品图片，商品描述；特征是数据小，但数量巨大</p><h2 id="4-4-大文件存储"><a href="#4-4-大文件存储" class="headerlink" title="4.4 大文件存储"></a>4.4 大文件存储</h2><ul><li>业务上的大数据<ul><li>youtube的视频</li><li>电影</li></ul></li><li>海量日志数据<ul><li>访问日志</li><li>操作日志</li><li>用户轨迹日志</li></ul></li></ul><p>几个开源方案</p><ul><li>Hadoop</li><li>HBase</li><li>Storm</li><li>Hive</li></ul><h1 id="5-开发层技术"><a href="#5-开发层技术" class="headerlink" title="5. 开发层技术"></a>5. 开发层技术</h1><h2 id="5-1-开发框架"><a href="#5-1-开发框架" class="headerlink" title="5.1 开发框架"></a>5.1 开发框架</h2><p>整个公司使用同样的框架和技术可以解决组和组之间沟通的问题，大大提升组织和团队的开发效率。</p><p>对于框架，应该选择成熟的框架，避免盲目追逐新技术。</p><ul><li>java<ul><li>SSH</li><li>SpringMVC</li><li>Play </li></ul></li><li>Ruby<ul><li>Ruby on Rails</li></ul></li><li>PHP<ul><li>ThinkPHP</li></ul></li><li>Python <ul><li>Django </li></ul></li></ul><h2 id="5-2-Web服务器"><a href="#5-2-Web服务器" class="headerlink" title="5.2 Web服务器"></a>5.2 Web服务器</h2><ul><li>Java<ul><li>Tomcat</li><li>JBoss </li><li>Besin </li></ul></li><li>PHP/ Python <ul><li>Nginx</li></ul></li><li>Apache </li></ul><h2 id="5-3-容器"><a href="#5-3-容器" class="headerlink" title="5.3 容器"></a>5.3 容器</h2><p>Docker技术，不跨平台，但是启动快，几乎不占资源</p><p>可以基于Docker打造自动化运维</p><h1 id="6-服务层技术"><a href="#6-服务层技术" class="headerlink" title="6. 服务层技术"></a>6. 服务层技术</h1><p>服务层的主要目标就是降低系统间相互关联的复杂度。</p><h2 id="6-1-配置中心"><a href="#6-1-配置中心" class="headerlink" title="6.1 配置中心"></a>6.1 配置中心</h2><ul><li>集中管理各个系统的配置</li><li>各系统管理自己的配置会带来一些问题<ul><li>需要多个系统配合的时候，配置分散，则配置检查和沟通协调都会比较费时间</li><li>处理线上问题，需要查询多个配置文件，相互比较，很麻烦</li><li>各系统自己配置，往往用文本方式，没有自动的校验机制，就比较容易出现错误</li></ul></li><li>配置中心，做成通用系统，给所有系统来使用<ul><li>集中配置</li><li>程序化的规则检查，避免常见错误，可以用正则表达式来检查</li><li>备份了系统的配置，便于快速搭建系统和恢复业务</li></ul></li></ul><h2 id="6-2-服务中心"><a href="#6-2-服务中心" class="headerlink" title="6.2 服务中心"></a>6.2 服务中心</h2><p>服务中心是用来解决跨系统依赖的配置和调度问题的。</p><h3 id="6-2-1-服务名字系统-–-Service-Name-System"><a href="#6-2-1-服务名字系统-–-Service-Name-System" class="headerlink" title="6.2.1 服务名字系统 – Service Name System"></a>6.2.1 服务名字系统 – Service Name System</h3><p>将Service的名称解析为<code>host+port+接口名称</code></p><p><img src="https://i.loli.net/2020/02/04/HqVy9UlC35ceauY.png" alt="fig2.png"></p><h3 id="6-2-2-服务总线系统-–-Service-Bus-System"><a href="#6-2-2-服务总线系统-–-Service-Bus-System" class="headerlink" title="6.2.2 服务总线系统 – Service Bus System"></a>6.2.2 服务总线系统 – Service Bus System</h3><p>有总线系统完成调用，服务请求方不需要直接和服务提供方进行交互了。</p><p><img src="https://i.loli.net/2020/02/04/G2UmVfZCIBpcLSD.png" alt="fig3.png"></p><p><img src="https://i.loli.net/2020/02/04/D5QZEIuiFAWoN1s.png" alt="fig4.png"></p><h2 id="6-3-消息队列"><a href="#6-3-消息队列" class="headerlink" title="6.3 消息队列"></a>6.3 消息队列</h2><p>很多业务处理需要采用异步的方式，消息队列就是为了实现这种跨系统异步通知的中间件系统。</p><h1 id="7-网络层技术"><a href="#7-网络层技术" class="headerlink" title="7. 网络层技术"></a>7. 网络层技术</h1><h2 id="7-1-负载均衡"><a href="#7-1-负载均衡" class="headerlink" title="7.1 负载均衡"></a>7.1 负载均衡</h2><ul><li>DNS<ul><li>地理级别的负载均衡 </li></ul></li><li>Nginx, LVS, F5 <ul><li>同一个地点内机器级别的负载均衡</li></ul></li><li>CDN<h2 id="7-2-多机房-跨国多机房"><a href="#7-2-多机房-跨国多机房" class="headerlink" title="7.2 多机房 + 跨国多机房"></a>7.2 多机房 + 跨国多机房</h2><h2 id="7-3-多中心"><a href="#7-3-多中心" class="headerlink" title="7.3 多中心"></a>7.3 多中心</h2></li></ul><p>每个中心都可以对外提供服务，且业务可以自动在多中心之间切换。</p><h1 id="8-用户层技术"><a href="#8-用户层技术" class="headerlink" title="8. 用户层技术"></a>8. 用户层技术</h1><h2 id="8-1-用户管理"><a href="#8-1-用户管理" class="headerlink" title="8.1 用户管理"></a>8.1 用户管理</h2><ul><li>单点登录 (SSO) - 统一登录<ul><li>cookie</li><li>Json</li><li>token </li><li>CAS </li></ul></li></ul><p><img src="https://i.loli.net/2020/02/04/y9ScKCkWZvTomLY.png" alt="fig5.png"></p><ul><li>授权登录<ul><li>OAuth 2.0</li></ul></li></ul><h2 id="8-2-消息推送"><a href="#8-2-消息推送" class="headerlink" title="8.2 消息推送"></a>8.2 消息推送</h2><ul><li>根据途径<ul><li>短信</li><li>邮件</li><li>站内信</li><li>App推送</li></ul></li><li>消息推送的功能<ul><li>设备管理<ul><li>唯一标识</li><li>注册</li><li>注销</li></ul></li><li>连接管理</li><li>消息管理</li></ul></li></ul><p>技术上的挑战：</p><ul><li><p>海量设备和用户管理</p><ul><li>需要将用户和设备关联起来</li><li>提取用户特征对用户进行分类或者打标签</li></ul></li><li><p>连接保活</p><ul><li>想推送消息必须有连接通道</li><li>但是手机等终端都会限制后台应用的运行</li><li>应用找厂商拉白名单，hhhh</li></ul></li><li><p>消息管理</p><ul><li>根据用户的特征，选择一些用户进行消息推送</li><li>这部分的逻辑的设计必须十分灵活<h2 id="8-3-存储云，图片云"><a href="#8-3-存储云，图片云" class="headerlink" title="8.3 存储云，图片云"></a>8.3 存储云，图片云</h2></li></ul></li><li><p>小文件存储</p></li></ul><h1 id="9-业务层技术"><a href="#9-业务层技术" class="headerlink" title="9. 业务层技术"></a>9. 业务层技术</h1><p>主要是随着发展业务层变得越来越大了，需要做的最主要的就是拆分了，将整体复杂性分散到多个子业务或者子系统当中。</p><p>当子系统太多的时候，再做高内聚，低耦合的操作，即将职责关联比较强的子系统合成一个虚拟业务域，然后通过网关对外统一呈现。</p><h1 id="10-平台技术"><a href="#10-平台技术" class="headerlink" title="10. 平台技术"></a>10. 平台技术</h1><h2 id="10-1-运维平台"><a href="#10-1-运维平台" class="headerlink" title="10.1 运维平台"></a>10.1 运维平台</h2><ul><li>配置<ul><li>主要负责资源的管理<ul><li>机器管理</li><li>IP地址管理</li><li>虚拟机管理</li></ul></li></ul></li><li>部署<ul><li>主要负责将系统发布到线上<ul><li>包管理</li><li>灰度发布管理</li><li>回滚</li></ul></li></ul></li><li>监控<ul><li>主要负责收集系统上线运行之后的相关数据并进行监控，以便及时发现问题 </li></ul></li><li>应急<ul><li>主要负责系统出故障以后的处理<ul><li>停止程序</li><li>下线故障机器</li><li>切换IP</li></ul></li></ul></li></ul><h2 id="10-2-测试平台"><a href="#10-2-测试平台" class="headerlink" title="10.2 测试平台"></a>10.2 测试平台</h2><ul><li>单元测试</li><li>集成测试</li><li>接口测试</li><li>性能测试</li></ul><p>重点就是自动化测试，使测试用例能够重复执行，无须人工参与，以提高测试效率。</p><h3 id="10-2-1-用例管理"><a href="#10-2-1-用例管理" class="headerlink" title="10.2.1 用例管理"></a>10.2.1 用例管理</h3><p>测试自动化的主要手段就是通过脚本或者代码来进行测试，为了重复执行此类代码，测试平台需要将用例进行管理，管理的维度有业务、系统、测试类型、用例代码。例如网购业务的订单系统的接口测试用例。</p><h3 id="10-2-2-资源管理"><a href="#10-2-2-资源管理" class="headerlink" title="10.2.2 资源管理"></a>10.2.2 资源管理</h3><p>具体的运行环境的配置，包括</p><ul><li>硬件<ul><li>服务器</li><li>手机</li><li>平板</li></ul></li><li>软件<ul><li>操作系统</li><li>数据库</li><li>Java虚拟机</li></ul></li><li>业务系统</li></ul><h3 id="10-2-3-任务管理"><a href="#10-2-3-任务管理" class="headerlink" title="10.2.3 任务管理"></a>10.2.3 任务管理</h3><p>将测试用例分配到具体的资源上来执行，跟踪任务的执行情况。任务管理是测试平台设计的核心，其将测试平台的各个部分串联起来从而完成自动化测试</p><h3 id="10-2-4-数据管理"><a href="#10-2-4-数据管理" class="headerlink" title="10.2.4 数据管理"></a>10.2.4 数据管理</h3><p>记录各种相关的数据</p><ul><li>执行时间</li><li>执行结果</li><li>用例执行期间的CPU，内存占用情况</li></ul><h2 id="10-3-数据平台"><a href="#10-3-数据平台" class="headerlink" title="10.3 数据平台"></a>10.3 数据平台</h2><ul><li>数据管理<ul><li>数据采集<ul><li>日志</li><li>用户行为</li><li>业务数据</li></ul></li><li>数据存储<ul><li>将从业务系统采集的数据存储到数据平台，用于后续数据分析 </li></ul></li><li>数据访问<ul><li>负责对外提供各种协议用于读写数据 </li></ul></li><li>数据安全</li></ul></li><li>数据分析<ul><li>数据统计</li><li>数据挖掘</li><li>机器学习</li><li>深度学习</li></ul></li><li>数据应用</li></ul><h2 id="10-4-管理平台"><a href="#10-4-管理平台" class="headerlink" title="10.4 管理平台"></a>10.4 管理平台</h2><p>管理平台的核心职责就是权限管理，要做身份认证以及权限控制。</p><ul><li>身份认证<ul><li>确定当前的操作人员身份，防止非法人员进入系统</li></ul></li><li>权限控制<ul><li>根据身份确定权限 </li></ul></li></ul><h1 id="11-Some-tips"><a href="#11-Some-tips" class="headerlink" title="11. Some tips"></a>11. Some tips</h1><h2 id="11-1-如何选择开源项目"><a href="#11-1-如何选择开源项目" class="headerlink" title="11.1 如何选择开源项目"></a>11.1 如何选择开源项目</h2><ul><li>不要重复造轮子</li><li>但要找到合适的轮子</li></ul><h3 id="11-1-1-选择方法"><a href="#11-1-1-选择方法" class="headerlink" title="11.1.1 选择方法"></a>11.1.1 选择方法</h3><ul><li>聚焦于是否满足业务，而不是聚焦于开源项目本身是否足够优秀</li><li>聚焦于该项目是否足够成熟<ul><li>版本号</li><li>使用的公司数量</li><li>社区活跃程度</li></ul></li><li>聚焦于运维能力<ul><li>开源项目日志是否齐全</li><li>是否有命令行，管理控制台等维护工具</li><li>是否有故障检测和恢复的能力，例如告警，切换等</li></ul></li></ul><h3 id="11-1-2-如何深入了解一个开源项目"><a href="#11-1-2-如何深入了解一个开源项目" class="headerlink" title="11.1.2 如何深入了解一个开源项目"></a>11.1.2 如何深入了解一个开源项目</h3><ul><li>通读开源项目的设计文档，白皮书，了解其设计原理</li><li>核对每个配置项的作用和影响，识别出关键配置项</li><li>进行多种场景的性能测试</li><li>进行压力测试，观察CPU、内存、磁盘I/O等关键指标</li><li>进行故障测试</li></ul><h3 id="11-1-3-如何基于开源项目做二次开发"><a href="#11-1-3-如何基于开源项目做二次开发" class="headerlink" title="11.1.3 如何基于开源项目做二次开发"></a>11.1.3 如何基于开源项目做二次开发</h3><ul><li>不改动原系统，因为还要要能够合并，与原来的能够兼容就再好不过了</li><li>开发辅助系统<ul><li>监控</li><li>报警</li><li>负载均衡</li><li>管理</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-技术演进的动力-企业发展&quot;&gt;&lt;a href=&quot;#1-技术演进的动力-企业发展&quot; class=&quot;headerlink&quot; title=&quot;1. 技术演进的动力 - 企业发展&quot;&gt;&lt;/a&gt;1. 技术演进的动力 - 企业发展&lt;/h1&gt;&lt;h2 id=&quot;1-1-业务和技术之间
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="架构" scheme="https://www.llchen60.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>架构学习-复杂度来源</title>
    <link href="https://www.llchen60.com/%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0-%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%9D%A5%E6%BA%90/"/>
    <id>https://www.llchen60.com/%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0-%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%9D%A5%E6%BA%90/</id>
    <published>2020-02-04T04:09:13.000Z</published>
    <updated>2020-02-04T04:09:32.574Z</updated>
    
    <content type="html"><![CDATA[<p>架构设计的主要目的是为了解决软件系统复杂度带来的问题，那么复杂度的来源到底在哪里呢？ </p><h1 id="1-高性能"><a href="#1-高性能" class="headerlink" title="1. 高性能"></a>1. 高性能</h1><h2 id="1-1-单机复杂度"><a href="#1-1-单机复杂度" class="headerlink" title="1.1 单机复杂度"></a>1.1 单机复杂度</h2><p>操作系统 - 是将硬件性能充分发挥出来的关键。</p><ul><li>最初是只有输入计算以及输出功能</li><li>批处理 - 将要执行的指令预先写下来，形成一个指令清单，然后将任务交给计算机执行，读取任务中的指令清单并进行处理</li><li>进程 - 进程对应任务，都有自己的内存空间，进程间互不相关</li><li>进程间的通信<ul><li>管道</li><li>消息队列</li><li>信号量</li><li>共享存储</li></ul></li><li>线程<ul><li>进程内部的子任务，都共享同一份进程数据。为保证数据的正确性，有了互斥锁机制。有了多线程以后，操作系统调度的最小单位就变成了线程，而进程变成了操作系统分配资源的最小单位。</li></ul></li><li>多个CPU真正同时执行计算任务<ul><li>SMP symmetric multi processor </li><li>NUMA  Non uniform memory access </li><li>MPP  Massive Parallel Processing </li></ul></li></ul><h2 id="1-2-集群复杂度"><a href="#1-2-集群复杂度" class="headerlink" title="1.2 集群复杂度"></a>1.2 集群复杂度</h2><p>突然发现双十一峰值，支付宝能到每秒12万笔；红包能达到76万。通过大量机器来提升性能，并不仅仅是增加机器这么简单，让多台机器来配合达到高性能的目的，是一个复杂的任务，复杂在于：</p><ul><li>任务分配<ul><li>任务分配器<ul><li>硬件网络设备 交换机</li><li>软件网络设备  LVS</li><li>负载均衡软件  Nginix  HAProxy</li><li>分配算法<ul><li>轮询</li><li>按权重分配</li><li>按负载分配</li></ul></li></ul></li><li>任务分配器和业务服务器的连接<ul><li>选择合适的连接方式</li><li>管理连接<ul><li>连接建立，检测，中断后的处理 </li></ul></li></ul></li><li>继续拓展 -&gt; 任务分配器也要变成多台了<ul><li>此时需要将不同的用户分配到不同的任务分配器上<ul><li>DNS轮询，CDN， GSLB(Global Server Load Balance)</li></ul></li><li>任务分配器和业务服务器，多对多的网状结构</li></ul></li></ul></li><li>任务分解<ul><li>任务分配到不同的机器上带来的帮助会递减的，因为当业务越来越复杂，单台机器的性能不够用了，所以就需要进行任务分解来做优化</li><li>可以从逻辑上将各个子业务进行拆分，将一整个业务系统拆分成小而简单，但是需要多个系统配合的业务系统</li><li>为什么能提升性能？ 代码还是那些代码哇？<ul><li>简单的系统更容易分析出瓶颈，更容易做到高性能</li><li>可以针对单个任务进行拓展</li><li>当然不能划分的太细，因为网络的调用性能远比系统内的函数调用要低</li></ul></li></ul></li></ul><h1 id="2-高可用"><a href="#2-高可用" class="headerlink" title="2. 高可用"></a>2. 高可用</h1><blockquote><p>系统无中断地执行其功能的能力，代表系统的可用性程度</p></blockquote><blockquote><p>通过冗余来实现高可用，与高性能的区别在于，高性能增加机器的目的在于扩展处理性能；高可用增加机器的目的在于冗余处理单元</p></blockquote><h2 id="2-1-计算高可用"><a href="#2-1-计算高可用" class="headerlink" title="2.1 计算高可用"></a>2.1 计算高可用</h2><p>多台服务器时主备的选择，具体采用什么方式，主备分别的个数，结合实际业务需求来分析和判断。</p><h2 id="2-2-存储高可用"><a href="#2-2-存储高可用" class="headerlink" title="2.2 存储高可用"></a>2.2 存储高可用</h2><p>高可用设计的关键点就在于存储高可用了，区别在于将数据从一台机器搬到另一台机器，需要经过线路进行传输</p><p>无论是正常情况下的传输延迟，还是异常情况下的传输中断，都会导致系统的数据在某个时间点或者时间段是不一致的，而数据的不一致又会导致业务问题；存储高可用的难点不在于如何备份数据，而在于如何减少或者规避数据不一致对业务造成的影响。</p><p>分布式领域的CAP定理，存储高可用性不可能同时满足一致性，可用性，分区容错性，最多满足其中两个，这就要求我们在做架构设计的时候结合业务进行取舍。</p><h2 id="2-3-高可用状态决策"><a href="#2-3-高可用状态决策" class="headerlink" title="2.3 高可用状态决策"></a>2.3 高可用状态决策</h2><p>无论是计算高可用还是存储高可用，其基础都是状态决策，即系统需要能够判断当前的状态是正常还是异常的，如果出现异常就要采取行动来保证高可用。但一个矛盾点在于： </p><p><strong>通过冗余实现的高可用，状态决策本质上就不可能做到完全正确</strong></p><p>常见的决策方式：</p><ul><li>独裁式<ul><li>只有一个决策者</li><li>n个上报者</li><li>不会出现决策混乱，但是决策者本身故障的时候，系统就崩了</li></ul></li><li>协商式<ul><li>两个独立的个体通过交流信息，根据规则进行决策</li><li>主备决策</li><li>2台服务器启动时都是备机</li><li>建立连接</li><li>交换状态信息</li><li>某1台服务器做出决策，成为主机；另一台继续保持备机身份</li><li>协商式 当连接出问题的时候，采用哪个？ 两主？ 多连接？ 仍然存在问题的</li></ul></li><li>民主式<ul><li>多个独立个体通过投票的方式进行状态决策</li><li>ZooKeeper集群在选举leader时就采用这种方式</li><li>对于连接断开，可能出现多个leader的问题的解决<ul><li>投票节点数必须超过系统总结点数的一半的规则 </li></ul></li></ul></li></ul><h1 id="3-可拓展性"><a href="#3-可拓展性" class="headerlink" title="3. 可拓展性"></a>3. 可拓展性</h1><ul><li>可拓展性指系统为了应对将来的需求变化而提供的一种扩展能力，当有新的需求出现的时候，系统不需要或者仅仅需要少量修改就可以支持，无须整个系统的重构或者重建。</li><li>面向对象的思想以及设计模式的诞生与演化，都是在努力提升代码的可拓展性</li><li>设计具备良好可拓展性的系统的基本条件<ul><li>正确预测变化<ul><li>不能每个点都考虑可拓展性</li><li>不能完全不考虑可拓展性</li><li>所有的预测都存在出错的可能性</li></ul></li><li>完美封装变化<ul><li>一般来说会将变化封装在一个变化层，将不变的部分封装在一个独立的稳定层</li><li>或者提炼出一个抽象层和一个实现层</li></ul></li></ul></li></ul><h1 id="4-低成本，安全，规模"><a href="#4-低成本，安全，规模" class="headerlink" title="4. 低成本，安全，规模"></a>4. 低成本，安全，规模</h1><ul><li>低成本<ul><li>通过减少服务器的数量来达成低成本的目标</li><li>首先指定一个成本目标，当我们根据高性能、高可用的要求设计出方案时，评估一下方案能否满足成本目标，如果不行，就要重新设计架构</li><li>通过引入新技术来达到目标<ul><li>NoSQL 解决关系型数据库无法应对高并发情况下的访问压力的问题</li><li>全文搜索引擎是为了解决关系型数据库like搜索的低效的问题</li><li>Hadoop的出现是为了解决传统文件体统无法应对海量数据存储和计算的问题</li></ul></li></ul></li><li>安全<ul><li>功能安全<ul><li>XSS攻击</li><li>CSRF攻击</li><li>SQL注入</li><li>Windows漏洞</li><li>密码破解</li></ul></li><li>架构安全<ul><li>防火墙<ul><li>隔离网络</li><li>通过将网络划分成不同的区域，制定出不同区域之间的访问控制策略来控制不同信任程度区域间传送的数据流</li><li>太贵，很难实现</li></ul></li><li>一般还是靠运营商或者云服务商强大的带宽和流量清洗能力</li></ul></li></ul></li><li>规模<ul><li>规模带来的复杂度 - 量变带来的质变</li><li>功能越来越多，复杂度指数级增加</li><li>数据越来越多</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;架构设计的主要目的是为了解决软件系统复杂度带来的问题，那么复杂度的来源到底在哪里呢？ &lt;/p&gt;
&lt;h1 id=&quot;1-高性能&quot;&gt;&lt;a href=&quot;#1-高性能&quot; class=&quot;headerlink&quot; title=&quot;1. 高性能&quot;&gt;&lt;/a&gt;1. 高性能&lt;/h1&gt;&lt;h2 id=&quot;
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="架构" scheme="https://www.llchen60.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>架构学习-可扩展架构模式</title>
    <link href="https://www.llchen60.com/%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0-%E5%8F%AF%E6%89%A9%E5%B1%95%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.llchen60.com/%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0-%E5%8F%AF%E6%89%A9%E5%B1%95%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-02-04T04:05:31.000Z</published>
    <updated>2020-02-04T04:06:41.922Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-可扩展架构的基本思想和模式"><a href="#1-可扩展架构的基本思想和模式" class="headerlink" title="1. 可扩展架构的基本思想和模式"></a>1. 可扩展架构的基本思想和模式</h1><p>软件系统与硬件/建筑系统最大的差异在于软件是可扩展的，会不断更新，不断发展。如何避免扩展时改动范围太大，是软件架构可扩展性设计的主要思考点。</p><h2 id="1-1-基本思想-拆分"><a href="#1-1-基本思想-拆分" class="headerlink" title="1.1 基本思想 - 拆分"></a>1.1 基本思想 - 拆分</h2><p>将大系统细分为小系统，扩展时只是修改其中一部分即可，无须整个系统到处都改，通过这种方式来减少改动范围，降低改动风险。</p><p>不同的拆分方式，本质上决定了系统的扩展方式</p><h3 id="1-1-1-面向流程拆分-分层架构"><a href="#1-1-1-面向流程拆分-分层架构" class="headerlink" title="1.1.1 面向流程拆分 - 分层架构"></a>1.1.1 面向流程拆分 - 分层架构</h3><p>将整个业务流程分为几个阶段，每个阶段作为一部分</p><p>扩展时大部分情况只需要修改一层，或者相关联的两层，不会出现所有层都需要修改的情况的。</p><h3 id="1-1-2-面向服务拆分-SOA，微服务"><a href="#1-1-2-面向服务拆分-SOA，微服务" class="headerlink" title="1.1.2 面向服务拆分 - SOA，微服务"></a>1.1.2 面向服务拆分 - SOA，微服务</h3><p>将系统提供的服务拆分，每个服务作为一部分</p><p>扩展时只需要扩展相关服务即可。</p><h3 id="1-1-3-面向功能拆分-微内核架构"><a href="#1-1-3-面向功能拆分-微内核架构" class="headerlink" title="1.1.3 面向功能拆分 - 微内核架构"></a>1.1.3 面向功能拆分 - 微内核架构</h3><p>将系统提供的功能拆分，每个功能作为一部分</p><p>扩展时只需要扩展相关功能即可</p><h1 id="2-分层架构"><a href="#2-分层架构" class="headerlink" title="2. 分层架构"></a>2. 分层架构</h1><p>N层架构，逻辑上的分层</p><h2 id="2-1-C-S-B-S架构"><a href="#2-1-C-S-B-S架构" class="headerlink" title="2.1 C/S, B/S架构"></a>2.1 C/S, B/S架构</h2><p>划分的对象是整个业务系统，划分的维度是用户交互，将和用户交互的部分独立为一层，支撑用户交互的后台作为另外一层。 </p><h2 id="2-2-MVC-MVP架构"><a href="#2-2-MVC-MVP架构" class="headerlink" title="2.2 MVC, MVP架构"></a>2.2 MVC, MVP架构</h2><p>划分的对象是单个业务子系统，划分的维度是职责，将不同的职责划分到独立层，但各层的依赖关系会相对比较灵活。</p><h2 id="2-3-逻辑分层架构"><a href="#2-3-逻辑分层架构" class="headerlink" title="2.3 逻辑分层架构"></a>2.3 逻辑分层架构</h2><p>划分的对象可以是单个业务子系统，也可以是整个业务系统，划分的维度也是职责。虽然都是基于职责划分，但是不同点在于逻辑分层架构中的层是自顶向下依赖的。</p><h2 id="2-4-分层架构的核心"><a href="#2-4-分层架构的核心" class="headerlink" title="2.4 分层架构的核心"></a>2.4 分层架构的核心</h2><p>保证各层之间的差异足够清晰，边界足够明显，让人看到架构图之后就能看懂整个架构。</p><p>分层架构能够较好支撑系统扩展的本质在于<strong>隔离关注点</strong>，即每层的组件只会处理本层的逻辑，这样可以支撑系统在某层上快速扩展。</p><p>要保证层与层之间的依赖是稳定的。</p><p>分层结构的另外一个特点是层层传递，即一旦分层确定，整个业务流程就会按照层进行依次传递，不能在层之间进行跳跃。</p><h1 id="3-SOA-amp-微服务"><a href="#3-SOA-amp-微服务" class="headerlink" title="3. SOA &amp; 微服务"></a>3. SOA &amp; 微服务</h1><h2 id="3-1-SOA-Service-Oriented-Architecture-面向服务的架构"><a href="#3-1-SOA-Service-Oriented-Architecture-面向服务的架构" class="headerlink" title="3.1 SOA - Service Oriented Architecture - 面向服务的架构"></a>3.1 SOA - Service Oriented Architecture - 面向服务的架构</h2><p>提出的背景是企业内部的IT系统重复建设并且效率极低的问题，SOA提出了几个关键概念</p><h3 id="3-1-1-服务"><a href="#3-1-1-服务" class="headerlink" title="3.1.1 服务"></a>3.1.1 服务</h3><p>所有业务功能都是一项服务，意味着要对外提供开放的能力，当其他系统需要使用这项功能时，不需要做定制化开发。</p><h3 id="3-1-2-ESB"><a href="#3-1-2-ESB" class="headerlink" title="3.1.2 ESB"></a>3.1.2 ESB</h3><p>Enterprise Service Bus - 企业服务总线. 屏蔽异构系统对外提供各种不同的接口方式，以此达到服务间高效的互联互通。</p><p>ESB功能强大，但是现实中的协议种类很多，如JMS，WS，HTTP，RPC等，数据格式也多种多样，转换的过程是需要耗费大量计算性能的，当ESB承载的消息太多时，ESB本身会成为整个系统的性能瓶颈。</p><h3 id="3-1-3-松耦合"><a href="#3-1-3-松耦合" class="headerlink" title="3.1.3 松耦合"></a>3.1.3 松耦合</h3><p>减少各个服务间的依赖和互相影响。</p><h2 id="3-2-MicroService-微服务"><a href="#3-2-MicroService-微服务" class="headerlink" title="3.2 MicroService - 微服务"></a>3.2 MicroService - 微服务</h2><h3 id="3-2-1-微服务与SOA的关系"><a href="#3-2-1-微服务与SOA的关系" class="headerlink" title="3.2.1 微服务与SOA的关系"></a>3.2.1 微服务与SOA的关系</h3><p><img src="https://i.loli.net/2020/02/04/VgmIHRSsCUL2b6u.png" alt="fig1.png"></p><ul><li>微服务与SOA相似但是本质上并不相同<ul><li>是否有ESB<ul><li>微服务推荐使用同一的协议和格式<ul><li>例如RESTful协议， RPC协议 </li></ul></li></ul></li><li>服务的粒度<ul><li>微服务的服务粒度相对较细 </li></ul></li><li>服务交付<ul><li>微服务架构理念是快速交付，相应的就要求采取自动化测试，持续集成，自动化部署等敏捷开发相关的最佳实践。 </li></ul></li><li>应用场景<ul><li>SOA更适合于庞大、复杂、异构的企业化系统</li><li>微服务更适合于快速，轻量级，基于Web的互联网系统</li></ul></li></ul></li></ul><h3 id="3-2-2-微服务的陷阱"><a href="#3-2-2-微服务的陷阱" class="headerlink" title="3.2.2 微服务的陷阱"></a>3.2.2 微服务的陷阱</h3><ul><li>服务划分过细，服务间关系复杂</li><li>服务数量太多，团队效率急剧下降</li><li>调用链太长，性能下降<ul><li>一般线上的业务接口之间的调用，平均响应时间大约为50毫秒</li></ul></li><li>调用链太长，问题定位困难</li><li>需要自动化的支撑以实现快速交付</li></ul><h1 id="4-微服务架构最佳实践"><a href="#4-微服务架构最佳实践" class="headerlink" title="4. 微服务架构最佳实践"></a>4. 微服务架构最佳实践</h1><h2 id="4-1-方法论"><a href="#4-1-方法论" class="headerlink" title="4.1 方法论"></a>4.1 方法论</h2><h3 id="4-1-1-人员分配"><a href="#4-1-1-人员分配" class="headerlink" title="4.1.1 人员分配"></a>4.1.1 人员分配</h3><ul><li>3个人负责一个微服务</li></ul><h3 id="4-1-2-拆分逻辑的方法"><a href="#4-1-2-拆分逻辑的方法" class="headerlink" title="4.1.2 拆分逻辑的方法"></a>4.1.2 拆分逻辑的方法</h3><ul><li>基于业务逻辑拆分<ul><li>将业务模块按照职责范围识别出来，每个单独的业务模块拆分为一个独立的服务</li><li>拆分粒度的考虑 - 看人数最好 </li></ul></li><li>基于可扩展拆分<ul><li>将系统中的业务模块按照稳定性排序<ul><li>稳定服务</li><li>变动服务</li></ul></li><li>这样做的目的是为了提升项目快速迭代的效率，避免在开发的时候，不小心影响了已有的成熟功能导致线上的问题。</li></ul></li><li>基于可靠性拆分<ul><li>将业务模块按照优先级顺序排序，将可靠性要求高的核心服务和可靠性要求低的非核心服务拆分，然后重点保证核心服务的高可用</li></ul></li><li>基于性能拆分<ul><li>将性能要求高或者性能压力大的模块拆分出来，避免影响其他服务器<h2 id="4-2-基础设施"><a href="#4-2-基础设施" class="headerlink" title="4.2 基础设施"></a>4.2 基础设施</h2></li></ul></li></ul><p><img src="https://i.loli.net/2020/02/04/wVulTOvkeKRjpH4.jpg" alt="fig2.jpg"></p><ul><li>服务发现、服务路由、服务容错</li><li>接口框架、API网关</li><li>自动化部署、自动化测试、配置中心</li><li>服务监控、服务跟踪、服务安全</li></ul><h3 id="4-2-1-自动化测试"><a href="#4-2-1-自动化测试" class="headerlink" title="4.2.1 自动化测试"></a>4.2.1 自动化测试</h3><ul><li>代码级的单元测试</li><li>单个系统级的集成测试</li><li>系统间的接口测试</li></ul><h3 id="4-2-2-自动化部署"><a href="#4-2-2-自动化部署" class="headerlink" title="4.2.2 自动化部署"></a>4.2.2 自动化部署</h3><ul><li>版本管理</li><li>资源管理</li><li>部署操作</li><li>回退操作</li></ul><h3 id="4-2-3-配置中心"><a href="#4-2-3-配置中心" class="headerlink" title="4.2.3 配置中心"></a>4.2.3 配置中心</h3><ul><li>统一的配置中心来管理所有微服务节点的配置</li><li>配置中心包括<ul><li>版本管理</li><li>增删改查配置</li><li>结点管理</li><li>配置同步</li><li>配置推送</li></ul></li></ul><h3 id="4-2-4-接口框架"><a href="#4-2-4-接口框架" class="headerlink" title="4.2.4 接口框架"></a>4.2.4 接口框架</h3><p>除了统一接口协议，还要统一接口传递的数据格式</p><h3 id="4-2-5-API网关"><a href="#4-2-5-API网关" class="headerlink" title="4.2.5 API网关"></a>4.2.5 API网关</h3><p>内部微服务是相互连通的，相互访问都是点对点的。如果外部系统想调用系统的某个功能，也采取点对点的方式，那么外部系统会很崩，因为其无法理解这么多微服务的职责分工和边界，它只会关注其所需要的能力，而不会关注这个能力应该由哪个微服务提供。</p><p>====》 微服务需要一个统一的API网关，负责外部系统的访问操作</p><p>API网关是外部系统访问的接口，所有的外部系统接入系统都需要通过API网关，主要包括：</p><ul><li>接入鉴权 - 是否允许接入</li><li>权限控制 - 可以访问哪些功能</li><li>传输加密 </li><li>请求路由</li><li>流量控制</li></ul><h3 id="4-2-6-服务发现"><a href="#4-2-6-服务发现" class="headerlink" title="4.2.6 服务发现"></a>4.2.6 服务发现</h3><ul><li>自理式结构<ul><li>每个微服务自己完成服务发现</li></ul></li><li>代理式<ul><li>微服务之间有一个负载均衡系统，有负载均衡系统来完成微服务之间的服务发现 </li></ul></li></ul><p><img src="https://i.loli.net/2020/02/04/PWs5h1L2EFHizZn.png" alt="fig3.png"></p><p><img src="https://i.loli.net/2020/02/04/hmHp54yirJAWPgQ.png" alt="fig4.png"></p><h3 id="4-2-7-服务容错"><a href="#4-2-7-服务容错" class="headerlink" title="4.2.7 服务容错"></a>4.2.7 服务容错</h3><ul><li>请求重试</li><li>流量控制</li><li>服务隔离</li></ul><h3 id="4-2-8-服务监控"><a href="#4-2-8-服务监控" class="headerlink" title="4.2.8 服务监控"></a>4.2.8 服务监控</h3><ul><li>实时搜集信息并进行分析，避免故障后再来分析，减少了处理时间</li><li>在实时分析的基础上进行预警，在问题萌芽的阶段发觉并预警，降低问题的影响范围和影响时间</li></ul><h3 id="4-2-9-服务跟踪"><a href="#4-2-9-服务跟踪" class="headerlink" title="4.2.9 服务跟踪"></a>4.2.9 服务跟踪</h3><p>对于单个请求的完整跟踪，记录单个请求的发起时间，响应时间，响应错误码，请求参数，返回的JSON对象等信息。</p><h3 id="4-2-10-服务安全"><a href="#4-2-10-服务安全" class="headerlink" title="4.2.10 服务安全"></a>4.2.10 服务安全</h3><ul><li>接入安全</li><li>数据安全</li><li>传输安全</li></ul><h1 id="5-微内核架构"><a href="#5-微内核架构" class="headerlink" title="5. 微内核架构"></a>5. 微内核架构</h1><p>也被称为插件化架构(Plug-in Architecture), 是一种面向功能进行拆分的可扩展性架构。</p><h2 id="5-1-基本架构"><a href="#5-1-基本架构" class="headerlink" title="5.1 基本架构"></a>5.1 基本架构</h2><ul><li>核心系统<ul><li>负责和具体业务功能无关的通用功能，例如模块加载，模块间通信 </li></ul></li><li>插件模块<ul><li>负责实现具体的业务逻辑</li></ul></li></ul><p><img src="https://i.loli.net/2020/02/04/kz3Wg4ehDEc2xqv.png" alt="fig5.png"></p><p>微内核架构本质就是将变化的部分封装在插件里面，从而达到快速灵活扩展的目的，而又不会影响整体系统的稳定。</p><h2 id="5-2-设计关键点"><a href="#5-2-设计关键点" class="headerlink" title="5.2 设计关键点"></a>5.2 设计关键点</h2><h3 id="5-2-1-插件管理"><a href="#5-2-1-插件管理" class="headerlink" title="5.2.1 插件管理"></a>5.2.1 插件管理</h3><p>通过插件注册表，来知道当前有哪些插件，如何加载以及何时加载。插件注册表含有每个插件模块的信息，包括其名字，位置，加载时机等。</p><h3 id="5-2-2-插件连接"><a href="#5-2-2-插件连接" class="headerlink" title="5.2.2 插件连接"></a>5.2.2 插件连接</h3><p>插件是如何连接到核心系统的。</p><p>常见连接机制：</p><ul><li>OSGi </li><li>消息模式</li><li>依赖注入</li><li>分布式协议  RPC， HTTP</li></ul><h3 id="5-2-3-插件通信"><a href="#5-2-3-插件通信" class="headerlink" title="5.2.3 插件通信"></a>5.2.3 插件通信</h3><p>实际应用当中会出现某个业务流程需要多个插件协作，这就要求两个插件之间进行通信。由于插件之间没有直接的联系，通信必须通过核心系统，因此核心系统需要提供插件通信机制。</p><h2 id="5-3-OSGi框架"><a href="#5-3-OSGi框架" class="headerlink" title="5.3 OSGi框架"></a>5.3 OSGi框架</h2><p><img src="https://i.loli.net/2020/02/04/QBtP6Gqxea5bV1Z.png" alt="fig6.png"></p><p>该框架为通过网络向设备提供服务建立开发的标准。该框架的初始目标是构建一个在广域网和局域网或设备上展开业务的基础平台，但因为其的动态化，热拔插，高可复用性的特点，成为了首选的插件化标准。</p><h3 id="5-3-1-模块层-Module"><a href="#5-3-1-模块层-Module" class="headerlink" title="5.3.1 模块层 (Module)"></a>5.3.1 模块层 (Module)</h3><p>模块层实现插件管理功能，插件被称为Bundle，每个Bundle是一个Java的JAR文件。模块层里含有所有的插件。</p><h3 id="5-3-2-生命周期层-Lifecycle"><a href="#5-3-2-生命周期层-Lifecycle" class="headerlink" title="5.3.2 生命周期层 (Lifecycle)"></a>5.3.2 生命周期层 (Lifecycle)</h3><p>实现插件连接功能，提供了执行时的模块管理，模块对底层OSGi框架的访问。生命周期层精确定义了Bundle生命周期的操作(安装、更新、启动、停止、卸载)，Bundle必须按照规范实现各个操作。</p><h3 id="5-3-3-服务层-Service"><a href="#5-3-3-服务层-Service" class="headerlink" title="5.3.3 服务层 (Service)"></a>5.3.3 服务层 (Service)</h3><p>服务层实现插件通信的功能。OSGi提供了一个服务注册的功能，用于插件将自己能提供的服务注册到OSGi核心的服务注册中心当中，如果某个服务想用其他服务，则直接在服务注册中心搜索可用服务中心即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-可扩展架构的基本思想和模式&quot;&gt;&lt;a href=&quot;#1-可扩展架构的基本思想和模式&quot; class=&quot;headerlink&quot; title=&quot;1. 可扩展架构的基本思想和模式&quot;&gt;&lt;/a&gt;1. 可扩展架构的基本思想和模式&lt;/h1&gt;&lt;p&gt;软件系统与硬件/建筑系统最大的差
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="架构" scheme="https://www.llchen60.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
</feed>
