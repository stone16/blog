<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Leilei&#39;s Blog | 磊磊的博客</title>
  
  <subtitle>Because it&#39;s there</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.llchen60.com/"/>
  <updated>2020-02-09T05:14:29.247Z</updated>
  <id>https://www.llchen60.com/</id>
  
  <author>
    <name>Leilei Chen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java是如何工作的</title>
    <link href="https://www.llchen60.com/Java%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/"/>
    <id>https://www.llchen60.com/Java%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/</id>
    <published>2020-02-09T05:14:12.000Z</published>
    <updated>2020-02-09T05:14:29.247Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-编程语言是如何工作的"><a href="#1-编程语言是如何工作的" class="headerlink" title="1. 编程语言是如何工作的"></a>1. 编程语言是如何工作的</h1><p>我们可以把编程语言按照与底层实现的接近程度来划分层次，更加高层次的编程语言会让我们写起来更像自然语言一些，比如Java, C++。而低层次的语言，更贴近机器语言，即在描述底层是如何实现的。</p><p>对于大部分编程语言来说，工作的整个过程是从编译 - 链接 - 执行。就是从源代码开始，编译器会运行源代码，将其转化为贴近机器语言的状态，我们将其称为<code>Object</code> 文件。一系列的<code>Object</code>文件可以被链接起来，并创建一个可执行文件。操作系统可以加载这个可执行文件到内存中，并运行程序。</p><p>还有一部分语言是解释性的，比如Lisp, Schema。他会针对每一个高层次的语句来做低层次的翻译，然后顺序执行他们。这个过程相当于我遇到一个语句，翻译成计算机能看懂的语言以后，再看下一句…</p><h1 id="2-Java是如何工作的"><a href="#2-Java是如何工作的" class="headerlink" title="2. Java是如何工作的"></a>2. Java是如何工作的</h1><p>Java是个平台独立的语言，那他是怎么做到的呢？</p><p>首先我们要理解一下什么叫做平台独立？</p><blockquote><p>对于很多编程语言来说，编译器会生成可以在特定计算机上执行的代码。比如你在windows机器上编译一段c++代码，那么生成的可执行文件可以在任何其他的windows电脑上运行，但无法在Mac或者Linux机器上运行。</p></blockquote><p>对于早期的语言来说，设计者需要针对每一个平台专门设计一个编译器。而作为一个程序员，如果你想自己的代码在多个平台上都可以工作，你也需要针对性的做很多修改。</p><p>Java重新组织了编译-链接-执行这个循环，它将和平台相关的代码给抽象出来，和其他代码分开。这样子，编译的时候不会生成一个Object文件，反之，会生成字节码文件，这个字节码文件是平台独立的，即它可以在任何平台运行。那么刚才说的和平台相关的代码放到哪里了呢？为了执行字节码，我们需要唤醒java解释器。每个平台都会有自己的解释器，来解决和平台相关的问题。</p><p>对于其他语言来说，执行的过程是 编译，链接然后执行。对于Java来说，更应该说是编译然后链接，执行。</p><h1 id="3-Compile-vs-Runtime"><a href="#3-Compile-vs-Runtime" class="headerlink" title="3. Compile vs Runtime"></a>3. Compile vs Runtime</h1><p>整个代码的lifecycle,程序员先写源码，通过源码定义了程序是比如和工作的。这些源码必须要编译成机器码(java里面等效为字节码)，然后变成可执行文件。这个编译的过程称之为compile time.</p><p>一个编译过的文件是可以打开并且运行的，当一个应用正在运行的时候，我们就叫他处在runtime当中。</p><p>compile error一般是在编译的过程中由编译器报的错，告诉我们哪一行出了什么问题。运行时候的错误就叫做runtime error，这往往是一些逻辑错误，系统崩溃，流量过大等原因造成的。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="http://www.cs.cmu.edu/~jcarroll/15-100-s05/supps/basics/history.html" target="_blank" rel="noopener">CMU Class Notes</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-编程语言是如何工作的&quot;&gt;&lt;a href=&quot;#1-编程语言是如何工作的&quot; class=&quot;headerlink&quot; title=&quot;1. 编程语言是如何工作的&quot;&gt;&lt;/a&gt;1. 编程语言是如何工作的&lt;/h1&gt;&lt;p&gt;我们可以把编程语言按照与底层实现的接近程度来划分层次，更
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java Unit Test - Junit5</title>
    <link href="https://www.llchen60.com/Java-Unit-Test-Junit5/"/>
    <id>https://www.llchen60.com/Java-Unit-Test-Junit5/</id>
    <published>2020-02-09T05:12:58.000Z</published>
    <updated>2020-02-09T05:13:43.504Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Writing-Tests"><a href="#1-Writing-Tests" class="headerlink" title="1. Writing Tests"></a>1. Writing Tests</h1><p>JUnit5 = Junit Platform + Junit Jupiter + Junit Vintage </p><p>First test cases: </p><pre><code>import static org.junit.jupiter.api.Assertions.assertEquals;import example.util.Calculator;import org.junit.jupiter.api.Test;class MyFirstJUnitJupiterTests {    private final Calculator calculator = new Calculator();    @Test    void addition() {        assertEquals(2, calculator.add(1, 1));    }}</code></pre><h2 id="1-1-Annotations"><a href="#1-1-Annotations" class="headerlink" title="1.1 Annotations"></a>1.1 Annotations</h2><ul><li>@Test <ul><li>Denotes that a method is a test method. This annotation does not declare any attributes</li></ul></li><li>@ParameterizedTest <ul><li>Denote a method is a parameterized test </li><li>Make it possible to run a test multiple times with different arguments </li><li>Must declare at least one source that will provide the arguments for each invocation and then consume the arguments in teh test method </li></ul></li><li>@RepeatedTest <ul><li>denotes a method is a test template for a repeated test </li><li>Provides ability to repeat a test a specific number of times by annotating a method with <code>@RepeatedTest</code> and specify the total number of repetitions desired. </li></ul></li><li>@TestFactory <ul><li>denotes a method is a test factory for dynamic tests</li><li>dynamic test generated at runtime by a factory method that is annotated with @TestFactory </li><li>a factory for test case </li></ul></li><li>@TestTemplate<ul><li>denotes that a method is a template for test cases designed to be invoked multiple times depending on the number of invocation contexts returned by the registered providers. </li></ul></li><li>@TestMethodOrder <ul><li>Configure the test method execution order </li></ul></li><li>@TestInstance<ul><li>Used to configure the test instance lifecycle for the annotated test class.  </li></ul></li><li>@DisplayName<ul><li>Declares a custom display name for the test class or test method.</li></ul></li><li>@BeforeEach<ul><li>Denotes that the annotated method should be executed before each @Test, @RepeatedTest, @ParameterizedTest, or @TestFactory method in the current class; analogous to JUnit 4’s @Before. </li></ul></li><li>@AfterEach <ul><li>Denotes that the annotated method should be executed after each @Test, @RepeatedTest, @ParameterizedTest, or @TestFactory method in the current class; analogous to JUnit 4’s @After</li></ul></li><li>@BeforeAll <ul><li>Denotes that the annotated method should be executed before all @Test, @RepeatedTest, @ParameterizedTest, and @TestFactory methods in the current class; analogous to JUnit 4’s @BeforeClass. Such methods are inherited (unless they are hidden or overridden) and must be static (unless the “per-class” test instance lifecycle is used).</li></ul></li><li>@AfterAll <ul><li>Denotes that the annotated method should be executed after all @Test, @RepeatedTest, @ParameterizedTest, and @TestFactory methods in the current class; analogous to JUnit 4’s @AfterClass. Such methods are inherited (unless they are hidden or overridden) and must be static</li></ul></li><li>@Nested <ul><li>Denotes that the annotated class is a non-static nested test class. @BeforeAll and @AfterAll methods cannot be used directly in a @Nested test class unless the “per-class” test instance lifecycle is used.</li></ul></li><li>@Tag<ul><li>Used to declare tags for filtering tests, either at the class or method level; analogous to test groups in TestNG or Categories in JUnit 4. Such annotations are inherited at the class level but not at the method level.</li></ul></li><li>@Disabled <ul><li>Used to disable a test class or test method; analogous to JUnit 4’s @Ignore. Such annotations are not inherited.</li></ul></li><li>@ExtendWith<ul><li>Used to register extensions declaratively </li></ul></li><li>@RegisterExtension<ul><li>Used to register extensions programmatically via fields.</li></ul></li><li>@TempDir<ul><li>Used to supply a temporary directory via field injection or parameter injection in a lifecycle method or test method </li></ul></li></ul><h2 id="1-2-Test-classes-and-methods"><a href="#1-2-Test-classes-and-methods" class="headerlink" title="1.2 Test classes and methods"></a>1.2 Test classes and methods</h2><ul><li>Test classes must not be abstract and mush have a single constructor</li><li>Test method: any instance method that is directly annotated or meta-annotated with @Test, @RepeatedTest, @ParameterizedTest, @TestFactory, or @TestTemplate</li><li>Lifecycle Method: any method that is directly annotated or meta-annotated with @BeforeAll, @AfterAll, @BeforeEach, or @AfterEach</li></ul><p>A standard unit test class: </p><pre><code>import static org.junit.jupiter.api.Assertions.fail;import static org.junit.jupiter.api.Assumptions.assumeTrue;import org.junit.jupiter.api.AfterAll;import org.junit.jupiter.api.AfterEach;import org.junit.jupiter.api.BeforeAll;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Disabled;import org.junit.jupiter.api.Test;class StandardTests {    @BeforeAll    static void initAll() {    }    @BeforeEach    void init() {    }    @Test    void succeedingTest() {    }    @Test    void failingTest() {        fail(&quot;a failing test&quot;);    }    @Test    @Disabled(&quot;for demonstration purposes&quot;)    void skippedTest() {        // not executed    }    @Test    void abortedTest() {        assumeTrue(&quot;abc&quot;.contains(&quot;Z&quot;));        fail(&quot;test should have been aborted&quot;);    }    @AfterEach    void tearDown() {    }    @AfterAll    static void tearDownAll() {    }}</code></pre><h2 id="1-3-Assertions"><a href="#1-3-Assertions" class="headerlink" title="1.3 Assertions"></a>1.3 Assertions</h2><p>All assertions are static methods in org.junit.jupiter.api.Assertions class.</p><p>See <a href="https://junit.org/junit5/docs/current/api/org/junit/jupiter/api/Assertions.html" target="_blank" rel="noopener">API doc</a> for detail: </p><ul><li>assertAll()</li><li>assertArrayEquals()</li><li>assertArrauEqualsString()</li><li>assertEquals()</li><li>assertNotEquals()</li><li>assertTimeout()</li><li>assertTimeoutPreemptively()</li><li>assertTure()</li><li>fail()</li></ul><pre><code>@Test    void dependentAssertions() {        // Within a code block, if an assertion fails the        // subsequent code in the same block will be skipped.        assertAll(&quot;properties&quot;,            () -&gt; {                String firstName = person.getFirstName();                assertNotNull(firstName);                // Executed only if the previous assertion is valid.                assertAll(&quot;first name&quot;,                    () -&gt; assertTrue(firstName.startsWith(&quot;J&quot;)),                    () -&gt; assertTrue(firstName.endsWith(&quot;e&quot;))                );            },            () -&gt; {                // Grouped assertion, so processed independently                // of results of first name assertions.                String lastName = person.getLastName();                assertNotNull(lastName);                // Executed only if the previous assertion is valid.                assertAll(&quot;last name&quot;,                    () -&gt; assertTrue(lastName.startsWith(&quot;D&quot;)),                    () -&gt; assertTrue(lastName.endsWith(&quot;e&quot;))                );            }        );    }</code></pre><h2 id="1-4-Assumptions"><a href="#1-4-Assumptions" class="headerlink" title="1.4 Assumptions"></a>1.4 Assumptions</h2><p>Assumptions is a collection of utility methods that support conditional test execution based on assumptions.In direct contrast to failed assertions, failed assumptions do not result in a test failure; rather, a failed assumption results in a <strong>test being aborted</strong>.</p><ul><li><p>assumeFalse()</p></li><li><p>assumeTrue()</p></li><li><p>assumingThat(boolean assumption, Executable executable)</p><p>   @Test</p><pre><code>  void testOnlyOnDeveloperWorkstation() {      assumeTrue(&quot;DEV&quot;.equals(System.getenv(&quot;ENV&quot;)),          () -&gt; &quot;Aborting test: not on developer workstation&quot;);      // remainder of test  }  @Test  void testInAllEnvironments() {      assumingThat(&quot;CI&quot;.equals(System.getenv(&quot;ENV&quot;)),          () -&gt; {              // perform these assertions only on the CI server              assertEquals(2, calculator.divide(4, 2));          });      // perform these assertions in all environments      assertEquals(42, calculator.multiply(6, 7));  }</code></pre></li></ul><h2 id="1-5-Test-Instance-Lifecycle"><a href="#1-5-Test-Instance-Lifecycle" class="headerlink" title="1.5 Test Instance Lifecycle"></a>1.5 Test Instance Lifecycle</h2><p>In order to allow individual test methods to be executed in isolation and to avoid unexpected side effects due to mutable test instance state, <strong>JUnit creates a new instance of each test class before executing each test method</strong></p><p>You can annotate your test class with <code>@TestInstance(Lifecycle.PER_CLASS)</code> if you <strong>prefer to execute all test methods on the same test instance</strong>. And if your test mothods rely on state stored in instance variables, may need to reset the state in @BeforeEach or @AfterEach methods. </p><p>The “per-class” mode has some additional benefits over the default “per-method” mode. Specifically, with the “per-class” mode it becomes possible to declare @BeforeAll and @AfterAll on non-static methods as well as on interface default methods. The “per-class” mode therefore also makes it possible to use @BeforeAll and @AfterAll methods in @Nested test classes.</p><pre><code>@TestInstance(Lifecycle.PER_CLASS)interface TestLifecycleLogger {    static final Logger logger = Logger.getLogger(TestLifecycleLogger.class.getName());    @BeforeAll    default void beforeAllTests() {        logger.info(&quot;Before all tests&quot;);    }    @AfterAll    default void afterAllTests() {        logger.info(&quot;After all tests&quot;);    }    @BeforeEach    default void beforeEachTest(TestInfo testInfo) {        logger.info(() -&gt; String.format(&quot;About to execute [%s]&quot;,            testInfo.getDisplayName()));    }    @AfterEach    default void afterEachTest(TestInfo testInfo) {        logger.info(() -&gt; String.format(&quot;Finished executing [%s]&quot;,            testInfo.getDisplayName()));    }}</code></pre><h2 id="1-6-Repeated-Test"><a href="#1-6-Repeated-Test" class="headerlink" title="1.6 Repeated Test"></a>1.6 Repeated Test</h2><pre><code>import static org.junit.jupiter.api.Assertions.assertEquals;import java.util.logging.Logger;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.DisplayName;import org.junit.jupiter.api.RepeatedTest;import org.junit.jupiter.api.RepetitionInfo;import org.junit.jupiter.api.TestInfo;class RepeatedTestsDemo {    private Logger logger = // ...    @BeforeEach    void beforeEach(TestInfo testInfo, RepetitionInfo repetitionInfo) {        int currentRepetition = repetitionInfo.getCurrentRepetition();        int totalRepetitions = repetitionInfo.getTotalRepetitions();        String methodName = testInfo.getTestMethod().get().getName();        logger.info(String.format(&quot;About to execute repetition %d of %d for %s&quot;, //            currentRepetition, totalRepetitions, methodName));    }    @RepeatedTest(10)    void repeatedTest() {        // ...    }    @RepeatedTest(5)    void repeatedTestWithRepetitionInfo(RepetitionInfo repetitionInfo) {        assertEquals(5, repetitionInfo.getTotalRepetitions());    }    @RepeatedTest(value = 1, name = &quot;{displayName} {currentRepetition}/{totalRepetitions}&quot;)    @DisplayName(&quot;Repeat!&quot;)    void customDisplayName(TestInfo testInfo) {        assertEquals(&quot;Repeat! 1/1&quot;, testInfo.getDisplayName());    }    @RepeatedTest(value = 1, name = RepeatedTest.LONG_DISPLAY_NAME)    @DisplayName(&quot;Details...&quot;)    void customDisplayNameWithLongPattern(TestInfo testInfo) {        assertEquals(&quot;Details... :: repetition 1 of 1&quot;, testInfo.getDisplayName());    }    @RepeatedTest(value = 5, name = &quot;Wiederholung {currentRepetition} von {totalRepetitions}&quot;)    void repeatedTestInGerman() {        // ...    }}</code></pre><h2 id="1-7-Parameterized-Tests"><a href="#1-7-Parameterized-Tests" class="headerlink" title="1.7 Parameterized Tests"></a>1.7 Parameterized Tests</h2><p>With parameterized, we could run a test multiple times with different arguments. And we must declare at least one source that will provide the arguments for each invocation and then consume the arguments in the test method. </p><pre><code>@ParameterizedTest@ValueSource(strings = { &quot;racecar&quot;, &quot;radar&quot;, &quot;able was I ere I saw elba&quot; })void palindromes(String candidate) {    assertTrue(StringUtils.isPalindrome(candidate));}</code></pre><h3 id="1-7-1-Annotations-used-in-parameterized-tests"><a href="#1-7-1-Annotations-used-in-parameterized-tests" class="headerlink" title="1.7.1 Annotations used in parameterized tests"></a>1.7.1 Annotations used in parameterized tests</h3><ul><li>@ValueSource<ul><li>specify a single array of literal values </li></ul></li><li>@NullSource<ul><li>provides a single null argument to the annotated @ParameterizedTest method.</li></ul></li><li>@EmptySource<ul><li>provides a single empty argument to the annotated @ParameterizedTest method for parameters of the following types: java.lang.String, java.util.List, java.util.Set, java.util.Map, primitive arrays (e.g., int[], char[][], etc.), object arrays (e.g.,String[], Integer[][], etc.).</li></ul></li><li>@NullAndEmptySource: <ul><li>a composed annotation that combines the functionality of @NullSource and @EmptySource.</li></ul></li></ul><pre><code>@ParameterizedTest@NullAndEmptySource@ValueSource(strings = { &quot; &quot;, &quot;   &quot;, &quot;\t&quot;, &quot;\n&quot; })void nullEmptyAndBlankStrings(String text) {    assertTrue(text == null || text.trim().isEmpty());}</code></pre><ul><li>@EnumSource<ul><li>provides a convenient way to use Enum constants. </li><li>also provides an optional names parameter that lets you specify which constants shall be used </li></ul></li></ul><pre><code>@ParameterizedTest@EnumSource(value = TimeUnit.class, names = { &quot;DAYS&quot;, &quot;HOURS&quot; })void testWithEnumSourceInclude(TimeUnit timeUnit) {    assertTrue(EnumSet.of(TimeUnit.DAYS, TimeUnit.HOURS).contains(timeUnit));}@ParameterizedTest@EnumSource(value = TimeUnit.class, mode = EXCLUDE, names = { &quot;DAYS&quot;, &quot;HOURS&quot; })void testWithEnumSourceExclude(TimeUnit timeUnit) {    assertFalse(EnumSet.of(TimeUnit.DAYS, TimeUnit.HOURS).contains(timeUnit));    assertTrue(timeUnit.name().length() &gt; 5);}</code></pre><ul><li>@MethodSource<ul><li>Allow you to refer to one or more factory methods of the test class or external classes </li><li>Each factory method must generate a stream of arguments</li></ul></li></ul><pre><code>@ParameterizedTest@MethodSource(&quot;stringProvider&quot;)void testWithExplicitLocalMethodSource(String argument) {    assertNotNull(argument);}static Stream&lt;String&gt; stringProvider() {    return Stream.of(&quot;apple&quot;, &quot;banana&quot;);}</code></pre><ul><li>@CsvSource </li><li>@CsvFileSource</li><li>@ArgumentsSource <ul><li>can be used to specify a custom resuable ArgumentsProvider </li><li>An implementation of ArgumentsProvider mush be declared as either a top-level class or as a static nested class. </li></ul></li></ul><pre><code>@ParameterizedTest@ArgumentsSource(MyArgumentsProvider.class)void testWithArgumentsSource(String argument) {    assertNotNull(argument);}public class MyArgumentsProvider implements ArgumentsProvider {    @Override    public Stream&lt;? extends Arguments&gt; provideArguments(ExtensionContext context) {        return Stream.of(&quot;apple&quot;, &quot;banana&quot;).map(Arguments::of);    }}</code></pre><h3 id="1-7-2-Lifecycle-and-Interoperability"><a href="#1-7-2-Lifecycle-and-Interoperability" class="headerlink" title="1.7.2 Lifecycle and Interoperability"></a>1.7.2 Lifecycle and Interoperability</h3><p>Each invocation of a parameterized test has the same lifecycle </p><h2 id="1-8-Test-Templates"><a href="#1-8-Test-Templates" class="headerlink" title="1.8 Test Templates"></a>1.8 Test Templates</h2><p>A @TestTemplate method is not a regular test case but rather a template for test cases. It is designed to be invoked multiple times depending on the number of invocation contexts returned by the registerd providers. </p><p>Thus, it must be used in conjunction with a registered TestTemplateInvocationContextProvider extension. Each invocation of a test template method behaves like the execution of a regular @Test method with full support for the same lifecycle callbacks and extensions.</p><h2 id="1-9-Dynamic-Tests"><a href="#1-9-Dynamic-Tests" class="headerlink" title="1.9 Dynamic Tests"></a>1.9 Dynamic Tests</h2><p> @Test describe methods that implement test cases. These test cases are static in the sense that they are fully specified at compile time, and their behavior cannot be changed by anything happening at runtime.</p><p> This new kind of test is a dynamic test which is generated at runtime by a factory method that is annotated with @TestFactory</p><p> In contrast to @Test methods, a @TestFactory method is not itself a test case but rather a factory for test cases. Thus, a dynamic test is the product of a factory. Technically speaking, a @TestFactory method must return a single DynamicNode or a Stream, Collection, Iterable, Iterator, or array of DynamicNode instances. Instantiable subclasses of DynamicNode are DynamicContainer and </p><p> DynamicContainer instances are composed of <strong>a display name</strong> and <strong>a list of dynamic child nodes</strong>, enabling the creation of arbitrarily nested hierarchies of dynamic nodes. DynamicTest instances will be executed lazily, enabling dynamic and even non-deterministic generation of test cases.</p><h3 id="1-9-1-Dynamic-test-lifecycle"><a href="#1-9-1-Dynamic-test-lifecycle" class="headerlink" title="1.9.1 Dynamic test lifecycle"></a>1.9.1 Dynamic test lifecycle</h3><p>The execution lifecycle of a dynamic test is quite different than it is for a standard @Test case. Specifically, there are <strong>no lifecycle callbacks for individual dynamic tests</strong>. This means that @BeforeEach and @AfterEach methods and their corresponding extension callbacks are** executed for the @TestFactory method** but not for each dynamic test. In other words, if you access fields from the test instance within a lambda expression for a dynamic test, those fields will not be reset by callback methods or extensions between the execution of individual dynamic tests generated by the same @TestFactory method.</p><h2 id="1-10-Parallel-Execution"><a href="#1-10-Parallel-Execution" class="headerlink" title="1.10 Parallel Execution"></a>1.10 Parallel Execution</h2><h3 id="1-10-1-Mode"><a href="#1-10-1-Mode" class="headerlink" title="1.10.1 Mode"></a>1.10.1 Mode</h3><p>Offers two mode: </p><ul><li>SAME_THREAD<ul><li>Force execution in the same thread used by the parent. For example, when used on a test method, the test method will be executed in the same thread as any @BeforeAll or @AfterAll methods of the containing test class. </li></ul></li><li>CONCURRENT<ul><li>Execute concurrently unless a resource lock forces execution in the same thread.</li></ul></li></ul><p>Alternatively, you can use the @Execution annotation to change the execution mode for the annotated element and its subelements (if any) which allows you to activate parallel execution for individual test classes, one by one.</p><h3 id="1-10-2-Synchronization"><a href="#1-10-2-Synchronization" class="headerlink" title="1.10.2 Synchronization"></a>1.10.2 Synchronization</h3><p>The @ResourceLock annotation allows you to declare that a test class or method uses a specific shared resource that requires synchronized access to ensure reliable test execution. </p><pre><code>@Execution(CONCURRENT)class SharedResourcesDemo {    private Properties backup;    @BeforeEach    void backup() {        backup = new Properties();        backup.putAll(System.getProperties());    }    @AfterEach    void restore() {        System.setProperties(backup);    }    @Test    @ResourceLock(value = SYSTEM_PROPERTIES, mode = READ)    void customPropertyIsNotSetByDefault() {        assertNull(System.getProperty(&quot;my.prop&quot;));    }    @Test    @ResourceLock(value = SYSTEM_PROPERTIES, mode = READ_WRITE)    void canSetCustomPropertyToApple() {        System.setProperty(&quot;my.prop&quot;, &quot;apple&quot;);        assertEquals(&quot;apple&quot;, System.getProperty(&quot;my.prop&quot;));    }    @Test    @ResourceLock(value = SYSTEM_PROPERTIES, mode = READ_WRITE)    void canSetCustomPropertyToBanana() {        System.setProperty(&quot;my.prop&quot;, &quot;banana&quot;);        assertEquals(&quot;banana&quot;, System.getProperty(&quot;my.prop&quot;));    }}</code></pre><h1 id="2-Extension-Model"><a href="#2-Extension-Model" class="headerlink" title="2. Extension Model"></a>2. Extension Model</h1><p>In contrast to Runner, TestRule and MethodRule extension points in JUnit4, the JUnit Jupiter extension model consists of a single, coherent concept – Extension API. </p><h2 id="2-1-Registering-Extensions"><a href="#2-1-Registering-Extensions" class="headerlink" title="2.1 Registering Extensions"></a>2.1 Registering Extensions</h2><p>Extensions can be registered declaraticely via @ExtendWith, programmatically via @RegisterExtension, or automatically via Java’s ServiceLoader mechanism. </p><h3 id="2-1-1-Declarative-Extension-Registration"><a href="#2-1-1-Declarative-Extension-Registration" class="headerlink" title="2.1.1 Declarative Extension Registration"></a>2.1.1 Declarative Extension Registration</h3><pre><code>@ExtendWith(RandomParametersExtension.class)@Testvoid test(@Random int i) {    // ...}</code></pre><p>Notice: we could annotate it in class level to register an extension for all tests in this specific class. </p><p>We can also register multiple extensions: </p><pre><code>@ExtendWith({ DatabaseExtension.class, WebServerExtension.class })class MyFirstTests {    // ...}</code></pre><h3 id="2-1-2-Programmatic-Extension-Registration"><a href="#2-1-2-Programmatic-Extension-Registration" class="headerlink" title="2.1.2 Programmatic Extension Registration"></a>2.1.2 Programmatic Extension Registration</h3><p>Register extensions programmatically by annotating fields in test classes with @RegisterExtension </p><p>When an extension is registered declaratively via @ExtendWith, it can typically only be configured via annotations. In contrast, when an extension is registered via @RegisterExtension, it can be <strong>configured programmatically</strong> - for example, in order to pass arguments to the extension’s constructor, a static factory method, or a builder API.</p><p>If a @RegisterExtension field is static, the extension will be registered after extensions that are registered at the class level via @ExtendWith. Such static extensions are not limited in which extension APIs they can implement. Extensions registered via static fields may therefore implement class-level and instance-level extension APIs such as BeforeAllCallback, AfterAllCallback, and TestInstancePostProcessor as well as method-level extension APIs such as BeforeEachCallback, etc.</p><pre><code>class WebServerDemo {    @RegisterExtension    static WebServerExtension server = WebServerExtension.builder()        .enableSecurity(false)        .build();    @Test    void getProductList() {        WebClient webClient = new WebClient();        String serverUrl = server.getServerUrl();        // Use WebClient to connect to web server using serverUrl and verify response        assertEquals(200, webClient.get(serverUrl + &quot;/products&quot;).getResponseStatus());    }}</code></pre><ul><li><p>For a non-static field with @RegisterExtension, it will be registered after the test class has been instantiated </p></li><li><p>By default, an instance extension will be registered after extensions that are registered at the method level via @ExtendWith </p></li><li><p>If the class is configured with @TestInstance(Lifecycle.PER_CLASS) semantics, an instance extension will be registered at the method level via @ExtendWith.</p><p>  class DocumentationDemo {</p><pre><code>  static Path lookUpDocsDir() {      // return path to docs dir  }  // The configured DocumentationExtension will be automatically registered as an extension at the method level.  @RegisterExtension  DocumentationExtension docs = DocumentationExtension.forPath(lookUpDocsDir());  @Test  void generateDocumentation() {      // use this.docs ...  }</code></pre><p>  }</p></li></ul><h3 id="2-1-3-Automatic-Extension-Registration"><a href="#2-1-3-Automatic-Extension-Registration" class="headerlink" title="2.1.3 Automatic Extension Registration"></a>2.1.3 Automatic Extension Registration</h3><p>JUnit Jupiter also supports global extension registration via Java’s java.util.ServiceLoader mechanism, allowing third-party extensions to be *<em>auto-detected and automatically registered *</em>based on what is available in the classpath.</p><h2 id="2-2-Conditional-Test-Execution"><a href="#2-2-Conditional-Test-Execution" class="headerlink" title="2.2 Conditional Test Execution"></a>2.2 Conditional Test Execution</h2><p>Used to define conditional test execution. </p><p>An ExecutionCondition is evaluated for each container (e.g., a test class) to determine if all the tests it contains should be executed based on the supplied ExtensionContext</p><h2 id="2-3-Execution-Order-of-User-Code-and-Extensions"><a href="#2-3-Execution-Order-of-User-Code-and-Extensions" class="headerlink" title="2.3 Execution Order of User Code and Extensions"></a>2.3 Execution Order of User Code and Extensions</h2><p>When executing a test class that contains one or more test methods, a number of extension callbacks are called in addition to the user-supplied test and lifecycle methods.</p><p><img src="https://i.loli.net/2020/02/09/9OkZPCtrFL8RfYM.png" alt="fig1.png"></p><p>JUnit Jupiter always guarantees wrapping behavior for multiple registered extensions that implement lifecycle callbacks such as BeforeAllCallback, AfterAllCallback, BeforeEachCallback, AfterEachCallback, BeforeTestExecutionCallback, and AfterTestExecutionCallback.</p><p>That means that, given two extensions Extension1 and Extension2 with Extension1 registered before Extension2, <strong>any “before” callbacks implemented by Extension1 are guaranteed to execute before any “before” callbacks implemented by Extension2</strong>.</p><pre><code>import static example.callbacks.Logger.afterAllMethod;import static example.callbacks.Logger.afterEachMethod;import static example.callbacks.Logger.beforeAllMethod;import static example.callbacks.Logger.beforeEachMethod;import org.junit.jupiter.api.AfterAll;import org.junit.jupiter.api.AfterEach;import org.junit.jupiter.api.BeforeAll;import org.junit.jupiter.api.BeforeEach;/** * Abstract base class for tests that use the database. */abstract class AbstractDatabaseTests {    @BeforeAll    static void createDatabase() {        beforeAllMethod(AbstractDatabaseTests.class.getSimpleName() + &quot;.createDatabase()&quot;);    }    @BeforeEach    void connectToDatabase() {        beforeEachMethod(AbstractDatabaseTests.class.getSimpleName() + &quot;.connectToDatabase()&quot;);    }    @AfterEach    void disconnectFromDatabase() {        afterEachMethod(AbstractDatabaseTests.class.getSimpleName() + &quot;.disconnectFromDatabase()&quot;);    }    @AfterAll    static void destroyDatabase() {        afterAllMethod(AbstractDatabaseTests.class.getSimpleName() + &quot;.destroyDatabase()&quot;);    }}</code></pre><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://junit.org/junit5/docs/current/user-guide/" target="_blank" rel="noopener">https://junit.org/junit5/docs/current/user-guide/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Writing-Tests&quot;&gt;&lt;a href=&quot;#1-Writing-Tests&quot; class=&quot;headerlink&quot; title=&quot;1. Writing Tests&quot;&gt;&lt;/a&gt;1. Writing Tests&lt;/h1&gt;&lt;p&gt;JUnit5 = Junit P
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
      <category term="Unit Test" scheme="https://www.llchen60.com/tags/Unit-Test/"/>
    
  </entry>
  
  <entry>
    <title>Java日志管理 - slf4j + log4j - 探究Distribute system 的threadContext复用的问题</title>
    <link href="https://www.llchen60.com/Java%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-slf4j-log4j-%E6%8E%A2%E7%A9%B6Distribute-system-%E7%9A%84threadContext%E5%A4%8D%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://www.llchen60.com/Java%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-slf4j-log4j-%E6%8E%A2%E7%A9%B6Distribute-system-%E7%9A%84threadContext%E5%A4%8D%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2020-02-07T03:48:00.000Z</published>
    <updated>2020-02-07T03:48:21.842Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-常用日志系统介绍"><a href="#1-常用日志系统介绍" class="headerlink" title="1. 常用日志系统介绍"></a>1. 常用日志系统介绍</h1><ul><li>日志门面<ul><li>jcl - jakarta common logging  <ul><li>日志接口，支持运行时动态加载日志组件的实现 </li></ul></li><li>slf4j<ul><li>日志接口</li><li>在log层和代码层之间起到门面作用，对于用户来说只要使用SLF4J的接口，就可以隐藏日志的具体实现，其提供的核心API是一些接口和一个LoggerFactory的工厂类，用户只需要按照其提供的日志接口进行使用，最终日志的格式，记录级别，输出方式等都可以通过具体日志系统的配置来实现</li></ul></li></ul></li><li>日志框架<ul><li>jul - java.util.logging </li><li>log4j</li><li>log4j2</li><li>logback<ul><li>slf4j的实现 </li><li>是log4j的升级版</li></ul></li></ul></li></ul><h1 id="2-日志级别"><a href="#2-日志级别" class="headerlink" title="2. 日志级别"></a>2. 日志级别</h1><ul><li>severe</li><li>warning </li><li>info</li><li>config</li><li>fine </li><li>finer </li></ul><h1 id="3-常见使用方式"><a href="#3-常见使用方式" class="headerlink" title="3. 常见使用方式"></a>3. 常见使用方式</h1><p>一般工程上会选择一个日志门面，加日志框架，常用的门面基本上还是SLF4J比较多，框架的选择很多，主要是需要注意工程上分布式系统的多线程方面的支持。</p><h1 id="4-Log4j2-ThreadContext复用的问题"><a href="#4-Log4j2-ThreadContext复用的问题" class="headerlink" title="4. Log4j2 ThreadContext复用的问题"></a>4. Log4j2 ThreadContext复用的问题</h1><p>ThreadContext出现的背景主要是因为现代系统基本上都需要都是和多个client打交道，在一个典型的多线程的应用系统当中，不同的线程就需要和不同的client打交道.为了能够分辨出同一个client发出的不同log请求，我们就需要给每个请求一个id，来做标记。</p><p>Log4j2使用Thread Context Map和Thread Context Stack来进行标记。常用Map，因为键值对更容易进行添加和处理</p><p>使用Stack: </p><pre><code>ThreadContext.push(UUID.randomUUID().toString()); // Add the fishtag;logger.debug(&quot;Message 1&quot;);...logger.debug(&quot;Message 2&quot;);..ThreadContext.pop();</code></pre><p>使用Map: </p><pre><code>ThreadContext.put(&quot;id&quot;, UUID.randomUUID().toString()); // Add the fishtag;ThreadContext.put(&quot;ipAddress&quot;, request.getRemoteAddr());ThreadContext.put(&quot;loginId&quot;, session.getAttribute(&quot;loginId&quot;));ThreadContext.put(&quot;hostName&quot;, request.getServerName());.logger.debug(&quot;Message 1&quot;);..logger.debug(&quot;Message 2&quot;);..ThreadContext.clear();</code></pre><p>问题来了，如果我们使用Executor.execute(new CachedThreadPool())的话，因为线程的复用，（所有使用完的线程会归还到线程池当中），那么ThreadContext里面的东西必须要进行手动清除，才能防止原先记录的这个线程的东西被复用掉。比如一般会记录的[Client][API]此类信息。</p><p>这个时候需要使用getContext()和cloneStack()来使得子线程获得父线程的信息。</p><pre><code>ThreadContext.clearAll();ThreadContext.putAll(preSavedThreadContextMap);ThreadContext.setStack(preSavedThreadContextStack);</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-常用日志系统介绍&quot;&gt;&lt;a href=&quot;#1-常用日志系统介绍&quot; class=&quot;headerlink&quot; title=&quot;1. 常用日志系统介绍&quot;&gt;&lt;/a&gt;1. 常用日志系统介绍&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;日志门面&lt;ul&gt;
&lt;li&gt;jcl - jakarta com
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
      <category term="Log" scheme="https://www.llchen60.com/tags/Log/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识</title>
    <link href="https://www.llchen60.com/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://www.llchen60.com/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2020-02-06T03:05:08.000Z</published>
    <updated>2020-02-06T03:05:28.755Z</updated>
    
    <content type="html"><![CDATA[<p>给自己搭个脚手架，建个基础知识的小字典，查遗用(持续更新)：</p><h1 id="1-Java平台"><a href="#1-Java平台" class="headerlink" title="1.Java平台"></a>1.Java平台</h1><h2 id="1-1-Java解释执行？"><a href="#1-1-Java解释执行？" class="headerlink" title="1.1 Java解释执行？"></a>1.1 Java解释执行？</h2><p>Java源代码，通过javac编译成字节码，运行时通过JVM内嵌的解释器将字节码转换为机器码。但是大部分JVM都提供了JIT(just in time),即动态编译器，它能够在运行时将热点代码编成机器码，这种情况下热点代码就属于编译执行。</p><h2 id="1-2-Java类加载机制"><a href="#1-2-Java类加载机制" class="headerlink" title="1.2 Java类加载机制"></a>1.2 Java类加载机制</h2><p>类加载大致过程：加载-验证-链接-初始化</p><h2 id="1-3-Java反射机制"><a href="#1-3-Java反射机制" class="headerlink" title="1.3 Java反射机制"></a>1.3 Java反射机制</h2><h2 id="1-4-面向对象编程SOLID原则"><a href="#1-4-面向对象编程SOLID原则" class="headerlink" title="1.4 面向对象编程SOLID原则"></a>1.4 面向对象编程SOLID原则</h2><ol><li>Single Responsibility </li><li>Open for extension, close for modification </li><li>Liskov Substitution </li><li>Interface Segragation </li><li>Dependency Injection </li></ol><p>E.G</p><pre><code>public class VIPCenter {  void serviceVIP(T extend User user&gt;) {     if (user instanceof SlumDogVIP) {        // 穷 X VIP，活动抢的那种        // do somthing      } else if(user instanceof RealVIP) {        // do somthing      }      // ...  }</code></pre><p>增加其扩展性：</p><pre><code>public class VIPCenter {   private Map&lt;User.TYPE, ServiceProvider&gt; providers;   void serviceVIP(T extend User user） {      providers.get(user.getType()).service(user);   } } interface ServiceProvider{   void service(T extend User user) ; } class SlumDogVIPServiceProvider implements ServiceProvider{   void service(T extend User user){     // do somthing   } } class RealVIPServiceProvider implements ServiceProvider{   void service(T extend User user) {     // do something   } } </code></pre><p>在另一篇博文里，有对SOLID的详细描述，详情见<a href="https://www.llchen60.com/2018/11/12/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/">面向对象设计原则</a></p><h2 id="1-5-类加载过程"><a href="#1-5-类加载过程" class="headerlink" title="1.5 类加载过程"></a>1.5 类加载过程</h2><p>load-link-initialize</p><ul><li>load </li></ul><p>首先是加载阶段（Loading），它是 Java 将字节码数据从不同的数据源读取到 JVM 中，并映射为 JVM 认可的数据结构（Class 对象），这里的数据源可能是各种各样的形态，如 jar 文件、class 文件，甚至是网络数据源等；如果输入数据不是 ClassFile 的结构，则会抛出 ClassFormatError。</p><ul><li>link </li></ul><p>第二阶段是链接（Linking），这是核心的步骤，简单说是把原始的类定义信息平滑地转化入 JVM 运行的过程中。这里可进一步细分为三个步骤：</p><ol><li>验证， JVM需要验证字节信息是符合Java虚拟机规范的，否则会被认为是Verify Error</li><li>准备 创建类或接口中的静态变量，并初始化静态变量的初始值，侧重点在分配所需要的内存空间，不会去执行更进一步的JVM指令</li><li>解析。将常量池中的符号引用替换为直接引用。</li></ol><p>再来谈谈双亲委派模型，简单说就是当类加载器（Class-Loader）试图加载某个类型的时候，除非父加载器找不到相应类型，否则尽量将这个任务代理给当前加载器的父加载器去做。使用委派模型的目的是避免重复加载 Java 类型。</p><h1 id="2-Java语言特性"><a href="#2-Java语言特性" class="headerlink" title="2. Java语言特性"></a>2. Java语言特性</h1><h2 id="2-1-泛型"><a href="#2-1-泛型" class="headerlink" title="2.1 泛型"></a>2.1 泛型</h2><h2 id="2-2-Lambda"><a href="#2-2-Lambda" class="headerlink" title="2.2 Lambda"></a>2.2 Lambda</h2><h2 id="2-3-Exception-Error"><a href="#2-3-Exception-Error" class="headerlink" title="2.3 Exception/ Error"></a>2.3 Exception/ Error</h2><h3 id="2-3-1-定义"><a href="#2-3-1-定义" class="headerlink" title="2.3.1 定义"></a>2.3.1 定义</h3><blockquote><p>Exception: 程序正常运行中可以预料到的意外情况，可能并且应该被捕获，进行相应处理</p></blockquote><blockquote><p>Error: 在正常情况下，不应该出现的情况。绝大部分的Error都会导致程序比如JVM自身处于非正常的、不可恢复的状态</p></blockquote><p>Throwable分类图！！！！！</p><p>异常之所以很强大，在调试方面，在于其回答了以下三个问题：</p><ol><li>什么出了错？    异常类型</li><li>在哪出了错？    异常堆栈跟踪位置</li><li>为什么出错？    异常信息</li></ol><h3 id="2-3-2-Tips"><a href="#2-3-2-Tips" class="headerlink" title="2.3.2 Tips"></a>2.3.2 Tips</h3><ol><li>不捕获通用异常，写自己的Exception，方便Debug</li><li>不要生吞异常，不知道怎么处理了可以继续向外层抛出</li><li>提早抛出，延迟捕获！ </li><li>把异常处理的责任往调用链的上游传递的方法就是在方法的throws子句声明异常。<a href="https://www.zhihu.com/question/28254987" target="_blank" rel="noopener">(如何优雅的处理异常？)</a></li></ol><h3 id="2-3-3-性能角度分析"><a href="#2-3-3-性能角度分析" class="headerlink" title="2.3.3 性能角度分析"></a>2.3.3 性能角度分析</h3><ol><li>try-catch代码段会产生额外的性能开销，往往会影响JVM对代码进行优化，因此应该仅捕获有必要的代码，尽量不要使用一个大的try包住整段代码</li><li>Java每实例化一个Exception，都会对<strong>当时的栈进行快照</strong>，这是个比较重的操作。</li></ol><h2 id="2-4-引用"><a href="#2-4-引用" class="headerlink" title="2.4 引用"></a>2.4 引用</h2><p>Java中除了原始数据类型的变量其他所有都是引用类型，指向不同的对象。理解引用，以理解Java对象的生命周期和JVM内部的相关机制。</p><p>不同的引用类型，主要体现在对象的不同的可达性状态和对垃圾收集的影响。</p><h3 id="2-4-1-强引用"><a href="#2-4-1-强引用" class="headerlink" title="2.4.1 强引用"></a>2.4.1 强引用</h3><p>Strong Reference, 即普通对象引用。只要还有强引用指向一个对象，那么垃圾收集器就不会碰。</p><h3 id="2-4-2-弱引用"><a href="#2-4-2-弱引用" class="headerlink" title="2.4.2 弱引用"></a>2.4.2 弱引用</h3><p>不能使对象豁免垃圾收集，提供一种访问在弱引用装天下对象的途径</p><p>使用weak reference类来实现的</p><h3 id="2-4-3-软引用"><a href="#2-4-3-软引用" class="headerlink" title="2.4.3 软引用"></a>2.4.3 软引用</h3><p>Soft Reference. 相对强引用弱化一些的引用，可以让对象豁免一些垃圾收集，只有当JVM认为内存不足时，才会去试图回收软引用指向的对象。</p><p>使用soft reference类实现的</p><h3 id="2-4-4-幻象引用"><a href="#2-4-4-幻象引用" class="headerlink" title="2.4.4 幻象引用"></a>2.4.4 幻象引用</h3><p>虚引用，提供一种确保对象被finalize以后，做某些事情的机制。</p><p>通过PhantomReference类来实现的</p><h2 id="2-5-String-vs-StringBuffer-vs-StringBuilder"><a href="#2-5-String-vs-StringBuffer-vs-StringBuilder" class="headerlink" title="2.5 String vs. StringBuffer vs. StringBuilder"></a>2.5 String vs. StringBuffer vs. StringBuilder</h2><ul><li><p>字符串缓存，放在对重，后来放在metaSpace当中，可以通过JVM调参来修改大小</p><p>  -XX:+PrintStringTableStatistics<br>  -XX:StringTableSize=N</p></li><li><p>String 压缩</p></li></ul><p>从使用Char到使用Byte + 标志编码位。紧凑字符串带来了很大优势，更小的内存占用，更快的操作速度。</p><h3 id="2-5-1-String"><a href="#2-5-1-String" class="headerlink" title="2.5.1 String"></a>2.5.1 String</h3><p>Immutable类，声明为final class,所有属性也都是final的。</p><p>java引入了字符创常量池，创建一个字符串，首先看常量池里面有没有值相同的字符串，如果有直接到池里拿对应的对象引用，如果没有就创建新的，并放到池里去。</p><pre><code>String str1 = &quot;123&quot;;// 放入常量池String str2 = new String(&quot;123&quot;); // 不放入常量池</code></pre><h3 id="2-5-2-StringBuffer"><a href="#2-5-2-StringBuffer" class="headerlink" title="2.5.2 StringBuffer"></a>2.5.2 StringBuffer</h3><p>为了解决String拼接产生太多中间对象的问题，本质上是一个线程安全的可修改字符序列。保证了线程安全，但是也带来了额外的性能开销。</p><p>线程安全是通过在各种修改数据的方法上加<code>synchronized</code>关键字来实现的。</p><p>底层使用char/ byte数组，继承了AbstractStringBuilder</p><h3 id="2-5-3-StringBuilder"><a href="#2-5-3-StringBuilder" class="headerlink" title="2.5.3 StringBuilder"></a>2.5.3 StringBuilder</h3><p>与StringBuffer类似，去掉了线程安全的部分，有效减少了开销</p><p>底层使用char/ byte数组，继承了AbstractStringBuilder。</p><h2 id="2-6-Abstract-and-Interface"><a href="#2-6-Abstract-and-Interface" class="headerlink" title="2.6 Abstract and Interface"></a>2.6 Abstract and Interface</h2><h3 id="2-6-1-接口"><a href="#2-6-1-接口" class="headerlink" title="2.6.1 接口"></a>2.6.1 接口</h3><p>接口是对行为的抽象，是抽象方法的集合，利用接口可以达到API定义和实现分离的目的。接口不能实例化，不能包含任何非常量成员，任何field都是隐含着public static final的意义的。同时，没有非静态方法的实现。要么是静态方法，要么是抽象方法。</p><p>接口可以多继承！类只可以单继承</p><h3 id="2-6-2-抽象类"><a href="#2-6-2-抽象类" class="headerlink" title="2.6.2 抽象类"></a>2.6.2 抽象类</h3><p>不能实例化的类，用abstract关键字来修饰，其目的主要是代码重用。抽象类大多用于抽取相关Java类的公用方法实现或者是共同成员变量，然后通过继承达到代码复用的目的。Java标准库中，比如Collection框架，很多通用部分就抽象成了抽象类来使用。</p><h1 id="3-Java基础类库"><a href="#3-Java基础类库" class="headerlink" title="3. Java基础类库"></a>3. Java基础类库</h1><h2 id="3-1-集合"><a href="#3-1-集合" class="headerlink" title="3.1 集合"></a>3.1 集合</h2><h3 id="3-1-1-Vector-vs-ArrayList-vs-LinkedList"><a href="#3-1-1-Vector-vs-ArrayList-vs-LinkedList" class="headerlink" title="3.1.1 Vector vs. ArrayList vs.LinkedList"></a>3.1.1 Vector vs. ArrayList vs.LinkedList</h3><p>三者都是集合框架中的List，根据位置有定位，添加或者删除的操作。Vector是Java早期提供的线程安全的动态数组。ArrayList动态数组，不是线程安全的，ArrayList扩容时会增加50%。LinkedList双向链表，不是线程安全的。</p><p>Vector, arrayList作为动态数组，非常适合随机访问的场合，插入删除元素性能会比较差，因为要移动后续的所有元素。LinkedList进行节点插入，删除会很高效，但是随机访问性能很差。</p><h3 id="3-1-2-Hashtable-vs-HashMap-vs-TreeMap"><a href="#3-1-2-Hashtable-vs-HashMap-vs-TreeMap" class="headerlink" title="3.1.2 Hashtable vs. HashMap vs. TreeMap"></a>3.1.2 Hashtable vs. HashMap vs. TreeMap</h3><p>Hashtable是同步的，性能开销大</p><p>HashMap 非同步的，性能开销小，put，get操作能达到常数时间的性能</p><p>TreeMap是基于红黑树的一种提供顺序访问的Map，和Hashmap不同，它的get\put\remove之类的操作都是O(log(n))的时间复杂度。</p><h2 id="3-2-IO-NIO"><a href="#3-2-IO-NIO" class="headerlink" title="3.2 IO/NIO"></a>3.2 IO/NIO</h2><h3 id="3-2-1-IO"><a href="#3-2-1-IO" class="headerlink" title="3.2.1 IO"></a>3.2.1 IO</h3><p>java.io包，基于流模型实现，提供了我们最熟知的一些IO功能，比如File抽象、输入输出流等。交互方式是同步、阻塞的方式。也就是说，在读取输入流或者写入输出流时，在读写动作之前，线程会一直阻塞在那里，他们之间的调用是可靠的线性顺序。</p><h3 id="3-2-2-NIO"><a href="#3-2-2-NIO" class="headerlink" title="3.2.2 NIO"></a>3.2.2 NIO</h3><p>NIO框架，提供Channel, selector, Buffer等新的抽象，可以构建<strong>多路复用，同步非阻塞IO程序</strong>，同时提供了更接近操作系统底层的高性能数据操作方式。</p><ul><li>Channel </li><li>Buffer</li><li>Selector </li></ul><h2 id="3-3-网络"><a href="#3-3-网络" class="headerlink" title="3.3 网络"></a>3.3 网络</h2><h2 id="3-4-并发"><a href="#3-4-并发" class="headerlink" title="3.4 并发"></a>3.4 并发</h2><h3 id="3-4-1-synchronized"><a href="#3-4-1-synchronized" class="headerlink" title="3.4.1 synchronized"></a>3.4.1 synchronized</h3><ul><li>概念</li></ul><p>是java内部的同步机制，也称为intrinsic locking, 提供了互斥的语义和可见性，当一个线程已经获取当前锁时，其他试图获取的线程只能等待或者阻塞在那里了。</p><p>在 Java 5 以前，synchronized 是仅有的同步手段，在代码中， synchronized 可以用来修饰方法，也可以使用在特定的代码块儿上，本质上** synchronized 方法等同于把方法全部语句用 synchronized 块包起来**。</p><ul><li>底层实现</li></ul><p>synchronized代码块是由一对<code>monitorenter/ moniterexit</code>指令来实现的，Monitor对象是同步的基本实现单元。</p><p>在 Java 6 之前，Monitor 的实现完全是依靠操作系统内部的互斥锁，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作。现代的（Oracle）JDK 中，JVM 对此进行了大刀阔斧地改进，提供了三种不同的 Monitor 实现，也就是常说的三种不同的锁：偏斜锁（Biased Locking）、轻量级锁和重量级锁，大大改进了其性能。</p><p>所谓锁的升级、降级，就是 JVM 优化 synchronized 运行的机制，当 JVM 检测到不同的竞争状况时，会自动切换到适合的锁实现，这种切换就是锁的升级、降级。</p><p>没有竞争的时候，默认使用偏斜锁。JVM会利用CAS操作，在对象头上的Mark Word部分设置线程ID，以表示这个对象偏向于当前线程，所以并不涉及真正的互斥锁。如果有另外的线程试图锁定某个已经被偏斜过的对象，JVM就需要撤销偏斜锁，并切换到轻量锁的实现。</p><h3 id="3-4-2-ReeantrantLock"><a href="#3-4-2-ReeantrantLock" class="headerlink" title="3.4.2 ReeantrantLock"></a>3.4.2 ReeantrantLock</h3><ul><li>ReentrantLock 再入锁</li></ul><p>再入锁通过代码直接调用lock()方法来获取，是表示当一个线程试图获取一个它已经获取的锁时，这个获取动作就自动成功。这是多锁获取粒度上的一个区分，锁的持有是以线程为单位而不是基于调用次数了，java锁实现强调再入性是为了和pthread的行为进行区分。</p><p>再入锁可以设置公平性：</p><pre><code>ReentrantLock fairLock = new ReetrantLock(true);</code></pre><p>这里所谓的公平性是指在竞争场景中，当公平性为真时，会倾向于将锁赋予等待时间最久的线程。公平性是减少线程“饥饿”（个别线程长期等待锁，但始终无法获取）情况发生的一个办法。</p><p>使用synchronized我们无法进行公平性的选择，其永远是不公平的，这也是主流操作系统线程调度的选择。通用场景中，公平性未必有想象中的那么重要，Java 默认的调度策略很少会导致 “饥饿”发生。与此同时，若要保证公平性则会引入额外开销，自然会导致一定的吞吐量下降。</p><h3 id="3-4-3-死锁"><a href="#3-4-3-死锁" class="headerlink" title="3.4.3 死锁"></a>3.4.3 死锁</h3><h2 id="3-5-安全"><a href="#3-5-安全" class="headerlink" title="3.5 安全"></a>3.5 安全</h2><h1 id="4-JVM基础概念和机制"><a href="#4-JVM基础概念和机制" class="headerlink" title="4. JVM基础概念和机制"></a>4. JVM基础概念和机制</h1><h2 id="4-1-类加载机制"><a href="#4-1-类加载机制" class="headerlink" title="4.1 类加载机制"></a>4.1 类加载机制</h2><h2 id="4-2-常见的垃圾收集器"><a href="#4-2-常见的垃圾收集器" class="headerlink" title="4.2 常见的垃圾收集器"></a>4.2 常见的垃圾收集器</h2><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://www.zhihu.com/question/28254987" target="_blank" rel="noopener">如何优雅的处理异常？</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给自己搭个脚手架，建个基础知识的小字典，查遗用(持续更新)：&lt;/p&gt;
&lt;h1 id=&quot;1-Java平台&quot;&gt;&lt;a href=&quot;#1-Java平台&quot; class=&quot;headerlink&quot; title=&quot;1.Java平台&quot;&gt;&lt;/a&gt;1.Java平台&lt;/h1&gt;&lt;h2 id=&quot;1-1
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Javadoc tutorial</title>
    <link href="https://www.llchen60.com/Javadoc-tutorial/"/>
    <id>https://www.llchen60.com/Javadoc-tutorial/</id>
    <published>2020-02-06T03:04:12.000Z</published>
    <updated>2020-02-06T03:04:33.985Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-What-is-javadoc"><a href="#1-What-is-javadoc" class="headerlink" title="1. What is javadoc"></a>1. What is javadoc</h1><p>A tool comes with JDK and used for generating Java code documentation in <strong>HTML format from Java source code</strong>, which requires documentation in a predefined format </p><h1 id="2-Javadoc-tags"><a href="#2-Javadoc-tags" class="headerlink" title="2. Javadoc tags"></a>2. Javadoc tags</h1><ul><li>@author</li><li>{@code}<ul><li>Displays text in code font without interpreting the text as HTML markup or nested javadoc tags.</li></ul></li><li>{@docRoot}<ul><li>Represents the relative path to the generated document’s root directory from any generated page.</li></ul></li><li>@deprecated</li><li>@exception<ul><li>Adds a Throws subheading to the generated documentation, with the classname and description text.</li></ul></li><li>{@inheritDoc}<ul><li>Inherits a comment from the nearest inheritable class or implementable interface.</li></ul></li><li>{@link}<ul><li>Inserts an in-line link with the visible text label that points to the documentation for the specified package, class, or member name of a referenced class. </li></ul></li><li>@param</li><li>@return</li><li>@see</li><li>@serial</li><li>@serialData <ul><li>Documents the data written by the writeObject( ) or writeExternal( ) methods.</li></ul></li><li>@serialField<ul><li>Documents an ObjectStreamField component.</li></ul></li><li>@since <ul><li>Adds a since heading with the specified since text to the generated documentation</li></ul></li><li>@throws </li><li>{@value}<ul><li>When {@value} is used in the doc comment of a static field, it displays the value of that constant. </li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-What-is-javadoc&quot;&gt;&lt;a href=&quot;#1-What-is-javadoc&quot; class=&quot;headerlink&quot; title=&quot;1. What is javadoc&quot;&gt;&lt;/a&gt;1. What is javadoc&lt;/h1&gt;&lt;p&gt;A tool c
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java 继承与组合</title>
    <link href="https://www.llchen60.com/Java-%E7%BB%A7%E6%89%BF%E4%B8%8E%E7%BB%84%E5%90%88/"/>
    <id>https://www.llchen60.com/Java-%E7%BB%A7%E6%89%BF%E4%B8%8E%E7%BB%84%E5%90%88/</id>
    <published>2020-02-06T03:03:28.000Z</published>
    <updated>2020-02-06T03:03:53.281Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-什么是组合？"><a href="#1-什么是组合？" class="headerlink" title="1. 什么是组合？"></a>1. 什么是组合？</h1><p>组合将类定义为各个部分的集合</p><pre><code>public class MerchantListHelper {    // TODO     void addToDDB (ListEntry entry) {    }    void removeFromDDB(DDBRecord record) {    }    List&lt;ListEntry&gt; getFromDDB() {    }}public class MerchantBlacklistBizLogic {    private MerchantListHelper merchantListHelper;    merchantListHelper.addToDDB(blabla..);    merchantListHelper.removeFromDDB(blabla..)}</code></pre><h1 id="2-什么是继承？"><a href="#2-什么是继承？" class="headerlink" title="2. 什么是继承？"></a>2. 什么是继承？</h1><p>将父类和子类通过集成关系紧密联系在一起 （紧耦合）。但与之相对的是继承会允许再利用类的方法以及其他的属性，会很便捷。</p><p>使用super()方法来直接访问父类的方法，构造器，属性等。</p><pre><code>public Abstract class MerchantListHelper {    // TODO     abstract void addToDDB (ListEntry entry);    abstract void removeFromDDB(DDBRecord record);    abstract List&lt;ListEntry&gt; getFromDDB();}public class MerchantBlacklistBizLogic {    private MerchantListHelper merchantListHelper;    @Override    void addToDDB(ListEntry entry) {        // TODO    }    @Override    void removeFromDDB(DDBRecord record) {        // TODO    }    ...}</code></pre><h1 id="3-Use-cases"><a href="#3-Use-cases" class="headerlink" title="3. Use cases"></a>3. Use cases</h1><p>组合和继承都可以将子对象放到新的类当中，组合一般是当你想要在这个新类当中使用一个已经存在的类的特征的时候。这意味着，通过这种方式你可以嵌入一个对象，并将其放在新的类当中。 继承表示的是一种is-a的关系，组合表达的含有某种功能。</p><p>如何判断是否需要继承或者组合 -&gt; 看是否需要从你的新类到基本类进行向上转型。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="http://thedeanbear.com/2012/09/24/composition_vs_inheritance/" target="_blank" rel="noopener">http://thedeanbear.com/2012/09/24/composition_vs_inheritance/</a></li><li>Java Challengers #7: Debugging Java inheritance </li><li>javaworld.com/article/3409071/java-challenger-7-debugging-java-inheritance.html</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-什么是组合？&quot;&gt;&lt;a href=&quot;#1-什么是组合？&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是组合？&quot;&gt;&lt;/a&gt;1. 什么是组合？&lt;/h1&gt;&lt;p&gt;组合将类定义为各个部分的集合&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class M
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
      <category term="Composition" scheme="https://www.llchen60.com/tags/Composition/"/>
    
  </entry>
  
  <entry>
    <title>Java 反射机制</title>
    <link href="https://www.llchen60.com/Java-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
    <id>https://www.llchen60.com/Java-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</id>
    <published>2020-02-06T03:02:35.000Z</published>
    <updated>2020-02-06T03:02:58.113Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h1><p>Java反射机制是在运行时用来判定或者修改方法，类，接口的行为的API。</p><ul><li><p>反射可以告诉我们类和对象之间的信息，以及我们可以用类的哪些方法来使用这个对象</p></li><li><p>通过反射，我们就可以在运行的时候赋予类一个新的对象</p></li></ul><h1 id="2-使用范例"><a href="#2-使用范例" class="headerlink" title="2. 使用范例"></a>2. 使用范例</h1><p>反射可以用来获取关于类，构造器和方法的信息：</p><ul><li><p>class: getClass()方法可以用来获取对象属于的类的名字</p></li><li><p>Constructors: getConstructor()可以用来获取对象属于的类的public的构造器</p></li><li><p>getMethods() 可以用来获取对象属于的类的public的方法</p><p>  // A simple Java program to demonstrate the use of reflection<br>  import java.lang.reflect.Method;<br>  import java.lang.reflect.Field;<br>  import java.lang.reflect.Constructor; </p><p>  // class whose object is to be created<br>  class Test<br>  { </p><pre><code>  // creating a private field   private String s;   // creating a public constructor   public Test() { s = &quot;GeeksforGeeks&quot;; }   // Creating a public method with no arguments   public void method1() {       System.out.println(&quot;The string is &quot; + s);   }   // Creating a public method with int as argument   public void method2(int n) {       System.out.println(&quot;The number is &quot; + n);   }   // creating a private method   private void method3() {       System.out.println(&quot;Private method invoked&quot;);   } </code></pre><p>  } </p><p>  class Demo<br>  { </p><pre><code>  public static void main(String args[]) throws Exception   {       // Creating object whose property is to be checked       Test obj = new Test();           // 构建类的对象      // getclass method       Class cls = obj.getClass();       System.out.println(&quot;The name of class is &quot; +                           cls.getName());       // Getting the constructor of the class through the       // object of the class       Constructor constructor = cls.getConstructor();       System.out.println(&quot;The name of constructor is &quot; +                           constructor.getName());       System.out.println(&quot;The public methods of class are : &quot;);       // Getting methods of the class through the object       // of the class by using getMethods       Method[] methods = cls.getMethods();       // Printing method names       for (Method method:methods)           System.out.println(method.getName());       // creates object of desired method by providing the       // method name and parameter class as arguments to       // the getDeclaredMethod        // 这里是通过方法的名字和输入变量来获取对应的方法      Method methodcall1 = cls.getDeclaredMethod(&quot;method2&quot;,                                               int.class);       // invokes the method at runtime       // 这里是在运行时执行这个方法       methodcall1.invoke(obj, 19);       // creates object of the desired field by providing       // the name of field as argument to the       // getDeclaredField method       // 运行时获取对应的private的变量      Field field = cls.getDeclaredField(&quot;s&quot;);       // allows the object to access the field irrespective       // of the access specifier used with the field       // 将这个变量设成可以获取的      field.setAccessible(true);       // takes object and the new value to be assigned       // to the field as arguments       field.set(obj, &quot;JAVA&quot;);       // Creates object of desired method by providing the       // method name as argument to the getDeclaredMethod       Method methodcall2 = cls.getDeclaredMethod(&quot;method1&quot;);       // invokes the method at runtime       methodcall2.invoke(obj);       // Creates object of the desired method by providing       // the name of method as argument to the       // getDeclaredMethod method       Method methodcall3 = cls.getDeclaredMethod(&quot;method3&quot;);       // allows the object to access the method irrespective       // of the access specifier used with the method       methodcall3.setAccessible(true);       // invokes the method at runtime       methodcall3.invoke(obj);   } </code></pre><p>  } </p></li></ul><h1 id="3-详细分析"><a href="#3-详细分析" class="headerlink" title="3. 详细分析"></a>3. 详细分析</h1><p>反射一言以蔽之，即在运行时拿到class，并创建类对应的对象的方式。这种好处是更具灵活性，劣势是会慢很多，代码会相对难理解些。</p><p>从代码本身的角度来讲，是指一部分代码有能力去观察/检查另一部分代码。用已知的部分合理推断出未知的部分，这未知的部分其实是指还不知道的信息。</p><p>一般来说在Java里我们都是和注解一起来使用反射的，</p><h1 id="4-优劣势"><a href="#4-优劣势" class="headerlink" title="4. 优劣势"></a>4. 优劣势</h1><ul><li>好处<ul><li>反射是什么呢？当我们的程序在运行时，需要动态的加载一些类这些类可能之前用不到所以不用加载到jvm，而是在运行时根据需要才加载，这样的好处对于服务器来说不言而喻，举个例子我们的项目底层有时是用mysql，有时用oracle，<strong>需要动态地根据实际情况加载驱动类，这个时候反射就有用了</strong>，假设 <code>com.java.dbtest.myqlConnection</code>，<code>com.java.dbtest.oracleConnection</code>这两个类我们要用，这时候我们的程序就写得比较动态化，通过<code>Class tc = Class.forName(&quot;com.java.dbtest.TestConnection&quot;);</code>通过类的全类名让jvm在服务器中找到并加载这个类，而如果是oracle则传入的参数就变成另一个了。这时候就可以看到反射的好处了，这个动态性就体现出java的特性了！</li><li>更具拓展性，可以在运行时获取信息</li><li>获取一些private的域的值方便debug</li></ul></li><li>劣势<ul><li>更慢，有延时</li><li>会暴露一些接口</li><li>反射会要求运行的许可，当在secure manager下来运行可能不被允许</li></ul></li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://stackoverflow.com/questions/37628/what-is-reflection-and-why-is-it-useful" target="_blank" rel="noopener">https://stackoverflow.com/questions/37628/what-is-reflection-and-why-is-it-useful</a></li><li><a href="https://docs.oracle.com/javase/tutorial/reflect/index.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/tutorial/reflect/index.html</a></li><li><a href="https://docs.oracle.com/javase/tutorial/reflect/class/index.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/tutorial/reflect/class/index.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-介绍&quot;&gt;&lt;a href=&quot;#1-介绍&quot; class=&quot;headerlink&quot; title=&quot;1. 介绍&quot;&gt;&lt;/a&gt;1. 介绍&lt;/h1&gt;&lt;p&gt;Java反射机制是在运行时用来判定或者修改方法，类，接口的行为的API。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;反射可以告诉我
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
      <category term="Reflection" scheme="https://www.llchen60.com/tags/Reflection/"/>
    
  </entry>
  
  <entry>
    <title>java - serialization</title>
    <link href="https://www.llchen60.com/java-serialization/"/>
    <id>https://www.llchen60.com/java-serialization/</id>
    <published>2020-02-06T03:01:26.000Z</published>
    <updated>2020-02-06T03:01:43.795Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a>1. Overview</h1><p>An object is eligible for serialization if and only if its class implements the <strong>java.io.Serializable</strong> interface. Serializable is a marker interface (contains no methods) that tell the Java Virtual Machine (JVM) that the objects of this class is ready for being written to and read from a persistent storage or over the network.</p><h1 id="2-Why-we-need-serialization"><a href="#2-Why-we-need-serialization" class="headerlink" title="2. Why we need serialization?"></a>2. Why we need serialization?</h1><p>It’s used when the need arises to send data/ object over network or stored in files.</p><p>The thing is network and hard disk are hardware component that understand bits and bytes but not Java Objects. </p><p>Serialization is the translation of your Java object’s values/states to bytes to send it over network or save it.</p><p>Also used to store into database. </p><h1 id="3-Implementation"><a href="#3-Implementation" class="headerlink" title="3. Implementation"></a>3. Implementation</h1><p>Ways for serialize/ deserialize  – xml JSON </p><p>Serialization process is instance independent. </p><ul><li>ObjectInputStream <ul><li>extends java.io.InputStream </li></ul></li></ul><pre><code>public final Object readObject() throws IOException, ClassNotFoundException;</code></pre><ul><li>ObjectOutputStream <ul><li>extends java.io.OutputStream</li></ul></li></ul><pre><code>public final void writeObject(Object o) throws IOException;</code></pre><h2 id="3-1-Example"><a href="#3-1-Example" class="headerlink" title="3.1 Example"></a>3.1 Example</h2><pre><code>public class Person implements Serializable {    private static final long serialVersionUID = 1L;    static String country = &quot;ITALY&quot;;    private int age;    private String name;    transient int height;    // getters and setters}@Testpublic void whenSerializingAndDeserializing_ThenObjectIsTheSame() ()   throws IOException, ClassNotFoundException {     Person person = new Person();    person.setAge(20);    person.setName(&quot;Joe&quot;);    FileOutputStream fileOutputStream      = new FileOutputStream(&quot;yourfile.txt&quot;);    ObjectOutputStream objectOutputStream       = new ObjectOutputStream(fileOutputStream);    objectOutputStream.writeObject(person);    objectOutputStream.flush();    objectOutputStream.close();    FileInputStream fileInputStream      = new FileInputStream(&quot;yourfile.txt&quot;);    ObjectInputStream objectInputStream      = new ObjectInputStream(fileInputStream);    Person p2 = (Person) objectInputStream.readObject();    objectInputStream.close();     assertTrue(p2.getAge() == p.getAge());    assertTrue(p2.getName().equals(p.getName()));}</code></pre><h1 id="4-Caveats"><a href="#4-Caveats" class="headerlink" title="4. Caveats"></a>4. Caveats</h1><ol><li>When a class implements the java.io.Serializable interface, all <strong>its sub-classes are serializable as well</strong>.</li><li>when an object has a reference to another object, these objects must implement the Serializable interface separately, or else a NotSerializableException will be thrown</li><li>JVM associates a version number with each serializable class. </li></ol><p>Reference</p><ol><li><a href="https://www.codejava.net/java-se/file-io/why-do-we-need-serialization-in-java" target="_blank" rel="noopener">https://www.codejava.net/java-se/file-io/why-do-we-need-serialization-in-java</a></li><li><a href="https://www.baeldung.com/java-serialization" target="_blank" rel="noopener">https://www.baeldung.com/java-serialization</a></li><li><a href="https://www.geeksforgeeks.org/serialization-in-java/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/serialization-in-java/</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Overview&quot;&gt;&lt;a href=&quot;#1-Overview&quot; class=&quot;headerlink&quot; title=&quot;1. Overview&quot;&gt;&lt;/a&gt;1. Overview&lt;/h1&gt;&lt;p&gt;An object is eligible for serializat
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java Pattern Regex表达式</title>
    <link href="https://www.llchen60.com/Java-Pattern-Regex%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://www.llchen60.com/Java-Pattern-Regex%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2020-02-06T03:00:32.000Z</published>
    <updated>2020-02-06T03:00:54.343Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-为什么要使用Pattern？"><a href="#1-为什么要使用Pattern？" class="headerlink" title="1. 为什么要使用Pattern？"></a>1. 为什么要使用Pattern？</h1><p>一般来说如果我们要对String做某个范式下的替换时，我们需要使用</p><pre><code>stringEG.replaceAll(&quot;(?i)@gmail\\.com$&quot;, &quot;&quot;);</code></pre><p>上面这行代码是将stringEG最后的@gmail.com给替换掉，通过这种方式来获得用户名。</p><p>这种Replace操作我们会经常使用，但是上述有一个问题，即每次运行都要执行一遍Regex操作，这样很费时间，每次都要进行编译，Pattern可以帮助我们解决这个问题。</p><p>通过设置static的变量，我们可以将Compile完的结果存起来，然后在需要的时候直接使用这个结果即可。</p><p>使用方法如下所示:</p><pre><code>private static final Pattern USER_NAME_PATTERN = Pattern.compile(&quot;(?i)@gmail\\.com$);final String username =  USER_NAME_PATTERN.matcher(stringEG.replace(&quot;&quot;));</code></pre><h1 id="2-如何使用Pattern？"><a href="#2-如何使用Pattern？" class="headerlink" title="2. 如何使用Pattern？"></a>2. 如何使用Pattern？</h1><p>使用Java Pattern，重点在于对于正则表达式的使用，可以看一下文章 - <a href="https://llchen60.com/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" target="_blank" rel="noopener">正则表达式</a>, 里面有对正则的详细介绍。</p><p>Pattern对象是一个已经编译过的正则表达式的表达，Pattern类没有public的构造器，想要创建一个Pattern，我们需要首先调用其静态的compile()方法，通过这个方法会得到一个Pattern对象。</p><p>Matcher 对象用来解释正则表达式然后根据表达式来找符合规则的相关表达，同样没有public的构造器，通过调用matcher() 方法来作比较</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-为什么要使用Pattern？&quot;&gt;&lt;a href=&quot;#1-为什么要使用Pattern？&quot; class=&quot;headerlink&quot; title=&quot;1. 为什么要使用Pattern？&quot;&gt;&lt;/a&gt;1. 为什么要使用Pattern？&lt;/h1&gt;&lt;p&gt;一般来说如果我们要对St
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
      <category term="Regex" scheme="https://www.llchen60.com/tags/Regex/"/>
    
  </entry>
  
  <entry>
    <title>Java map() 与 flatMap()的比较</title>
    <link href="https://www.llchen60.com/Java-map-%E4%B8%8E-flatMap-%E7%9A%84%E6%AF%94%E8%BE%83/"/>
    <id>https://www.llchen60.com/Java-map-%E4%B8%8E-flatMap-%E7%9A%84%E6%AF%94%E8%BE%83/</id>
    <published>2020-02-06T02:59:48.000Z</published>
    <updated>2020-02-06T03:00:06.496Z</updated>
    
    <content type="html"><![CDATA[<p><code>map()</code>和<code>flatMap()</code>方法都来自于functional languages. 在Java8当中，我们可以在Optional, Stream还有CompletableFuture当中找到他们。</p><p>Stream代表一些列的对象，而Optional代表一个存在或者空的值。<code>map()</code>和<code>flatmap()</code>都是聚合方法，尽管其有着相同的返回类型，但是实际上他们有很多的不同。下面我们通过例子来逐一展现。</p><h1 id="1-在Optionals当中"><a href="#1-在Optionals当中" class="headerlink" title="1. 在Optionals当中"></a>1. 在Optionals当中</h1><pre><code>// map()Optional&lt;String&gt; s = Optional.of(&quot;Test&quot;);assertEquals(Optional.of(&quot;TEST&quot;), s.map(String::toUpperCase));// 如果情况更为复杂，变成Optional&lt;Optional&lt;String&gt;&gt;assertEquals(Optional.of(Optional.of(&quot;STRING&quot;)),     Optional.of(&quot;string&quot;).map(s -&gt; Optional.of(&quot;STRING&quot;)));// 同样的代码用flatmap来表示assertEquals(Optional.of(&quot;STRING&quot;), Optional.of(&quot;string&quot;).flatMap(s -&gt; Optional.of(&quot;STRING&quot;)));</code></pre><h1 id="2-在Streams当中"><a href="#2-在Streams当中" class="headerlink" title="2. 在Streams当中"></a>2. 在Streams当中</h1><p>map方法只能做一层的序列化，但是flatmap可以做多层的，来解决Stream&lt;Stream<R>&gt;的这种结构的问题。</p><pre><code>// 对于这种多层架构的, map()方法就显得力有未逮了List&lt;List&lt;String&gt;&gt; list = Arrays.asList(  Arrays.asList(&quot;a&quot;),  Arrays.asList(&quot;b&quot;));System.out.println(list);// flatmap可以很好的解决System.out.println(list.stream().flatMap(Collection::stream).collect(Collectors.toList()));</code></pre><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://www.baeldung.com/java-difference-map-and-flatmap" target="_blank" rel="noopener">https://www.baeldung.com/java-difference-map-and-flatmap</a></li><li><a href="https://www.mkyong.com/java8/java-8-flatmap-example/" target="_blank" rel="noopener">https://www.mkyong.com/java8/java-8-flatmap-example/</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;map()&lt;/code&gt;和&lt;code&gt;flatMap()&lt;/code&gt;方法都来自于functional languages. 在Java8当中，我们可以在Optional, Stream还有CompletableFuture当中找到他们。&lt;/p&gt;
&lt;p&gt;Stre
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
      <category term="Map" scheme="https://www.llchen60.com/tags/Map/"/>
    
  </entry>
  
  <entry>
    <title>Java - ExecutorService</title>
    <link href="https://www.llchen60.com/Java-ExecutorService/"/>
    <id>https://www.llchen60.com/Java-ExecutorService/</id>
    <published>2020-02-06T02:58:50.000Z</published>
    <updated>2020-02-06T02:59:23.181Z</updated>
    
    <content type="html"><![CDATA[<p>ExecutorService is a framework provided by the JDK which simplifies the execution of tasks in <strong><em>asynchronous</em></strong> mode. ExecutorService automatically provides a pool of threads and API for assigning tasks to it. </p><h1 id="1-Instantiation"><a href="#1-Instantiation" class="headerlink" title="1. Instantiation"></a>1. Instantiation</h1><h2 id="1-1-Factory-methods-of-Executors-class"><a href="#1-1-Factory-methods-of-Executors-class" class="headerlink" title="1.1 Factory methods of Executors class"></a>1.1 Factory methods of Executors class</h2><p>Use its factory methods of the Executors class to create ExecutorService. </p><pre><code>ExecutorService executor = Executors.newFixedThreadPool(10);</code></pre><h2 id="1-2-Directly-create"><a href="#1-2-Directly-create" class="headerlink" title="1.2 Directly create"></a>1.2 Directly create</h2><pre><code>ExecutorService executorService =   new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS,     new LinkedBlockingQueue&lt;Runnable&gt;());</code></pre><h1 id="2-Assigning-Tasks"><a href="#2-Assigning-Tasks" class="headerlink" title="2. Assigning Tasks"></a>2. Assigning Tasks</h1><p>ExecutorService can execute Runnable and Callable tasks. </p><pre><code>Runnable runnableTask = () -&gt; {    try {        TimeUnit.MILLISECONDS.sleep(300);    } catch (InterruptedException e) {        e.printStackTrace();    }};Callable&lt;String&gt; callableTask = () -&gt; {    TimeUnit.MILLISECONDS.sleep(300);    return &quot;Task&#39;s execution&quot;;};List&lt;Callable&lt;String&gt;&gt; callableTasks = new ArrayList&lt;&gt;();callableTasks.add(callableTask);callableTasks.add(callableTask);callableTasks.add(callableTask);</code></pre><h2 id="2-1-execute"><a href="#2-1-execute" class="headerlink" title="2.1 execute()"></a>2.1 execute()</h2><p>The execute() method is void, and it doesn’t give any possibility to get the result of task’s execution or to check the task’s status (is it running or executed).</p><pre><code>executerService.execute(runnableTask);</code></pre><h2 id="2-2-submit"><a href="#2-2-submit" class="headerlink" title="2.2 submit()"></a>2.2 submit()</h2><p>submit() submits a Callable or a Runnable task to an ExecutorService and returns a result of type Future.</p><pre><code>Future&lt;String&gt; future = executorService.submit(callableTask);</code></pre><h2 id="2-3-invokeAny"><a href="#2-3-invokeAny" class="headerlink" title="2.3 invokeAny()"></a>2.3 invokeAny()</h2><p>invokeAny() assigns a collection of tasks to an ExecutorService, causing each to be executed, and returns the result of a successful execution of one task (if there was a successful execution).</p><pre><code>String result = executorService.invokeAny(callableTasks);</code></pre><h2 id="2-4-invokeAll"><a href="#2-4-invokeAll" class="headerlink" title="2.4 invokeAll()"></a>2.4 invokeAll()</h2><p>invokeAll() assigns a collection of tasks to an ExecutorService, causing each to be executed, and returns the result of all task executions in the form of a list of objects of type Future.</p><pre><code>List&lt;Future&lt;String&gt;&gt; futures = executorService.invokeAll(callableTasks);</code></pre><h1 id="3-Shutdown"><a href="#3-Shutdown" class="headerlink" title="3. Shutdown"></a>3. Shutdown</h1><p>In general, the ExecutorService will not be automatically destroyed when there is not task to process. It will stay alive and wait for new work to do.</p><p>In some cases this is very helpful; for example, if an app needs to process tasks which appear on an irregular basis or the quantity of these tasks is not known at compile time.</p><p>On the other hand, an app could reach its end, but it will not be stopped because a waiting ExecutorService will cause the JVM to keep running.</p><h2 id="3-1-shutdown"><a href="#3-1-shutdown" class="headerlink" title="3.1 shutdown()"></a>3.1 shutdown()</h2><p>The shutdown() method doesn’t cause an immediate destruction of the ExecutorService. It will make the ExecutorService stop accepting new tasks and shut down after all running threads finish their current work.</p><pre><code>executorService.shutdown();</code></pre><h2 id="3-2-shutdownNow"><a href="#3-2-shutdownNow" class="headerlink" title="3.2 shutdownNow()"></a>3.2 shutdownNow()</h2><p>The shutdownNow() method tries to destroy the ExecutorService immediately, but it doesn’t guarantee that all the running threads will be stopped at the same time. This method returns a list of tasks which are waiting to be processed. It is up to the developer to decide what to do with these tasks.</p><pre><code>List&lt;Runnable&gt; notExecutedTasks = executorService.shutDownNow();</code></pre><h2 id="3-3-best-behavior"><a href="#3-3-best-behavior" class="headerlink" title="3.3 best behavior"></a>3.3 best behavior</h2><pre><code>executorService.shutdown();try {    if (!executorService.awaitTermination(800, TimeUnit.MILLISECONDS)) {        executorService.shutdownNow();    } } catch (InterruptedException e) {    executorService.shutdownNow();}</code></pre><h1 id="4-Future-interface"><a href="#4-Future-interface" class="headerlink" title="4. Future interface"></a>4. Future interface</h1><p>Future interface provides a <code>get()</code> which returns an actual result of the Callable task’s execution or null in the case of Runnable task. Calling the get() method while the task is still running will cause execution to block until the task is properly executed and the result is available.</p><pre><code>Future&lt;String&gt; future = executorService.submit(callableTask);String result = null;try {    result = future.get();} catch (InterruptedException | ExecutionException e) {    e.printStackTrace();}</code></pre><p>With very long blocking caused by the get() method, an application’s performance can degrade. If the resulting data is not crucial, it is possible to avoid such a problem by using timeouts:</p><pre><code>String result = future.get(200, TimeUnit.MILLISECONDS);</code></pre><p>some other methods provided:</p><pre><code>cancel()isCancelled()isDone() </code></pre><h1 id="5-How-to-sync-the-value-across-different-threads"><a href="#5-How-to-sync-the-value-across-different-threads" class="headerlink" title="5. How to sync the value across different threads?"></a>5. How to sync the value across different threads?</h1><p>Suppose we have i++ in several threads, and they all perform such operations. To make the i computed properly, we need to make it atomic. </p><p>Use <code>AtomicInteger</code> or <code>synchronized</code> to get the final correct result. </p><p>Notice, <code>volatile</code> cannot make sure the final result is correct. It mainly makes sure the visibility of newest value, but there is possibility that we mound and switch to other thread before the new value being recorded. </p><p>AtomicInteger class uses CAS(Compare and swap) low level CPU operations. They allow you to modify a particular variable only if the present value is equal to something else (and is returned successfully).</p><h1 id="6-Executor-execute-and-ExecutorService-submit-differences"><a href="#6-Executor-execute-and-ExecutorService-submit-differences" class="headerlink" title="6. Executor.execute() and ExecutorService.submit() differences"></a>6. Executor.execute() and ExecutorService.submit() differences</h1><ol><li>execute(Runnable) does not return anything; while submit(Callable<T>) returns a Future object which allows a way to programatically cancel the running thread and get the return result. </li><li>submit() can accept both Runnable and Callable task but execute() can only accept the Runnable task</li><li>submit() return a Future object while execute() has no return</li><li>get() is a blocking call, which will take some time</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ExecutorService is a framework provided by the JDK which simplifies the execution of tasks in &lt;strong&gt;&lt;em&gt;asynchronous&lt;/em&gt;&lt;/strong&gt; mode
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
      <category term="Executor Service" scheme="https://www.llchen60.com/tags/Executor-Service/"/>
    
  </entry>
  
  <entry>
    <title>Java - callback</title>
    <link href="https://www.llchen60.com/Java-callback/"/>
    <id>https://www.llchen60.com/Java-callback/</id>
    <published>2020-02-06T02:57:58.000Z</published>
    <updated>2020-02-06T02:58:23.254Z</updated>
    
    <content type="html"><![CDATA[<p>In C/ C++, callback refers to the mechanism of calling a function from another function. Memory address of a function is represented as function pointer here. SO the callback is achieved by passing the pointer of func1() to func2().</p><p>However, in java, there is no function pointer existing. And we use a callback object or a callback interface, and the interface is passed that refers to the location of a function. </p><p>Below is an example to compute tax by state tax and fedaral tax. Suppose federal tax keeps same while state tax vary by state. We can build interface and implements interface to realize it.<br>    // Java program to demonstrate callback mechanism<br>    // using interface is Java </p><pre><code>// Create interface import java.util.Scanner; interface STax {     double stateTax(); } // Implementation class of Punjab state tax class Punjab implements STax {     public double stateTax()     {         return 3000.0;     } } // Implementation class of Himachal Pardesh state tax class HP implements STax {     public double stateTax()     {         return 1000.0;     } } class TAX {     public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException     {         Scanner sc = new Scanner(System.in);         System.out.println(&quot;Enter the state name&quot;);         String state = sc.next(); // name of the state         // The state name is then stored in an object c         Class c = Class.forName(state);         // Create the new object of the class whose name is in c         // Stax interface reference is now referencing that new object         STax ref = (STax)c.newInstance();         /*Call the method to calculate total tax         and pass interface reference - this is callback .         Here, ref may refer to stateTax() of Punjab or HP classes         depending on the class for which the object is created         in the previous step         */        calculateTax(ref);     }     static void calculateTax(STax t)     {         // calculate central tax         double ct = 2000.0;         // calculate state tax         double st = t.stateTax();         double totaltax = st + ct;         // display total tax         System.out.println(&quot;Total tax =&quot; + totaltax);     } } </code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;In C/ C++, callback refers to the mechanism of calling a function from another function. Memory address of a function is represented as f
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Callback" scheme="https://www.llchen60.com/tags/Callback/"/>
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java Annotations 注解详解</title>
    <link href="https://www.llchen60.com/Java-Annotations-%E6%B3%A8%E8%A7%A3%E8%AF%A6%E8%A7%A3/"/>
    <id>https://www.llchen60.com/Java-Annotations-%E6%B3%A8%E8%A7%A3%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-02-06T02:57:11.000Z</published>
    <updated>2020-02-06T02:57:33.469Z</updated>
    
    <content type="html"><![CDATA[<p>Java annotation很有用，这篇博客会带着大家去理解Annotation的语法以及用法，希望能有所裨益。</p><h1 id="1-Annotation架构"><a href="#1-Annotation架构" class="headerlink" title="1. Annotation架构"></a>1. Annotation架构</h1><h2 id="1-0-Annotation的介绍"><a href="#1-0-Annotation的介绍" class="headerlink" title="1.0 Annotation的介绍"></a>1.0 Annotation的介绍</h2><p>用一句话来解释Annotation的话，我想可以称其为Metadata(元数据) - 即数据的数据。</p><p>举个例子，比如这里我使用了@Override：</p><pre><code>@Overridepublic String toString() {return &quot;This is String Representation of current object.&quot;;}</code></pre><p>通过注解的方式，我告诉编译器我重写了这个toString()的方法。但其实就算我没有加这个注解，代码仍然是可以有效运行的，那么用注解的好处有哪些呢？为什么我们需要使用注解呢？？？ </p><p>上述的注解告诉编译器我重写了父类里面的一个方法，然后编译器会去父类检查看这个方法是否存在，如果不存在的话，那就会扔出一个编译错误。通过这种方式我们可以减少错误的发生，并且提高整个代码的可读性，给我们带来一些便利。</p><p>其实就像上面说的那样，注解是一种携带元数据的方式，我们实际上在注解之前是用XML来做元数据的存储的。二者各有自己的适用场景。对于XML来说，如果你写的应用有大量的常数，参量，用XML会更好，因为我们可以将这些常量和代码完全解耦，这样在改变常量值的时候会方便很多。如果你想对外暴露一些方法来做服务，那注解会是更好的选择。因为这种情形下元数据最好和方法紧密相连，让开发者意识到这个方法的一些特征。</p><p>另外注解提供了一个标准的在代码中定义元数据的方式，在注解之前工程师常会自己定义，比如注释，接口，等等。注解将这个过程做了标准化。</p><h2 id="1-1-Annotation-组成部分"><a href="#1-1-Annotation-组成部分" class="headerlink" title="1.1 Annotation 组成部分"></a>1.1 Annotation 组成部分</h2><p><img src="fig1.jpg" alt="fig1.jpg"></p><ul><li>Annotation<ul><li>1 RetentionPolicy 每一个注解对象都会有唯一的RetentionPolicy属性</li><li>1 - n ElementType  每个注解对象都可以有若干个ElementType属性</li><li>Annotation有多个实现类，包括<ul><li>Deprecated </li><li>Documented</li><li>Inherited </li><li>Override </li><li>Retention </li><li>Target </li></ul></li></ul></li></ul><p>第一个很重要的观念，就是<strong><em>注解只是元数据，它不包括任何真正的代码逻辑</em></strong>。</p><p>第二个很重要的观念，建立在第一个的基础之上，即如果注解不包括代码逻辑，那么就一定有针对注解的消费者，来读取注解提供的信息，并且执行对应的代码逻辑。</p><p>比如以@override为例，这里JVM就是这个注解的消费者，并且在字节码的水平利用注解信息。</p><h3 id="1-1-1-Annotation-java"><a href="#1-1-1-Annotation-java" class="headerlink" title="1.1.1 Annotation.java"></a>1.1.1 Annotation.java</h3><pre><code>package java.lang.annotation;public interface Annotation {    boolean equals(Object obj);    int hashCode();    String toString();    Class&lt;? extends Annotation&gt; annotationType();}</code></pre><p>一个接口</p><h3 id="1-1-2-ElementType-java"><a href="#1-1-2-ElementType-java" class="headerlink" title="1.1.2 ElementType.java"></a>1.1.2 ElementType.java</h3><pre><code>package java.lang.annotation;public enum ElementType {    TYPE,               /* 类、接口（包括注释类型）或枚举声明  */    FIELD,              /* 字段声明（包括枚举常量）  */    METHOD,             /* 方法声明  */    PARAMETER,          /* 参数声明  */    CONSTRUCTOR,        /* 构造方法声明  */    LOCAL_VARIABLE,     /* 局部变量声明  */    ANNOTATION_TYPE,    /* 注释类型声明  */    PACKAGE             /* 包声明  */}</code></pre><p>枚举类型，用来指定Annotation的类型。就是这个注解对象是用来修饰什么的，是方法，是变量，还是其他的各种…</p><h3 id="1-1-3-RetentionPolicy-java"><a href="#1-1-3-RetentionPolicy-java" class="headerlink" title="1.1.3 RetentionPolicy.java"></a>1.1.3 RetentionPolicy.java</h3><pre><code>package java.lang.annotation;public enum RetentionPolicy {    SOURCE,            /* Annotation信息仅存在于编译器处理期间，编译器处理完之后就没有该Annotation信息了  */    CLASS,             /* 编译器将Annotation存储于类对应的.class文件中。默认行为  */    RUNTIME            /* 编译器将Annotation存储于class文件中，并且可由JVM读入 */}</code></pre><p>RetentionPolicy是Enum枚举类型，每个都有其对应的行为。</p><p><strong>RetentionPolicy.SOURCE</strong> – Discard during the compile. These annotations don’t make any sense after the compile has completed, so they aren’t written to the bytecode. Examples @Override, @SuppressWarnings</p><p><strong>RetentionPolicy.CLASS</strong> – Discard during class load. Useful when doing bytecode-level post-processing. Somewhat surprisingly, this is the default.</p><p><strong>RetentionPolicy.RUNTIME</strong> – Do not discard. The annotation should be available for reflection at runtime. This is what we generally use for our custom annotations.</p><h2 id="1-2-通用定义"><a href="#1-2-通用定义" class="headerlink" title="1.2 通用定义"></a>1.2 通用定义</h2><pre><code>@Documented@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface MyAnnotation1 {}</code></pre><h3 id="1-2-1-interface"><a href="#1-2-1-interface" class="headerlink" title="1.2.1 @interface"></a>1.2.1 @interface</h3><p>意味着实现了java.lang.annotation.Annotation接口，即该注解就是一个Annotation。Annotation接口的实现细节都由编译器来完成的，通过@interface定义注解吼，该注解不能继承其他的注解或接口。</p><h3 id="1-2-2-Documented"><a href="#1-2-2-Documented" class="headerlink" title="1.2.2 @Documented"></a>1.2.2 @Documented</h3><p>类和方法的Annotation在缺省情况下是不出现在javadoc中的。如果使用@Documented修饰该Annotation，则表示它可以出现在javadoc中。</p><h3 id="1-2-3-Target-ElementType-TYPE"><a href="#1-2-3-Target-ElementType-TYPE" class="headerlink" title="1.2.3 @Target(ElementType.TYPE)"></a>1.2.3 @Target(ElementType.TYPE)</h3><p>ElementType是Annotation的类型属性，而@Target的作用，就是来指定类型属性的</p><p>有@Target，则该Annotation只能用于其所指定的地方；若没有，则该Annotation可以用于任何地方</p><h3 id="1-2-4-Retention-RetentionPolicy-RUNTIME"><a href="#1-2-4-Retention-RetentionPolicy-RUNTIME" class="headerlink" title="1.2.4 @Retention(RetentionPolicy.RUNTIME)"></a>1.2.4 @Retention(RetentionPolicy.RUNTIME)</h3><p>RetentionPolicy是Annotation的策略属性，</p><h2 id="1-3-常用Annotation"><a href="#1-3-常用Annotation" class="headerlink" title="1.3 常用Annotation"></a>1.3 常用Annotation</h2><h3 id="1-3-1-Deprecated"><a href="#1-3-1-Deprecated" class="headerlink" title="1.3.1 @Deprecated"></a>1.3.1 @Deprecated</h3><pre><code>@Documented@Retention(RetentionPolicy.RUNTIME)public @interface Deprecated {}</code></pre><ol><li>@interface – 它的用来修饰Deprecated，意味着Deprecated实现了java.lang.annotation.Annotation接口；即Deprecated就是一个注解。</li><li>@Documented – 它的作用是说明该注解能出现在javadoc中。</li><li>@Retention(RetentionPolicy.RUNTIME) – 它的作用是指定Deprecated的策略是RetentionPolicy.RUNTIME。这就意味着，编译器会将Deprecated的信息保留在.class文件中，并且能被虚拟机读取。</li><li>@Deprecated 所标注内容，不再被建议使用。<h3 id="1-3-2-Override"><a href="#1-3-2-Override" class="headerlink" title="1.3.2 @Override"></a>1.3.2 @Override</h3></li></ol><h3 id="1-3-3-Documented"><a href="#1-3-3-Documented" class="headerlink" title="1.3.3 @Documented"></a>1.3.3 @Documented</h3><h3 id="1-3-4-Inherited"><a href="#1-3-4-Inherited" class="headerlink" title="1.3.4 @Inherited"></a>1.3.4 @Inherited</h3><p>用来标注Annotation类型，所标注的Annotation具有继承性</p><pre><code>@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Inherited {}</code></pre><ol><li>@interface – 它的用来修饰Inherited，意味着Inherited实现了java.lang.annotation.Annotation接口；即Inherited就是一个注解。</li><li>@Documented – 它的作用是说明该注解能出现在javadoc中。</li><li>@Retention(RetentionPolicy.RUNTIME) – 它的作用是指定Inherited的策略是RetentionPolicy.RUNTIME。这就意味着，编译器会将Inherited的信息保留在.class文件中，并且能被虚拟机读取。</li><li>@Target(ElementType.ANNOTATION_TYPE) – 它的作用是指定Inherited的类型是ANNOTATION_TYPE。这就意味着，@Inherited只能被用来标注“Annotation类型”。</li></ol><h3 id="1-3-5-Retention"><a href="#1-3-5-Retention" class="headerlink" title="1.3.5 @Retention"></a>1.3.5 @Retention</h3><p>用来标注Annotation类型，用来指定RetentionPolicy属性</p><h3 id="1-3-6-Target"><a href="#1-3-6-Target" class="headerlink" title="1.3.6 @Target"></a>1.3.6 @Target</h3><p>@Target只能被用来标注“Annotation类型”，而且它被用来指定Annotation的ElementType属性。</p><h3 id="1-3-7-SuppressWarnings"><a href="#1-3-7-SuppressWarnings" class="headerlink" title="1.3.7 @SuppressWarnings"></a>1.3.7 @SuppressWarnings</h3><p>@SuppressWarnings 所标注内容产生的警告，编译器会对这些警告保持静默。</p><pre><code>@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})@Retention(RetentionPolicy.SOURCE)public @interface SuppressWarnings {    String[] value();}</code></pre><ol><li>@interface – 它的用来修饰SuppressWarnings，意味着SuppressWarnings实现了java.lang.annotation.Annotation接口；即SuppressWarnings就是一个注解。</li><li>@Retention(RetentionPolicy.SOURCE) – 它的作用是指定SuppressWarnings的策略是RetentionPolicy.SOURCE。这就意味着，SuppressWarnings信息仅存在于编译器处理期间，编译器处理完之后SuppressWarnings就没有作用了。</li><li>@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE}) – 它的作用是指定SuppressWarnings的类型同时包括TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE。</li></ol><ul><li>TYPE意味着，它能标注“类、接口（包括注释类型）或枚举声明”。</li><li>FIELD意味着，它能标注“字段声明”。</li><li>METHOD意味着，它能标注“方法”。</li><li>PARAMETER意味着，它能标注“参数”。</li><li>CONSTRUCTOR意味着，它能标注“构造方法”。</li><li>LOCAL_VARIABLE意味着，它能标注“局部变量”。</li></ul><ol start="4"><li>String[] value(); 意味着，SuppressWarnings能指定参数</li><li>SuppressWarnings 的作用是，让编译器对“它所标注的内容”的某些警告保持静默。例如，”@SuppressWarnings(value={“deprecation”, “unchecked”})” 表示对“它所标注的内容”中的 “SuppressWarnings不再建议使用警告”和“未检查的转换时的警告”保持沉默。<h1 id="2-创建自己的Annotation"><a href="#2-创建自己的Annotation" class="headerlink" title="2. 创建自己的Annotation"></a>2. 创建自己的Annotation</h1></li></ol><p>注解只支持基本类型，String，还有Enum。所有的注解的属性都被定义为方法，default的值也会在方法里提供。</p><pre><code>@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)@interface Todo {public enum Priority {LOW, MEDIUM, HIGH}public enum Status {STARTED, NOT_STARTED}String author() default &quot;Yash&quot;;Priority priority() default Priority.LOW;Status status() default Status.NOT_STARTED;}</code></pre><p>这里我们创建了一个新的注解，@Todo</p><pre><code>@Todo(priority = Todo.Priority.MEDIUM, author = &quot;Yashwant&quot;, status = Todo.Status.STARTED)public void incompleteMethod1() {    //一些业务逻辑}</code></pre><p>值得注意的一点，如果注解只有一个属性，那么它应该被命名为value,在使用它的时候不用使用具体的变量名了。</p><pre><code>@interface Author{String value();}@Author(&quot;Yashwant&quot;)public void someMethod() {}</code></pre><p>定义好注解以后，我们需要写注解的消费者，使用反射。</p><pre><code>Class businessLogicClass = BusinessLogic.class;for(Method method : businessLogicClass.getMethods()) {    Todo todoAnnotation = (Todo)method.getAnnotation(Todo.class);    if(todoAnnotation != null) {    System.out.println(&quot; Method Name : &quot; + method.getName());    System.out.println(&quot; Author : &quot; + todoAnnotation.author());    System.out.println(&quot; Priority : &quot; + todoAnnotation.priority());    System.out.println(&quot; Status : &quot; + todoAnnotation.status());    }}</code></pre><h1 id="3-Reference"><a href="#3-Reference" class="headerlink" title="3. Reference"></a>3. Reference</h1><ol><li><a href="https://www.cnblogs.com/skywang12345/p/3344137.html" target="_blank" rel="noopener">https://www.cnblogs.com/skywang12345/p/3344137.html</a> </li><li><a href="https://dzone.com/articles/how-annotations-work-java" target="_blank" rel="noopener">https://dzone.com/articles/how-annotations-work-java</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java annotation很有用，这篇博客会带着大家去理解Annotation的语法以及用法，希望能有所裨益。&lt;/p&gt;
&lt;h1 id=&quot;1-Annotation架构&quot;&gt;&lt;a href=&quot;#1-Annotation架构&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
      <category term="Annotations" scheme="https://www.llchen60.com/tags/Annotations/"/>
    
  </entry>
  
  <entry>
    <title>Jackson  java-json parser</title>
    <link href="https://www.llchen60.com/Jackson-java-json-parser/"/>
    <id>https://www.llchen60.com/Jackson-java-json-parser/</id>
    <published>2020-02-06T02:55:49.000Z</published>
    <updated>2020-02-06T02:56:25.555Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Intro"><a href="#1-Intro" class="headerlink" title="1. Intro"></a>1. Intro</h1><ul><li>JSON <ul><li>JavaScript Object Notation </li><li>Data exchange format between browsers and web servers </li></ul></li><li>Jackson <ul><li>2 main parsers <ul><li>ObjectMapper <ul><li>parse JSON into custom Java objects, or into a jackson specific tree structure </li></ul></li><li>JsonParser <ul><li>JSON pull parser, parsing JSON one token at a time </li></ul></li></ul></li><li>2 main JSON generator<ul><li>ObjectMapper </li><li>JsonGenerator<ul><li>generate JSON one token at a time </li></ul></li></ul></li><li>3 main packages <ul><li>Jackson Core</li><li>Jackson Annotations</li><li>Jackson Databind </li></ul></li></ul></li></ul><h1 id="2-Parsers-JSON-to-Java-Object"><a href="#2-Parsers-JSON-to-Java-Object" class="headerlink" title="2. Parsers - JSON to Java Object"></a>2. Parsers - JSON to Java Object</h1><pre><code>ObjectMapper objectMapper = new ObjectMapper();String lakers = &quot;{ \&quot;SuperStar\&quot;:\&quot;Kobe Bryant\&quot;}&quot;;try {    Lakers lakers = objectMapper.readValue(lakers, Lakers.class);} catch (IOException e) {    log.error(e);}@Datapublic class Lakers {    private String superStar;}</code></pre><h2 id="2-1-How-Jackson-ObjectMapper-matches-JSON-fields-to-Java-Fields"><a href="#2-1-How-Jackson-ObjectMapper-matches-JSON-fields-to-Java-Fields" class="headerlink" title="2.1 How Jackson ObjectMapper matches JSON fields to Java Fields?"></a>2.1 How Jackson ObjectMapper matches JSON fields to Java Fields?</h2><p>By default, Jackson maps the fields of a JSON object to fields in a Java object by matching the names of the JSON field to the getter and setter methods in the Java object.<br>Jackson removes the “get” and “set” part of the names of the getter and setter methods, and converts the first character of the remaining name to lowercase.</p><p>If you want to customize the parsing process, you may want to use a custom serializer and deserializer, or use Jackson Annotations </p><h2 id="2-2-Fail-on-Null-for-primitive-types"><a href="#2-2-Fail-on-Null-for-primitive-types" class="headerlink" title="2.2 Fail on Null for primitive types"></a>2.2 Fail on Null for primitive types</h2><p>We could configure the Jackson ObjectMapper to fail if a JSON string contains a field with its value set to null. </p><pre><code>ObjectMapper objectMapper = new ObjectMapper();objectMapper.configure(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES, true);</code></pre><h2 id="2-3-Jackson-JsonParser"><a href="#2-3-Jackson-JsonParser" class="headerlink" title="2.3 Jackson JsonParser"></a>2.3 Jackson JsonParser</h2><ul><li><p>lower level than the ObjectMapper </p><ul><li>faster than the ObjectMapper</li></ul></li><li><p>Create a JsonParser </p><ul><li><code>JsonFactory factory = new JsonFactory();</code></li><li><code>JsonParser parser = factory.createParser(carJson);</code></li></ul></li><li><p>Parsing Json with JsonParser</p><ul><li>break the JSON up into a sequence of tokens which you can iterate one by one </li></ul></li></ul><pre><code>String carJson =        &quot;{ \&quot;brand\&quot; : \&quot;Mercedes\&quot;, \&quot;doors\&quot; : 5 }&quot;;JsonFactory factory = new JsonFactory();JsonParser  parser  = factory.createParser(carJson);while(!parser.isClosed()){    JsonToken jsonToken = parser.nextToken();    System.out.println(&quot;jsonToken = &quot; + jsonToken);}</code></pre><h1 id="3-Generators-Java-Object-to-JSON"><a href="#3-Generators-Java-Object-to-JSON" class="headerlink" title="3. Generators - Java Object to JSON"></a>3. Generators - Java Object to JSON</h1><ul><li>ObjectMapper<ul><li>writeValue()</li><li>writeValueAsString()</li><li>writeValueAsBytes()</li></ul></li></ul><h2 id="3-1-Jackson-JsonGenerator"><a href="#3-1-Jackson-JsonGenerator" class="headerlink" title="3.1 Jackson JsonGenerator"></a>3.1 Jackson JsonGenerator</h2><ul><li>used to generate JSON from java objects </li></ul><pre><code>JsonFactory factory = new JsonFactory();JsonGenerator generator = factory.createGenerator(    new File(&quot;blabla&quot;), JsonEncoding.UTF8);</code></pre><h1 id="4-Jackson-JSON-Tree-Model"><a href="#4-Jackson-JSON-Tree-Model" class="headerlink" title="4. Jackson JSON Tree Model"></a>4. Jackson JSON Tree Model</h1><ul><li>A built-in tree model: used to represent a JSON object </li><li>Represented by the JsonNode class <ul><li>use the ObjectMapper to parse JSON into a JsonNode tree model</li></ul></li><li>JsonNode class lets you navigate the JSOn as a Java object in a quite flexible and dynamic way </li></ul><pre><code>String carJson =        &quot;{ \&quot;brand\&quot; : \&quot;Mercedes\&quot;, \&quot;doors\&quot; : 5 }&quot;;ObjectMapper objectMapper = new ObjectMapper();try {    JsonNode jsonNode = objectMapper.readValue(carJson, JsonNode.class);} catch (IOException e) {    e.printStackTrace();}// ways on how to access JSON fields, arrays and nested objects String carJson =    &quot;{ \&quot;brand\&quot; : \&quot;Mercedes\&quot;, \&quot;doors\&quot; : 5,&quot; +    &quot;  \&quot;owners\&quot; : [\&quot;John\&quot;, \&quot;Jack\&quot;, \&quot;Jill\&quot;],&quot; +    &quot;  \&quot;nestedObject\&quot; : { \&quot;field\&quot; : \&quot;value\&quot; } }&quot;;ObjectMapper objectMapper = new ObjectMapper();try {    JsonNode jsonNode = objectMapper.readValue(carJson, JsonNode.class);    // we could always use get() to get the node     JsonNode brandNode = jsonNode.get(&quot;brand&quot;);    String brand = brandNode.asText();    System.out.println(&quot;brand = &quot; + brand);    JsonNode doorsNode = jsonNode.get(&quot;doors&quot;);    int doors = doorsNode.asInt();    System.out.println(&quot;doors = &quot; + doors);    JsonNode array = jsonNode.get(&quot;owners&quot;);    JsonNode jsonNode = array.get(0);    String john = jsonNode.asText();    System.out.println(&quot;john  = &quot; + john);    JsonNode child = jsonNode.get(&quot;nestedObject&quot;);    JsonNode childField = child.get(&quot;field&quot;);    String field = childField.asText();    System.out.println(&quot;field = &quot; + field);} catch (IOException e) {    e.printStackTrace();}</code></pre><h2 id="4-1-Read-JsonNode-from-JSON"><a href="#4-1-Read-JsonNode-from-JSON" class="headerlink" title="4.1 Read JsonNode from JSON"></a>4.1 Read JsonNode from JSON</h2><pre><code>String jsonStr = blablabla;ObjectMapper objectMapper = new ObjectMapper();JsonNode jsonNode = objectMapper.readTree(json);</code></pre><h2 id="4-2-Write-JsonNode-to-JSON"><a href="#4-2-Write-JsonNode-to-JSON" class="headerlink" title="4.2 Write JsonNode to JSON"></a>4.2 Write JsonNode to JSON</h2><pre><code>ObjectMapper objectMapper = new ObjectMapper();JsonNode jsonNode = readJsonIntoJsonNode();String json = objectMapper.writeValueAsString(jsonNode);</code></pre><h1 id="5-JsonAnnotation"><a href="#5-JsonAnnotation" class="headerlink" title="5. JsonAnnotation"></a>5. JsonAnnotation</h1><ul><li>@JsonIgnore</li><li>@JsonIgnoreProperties<ul><li>specify a list of properties of a class to ignore </li></ul></li><li>@JsonIgnoreType</li><li>@JsonAutoDetect </li><li>@JsonSetter </li><li>@JsonCreator</li><li>@JsonProperty </li><li>@JsonInclude<ul><li>tells Jackson only to include properties under certain circumstances</li></ul></li><li>@JsonGetter <ul><li>tell Jackson that a certain field value should be obtained from calling a getter method instead of via direct field access </li></ul></li><li>@JsonPropertyOrder<ul><li>specify in what order the fields of your java object should be serialized into JSON</li></ul></li><li>@JsonValue<ul><li>tells jackson that it should not attempt to serialize the obejct itself, but rather call a method on the object which serialize the object to a JSON string </li></ul></li><li>@JsonSerialize <ul><li>specify a custom serializer for a field in a Java object  </li></ul></li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="http://tutorials.jenkov.com/java-json/jackson-objectmapper.html" target="_blank" rel="noopener">http://tutorials.jenkov.com/java-json/jackson-objectmapper.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Intro&quot;&gt;&lt;a href=&quot;#1-Intro&quot; class=&quot;headerlink&quot; title=&quot;1. Intro&quot;&gt;&lt;/a&gt;1. Intro&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;JSON &lt;ul&gt;
&lt;li&gt;JavaScript Object Notation &lt;
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
      <category term="Jackson" scheme="https://www.llchen60.com/tags/Jackson/"/>
    
      <category term="Serialization" scheme="https://www.llchen60.com/tags/Serialization/"/>
    
  </entry>
  
  <entry>
    <title>HashMap在Java中是如何工作的</title>
    <link href="https://www.llchen60.com/HashMap%E5%9C%A8Java%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/"/>
    <id>https://www.llchen60.com/HashMap%E5%9C%A8Java%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/</id>
    <published>2020-02-04T17:15:10.000Z</published>
    <updated>2020-02-04T17:15:47.639Z</updated>
    
    <content type="html"><![CDATA[<p>HashMap是存储以及获取数据的一种简单有效的方式，本文探究Java的HashMap的内部实现。</p><h1 id="1-内部存储"><a href="#1-内部存储" class="headerlink" title="1. 内部存储"></a>1. 内部存储</h1><p>Java的HashMap Class implements <code>Map&lt;K,V&gt;</code> 接口。这个接口的主要方法有：</p><ul><li>put(K key, V value)</li><li>get(Object key)</li><li>remove(Object key)</li><li>Boolean containsKey(Object key)</li></ul><p>HashMap在内部用键值对来进行存储，但是还包含两份其他数据，分别为：</p><ul><li>一个到其他的Entry的reference，这样子HashMap就可以像存单向链表一样来存Entries</li><li>一个代表key的哈希值的值。将这个值存储来避免每次hashMap需要的时候都要重新计算。</li></ul><h2 id="1-1-Java-的Entry的实现"><a href="#1-1-Java-的Entry的实现" class="headerlink" title="1.1 Java 的Entry的实现"></a>1.1 Java 的Entry的实现</h2><pre><code>static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {    final K key;    V value;    Entry&lt;K,V&gt; next;    int hash;}</code></pre><p>一个HashMap存储在多个单向链表中，每个单向链表称为Buckets或者bins. 所有的链表都注册在一个数组中，数组元素为<code>Entry&lt;K,V&gt;</code>. 默认的数组大小是16.<br><img src="https://i.loli.net/2020/02/05/yORJs9NVWXPt75p.jpg" alt="fig1.jpg"></p><p>所有有相同哈希值的key值会存在同一个单向链表当中， 当使用者用put或者get方法的时候，程序会计算需要分配搭配哪个链表(数组的位置)，然后会在链表里用equal方法去找entry中有相同key的entry(针对get方法而言)</p><p>值得注意的是当调用put方法时，如果找到了同样的key，会将value进行替换。</p><p>链表的序号(在数组中的位置)由以下三步来生成：</p><ul><li>得到key的哈希值</li><li>rehash哈希值，来避免不佳的哈希函数把所有数据都放到了一个单向链表当中</li><li>用rehash的哈希值和数组的大小做位掩码， </li></ul><pre><code>// the &quot;rehash&quot; function in JAVA 7 that takes the hashcode of the keystatic int hash(int h) {    h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);    return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);}// the &quot;rehash&quot; function in JAVA 8 that directly takes the keystatic final int hash(Object key) {    int h;    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);    }// the function that returns the index from the rehashed hashstatic int indexFor(int h, int length) {    return h &amp; (length-1);}</code></pre><h2 id="1-2-自动重置大小"><a href="#1-2-自动重置大小" class="headerlink" title="1.2 自动重置大小"></a>1.2 自动重置大小</h2><p>在得到在数组中的位置以后，假设要寻找一个key值，我们需要遍历整个单向链表，来找到这个key值。如果array的size固定的话，单个链表的大小可能会非常大，会使整个查找效率变得很低，因此我们需要自动更新整个数组的大小来保证查找效率。</p><p>当我们创建一个HashMap的时候，我们可以定义初始数组的大小和加载参数(Load Factor).如果你不自行定义，那默认的数组大小是16，加载参数是0.75.</p><pre><code>public HashMap(int initialCapacity, float loadFactor)</code></pre><p>当你调用put方法尝试往HashMap里加新的entry的时候，函数会检测是否需要去增加整个数组的大小。HashMap会存储两个数据：</p><ol><li>HashMap的大小：代表了HashMap中的entry的数量</li><li>Threshold = 数组当下的大小 * load factor. </li></ol><p>当调用put方法的时候，会先检测现在的数组的大小是否超过了定义的阈值(Threshold)，如果超过，就会将当前数组的大小进行加倍处理。值得注意的是，当数组大小发生变化的时候，哈希值和数组大小减一的位操作的值会发生变化，也就是说原先的entry会按照现在的数组大小进行重新的分配，将现存的所有entry分配到不同的bucket里面。</p><p>这样做的目的就是减小每个数组元素- 单向链表的大小，让put, remove, get操作所需要的时间在合理的范围内。</p><p><img src="https://i.loli.net/2020/02/05/xk4JnhHSFTPupgQ.jpg" alt="fig2.jpg"></p><h1 id="2-线程安全？"><a href="#2-线程安全？" class="headerlink" title="2. 线程安全？"></a>2. 线程安全？</h1><p>HashMap不是线程安全的，是因为假设现在到了设的阈值，需要进行HashMap内部数组的resize。这个时候新的entry可能是用原先的哈希函数来做bucket的分配的，这样子就会造成整个数据的不同步。</p><h1 id="3-键值的不可变性"><a href="#3-键值的不可变性" class="headerlink" title="3. 键值的不可变性"></a>3. 键值的不可变性</h1><p>String和Integer是很好的键值选项，因为他们本身就是不可变的。如果你创建自己的键值类，而且这个键值类是可变的，那么我们也许就会在HashMap中丢失数据。</p><p>因为旧哈希值是被存储在Array中的，作为分配到特定bucket的基准，你改变了键值，也就是改变了传入的哈希值，这时候这是全新的一条数据，无法回到原来的bucket，也无法对其进行覆盖了。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="http://coding-geek.com/how-does-a-hashmap-work-in-java/" target="_blank" rel="noopener">Coding Geek</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;HashMap是存储以及获取数据的一种简单有效的方式，本文探究Java的HashMap的内部实现。&lt;/p&gt;
&lt;h1 id=&quot;1-内部存储&quot;&gt;&lt;a href=&quot;#1-内部存储&quot; class=&quot;headerlink&quot; title=&quot;1. 内部存储&quot;&gt;&lt;/a&gt;1. 内部存储&lt;/h
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
      <category term="HashMap" scheme="https://www.llchen60.com/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>Handling overload effectively with load balancers</title>
    <link href="https://www.llchen60.com/Handling-overload-effectively-with-load-balancers/"/>
    <id>https://www.llchen60.com/Handling-overload-effectively-with-load-balancers/</id>
    <published>2020-02-04T17:13:39.000Z</published>
    <updated>2020-02-04T17:14:06.176Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Fail-Smarter"><a href="#1-Fail-Smarter" class="headerlink" title="1. Fail Smarter"></a>1. Fail Smarter</h1><ul><li>Average latency has a spike, availability down</li><li>reasons <ul><li>dependencies </li><li>cascading effect </li><li>client change   peak </li></ul></li></ul><h1 id="2-Load-balancers"><a href="#2-Load-balancers" class="headerlink" title="2. Load balancers"></a>2. Load balancers</h1><ul><li>clients - load balancers - servers </li><li>hardware devices </li><li>multi tenant - use VIP - for efficiency </li><li>used for (features)<ul><li>scaling </li><li>even traffic distribution </li><li>overload protection</li></ul></li><li>how<ul><li>how to pick a server <ul><li>random dice </li><li>round robin </li><li>least conns </li></ul></li><li>desired algorithm - we use least conns <ul><li>simple </li><li>reliable </li><li>even </li></ul></li><li>max conns? </li><li>how to deal with overload? <ul><li>attributes <ul><li>cheap </li><li>local </li><li>buffering - having capacity soon </li><li>priority </li></ul></li><li>reject requests  - spillover - choose! <ul><li>close the TCP connection </li><li>no buffer </li></ul></li><li>hang on, wait in a queue - surge queue <ul><li>may mkes it take longer</li></ul></li></ul></li></ul></li><li>some default we set - maxConns - perhost setting <ul><li>little’s law <ul><li>arrival rate * time shopping = people in the store </li></ul></li><li>see load balancers how many services we have </li><li>fleet-wide concurrent requests / host count = <strong>avg conns</strong></li></ul></li></ul><ul><li>metrics matter <ul><li>latency netwrok latency + 25% <ul><li>client side </li><li>server side </li></ul></li><li>request rate </li></ul></li><li>coral server <ul><li>concurrent requests - outstanding request - in one host </li></ul></li><li>33% overhead room - dependency failures </li></ul><h1 id="3-Actual-behave"><a href="#3-Actual-behave" class="headerlink" title="3. Actual behave"></a>3. Actual behave</h1><ul><li>increase load to see average latency </li><li>run actual test </li><li>generate graph with outstanding requests <ul><li>see the cross of client timeout and p99 </li></ul></li></ul><h1 id="4-Abnormal-cases"><a href="#4-Abnormal-cases" class="headerlink" title="4. Abnormal cases"></a>4. Abnormal cases</h1><ul><li>dependency latency, timeout </li><li>network  packet loss </li></ul><ul><li>let server decide what’s the maxCon should be </li><li>coral has<ul><li>connection </li><li>worker  work thread </li></ul></li><li>classify requests <ul><li>importance <ul><li>droppable </li></ul></li><li>priority <ul><li>order  </li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Fail-Smarter&quot;&gt;&lt;a href=&quot;#1-Fail-Smarter&quot; class=&quot;headerlink&quot; title=&quot;1. Fail Smarter&quot;&gt;&lt;/a&gt;1. Fail Smarter&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Average latenc
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Load Balancers" scheme="https://www.llchen60.com/tags/Load-Balancers/"/>
    
  </entry>
  
  <entry>
    <title>Google Dagger Tutorial</title>
    <link href="https://www.llchen60.com/Google-Dagger-Tutorial/"/>
    <id>https://www.llchen60.com/Google-Dagger-Tutorial/</id>
    <published>2020-02-04T17:12:52.000Z</published>
    <updated>2020-02-04T17:14:18.480Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Comparisons"><a href="#1-Comparisons" class="headerlink" title="1. Comparisons"></a>1. Comparisons</h1><p>Spring is a giant collection of libraries and utilities. with a lot of integration, an XML configuration, runtime/ reflective bindings. Application already using Spring can use its dependency injection smoothly. </p><p>Dependency is only a small part of it. Guice and Dagger is lightweight and only a dependency injection framework</p><p>Dagger is very lightweight framework with very few integrations, java interface/ annotation configuration, and compile-time code generated bindings. </p><p>For dependency injection and IOC container, there is <a href="https://llchen60.com/IOC%E5%AE%B9%E5%99%A8%E5%92%8CDependency-Injection%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">a post in Chinese</a> wrote last year.</p><p>Also a big difference between those DI framework is when does the injection happen, compile time or runtime? </p><p>Run-time DI is <strong>based on reflection</strong> which is simpler to use but slower at run-time —- Spring, Guice </p><p>Compile-time DI is <strong>based on code generation</strong>. This means that all the heavy-weight operations are performed during compilation. It adds complexity but generally performs faster</p><h1 id="2-Implementation"><a href="#2-Implementation" class="headerlink" title="2. Implementation"></a>2. Implementation</h1><ul><li>POJO</li><li>Module<ul><li>a class provides or builds the objects’ dependencies </li></ul></li><li>Component<ul><li>an interface used to generate the injector </li></ul></li></ul><h2 id="2-1-POJO"><a href="#2-1-POJO" class="headerlink" title="2.1 POJO"></a>2.1 POJO</h2><pre><code>public class Car {    private Engine engine;    private Brand brand;    @Inject    public Car(Engine engine, Brand brand) {        this.engine = engine;        this.brand = brand;    }    // getters and setters}</code></pre><h2 id="2-2-Module"><a href="#2-2-Module" class="headerlink" title="2.2 Module"></a>2.2 Module</h2><pre><code>@Module // similar to @Controller  @Service public class VehiclesModule {    @Provides // similar to @Bean     public Engine provideEngine() {        return new Engine();    }    @Provides    @Singleton    public Brand provideBrand() {         return new Brand(&quot;lol&quot;);     }}</code></pre><h2 id="2-3-Component"><a href="#2-3-Component" class="headerlink" title="2.3 Component"></a>2.3 Component</h2><p>here we could return the real object we want to be the starting point of the whole mechanism:</p><p>Dagger will start from here, go through all the @Inject and satisfy those dependencies. In our example, will create engine and brand object. </p><pre><code>@Singleton@Component(modules = VehiclesModule.class)public interface VehiclesComponent {    Car buildCar();}</code></pre><h2 id="2-4-client-side"><a href="#2-4-client-side" class="headerlink" title="2.4 client side"></a>2.4 client side</h2><p>Notice: <code>DaggerVehiclesComponent</code> is created by dagger automatically. </p><pre><code>VehiclesComponent component = DaggerVehiclesComponent.create();Car eg = component.buildCar();</code></pre><h1 id="3-Dagger-User-Guide"><a href="#3-Dagger-User-Guide" class="headerlink" title="3. Dagger User Guide"></a>3. Dagger User Guide</h1><h2 id="3-1-Declaring-Dependencies"><a href="#3-1-Declaring-Dependencies" class="headerlink" title="3.1 Declaring Dependencies"></a>3.1 Declaring Dependencies</h2><p>Dagger constructs instances of application classes and satisfies their dependencies. It uses @Inject annotation to identify which constructors and fields it is interested in. </p><h2 id="3-2-Satisfying-Dependencies"><a href="#3-2-Satisfying-Dependencies" class="headerlink" title="3.2 Satisfying Dependencies"></a>3.2 Satisfying Dependencies</h2><p>By default, Dagger satisfies each dependency by constructing an instance of the requested type. It call <code>new SomeObject()</code> and setting its injectable fields. </p><ul><li>@Inject <ul><li>interfaces cannot be constructed </li><li>third party classes cannot be annotated </li><li>configurable objects must be configured </li></ul></li><li>Instead, use @provides <ul><li>all @provides methods should be named with a provide prefix and module classes are named with a Module suffix </li></ul></li></ul><h2 id="3-3-Building-the-Graph"><a href="#3-3-Building-the-Graph" class="headerlink" title="3.3 Building the Graph"></a>3.3 Building the Graph</h2><p>The @Inject and @Provides annotated classes form a graph of objects, linked by their dependencies. Build the application by <strong>an interface with methods that have no arguments and return the desired type</strong>. </p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://stackoverflow.com/questions/39688830/why-use-develop-guice-when-you-have-spring-and-dagger" target="_blank" rel="noopener">https://stackoverflow.com/questions/39688830/why-use-develop-guice-when-you-have-spring-and-dagger</a></li><li><a href="https://www.baeldung.com/dagger-2" target="_blank" rel="noopener">https://www.baeldung.com/dagger-2</a></li><li><a href="https://rskupnik.github.io/dependency-injection-in-pet-project-dagger2" target="_blank" rel="noopener">https://rskupnik.github.io/dependency-injection-in-pet-project-dagger2</a></li><li><a href="https://dagger.dev/" target="_blank" rel="noopener">https://dagger.dev/</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Comparisons&quot;&gt;&lt;a href=&quot;#1-Comparisons&quot; class=&quot;headerlink&quot; title=&quot;1. Comparisons&quot;&gt;&lt;/a&gt;1. Comparisons&lt;/h1&gt;&lt;p&gt;Spring is a giant collec
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
      <category term="Dagger" scheme="https://www.llchen60.com/tags/Dagger/"/>
    
      <category term="DI" scheme="https://www.llchen60.com/tags/DI/"/>
    
  </entry>
  
  <entry>
    <title>Executor, ExecutorService and Executors</title>
    <link href="https://www.llchen60.com/Executor-ExecutorService-and-Executors/"/>
    <id>https://www.llchen60.com/Executor-ExecutorService-and-Executors/</id>
    <published>2020-02-04T17:11:48.000Z</published>
    <updated>2020-02-04T17:12:16.419Z</updated>
    
    <content type="html"><![CDATA[<p>Executor, ExecutorService and Executors, they are all part of Java’s Executor framework, this framework offers a threadpool. Thus we don’t need to manage threads on our own, the pool can help us manage themselves. </p><p>A thread pool which is created when an application is a startup solves both of these problems. It has <strong>ready threads</strong> to serve clients when needed and it also has a bound on how many threads to create under load.</p><h1 id="1-Executor"><a href="#1-Executor" class="headerlink" title="1. Executor"></a>1. Executor</h1><p><strong>the core interface</strong> which is an abstraction for parallel execution</p><p>It separates task from execution, this is different from java.lang.Thread class which <strong>combines both task and its execution</strong>. </p><h1 id="2-ExecutorService"><a href="#2-ExecutorService" class="headerlink" title="2. ExecutorService"></a>2. ExecutorService</h1><p>ExecutorService is an extension of Executor interface and provides a facility for returning a Future object and terminate, or shut down the thread pool. Once the shutdown is called, the thread pool will not accept new task but complete any pending task. It also provides a submit() method which extends Executor.execute() method and returns a Future.</p><p>The Future object provides the facility of asynchronous execution, which means you don’t need to wait until the execution finishes, you can just submit the task and go around, come back and check if Future object has the result, if execution is completed then it would have result which you can access by using the Future.get() method. Just remember that this method is a <strong>blocking method</strong> i.e. it will wait until execution finish and the result is available if it’s not finished already.</p><p>By using the Future object returned by ExecutorService.submit() method, you can also cancel the execution if you are not interested anymore. It provides cancel() method to cancel any pending execution.</p><h1 id="3-Executors"><a href="#3-Executors" class="headerlink" title="3. Executors"></a>3. Executors</h1><p>Third one Executors is a utility class similar to Collections, which provides <strong>factory methods</strong> to create different types of thread pools e.g. fixed and cached thread pools. Let’s see some more difference between these three classes.</p><h1 id="4-Difference"><a href="#4-Difference" class="headerlink" title="4. Difference"></a>4. Difference</h1><p>1) One of the key difference between Executor and ExecutorService interface is that <strong>former is a parent interface while ExecutorService extends Executor</strong> i.e. it’s a sub-interface of Executor.</p><p>2) Another important difference between ExecutorService and Executor is that Executor defines execute() method which accepts an object of the Runnable interface, while submit() method can accept objects of both Runnable and Callable interfaces.</p><p>3) The third difference between Executor and ExecutorService interface is that execute() method doesn’t return any result, its return type is void but submit() method returns the result of computation via a Future object. This is also the key difference between submit() and execute() method, which is one of the frequently asked Java concurrency interview questions.</p><p>4) The fourth difference between ExecutorService and Executor interface is that apart from allowing a client to submit a task, <strong>ExecutorService also provides methods to control the thread pool</strong> e.g. terminate the thread pool by calling the shutDown() method. You should also read “Java Concurrency in Practice” to learn more about the graceful shutdown of a thread-pool and how to handle pending tasks.</p><p>5) Executors class provides factory methods to create different kinds of thread pools e.g. newSingleThreadExecutor() creates a thread pool of just one thread, newFixedThreadPool(int numOfThreads) creates a thread pool of fixed number of threads and newCachedThreadPool() creates new threads when needed but reuse the existing threads if they are available.</p><h1 id="5-Differences-between-Executor-and-Thread"><a href="#5-Differences-between-Executor-and-Thread" class="headerlink" title="5. Differences between Executor and Thread"></a>5. Differences between Executor and Thread</h1><ol><li>Executor provides a thread pool in java, while Thread not. </li><li>java.lang.Thread is a class in Java while java.util.concurrent.Executor is an interface.</li><li>The Executor concept is actually an abstraction over parallel computation. It allows concurrent code to be run in managed way. On the other hand, Thread is a concrete way to run the code in parallel.</li><li>Executor decouples a task (the code which needs to be executed in parallel) from execution, while in the case of a Thread, both task and execution are tightly coupled.</li><li>The Executor concept allows your task is to be executed by a worker thread from the thread pool, while Thread itself execute your task</li><li>a Thread can only execute one Runnable task but an Executor can execute any number of Runnable task.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Executor, ExecutorService and Executors, they are all part of Java’s Executor framework, this framework offers a threadpool. Thus we don’
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>EnumMap vs HashMap</title>
    <link href="https://www.llchen60.com/EnumMap-vs-HashMap/"/>
    <id>https://www.llchen60.com/EnumMap-vs-HashMap/</id>
    <published>2020-02-04T17:10:34.000Z</published>
    <updated>2020-02-04T17:11:21.139Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-EnumMap"><a href="#1-EnumMap" class="headerlink" title="1. EnumMap"></a>1. EnumMap</h1><ul><li>Can only be used with <strong>enum type</strong> keys </li><li>It’s specialized implementation of Map Interface for use with enum type keys</li><li>Internally using <strong>arrays</strong> </li><li>stored in <strong>natural order</strong></li><li>not possible for collision </li><li>much efficient compared with HashMap </li></ul><h1 id="2-HashMap"><a href="#2-HashMap" class="headerlink" title="2. HashMap"></a>2. HashMap</h1><ul><li>Extends AbstrctMap and implement Map interface </li><li>Internally using hashTable</li><li>Possible for collision </li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://www.geeksforgeeks.org/enummap-class-java-example/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/enummap-class-java-example/</a> </li><li><a href="https://walkingtechie.blogspot.com/2017/03/difference-between-enummap-and-hashmap.html" target="_blank" rel="noopener">https://walkingtechie.blogspot.com/2017/03/difference-between-enummap-and-hashmap.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-EnumMap&quot;&gt;&lt;a href=&quot;#1-EnumMap&quot; class=&quot;headerlink&quot; title=&quot;1. EnumMap&quot;&gt;&lt;/a&gt;1. EnumMap&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Can only be used with &lt;strong&gt;enum
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Effective Java</title>
    <link href="https://www.llchen60.com/Effective-Java/"/>
    <id>https://www.llchen60.com/Effective-Java/</id>
    <published>2020-02-04T17:09:44.000Z</published>
    <updated>2020-02-04T17:10:04.050Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-General-Programming"><a href="#1-General-Programming" class="headerlink" title="1. General Programming"></a>1. General Programming</h1><h2 id="1-1-Scope-of-Local-variables"><a href="#1-1-Scope-of-Local-variables" class="headerlink" title="1.1 Scope of Local variables"></a>1.1 Scope of Local variables</h2><pre><code>for (Iterator&lt;Element&gt; i = c.iterator(); i.hasNext(); ) {    Element e = i.next();    ... // Do something with e and i}// code with bugIterator&lt;Element&gt; i2 = c2.iterator();while (i.hasNext()) {    Element e2 = i2.next();    ... // Do something with e2 and i2}</code></pre><p>i - i2. causing a runtime bug. This bug can be caught at compile time if you <strong>use local variable with minimal scope</strong>. </p><ol><li>Declare the scope of a local variable where it is first used </li><li>initialize every local variable</li><li>prefer for loops to while loops </li><li>keep methods small and focused on a single task </li></ol><h2 id="1-2-Use-library"><a href="#1-2-Use-library" class="headerlink" title="1.2 Use library"></a>1.2 Use library</h2><p>Use library will give you some advantages:</p><ul><li>The knowledge of experts who implemented it and the experience of others who used it before you. </li><li>Better performance that is implemented by experts.</li><li>New features that are added to the libraries in every major release. </li></ul><h2 id="1-3-Float-Double-and-Exact-Calculations"><a href="#1-3-Float-Double-and-Exact-Calculations" class="headerlink" title="1.3 Float, Double and Exact Calculations"></a>1.3 Float, Double and Exact Calculations</h2><pre><code>int getPossibleBoughtItems() {    double dollarFunds = 1.0;    int numItems = 0;    for (double price = 0.10; dollarFunds &gt;= price; price += 0.10) {        dollarFunds -= price;        numItems++;    }    return numItems;}</code></pre><p>We should use BigDecimal, int or long for exact calculations. We should avoid using float and double for exact calculations because they are carefully designed for accurate approximations in scientific and engineering calculations. </p><p>Note that the first method above will return 3, which is wrong, with funds left of $0.3999999999999999. The correct return should be 4, with funds left 0 (see the second implementation).</p><h2 id="1-4-Primitive-Types-and-Boxed-Primitives"><a href="#1-4-Primitive-Types-and-Boxed-Primitives" class="headerlink" title="1.4 Primitive Types and Boxed Primitives"></a>1.4 Primitive Types and Boxed Primitives</h2><p>When possible, you should use primitives, instead of boxed primitives, because: </p><ol><li>Unnecessary use of boxed primitives may result in a hideously slow program because of repeated boxed and unboxed operations. </li><li>whenboxes primitives are used, applying <code>==</code> operator is almost always wrong and can lead to deadly bugs that are difficult to discover. </li></ol><h2 id="1-5-Use-of-Strings-and-Other-Types"><a href="#1-5-Use-of-Strings-and-Other-Types" class="headerlink" title="1.5 Use of Strings and Other Types"></a>1.5 Use of Strings and Other Types</h2><pre><code>// goodpublic final class ThreadLocal&lt;T&gt; {    public ThreadLocal() {};    public void set (T value) {...};    public T get() {...};}// not good public final class ThreadLocal {    private ThreadLocal() {};    public static void set (String key, Object value) {...};    public static Object get(String key) {...};}</code></pre><p>We should avoid using String, because it is poor substitutes for other value types, or aggregate types, or capacity types. It is cumbersome, slower, error-prone and inflexible than other types. </p><h2 id="1-6-String-Builder-and-String-Concatenation"><a href="#1-6-String-Builder-and-String-Concatenation" class="headerlink" title="1.6 String Builder and String Concatenation"></a>1.6 String Builder and String Concatenation</h2><p>Use String Builder instead of String Concatenation, due to its poor performance. </p><pre><code>// Good public String firstNamesToString(List&lt;Person&gt; members) {    StringBuilder sb = new StringBuilder();    for (Person p : members) {        sb.append(&quot;[&quot;);        sb.append(p.firstName);        sb.append(&quot;]&quot;);    }    return sb.toString();}// Bad public String firstNamesToString(List&lt;Person&gt; members) {    String s = &quot;&quot;;    for (Person p : members) {        s += &quot;[&quot; + p.firstName + &quot;]&quot;;    }    return s;}</code></pre><h2 id="1-7-Interface-and-Class-reference"><a href="#1-7-Interface-and-Class-reference" class="headerlink" title="1.7 Interface and Class reference"></a>1.7 Interface and Class reference</h2><p>Use of interface reference </p><pre><code>public List&lt;Person&gt; getPeopleByFirstName(List&lt;Person&gt; members, String firstName) {}</code></pre><p>It would be desirable, more flexible and more backward-compatible to use interface types to refer to parameters, return values, variables and fields if appropriate interface types exist. If appropriate interface types do not exist, use least specific class types to refer to parameters, return values, variables and fields if appropriate interface types do not exist. </p><h1 id="2-Objects"><a href="#2-Objects" class="headerlink" title="2. Objects"></a>2. Objects</h1><h2 id="2-1-Static-Factory-Methods-and-Constructors"><a href="#2-1-Static-Factory-Methods-and-Constructors" class="headerlink" title="2.1 Static Factory Methods and Constructors"></a>2.1 Static Factory Methods and Constructors</h2><p>You are designing a class such as Date and you want to allow a client to obtain an instance of the class, given some input such as instant.</p><p>We should use static factory methods because Factory method has following advantages: </p><ol><li>have names </li><li>not required to create a new object each time invoked </li><li>can return an object of any subtype of their return type </li><li>decouple service provider frameworks </li></ol><h2 id="2-2-Builders-and-Constructors"><a href="#2-2-Builders-and-Constructors" class="headerlink" title="2.2 Builders and Constructors"></a>2.2 Builders and Constructors</h2><p>Use builders since it makes code easier for reading</p><h2 id="2-3-Singleton"><a href="#2-3-Singleton" class="headerlink" title="2.3 Singleton"></a>2.3 Singleton</h2><h3 id="2-3-1-Use-of-enum"><a href="#2-3-1-Use-of-enum" class="headerlink" title="2.3.1 Use of enum"></a>2.3.1 Use of enum</h3><pre><code>public enum MySingleton {    INSTANCE;    public void getDataByMarketplaceId(MarketplaceId id) { ... }}</code></pre><h3 id="2-3-2-Use-of-static-factory"><a href="#2-3-2-Use-of-static-factory" class="headerlink" title="2.3.2 Use of static factory"></a>2.3.2 Use of static factory</h3><pre><code>public class MySingleton {    private static final MySingleton INSTANCE = new MySingleton();    private MySingleton() { ... }    public static MySingleton getInstance() { return INSTANCE; }    public void getDataByMarketplaceId(MarketplaceId id) { ... }}</code></pre><h2 id="2-4-Reusable-Objects"><a href="#2-4-Reusable-Objects" class="headerlink" title="2.4 Reusable Objects"></a>2.4 Reusable Objects</h2><pre><code>public class RomanNumber {    private static Pattern ROMAN = Pattern.compile(&quot;^(?=.)M*(C[MD]|D?C{0,3})(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$&quot;);    static boolean isRomanNumber(String s) {        return ROMAN.matcher(s).matches();    }}</code></pre><p>Reuse the expensive objects(here is Pattern), in performace critical situations. </p><h1 id="3-Classes"><a href="#3-Classes" class="headerlink" title="3. Classes"></a>3. Classes</h1><h2 id="3-1-Accessibility-of-Classes-and-Members"><a href="#3-1-Accessibility-of-Classes-and-Members" class="headerlink" title="3.1 Accessibility of Classes and Members"></a>3.1 Accessibility of Classes and Members</h2><p>Avoid using a public array because a nonzero length array is always mutable, and thus clients will be able to modify the elements of the array. </p><h2 id="3-2-Mutability"><a href="#3-2-Mutability" class="headerlink" title="3.2 Mutability"></a>3.2 Mutability</h2><p>In general, classes should be immutable unless there’s a very good reason to make them mutable; and if so, you should minimize mutability when designing and implementing classes. Rules to make a class immutable: </p><ol><li>Don’t provide methods that modify the state of objects that you want to be immutable. </li><li>Ensure that the class cann’t be extended.</li><li>Make all fields final to express your intent clearly</li><li>Make all fields private to prevent clients from obtaining access to mutable objects </li><li>Ensure exclusive access to any mutable components</li></ol><p>Try to use more immutability, since it offers benefits byu nature: </p><ol><li>Immutable objects are simple: providing failure atomicity </li><li>Inherently thread-safe, require no synchronization </li><li>Can share immutable objects freely</li><li>Immutable objects make great building blocks for other objects. </li></ol><h2 id="3-3-Interfaces-and-Abstract-Classes"><a href="#3-3-Interfaces-and-Abstract-Classes" class="headerlink" title="3.3 Interfaces and Abstract Classes"></a>3.3 Interfaces and Abstract Classes</h2><p>In general, use of interfaces is the best way to define a type that permits multiple implementations because a class can implement multiple interfaces whereas it cannot extend multiple abstract classes. </p><h2 id="3-4-Static-Member-Classes"><a href="#3-4-Static-Member-Classes" class="headerlink" title="3.4 Static Member Classes"></a>3.4 Static Member Classes</h2><pre><code>public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable {    ...    static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {        final int hash;        final K key;        V value;        Node&lt;K,V&gt; next;        ...        public final K getKey()        { return key; }        public final V getValue()      { return value; }        ...    }}</code></pre><p>A nested class is a class defined within another class, the former should exist only to serve the latter. If you declare a member class that doesn’t require access to its enclosing instance then always put static modifier in its declaration. </p><p>If you omit this modifier then each instance will have a hidden extraneous reference to its enclosing instance, and storing this reference takes time and space. More seriously, it can result in the enclosing instance being retained when it would be otherwise be eligible for garbage collection, causing catastrophic memory leak.</p><h1 id="4-Methods-and-Generics"><a href="#4-Methods-and-Generics" class="headerlink" title="4. Methods and Generics"></a>4. Methods and Generics</h1><h2 id="4-1-Empty-and-Null-returns"><a href="#4-1-Empty-and-Null-returns" class="headerlink" title="4.1 Empty and Null returns"></a>4.1 Empty and Null returns</h2><p>Never return null in place of an empty array or collection because it will require clients to check null return for all method calls, ugly!</p><h2 id="4-2-Optional-Returns"><a href="#4-2-Optional-Returns" class="headerlink" title="4.2 Optional Returns"></a>4.2 Optional Returns</h2><pre><code>public static &lt;E extends Comparable&lt;E&gt;&gt; Optional&lt;E&gt; max(Collection&lt;E&gt; c) {    if (c.isEmpty()) {        return Optional.empty();    }    E result = null;    for (E e : c) {        if (result == null || e.compareTo(result) &gt; 0) {            result = Objects.requireNonNull(e);        }    }    return Optional.of(result);}</code></pre><p>Since Java 8, an Optional-returning method is possible, more flexible, and easier to use than one that throws an exception; it is also less error-prone than one that returns  null . Here are some best practices when using   Optional :</p><ul><li>Never return a null value from an optinal-returning method because doing so defeats the entire purpose of the facility.</li><li>Use helpers provided by the facility</li></ul><pre><code> String lastWordInLexicon = max(words).orElse(&quot;No words...&quot;); ,   Toy myToy = max(toys).orElseThrow(ToyException::new); </code></pre><ul><li>Container types, including collections, maps, streams, arrays, and optionals, should not be wrapped in optionals, because they have already provided facility to handle empty values.</li><li>Never return an optional of a boxed primitive type, with possible exception of  Boolean ,  Byte ,   Character ,  Short ,  Float . For other boxed primitive types, use  OptionalInt ,   OptionalLong ,  OptionalDouble  instead.</li></ul><h2 id="4-3-Generics-and-Unchecked-Warnings"><a href="#4-3-Generics-and-Unchecked-Warnings" class="headerlink" title="4.3 Generics and Unchecked Warnings"></a>4.3 Generics and Unchecked Warnings</h2><pre><code>public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable {    ...    public &lt;T&gt; T[] toArray(T[] a) {        if (a.length &lt; size) {            @SuppressWarnings(&quot;unchecked&quot;) T[] result = (T[]) Arrays.copyOf(elementData, size, a.getClass());            return result;        }        System.arraycopy(elementData, 0, a, 0, size);        if (a.length &gt; size) {            a[size] = null;        }        return a;    }    ...} </code></pre><p>Unchecked warnings are important; don’t ignore them because every unchecked warning has the potential to throw a   ClassCastException  at runtime. You should do your best to eliminate as many of them as possible. If you can’t, however, get rid of an unchecked warning, but you can prove that the code that provoke it is typesafe then suppress it with the corresponding annotation in the <strong>narrowest possible scope</strong>.</p><p>@SupressWarning: An anotation to surpress compile warnings about unchecked generic operations. </p><h2 id="4-4-Generics-and-Wildcards"><a href="#4-4-Generics-and-Wildcards" class="headerlink" title="4.4 Generics and Wildcards"></a>4.4 Generics and Wildcards</h2><pre><code>public class Stack&lt;E&gt; {    ...    public Stack() { ... }    public void push(E e) { ... }    public E pop() { ... }    public boolean isEmpty { ... }    public void pushAll(Iterable&lt;? extends E&gt; src) {        for (E e : src) {            push(e);        }    }    public void popAll(Collection&lt;? super E&gt; dst) {        while (!isEmpty()) {            dst.add(pop());        }    }}</code></pre><p>It is clear that for maximum flexibility you should use wildcard types on input parameters that represent producers or consumers.</p><ul><li>Remember PECS, which stands for <strong>Producer-Extends and Consumer-Super</strong>. Note that  Comparable  and   Comparator  are always consumers.</li></ul><h1 id="5-Exceptions"><a href="#5-Exceptions" class="headerlink" title="5. Exceptions"></a>5. Exceptions</h1><h2 id="5-1-Checked-Exceptions-and-Unchecked-Exceptions"><a href="#5-1-Checked-Exceptions-and-Unchecked-Exceptions" class="headerlink" title="5.1 Checked Exceptions and Unchecked Exceptions"></a>5.1 Checked Exceptions and Unchecked Exceptions</h2><pre><code>/** * Returns MarketplaceInfo of a given marketplace. * @throws NotFoundException if marketplaceId is not found; do not retry. * @throws ServiceUnavailableException if MarketplaceService does not respond after 3 retries. */public MarketplaceInfo getMarketplaceInfoById(MarketplaceId marketplaceId) {    try {        return getMarketplaceInfoByIdFromLocalCache(marketplaceId);    } catch (IOException e) {        try {            MarketplaceInfo info = getMarketplaceInfoByIdFromRemoteCache(marketplaceId);            putMarketplaceInfoToLocalCache(marketplaceId, info);            return info;        } catch (IOException e) {            for (int numRetries = 0; numRetries &lt; 3; numRetries++) {                try {                    // Call dependent service to get marketplace info                    MarketplaceInfo info = marketplaceService.getMarketplaceInfoById(marketplaceId);                    putMarketplaceInfoToLocalCache(marketplaceId, info);                    putMarketplaceInfoToRemoteCache(marketplaceId, info);                                    return info;                } catch (ServiceUnavailableException e) {                    sleep(5); // sleep 5 seconds before retry                } catch (NotFoundException e) {                    LOG.error(&quot;Unable to get marketplace info because marketplace id {} is not found.&quot;, marketplaceId);                    throw e;                }            }            throw new ServiceUnavailableException(&quot;Unable to get marketplace info after 3 retries.&quot;);        }    }}</code></pre><p>We should: </p><ul><li>throw checked exceptions, a subclass of Exception <ul><li>for recoverable conditions</li></ul></li><li>throw unchecked exceptions, a subclass of runtimeException <ul><li>for programming errors </li></ul></li></ul><p>When in doubt, throw unchecked exceptions. When throwing checked exceptions, add methods to aid in recovery for clients. </p><p>You should declare checked exceptions individually and document precisely the conditions under which each exception is thrown, by using Javadoc  @throws  tag. If the same exception is thrown by many methods in a class for the same reason then you can document it in the class’s documentation comment. In addition, it is particularly important to document unchecked exceptions of methods in interfaces they may throw</p><h2 id="5-2-Exception-Implementation"><a href="#5-2-Exception-Implementation" class="headerlink" title="5.2 Exception Implementation"></a>5.2 Exception Implementation</h2><ul><li>Provide detail as much as possible</li><li>detail msg should contain the values of all parameters and fields that have contributed to the exception </li><li>No sensitive information contained </li></ul><h1 id="6-Lambdas-and-Streams"><a href="#6-Lambdas-and-Streams" class="headerlink" title="6. Lambdas and Streams"></a>6. Lambdas and Streams</h1><h2 id="6-1-Method-references"><a href="#6-1-Method-references" class="headerlink" title="6.1 Method references"></a>6.1 Method references</h2><ul><li><code>Integer::parseInt</code> -&gt; a static method reference for <code>str -&gt; Integer.parseInt(str)</code></li><li><code>Instant.now()::isAfter</code> -&gt; a bound method reference for <code>Instance i = Instant.now(); t -&gt; i.isAfter(t)</code></li><li><code>String::toLowerCase</code> -&gt; an unbound method reference for <code>str -&gt; str.toLowerCase()</code></li><li><code>TreeMap&lt;K, V&gt;::new</code> -&gt; A class constructor for <code>() -&gt; new TreeMap&lt;K, V&gt;</code></li></ul><h1 id="7-Concurrency"><a href="#7-Concurrency" class="headerlink" title="7. Concurrency"></a>7. Concurrency</h1><h2 id="7-1-Synchronize-Access-to-Sharable-Mutable-Data"><a href="#7-1-Synchronize-Access-to-Sharable-Mutable-Data" class="headerlink" title="7.1 Synchronize Access to Sharable Mutable Data"></a>7.1 Synchronize Access to Sharable Mutable Data</h2><p>When multiple threads share mutable data, each thread that reads or writes the data must <strong>perform synchronization</strong>, otherwise there is no guarantee that one thread’s changes of the data will be visible to other threads, and therefore may cause liveness and safety failures. These failures are among the most difficult to debug.<br><code>var ++</code><br>It performs two operations on var : (1) it reads the value, (2) it writes back a new value that is equal to the old value plus one. If a second thread reads the field between the time the first thread reads the old value and writes back the new one, then both threads will see the same value and thus return the same serial number, OUCH; this is a safety failure.</p><p>Note that the best way to avoid safety failure is <strong>not to share mutable data</strong>, meaning share only immutable data or don’t share at all — confine mutable data to a single thread. If you adopt this policy then you should document it carefully, so that the policy is maintained as your program evolves. It is also crucial to have a deep understanding of the frameworks and libraries you’re using because they may introduce threads that you are unaware of.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-General-Programming&quot;&gt;&lt;a href=&quot;#1-General-Programming&quot; class=&quot;headerlink&quot; title=&quot;1. General Programming&quot;&gt;&lt;/a&gt;1. General Programming
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
  </entry>
  
</feed>
