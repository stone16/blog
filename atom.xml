<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Leilei&#39;s Blog | 磊磊的博客</title>
  
  <subtitle>Because it&#39;s there</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.llchen60.com/"/>
  <updated>2020-05-21T20:34:49.944Z</updated>
  <id>https://www.llchen60.com/</id>
  
  <author>
    <name>Leilei Chen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何高效开Design Meetings</title>
    <link href="https://www.llchen60.com/%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E5%BC%80Design-Meetings/"/>
    <id>https://www.llchen60.com/%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E5%BC%80Design-Meetings/</id>
    <published>2020-05-21T20:33:43.000Z</published>
    <updated>2020-05-21T20:34:49.944Z</updated>
    
    <content type="html"><![CDATA[<p>能靠规范做的事情就尽量不要靠直觉，把直觉用在更需要直觉的地方吧。</p><p>工作的日常一定少不了开会的，但是你会有感觉到有一些会议效率非常高，你带着问题来开会，问题迅速被解决，每个人都对下一步很清晰，然后会议结束。但是我们也时常经历完全相反的过程，你带着问题进入，但是问题没有被解答，每个人变得更加困惑的结束会议。</p><p>问题在于，如何能够确保我们的会议是有效率的，能够解决问题的，这需要一些规则和日程上的安排，来确保其效率。</p><h1 id="1-清晰认知会议的类型"><a href="#1-清晰认知会议的类型" class="headerlink" title="1. 清晰认知会议的类型"></a>1. 清晰认知会议的类型</h1><p>在项目的设计过程当中，我们可以根据输入和输出将会议分为三个主要的类型：定义，设计与开发</p><h2 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h2><p>定义类型的会议指的是开展一个新项目，以及设定需求的过程。在这个会议当中，我们需要定义：</p><ul><li>问题是什么</li><li>用户是谁</li><li>有哪些限制</li><li>时间轴</li></ul><p>一般来说，需求定义的会议参加的人数少效果会更加理想一些，比如只带产品经理以及设计师。</p><h2 id="1-2-设计"><a href="#1-2-设计" class="headerlink" title="1.2 设计"></a>1.2 设计</h2><p>设计是个交互的过程，会需要大量的和产品，设计，技术来进行交流。可以将整个设计过程划分为以下的步骤：</p><ul><li><p>调研 (Research)</p><ul><li>看看问题和用户是否已经被定义了，花点时间去看看其他人是如何解决这个问题的（不仅限于你的公司，包括工业界）</li></ul></li><li><p>草拟 (Sketch)</p><ul><li>探索不同的选择，然后判断哪一个能够满足需求</li></ul></li><li><p>反馈 (Feedback)</p><ul><li>注意想要得到哪方面的反馈 </li><li>最好专注在某一个方向上</li></ul></li><li><p>迭代 (Refine)</p><ul><li>根据时间轴不断获取反馈，完成迭代</li></ul></li></ul><p>设计会议的关键在于需求解决哪方面的问题，我们需要聚焦于这个问题。对于不同的设计的选择，我们需要从开发者那里拿到反馈。</p><h2 id="1-3-开发"><a href="#1-3-开发" class="headerlink" title="1.3 开发"></a>1.3 开发</h2><p>当我们进入这部分的会议的时候，我们已经有了大致上的设计的思路，这个时候会更多的考虑一些edge case，还有技术上的限制。这里会有一些技术和设计方面的权衡，我们可能会需要调整我们的设计，来满足从技术角度的考量。设计和产品需要一直参与在这个过程当中，以保证哪怕细节上有调整，但是设计的初衷/理念不会被改变。</p><h1 id="2-邀请正确的人"><a href="#2-邀请正确的人" class="headerlink" title="2. 邀请正确的人"></a>2. 邀请正确的人</h1><p>我们需要很清楚这个会议是关于什么的，以及谁应该出现在这里。一个组往往可能会有3 - 10人左右，一般来说，让10个人全都出现在会议当中不是很有效率的方式，我们需要一个模型来决定谁应该出现在会议当中。 </p><p>Decide, Console, Inform模型</p><h2 id="2-1-决策"><a href="#2-1-决策" class="headerlink" title="2.1 决策"></a>2.1 决策</h2><p>决策者是可以对项目付出时间精力以及金钱的人。他们会最终决定要做什么，以及为什么要这样做。我们需要将所有的决策者带入到会议室当中，这样如果相互之间有不同意见，可以很及时的解决。并且提供下一步。</p><p>这种时候，往往相对比较小的会议更容易达成好的结果，即只带入必要的人，一般来说，是产品的带头人，设计的带头人，以及技术方面的带头人。</p><h2 id="2-2-咨询"><a href="#2-2-咨询" class="headerlink" title="2.2 咨询"></a>2.2 咨询</h2><p>这里指的是对这个领域很了解的人，他们会提出很有价值的建议，不过决定权还在决策者手中。比如几种技术方案的最终选择，就需要引入对框架，各种方法很熟悉的工程师来给出建议了。</p><h2 id="2-3-通知"><a href="#2-3-通知" class="headerlink" title="2.3 通知"></a>2.3 通知</h2><p>组里的一员，被邀请 == 被通知，lol </p><h1 id="3-按照时间安排展开会议"><a href="#3-按照时间安排展开会议" class="headerlink" title="3. 按照时间安排展开会议"></a>3. 按照时间安排展开会议</h1><p>我们需要十分清楚这个会议的目的是什么，我们最终想达到什么样的成果</p><ul><li>我们解决了什么样的问题</li><li>我们可以做出什么样的决定</li><li>下一步措施是什么</li></ul><p>一些比较好的行为，强烈推荐：</p><ul><li><p>会议前</p><ul><li>发送邮件，给出安排</li><li>给出相关的链接，使得参会人可以在参会前可以做一些准备</li></ul></li><li><p>会议开始</p><ul><li>说整个会议的安排<ul><li>比如想看看几种设计</li><li>需要基于什么什么得到反馈</li><li>下一步</li></ul></li></ul></li><li><p>会议结束</p><ul><li>总结反馈 以及下一步<ul><li>在会议还剩下5min左右的时候来做总结和下一步计划</li><li>总结获得的反馈，和决定  这样子如果我们忘记了一些东西，其他人可以给我们做补充</li><li>问下一步是什么，以及每一步的负责人</li></ul></li></ul></li><li><p>会议后</p><ul><li>发送邮件总结会议<ul><li>讨论了什么</li><li>下了什么决定</li><li>下一步工作，是什么，谁来做</li></ul></li></ul></li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://blog.prototypr.io/3-tips-to-run-effective-design-meetings-dec2ec238b56" target="_blank" rel="noopener">https://blog.prototypr.io/3-tips-to-run-effective-design-meetings-dec2ec238b56</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;能靠规范做的事情就尽量不要靠直觉，把直觉用在更需要直觉的地方吧。&lt;/p&gt;
&lt;p&gt;工作的日常一定少不了开会的，但是你会有感觉到有一些会议效率非常高，你带着问题来开会，问题迅速被解决，每个人都对下一步很清晰，然后会议结束。但是我们也时常经历完全相反的过程，你带着问题进入，但是问
      
    
    </summary>
    
    
      <category term="Notes" scheme="https://www.llchen60.com/categories/Notes/"/>
    
    
      <category term="meeting" scheme="https://www.llchen60.com/tags/meeting/"/>
    
      <category term="tips" scheme="https://www.llchen60.com/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>Enzyme -- React测试库</title>
    <link href="https://www.llchen60.com/Enzyme-React%E6%B5%8B%E8%AF%95%E5%BA%93/"/>
    <id>https://www.llchen60.com/Enzyme-React%E6%B5%8B%E8%AF%95%E5%BA%93/</id>
    <published>2020-05-18T23:06:42.000Z</published>
    <updated>2020-05-18T23:07:22.568Z</updated>
    
    <content type="html"><![CDATA[<p>这是前端用于对React的组件进行测试的一个工具类，我们可以使用这个工具来遍历，控制，以及一定程度上的模拟运行时输出。我们主要是将该工具类和Jest一起使用，写我们的react组件的单元测试们。</p><h1 id="1-Shalow-Rendering"><a href="#1-Shalow-Rendering" class="headerlink" title="1. Shalow Rendering"></a>1. Shalow Rendering</h1><p>用于以单个组件为单元来进行测试，然后确保你的测试不会依赖于子组件的状态。从Enzyme v3开始，shallow API会call React生命周期方法了，譬如<code>componentDidUpdate</code>和<code>componentDidMount</code></p><pre><code>import { shallow } from &#39;enzyme&#39;;import sinon from &#39;sinon&#39;;import Foo from &#39;./Foo&#39;;describe(&#39;&lt;MyComponent /&gt;&#39;, () =&gt; {  it(&#39;renders three &lt;Foo /&gt; components&#39;, () =&gt; {    const wrapper = shallow(&lt;MyComponent /&gt;);    expect(wrapper.find(Foo)).to.have.lengthOf(3);  });  it(&#39;renders an `.icon-star`&#39;, () =&gt; {    const wrapper = shallow(&lt;MyComponent /&gt;);    expect(wrapper.find(&#39;.icon-star&#39;)).to.have.lengthOf(1);  });  it(&#39;renders children when passed in&#39;, () =&gt; {    const wrapper = shallow((      &lt;MyComponent&gt;        &lt;div className=&quot;unique&quot; /&gt;      &lt;/MyComponent&gt;    ));    expect(wrapper.contains(&lt;div className=&quot;unique&quot; /&gt;)).to.equal(true);  });  it(&#39;simulates click events&#39;, () =&gt; {    const onButtonClick = sinon.spy();    const wrapper = shallow(&lt;Foo onButtonClick={onButtonClick} /&gt;);    wrapper.find(&#39;button&#39;).simulate(&#39;click&#39;);    expect(onButtonClick).to.have.property(&#39;callCount&#39;, 1);  });});</code></pre><p><a href="https://enzymejs.github.io/enzyme/docs/api/shallow.html" target="_blank" rel="noopener">API Reference</a></p><h1 id="2-Full-Dom-Rendering"><a href="#2-Full-Dom-Rendering" class="headerlink" title="2. Full Dom Rendering"></a>2. Full Dom Rendering</h1><p>这种测试方式在你需要和DOM API进行交互，或者需要测试在更高次位的组件的时候非常有用。</p><p>需要运行在浏览器环境当中，如果无法运行在真实的浏览器当中，那我们就需要依赖于<code>mount</code>指令，在指令之下，是调用了一个叫做jsdom的包，完全使用JavaScript实现了一个浏览器。</p><p>值得注意的是，full dom rendering是真实的将当前组件渲染到DOM树当中，这也意味着如果用的是同一棵DOM树，那么你做的改动很可能会影响其他的测试，这点是值得我们注意的。</p><pre><code>import { mount } from &#39;enzyme&#39;;import sinon from &#39;sinon&#39;;import Foo from &#39;./Foo&#39;;describe(&#39;&lt;Foo /&gt;&#39;, () =&gt; {  it(&#39;calls componentDidMount&#39;, () =&gt; {    sinon.spy(Foo.prototype, &#39;componentDidMount&#39;);    const wrapper = mount(&lt;Foo /&gt;);    expect(Foo.prototype.componentDidMount).to.have.property(&#39;callCount&#39;, 1);  });  it(&#39;allows us to set props&#39;, () =&gt; {    const wrapper = mount(&lt;Foo bar=&quot;baz&quot; /&gt;);    expect(wrapper.props().bar).to.equal(&#39;baz&#39;);    wrapper.setProps({ bar: &#39;foo&#39; });    expect(wrapper.props().bar).to.equal(&#39;foo&#39;);  });  it(&#39;simulates click events&#39;, () =&gt; {    const onButtonClick = sinon.spy();    const wrapper = mount((      &lt;Foo onButtonClick={onButtonClick} /&gt;    ));    wrapper.find(&#39;button&#39;).simulate(&#39;click&#39;);    expect(onButtonClick).to.have.property(&#39;callCount&#39;, 1);  });});</code></pre><p><a href="https://enzymejs.github.io/enzyme/docs/api/mount.html" target="_blank" rel="noopener">API Reference</a></p><h1 id="3-Static-Rendering"><a href="#3-Static-Rendering" class="headerlink" title="3. Static Rendering"></a>3. Static Rendering</h1><p>Render 使用的是Cheerio这个HTML转化库，用于从我们的React树来生成HTML，然后分析HTML的整个架构。</p><pre><code>import React from &#39;react&#39;;import { render } from &#39;enzyme&#39;;import PropTypes from &#39;prop-types&#39;;describe(&#39;&lt;Foo /&gt;&#39;, () =&gt; {  it(&#39;renders three `.foo-bar`s&#39;, () =&gt; {    const wrapper = render(&lt;Foo /&gt;);    expect(wrapper.find(&#39;.foo-bar&#39;)).to.have.lengthOf(3);  });  it(&#39;rendered the title&#39;, () =&gt; {    const wrapper = render(&lt;Foo title=&quot;unique&quot; /&gt;);    expect(wrapper.text()).to.contain(&#39;unique&#39;);  });  it(&#39;renders a div&#39;, () =&gt; {    const wrapper = render(&lt;div className=&quot;myClass&quot; /&gt;);    expect(wrapper.html()).to.contain(&#39;div&#39;);  });  it(&#39;can pass in context&#39;, () =&gt; {    function SimpleComponent(props, context) {      const { name } = context;      return &lt;div&gt;{name}&lt;/div&gt;;    }    SimpleComponent.contextTypes = {      name: PropTypes.string,    };    const context = { name: &#39;foo&#39; };    const wrapper = render(&lt;SimpleComponent /&gt;, { context });    expect(wrapper.text()).to.equal(&#39;foo&#39;);  });});</code></pre><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://enzymejs.github.io/enzyme/" target="_blank" rel="noopener">https://enzymejs.github.io/enzyme/</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是前端用于对React的组件进行测试的一个工具类，我们可以使用这个工具来遍历，控制，以及一定程度上的模拟运行时输出。我们主要是将该工具类和Jest一起使用，写我们的react组件的单元测试们。&lt;/p&gt;
&lt;h1 id=&quot;1-Shalow-Rendering&quot;&gt;&lt;a href
      
    
    </summary>
    
    
      <category term="FrontEnd" scheme="https://www.llchen60.com/categories/FrontEnd/"/>
    
    
      <category term="Enzyme" scheme="https://www.llchen60.com/tags/Enzyme/"/>
    
  </entry>
  
  <entry>
    <title>应用设计 Practice</title>
    <link href="https://www.llchen60.com/%E5%BA%94%E7%94%A8%E8%AE%BE%E8%AE%A1-Practice/"/>
    <id>https://www.llchen60.com/%E5%BA%94%E7%94%A8%E8%AE%BE%E8%AE%A1-Practice/</id>
    <published>2020-05-17T20:03:10.000Z</published>
    <updated>2020-05-20T00:12:33.088Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-thought"><a href="#1-thought" class="headerlink" title="1. thought"></a>1. thought</h1><p>实际应用设计，首先还是需要将工作进行合理分割：</p><ul><li>前期需求沟通分析<ul><li>工程师应该尽量参与到产品设计当中</li><li>寻找类似的产品，进行借鉴</li><li>将借鉴来的东西努力融合到我们自己的产品当中</li></ul></li><li>中期代码设计实现</li><li>后期系统上线维护 <h1 id="2-业务系统设计-–-积分系统"><a href="#2-业务系统设计-–-积分系统" class="headerlink" title="2. 业务系统设计 – 积分系统"></a>2. 业务系统设计 – 积分系统</h1></li></ul><h2 id="2-1-业务需求"><a href="#2-1-业务需求" class="headerlink" title="2.1 业务需求"></a>2.1 业务需求</h2><ul><li><p>功能点</p><ul><li>赚取积分<ul><li>积分赚取渠道<ul><li>订单</li><li>签到</li><li>评论</li></ul></li><li>积分兑换规则<ul><li>订单金额与积分的兑换比例</li><li>签到赠送积分数量等</li></ul></li></ul></li><li>消费积分<ul><li>积分消费渠道<ul><li>抵扣订单金额</li><li>兑换优惠券</li><li>积分换购</li><li>参与活动</li></ul></li></ul></li></ul></li><li><p>方式方法</p><ul><li>借鉴已经相对成熟的产品<ul><li>看其实现的方式方法</li></ul></li><li>通过产品线框图</li><li>user case<ul><li>模拟用户是如何使用我们的产品的</li><li>描述用户在特定的应用场景当中的一个完整的业务操作流程</li></ul></li></ul></li></ul><h2 id="2-2-系统设计"><a href="#2-2-系统设计" class="headerlink" title="2.2 系统设计"></a>2.2 系统设计</h2><h3 id="2-2-1-功能模块划分"><a href="#2-2-1-功能模块划分" class="headerlink" title="2.2.1 功能模块划分"></a>2.2.1 功能模块划分</h3><ul><li>将功能划分到不同的模块当中 <ul><li>做到模块层面的高内聚，低耦合</li></ul></li></ul><ul><li>针对上述的业务需求，我们可以采用<ul><li><ol><li>将关于积分的赚取消费的规则的管理维护放到更上层的营销系统当中，这样积分系统就只负责增删改查的数据库操作了</li></ol></li><li><ol start="2"><li>将规则分散到各个子系统当中，譬如订单系统，评论系统，签到系统，诸如此类</li></ol></li><li><ol start="3"><li>所有功能划分到积分系统当中</li></ol></li></ul></li></ul><p>值得注意的是，为了避免业务知识的耦合，让下层系统更加通用，我们不希望下层系统（被调用系统）包含太多上层系统（调用系统）的业务信息。但上层系统是可以包含下层系统的业务信息的，比如，订单系统、优惠券系统、换购商城等作为调用积分系统的上层系统，可以包含一些积分相关的业务信息。但是，反过来，积分系统中最好不要包含太多跟订单、优惠券、换购等相关的信息。</p><p>因此，1，2都是相对不错的选择，我们希望做的是让积分系统模块只包含积分的增删改查的操作，而不包含太多的业务层面的逻辑。</p><h3 id="2-2-2-模块间交互"><a href="#2-2-2-模块间交互" class="headerlink" title="2.2.2 模块间交互"></a>2.2.2 模块间交互</h3><p>定位需要和积分系统之间进行交互的系统，以及交互方式。</p><p>一般来说，系统之间的交互方式有两大类：</p><ul><li>同步接口调用</li><li>利用信息中间件异步调用</li></ul><h3 id="2-2-3-设计模块的接口、数据库、业务模型"><a href="#2-2-3-设计模块的接口、数据库、业务模型" class="headerlink" title="2.2.3 设计模块的接口、数据库、业务模型"></a>2.2.3 设计模块的接口、数据库、业务模型</h3><p>数据库和接口的设计相对来说都比较重要，一旦设计好，都不能轻易改动。尤其是当有不同的组来调用你的API的时候，让所有的组都快速迁移到新的API上是一件相对比较困难的事情了。  改动数据库表的结构，需要涉及数据的迁移和适配。</p><p>而业务模型，即业务逻辑代码，因为都是内部使用，改动的可能性比较大，对外是不可见的。</p><ul><li><p>数据库设计：</p><ul><li>id - 明细ID</li><li>user_id - 用户ID</li><li>channel_id - 赚取或消费渠道ID</li><li>event_id - 相关事件ID，例如订单ID，评论ID，优惠券换购ID等</li><li>credit - 积分 </li><li>create_time - 积分赚取或消费时间</li><li>expired_time - 积分过期时间</li></ul></li><li><p>接口设计</p><ul><li>单一职责原则 <ul><li>但是粒度太小也不好，比如一个功能的实现需要多个接口，但是每个接口如果都是RPC的一次远程调用的话，那网络上的损耗就很多，多次远程调用会影响性能的</li><li>另外还有数据一致性 - 即操作的原子性方面的考量</li><li>可以借鉴facade外观设计模式，在职责单一的细粒度接口之上，封装一层粗粒度的接口给外部使用</li></ul></li></ul></li><li><p>MVC </p><ul><li>controller负责接口暴露</li><li>service 负责核心业务逻辑</li><li>repository负责数据读写</li><li>为什么要分成MVC三层？<ul><li>代码复用</li><li>隔离变化</li><li>隔离关注点</li><li>提高代码的可测试性</li><li>能够应对系统的复杂性</li></ul></li></ul></li></ul><h1 id="3-非业务通用框架设计"><a href="#3-非业务通用框架设计" class="headerlink" title="3. 非业务通用框架设计"></a>3. 非业务通用框架设计</h1><p>假设我们要设计开发一个小框架，来获取接口调用的各种统计信息。</p><ul><li>响应时间<ul><li>max/ min/ avg/ percentile/ count/ tps </li></ul></li></ul><h2 id="3-1-需求分析"><a href="#3-1-需求分析" class="headerlink" title="3.1 需求分析"></a>3.1 需求分析</h2><p>是一个和业务无关的独立功能，我们可以将其开发成一个独立的框架或者库，集成到很多的业务系统当中。作为一个需要复用性的框架，除了功能上的需求以外，非功能性的需求也非常重要。</p><ul><li><p>功能性需求分析</p><ul><li><p>接口统计信息</p><ul><li>响应时间</li><li>接口调用次数</li></ul></li><li><p>统计信息的类型</p><ul><li>max min ave percentile tps count </li></ul></li><li><p>统计信息显示格式</p><ul><li>json</li><li>html</li><li>自定义</li></ul></li><li><p>统计信息显示终端</p><ul><li>console</li><li>email</li><li>http 页面</li><li>日志</li><li>自定义</li></ul></li><li><p>统计触发方式</p></li><li><p>统计时间区间</p></li><li><p>统计时间间隔</p></li></ul></li></ul><ul><li><p>非功能性需求分析</p><ul><li><p>易用性</p><ul><li>框架是否易集成，易拔插</li><li>跟业务代码是否为松耦合</li><li>提供的接口是否足够灵活</li></ul></li><li><p>性能</p><ul><li>不希望框架本身的代码执行效率会对业务系统有太多性能上的影响</li><li>希望框架低延迟，并且对内存的消耗不能太大</li></ul></li><li><p>扩展性</p><ul><li>在不修改或者尽量少修改代码的情况下添加新功能的能力</li></ul></li><li><p>容错性</p></li><li><p>通用性</p><ul><li>除了接口数据统计，能否将其放到其他事件上来做统计呢？ </li></ul></li></ul></li></ul><h2 id="3-2-框架设计"><a href="#3-2-框架设计" class="headerlink" title="3.2 框架设计"></a>3.2 框架设计</h2><p>可以借鉴TDD (测试驱动开发)和Prototype(最小原型)的思想，先聚焦于一个简单的应用场景，基于此来设计一个简单的原型，然后不断进行迭代。</p><p>而后是将整个框架分为多个模块，分模块进行思考：</p><ul><li>数据采集<ul><li>打点采集原始数据</li><li>记录每次接口请求的响应时间和请求时间</li><li>数据采集过程要高度容错，不能影响到接口本身的可用性</li></ul></li><li>存储<ul><li>负责将采集的原始数据保存下来，以便后面做聚合统计</li><li>数据可以存储在<ul><li>redis</li><li>mysql</li><li>hbase</li><li>日志</li><li>文件</li><li>内存</li></ul></li></ul></li><li>聚合统计<ul><li>将原始数据聚合为统计数据</li></ul></li><li>显示<ul><li>将统计数据以某种格式显示到终端当中</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-thought&quot;&gt;&lt;a href=&quot;#1-thought&quot; class=&quot;headerlink&quot; title=&quot;1. thought&quot;&gt;&lt;/a&gt;1. thought&lt;/h1&gt;&lt;p&gt;实际应用设计，首先还是需要将工作进行合理分割：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前期需
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="System Design" scheme="https://www.llchen60.com/tags/System-Design/"/>
    
  </entry>
  
  <entry>
    <title>Jest - JS测试框架</title>
    <link href="https://www.llchen60.com/Jest-JS%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
    <id>https://www.llchen60.com/Jest-JS%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/</id>
    <published>2020-05-14T04:31:23.000Z</published>
    <updated>2020-05-15T04:11:30.500Z</updated>
    
    <content type="html"><![CDATA[<p>JJest是一个简洁的JavaScript测试框架，我们可以将其与Babel, TS, Node, React, Angular, Vue等来共同使用</p><h1 id="1-Intro"><a href="#1-Intro" class="headerlink" title="1. Intro"></a>1. Intro</h1><p>首先jest是希望能够用很轻量的方式来进行前端测试，自己最近在做一个偏向前端的项目，希望把组里的对外页面从其他平台转移出来，通过router完成路径的转接，然后在自己的平台上，就可以更自由，更快捷的进行迭代了。</p><p>整个架构还是RPC 暴露RESTFul接口，用类似于API Gateway的系统完成Authorization Authentication的工作，前端直接调用后端的信息这样子。想要达到的最终的目标就是易于维护且易于扩展的一个前端小平台，几个基本需求，也是要做转移的原因：</p><ul><li><p>前端的埋点，希望有更多的metrics以知道用户的行为</p><ul><li>各个页面的浏览时长</li><li>跳出率</li><li>哪个步骤过滤走了最多的用户请求，诸如此类</li></ul></li><li><p>CI/ CD</p><ul><li>手动QA太容易犯错了，如果能写一部分unit tests &amp; integration tests,实现整个前端页面的可测试，那么就可以实现持续继承持续部署，会很大程度上提高可交付能力</li></ul></li><li><p>访问速度</p><ul><li>利用S3 host页面，使用CDN完成分布，会提高整体的响应速度</li></ul></li></ul><p>Jest是实现CI/CD的很不错的一个工具，on my way learning it ;) </p><h2 id="1-1-匹配器"><a href="#1-1-匹配器" class="headerlink" title="1.1 匹配器"></a>1.1 匹配器</h2><p>与Junit类似，使用expect做关键词，E.G</p><pre><code>test(&#39;two plus two is four&#39;, () =&gt; {  expect(2 + 2).toBe(4);});</code></pre><ul><li><p>toBe </p><ul><li>匹配器，内部使用的是<code>Object.is</code>来做精确相等</li></ul></li><li><p>toEqual</p><ul><li>来检查对象的值</li></ul></li><li><p>比较真实性</p><ul><li>toBeNull</li><li>toBeUndefined</li><li>toBeTruthy<ul><li>匹配任何if语句为真</li></ul></li><li>toBeFalsy <ul><li>匹配任何if语句为假 </li></ul></li></ul></li><li><p>比较数字</p><ul><li>toBeGreaterThan()</li><li>toBeGreaterThanOrEqual()</li><li>toBeLessThan()</li><li>toBeLessThanOrEqual()</li><li>toBe()</li><li>toEqual()</li></ul></li><li><p>字符串</p><ul><li>toMatch()  match一个正则表达式</li></ul></li><li><p>数组 </p><ul><li>toContain() 检查一个数组或可迭代的对象是否包含某个特定项</li></ul></li></ul><pre><code>const shoppingList = [  &#39;diapers&#39;,  &#39;kleenex&#39;,  &#39;trash bags&#39;,  &#39;paper towels&#39;,  &#39;beer&#39;,];test(&#39;the shopping list has beer on it&#39;, () =&gt; {  expect(shoppingList).toContain(&#39;beer&#39;);  expect(new Set(shoppingList)).toContain(&#39;beer&#39;);});</code></pre><h2 id="1-2-测试异步代码"><a href="#1-2-测试异步代码" class="headerlink" title="1.2 测试异步代码"></a>1.2 测试异步代码</h2><pre><code>// 对于回调函数的测试test(&#39;the data is peanut butter&#39;, done =&gt; {  function callback(data) {    try {      expect(data).toBe(&#39;peanut butter&#39;);      done();    } catch (error) {      done(error);    }  }  fetchData(callback);});// Promisestest(&#39;the data is peanut butter&#39;, () =&gt; {  return fetchData().then(data =&gt; {    expect(data).toBe(&#39;peanut butter&#39;);  });});// Resolve/ rejecttest(&#39;the data is peanut butter&#39;, () =&gt; {  return expect(fetchData()).resolves.toBe(&#39;peanut butter&#39;);});// async/ awaittest(&#39;the data is peanut butter&#39;, async () =&gt; {  const data = await fetchData();  expect(data).toBe(&#39;peanut butter&#39;);});test(&#39;the fetch fails with an error&#39;, async () =&gt; {  expect.assertions(1);  try {    await fetchData();  } catch (e) {    expect(e).toMatch(&#39;error&#39;);  }});</code></pre><h2 id="1-3-测试前后的utility方法"><a href="#1-3-测试前后的utility方法" class="headerlink" title="1.3 测试前后的utility方法"></a>1.3 测试前后的utility方法</h2><ul><li>重复设置值 </li></ul><pre><code>beforeEach(() =&gt; {});afterEach(() =&gt; {});</code></pre><ul><li><p>一次性设置 – 单个测试不会改变其值</p><p>  beforeAll(() =&gt; {</p><p>  });</p><p>  afterAll(() =&gt; {</p><p>  });</p></li><li><p>作用域 </p><ul><li>通过describe来将测试进行分组操作 </li><li>注意describe的执行顺序 <ul><li>在真正的测试开始之前执行测试文件当中的所有的describe处理程序</li><li>当describe块运行完后，Jest会按照test出现的顺序依次运行所有测试，等待每一个测试完成并整理好，然后继续往下走</li></ul></li><li>通用建议<ul><li>当测试失败的时候，首先要检查的是如果仅运行这条测试，是否仍然失败</li><li>通过将test指令改为test.only指令来实现</li></ul></li></ul></li></ul><h2 id="1-4-Mock-方法"><a href="#1-4-Mock-方法" class="headerlink" title="1.4 Mock 方法"></a>1.4 Mock 方法</h2><p>Mock函数允许我们来测试代码之间的连接，和Mockito， EasyMock其实是一个理念的，擦除函数的实际实现，专注于当前的文件的方法本身，捕获对函数的调用，实例等</p><pre><code>function forEach(items, callback) {  for (let index = 0; index &lt; items.length; index++) {    callback(items[index]);  }}const mockCallback = jest.fn(x =&gt; 42 + x);forEach([0, 1], mockCallback);// 此 mock 函数被调用了两次expect(mockCallback.mock.calls.length).toBe(2);// 第一次调用函数时的第一个参数是 0expect(mockCallback.mock.calls[0][0]).toBe(0);// 第二次调用函数时的第一个参数是 1expect(mockCallback.mock.calls[1][0]).toBe(1);// 第一次函数调用的返回值是 42expect(mockCallback.mock.results[0].value).toBe(42);</code></pre><h1 id="2-测试方法"><a href="#2-测试方法" class="headerlink" title="2. 测试方法"></a>2. 测试方法</h1><h2 id="2-1-Snapshot-测试"><a href="#2-1-Snapshot-测试" class="headerlink" title="2.1 Snapshot 测试"></a>2.1 Snapshot 测试</h2><p>给当前的UI做快照，然后和过去做过的快照进行比较，看是否有不同。</p><pre><code>import React from &#39;react&#39;;import Link from &#39;../Link.react&#39;;import renderer from &#39;react-test-renderer&#39;;it(&#39;renders correctly&#39;, () =&gt; {  const tree = renderer    .create(&lt;Link page=&quot;http://www.facebook.com&quot;&gt;Facebook&lt;/Link&gt;)    .toJSON();  expect(tree).toMatchSnapshot();});</code></pre><p>实际上是生成一个DOM树，然后来比较两颗DOM树的节点，看设置是否相同。</p><p>在每次提交的时候，会记录下当前的快照，下次提交的时候会和这次的来进行比较。</p><p>然后当我们有目的的引入了变化的时候，我们需要告诉jest 需要更新现在保存的snapshot了，这种情况下需要运行指令<code>jest --updateSnapshot</code>.</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://jestjs.io/docs/en/getting-started" target="_blank" rel="noopener">https://jestjs.io/docs/en/getting-started</a> </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JJest是一个简洁的JavaScript测试框架，我们可以将其与Babel, TS, Node, React, Angular, Vue等来共同使用&lt;/p&gt;
&lt;h1 id=&quot;1-Intro&quot;&gt;&lt;a href=&quot;#1-Intro&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="FrontEnd" scheme="https://www.llchen60.com/categories/FrontEnd/"/>
    
    
      <category term="Jest" scheme="https://www.llchen60.com/tags/Jest/"/>
    
  </entry>
  
  <entry>
    <title>好玩的网站列表</title>
    <link href="https://www.llchen60.com/%E5%A5%BD%E7%8E%A9%E7%9A%84%E7%BD%91%E7%AB%99%E5%88%97%E8%A1%A8/"/>
    <id>https://www.llchen60.com/%E5%A5%BD%E7%8E%A9%E7%9A%84%E7%BD%91%E7%AB%99%E5%88%97%E8%A1%A8/</id>
    <published>2020-05-13T04:33:52.000Z</published>
    <updated>2020-05-20T04:56:17.720Z</updated>
    
    <content type="html"><![CDATA[<p>好玩的东西，持续更新~ </p><ul><li>digital nomad<ul><li>以数字技术为生，搬到风景优美，气候温和，物价便宜的地方，做自己想做的事情，这概念有意思的</li><li><a href="https://nomadlist.com/" target="_blank" rel="noopener">https://nomadlist.com/</a> </li></ul></li><li>Regex 101 <ul><li>神一样的正则网站，可以做在线debug</li><li><a href="https://regex101.com/" target="_blank" rel="noopener">https://regex101.com/</a> </li></ul></li><li>中国互联网中讨论的消亡<ul><li><a href="https://mp.weixin.qq.com/s/a-32UpINmb_vSj17epysiA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/a-32UpINmb_vSj17epysiA</a></li></ul></li><li>经济机器是怎样运行的 by Ray Dalio <ul><li>在2020年对着现在的经济形势看，别有一番滋味 lol</li><li>tips<ul><li>不要让债务的增长速度超过收入</li><li>不要让收入的增长速度超过生产率</li><li>尽一切努力提高生产率</li></ul></li><li><a href="https://www.bilibili.com/video/av6496369/" target="_blank" rel="noopener">https://www.bilibili.com/video/av6496369/</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;好玩的东西，持续更新~ &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;digital nomad&lt;ul&gt;
&lt;li&gt;以数字技术为生，搬到风景优美，气候温和，物价便宜的地方，做自己想做的事情，这概念有意思的&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://nomadlist.com/&quot; ta
      
    
    </summary>
    
    
      <category term="Notes" scheme="https://www.llchen60.com/categories/Notes/"/>
    
    
  </entry>
  
  <entry>
    <title>中台(三) - 看白话中台系列的一些总结</title>
    <link href="https://www.llchen60.com/%E4%B8%AD%E5%8F%B0-%E4%B8%89-%E7%9C%8B%E7%99%BD%E8%AF%9D%E4%B8%AD%E5%8F%B0%E7%B3%BB%E5%88%97%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/"/>
    <id>https://www.llchen60.com/%E4%B8%AD%E5%8F%B0-%E4%B8%89-%E7%9C%8B%E7%99%BD%E8%AF%9D%E4%B8%AD%E5%8F%B0%E7%B3%BB%E5%88%97%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/</id>
    <published>2020-05-12T03:36:52.000Z</published>
    <updated>2020-05-12T03:40:08.892Z</updated>
    
    <content type="html"><![CDATA[<p>前面两篇文章讲了一些关于中台的信息, <a href="https://llchen60.com/%E4%B8%AD%E5%8F%B0/" target="_blank" rel="noopener">中台1</a>,<a href="https://llchen60.com/%E4%B8%AD%E5%8F%B0-%E4%BA%8C-%E7%95%A5%E6%B7%B1%E5%85%A5%E4%BA%9B%E7%9A%84%E6%8E%A2%E7%A9%B6/" target="_blank" rel="noopener">中台2</a>。</p><ul><li><p>为什么需要平台化</p><ul><li>赋予企业用户响应力</li></ul></li><li><p>什么是中台</p><ul><li><strong>企业级能力复用平台</strong></li><li>基础的理念和架构</li><li>可以联通，支持上端的业务</li><li>需要能够将后台各式各样的资源转化为前台易于使用的能力 –&gt; 以用户为中心的持续规模化创新</li><li>Platform as a product </li><li>亚马逊大量使用微服务，关于微服务与中台，可以想象成中台是多个有平台化能力的微服务的集合，通过隐藏内部的信息和不必要的接口，对外呈现为单独一个具有平台服务能力的微服务。</li></ul></li><li><p>中台分类/ 为什么要建平台</p><ul><li>内部研发效能提升</li><li>资源整合</li><li>新零售</li><li>全周期</li><li>全渠道</li><li>开放银行</li><li>多品牌战略</li><li>全球化战略</li><li>产业互联</li><li>构建商业生态</li></ul></li><li><p>阿里的数据业务双中台</p><ul><li>业务中台将后台资源进行抽象包装整合，转化为前台友好的可重用可共享的核心能力，实现后端业务资源到前台易用能力的转化</li><li>数据中台从后台及业务中台将数据流入，完成海量数据的存储，计算，产品化包装的过程，构成企业的核心数据能力</li></ul></li><li><p>阿里技术中台</p><ul><li>将使用云或者其他基础设施的能力以及应用各种技术中间件的能力进行整合包装，过滤掉技术细节，提供简单一致，易于使用的应用技术基础设施的能力接口，助力前台和业务中台数据中台的快速建设</li></ul></li><li><p>组织中台</p><ul><li>中台建设真正困难的地方在于组织上的重构，技术架构与组织架构的匹配！！</li><li>组织中台很像企业中的内部风投和创新孵化机构，为前台组织和团队构建创新型前台应用提供类似于投资评估（项目甄别）、投资管理、投后管理（孵化与风控），真正从组织和制度上支撑前台组织和应用的快速迭代规模化创新</li></ul></li><li><p>中台建设的难点 – 需要关注组织架构的调整</p><ul><li>组织架构的调整和演进以及利益的重新分配 </li><li>战略的落地是需要靠组织架构的调整来实现的，企业的发展取决于企业正确的战略以及企业的组织结构。前者决定了后者，后者能够保证前者的落地实现</li><li>如果将中台和前台之间的关系定义成服务和被服务的关系，很容易会因为大量需求占据大量时间，短期利益和长期利益的博弈，造成很多问题</li><li>产品化思维，将中台当做一个产品，和其他组是产品之间互通的关系</li></ul></li><li><p>关于中台 - 产品化思考以后的问题</p><ul><li>愿景是什么？<ul><li>中台作为产品需要有自己的愿景定位，不一定需要满足所有前台客户的需求，这同样也意味着前台可以选择不使用中台的某些能力而选择自建。</li></ul></li><li>用户是谁？ 如何划分？<ul><li>中台作为产品需要有自己清晰的用户定位和用户划分，前台作为中台的用户不再是平等的，VIP 前台用户的需求要优于免费前台用户的诉求，通过产品上常见的用户划分来解决需求膨胀、排期、优先级和冲突问题</li></ul></li><li>解决了什么问题？<ul><li>中台作为一个产品，需要想方设法体现自身的价值，真正为前台客户解决实际问题，并关注前台用户体验，通过营销和售前等手段获取前台客户，通过清晰的用户定位和产品力吸引前台客户，让其主动选择采购中台产品</li></ul></li><li>竞争环境？ 团队构成？<ul><li>产品的建设初期，不一定启动资金直接从业务上切分，可能需要类似于天使投资的企业战略投资进行初始孵化，减少中台前期建设的业务交付压力，甚至作为企业的战略级产品，需要一些内部保护和孵化，但仍需要快速验证其价值，获取客户，实现自负盈亏</li></ul></li><li>如何获取用户？营销？售前？</li><li>如何向用户提供服务？<ul><li>产品的建设过程可以借鉴精益创业思路，需要尽快体现其商业价值，如果一定时期内无法获取相应的前台用户（前台不用），或是其他考核指标不达标，则需要进行中台建设止损，类似于创业失败</li><li>甚至在特殊情况下，允许同一类型的中台产品存在合理的内部竞争，同时对两个相似的中台产品进行孵化，使用类似于内部赛马的机制解决内部服务差异性带来的内部产品垄断和定价困难问题</li><li>中台产品为了用户留存，需要对于前台客户提供产品级 SLA，提供客户运营，客户售后服务，保持产品平滑更新，关注用户满意度，实现客户留存与转化</li></ul></li><li>如何验证价值？成本核算？ 定价机制？</li><li>如何保证服务质量？ </li><li>如何升级演进？产品运营？<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1></li></ul></li></ul><ol><li><a href="https://www.infoq.cn/profile/1084916/publish" target="_blank" rel="noopener">https://www.infoq.cn/profile/1084916/publish</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前面两篇文章讲了一些关于中台的信息, &lt;a href=&quot;https://llchen60.com/%E4%B8%AD%E5%8F%B0/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;中台1&lt;/a&gt;,&lt;a href=&quot;https://llchen60.co
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="中台" scheme="https://www.llchen60.com/tags/%E4%B8%AD%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>Bash 脚本</title>
    <link href="https://www.llchen60.com/Bash-%E8%84%9A%E6%9C%AC/"/>
    <id>https://www.llchen60.com/Bash-%E8%84%9A%E6%9C%AC/</id>
    <published>2020-05-08T05:24:54.000Z</published>
    <updated>2020-05-10T05:59:04.101Z</updated>
    
    <content type="html"><![CDATA[<p>Bash是大多数Linux发行版的默认Shell（命令行环境），值得去研究一波~</p><p>最近也有很多人转而使用zsh，看到一个不错的<a href="https://apple.stackexchange.com/questions/361870/what-are-the-practical-differences-between-bash-and-zsh" target="_blank" rel="noopener">post</a>,讲了二者的主要区别</p><h1 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1. 基本语法"></a>1. 基本语法</h1><ul><li><p>echo 在屏幕输出一行文本，可以将该命令的参数原样输出</p><ul><li><code>-n</code> 取消末尾的回车符</li><li><code>-e</code> 解释引号当中的特殊字符，进行转义 </li></ul></li><li><p>命令格式</p><ul><li><code>command [arg1 ... argN]</code></li><li><code>ls -l</code> 等于 <code>ls --list</code><ul><li>其实主要是写script的时候为了让语句自己能够解释自己，会选用长形式，其余时候一般都选用短形式的语句</li></ul></li></ul></li><li><p>分号</p><ul><li>命令的结束符，使得一行可以放置多个命令</li><li>上个命令执行完之后，才会执行下一个命令</li><li>后一个指令总会接着第一个来执行，不管第一个成功或者失败</li></ul></li><li><p>命令组合符</p><ul><li><code>command1 &amp;&amp; command2</code> <ul><li>如果command1成功，才会继续执行command2</li></ul></li><li><code>command1 || command2</code><ul><li>如果command1成功，就不执行command2了</li></ul></li></ul></li><li><p>type命令  – 用于判断命令的来源，是内置的命令或者外部程序</p><ul><li><code>-a</code> 去查看一个命令的所有定义</li><li><code>-t</code> 可以返回一个命令的类型<ul><li>alias</li><li>keyword</li><li>function</li><li>builtin</li><li>file</li></ul></li></ul></li><li><p>快捷键</p><ul><li><code>Ctrl + L</code>：清除屏幕并将当前行移到页面顶部。</li><li><code>Ctrl + C</code>：中止当前正在执行的命令。</li><li><code>Shift + PageUp</code>：向上滚动。</li><li><code>Shift + PageDown</code>：向下滚动。</li><li><code>Ctrl + U</code>：从光标位置删除到行首。</li><li><code>Ctrl + K</code>：从光标位置删除到行尾。</li><li><code>Ctrl + D</code>：关闭 Shell 会话。</li></ul></li></ul><h1 id="2-模式扩展"><a href="#2-模式扩展" class="headerlink" title="2. 模式扩展"></a>2. 模式扩展</h1><p>Shell接到用户输入命令，通过空格进行对输入的分割，拆成词元，然后扩展词元里面的特殊字符，来调用相应的命令。</p><ul><li><p>波浪线扩展</p><ul><li>自动扩展为当前用户的主目录</li></ul></li><li><p><code>？</code>扩展</p><ul><li>？代表文件路径里面的任意单个字符，不包括空字符</li><li><code>file???</code>就表示file后面跟着三个字符的文件名</li></ul></li><li><p><code>*</code>扩展</p><ul><li>代表文件路径里面的任意数量的字符，包括零个字符</li><li>注意不会匹配隐藏文件</li></ul></li><li><p><code>[]</code>扩展</p><ul><li>匹配内部包含的任意一个</li><li><code>[abcde]</code>就会匹配abcde里面的任意一个</li><li><code>[!abc]</code> or <code>[^abc]</code> 表示匹配除了abc以外的其他字符</li></ul></li><li><p><code>[start-end]</code>扩展</p><ul><li>表示匹配一个连续的范围</li><li><code>[a-c]</code>等同于[abc]</li></ul></li><li><p><code>{...}</code>扩展</p><ul><li>指分别扩展为大括号当中定义的所有值</li><li>大括号颞部逗号前后不能有空格</li><li><code>echo d{a,e,i,u,o}g</code><ul><li>output:  dag deg dig dug dog</li></ul></li></ul></li><li><p><code>{start..end}</code>扩展</p><ul><li><code>echo {1..4}</code><ul><li>output: 1 2 3 4</li></ul></li></ul></li><li><p>字符类</p><ul><li><code>[[:class:]]</code> 表示一个字符类，扩展成某一类特定字符之中的一个</li><li><code>[[:alnum:]]</code>：匹配任意英文字母与数字</li><li><code>[[:alpha:]]</code>：匹配任意英文字母</li><li><code>[[:blank:]]</code>：空格和 Tab 键。</li><li><code>[[:cntrl:]]</code>：ASCII 码 0-31 的不可打印字符。</li><li><code>[[:digit:]]</code>：匹配任意数字 0-9。</li><li><code>[[:graph:]]</code>：A-Z、a-z、0-9 和标点符号。</li><li><code>[[:lower:]]</code>：匹配任意小写字母 a-z。</li><li><code>[[:print:]]</code>：ASCII 码 32-127 的可打印字符。</li><li><code>[[:punct:]]</code>：标点符号（除了 A-Z、a-z、0-9 的可打印字符）。</li><li><code>[[:space:]]</code>：空格、Tab、LF（10）、VT（11）、FF（12）、CR（13）。</li><li><code>[[:upper:]]</code>：匹配任意大写字母 A-Z。</li><li><code>[[:xdigit:]]</code>：16进制字符（A-F、a-f、0-9）</li></ul></li><li><p>量词语法</p><ul><li><code>?(pattern-list)</code>：匹配零个或一个模式。</li><li><code>*(pattern-list)</code>：匹配零个或多个模式。</li><li><code>+(pattern-list)</code>：匹配一个或多个模式。</li><li><code>@(pattern-list)</code>：只匹配一个模式。</li><li><code>!(pattern-list)</code>：匹配零个或一个以上的模式，但不匹配单独一个的模式</li></ul></li><li><p>shopt 命令 – 用来调整bach的行为</p><ul><li>-s 打开某个参数</li><li>-u 关闭某个参数</li><li>直接加 optionName  可以来查询某个参数是关闭的还是打开的</li><li>参数<ul><li>dotglob  让扩展结果包括隐藏文件</li><li>nullglob 让通配符不匹配任何文件名，返回空字符</li><li>failglob 使得通配符不匹配任何文件名时，Bash 会直接报错，而不是让各个命令去处理</li><li>extglob 支持ksh的一些扩展语法</li><li>nocaseglob 让通配符扩展不区分大小写</li><li>globstar  是的<code>**</code>可以匹配零个或多个子目录</li></ul></li></ul></li><li><p>tips</p><ul><li>通配符是先解释，再执行</li><li>文件名扩展不匹配的时候，会原样输出</li><li>只适用于单层路径 </li></ul></li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://wangdoc.com/bash/grammar.html" target="_blank" rel="noopener">https://wangdoc.com/bash/grammar.html</a> </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Bash是大多数Linux发行版的默认Shell（命令行环境），值得去研究一波~&lt;/p&gt;
&lt;p&gt;最近也有很多人转而使用zsh，看到一个不错的&lt;a href=&quot;https://apple.stackexchange.com/questions/361870/what-are-
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.llchen60.com/categories/Linux/"/>
    
    
      <category term="bash" scheme="https://www.llchen60.com/tags/bash/"/>
    
  </entry>
  
  <entry>
    <title>关于时间管理</title>
    <link href="https://www.llchen60.com/%E5%85%B3%E4%BA%8E%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/"/>
    <id>https://www.llchen60.com/%E5%85%B3%E4%BA%8E%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/</id>
    <published>2020-05-06T05:33:31.000Z</published>
    <updated>2020-05-06T05:34:05.299Z</updated>
    
    <content type="html"><![CDATA[<p>最近给自己添了些个人的项目，然后，瞬间感觉到时间不够用。会有忙了一天不知道自己忙什么了的感觉，会有一天被无穷的琐事，被各种问题，沟通占满，然后本来计划做的事情什么都没做的时候。hmm，看了一些博客和书，试着将学到的一些方法用在每天的安排上，发现效果还不错. </p><p>整理了思维导图，和大家分享下。其中对我帮助最大的一条，是关于如何真正的分清楚一件事情的重要程度和紧急程度，不是老板跟你说很重要，PM在屁股后面追着你这件事情就是很重要的。弄清楚他们为什么有这个需求，有没有更加快捷的解决方式更重要。如果更近距离的看，一种理解就是–不是别人用通信软件找你，你就必须当下看当下回，按照自己的工作节奏，保证自己在做的事情没有被打断，这往往是更有效率的方式。</p><p>喜欢书中所说的”做事情靠系统，而不是靠直觉“。希望大家都能建立自己的系统！ </p><p><img src="https://i.loli.net/2020/05/06/rqCPTkEKiV5pYM3.png" alt="时间管理思维导图"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近给自己添了些个人的项目，然后，瞬间感觉到时间不够用。会有忙了一天不知道自己忙什么了的感觉，会有一天被无穷的琐事，被各种问题，沟通占满，然后本来计划做的事情什么都没做的时候。hmm，看了一些博客和书，试着将学到的一些方法用在每天的安排上，发现效果还不错. &lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
    
      <category term="Notes" scheme="https://www.llchen60.com/categories/Notes/"/>
    
    
      <category term="时间管理" scheme="https://www.llchen60.com/tags/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Java 多线程 基础知识(二)</title>
    <link href="https://www.llchen60.com/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E4%BA%8C/"/>
    <id>https://www.llchen60.com/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E4%BA%8C/</id>
    <published>2020-05-03T17:51:40.000Z</published>
    <updated>2020-05-03T18:20:26.370Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-并发容器"><a href="#1-并发容器" class="headerlink" title="1. 并发容器"></a>1. 并发容器</h1><h2 id="1-1-ConcurrentHashMap"><a href="#1-1-ConcurrentHashMap" class="headerlink" title="1.1 ConcurrentHashMap"></a>1.1 ConcurrentHashMap</h2><ul><li><p>HashMap不是线程安全的</p></li><li><p>并发情况下一个可行的方式是使用Collections.synchronizedMap()来包装HashMap。</p><ul><li>但问题在于一个全局的锁同步不同线程之间的并发访问，会带来不可忽视的性能问题</li></ul></li><li><p>故而使用ConcurrentHashMap</p><ul><li>读写都能保证较高的性能</li><li>读操作时几乎不需要加锁</li><li>写操作的时候通过锁分段技术只对所操作的段加锁而不影响客户端对其他段的访问</li></ul></li></ul><ul><li><p>ConcurrentHashMap和HashTable的区别主要体现在实现线程安全的方式上不同</p><ul><li>底层数据结构<ul><li>ConcurrentHashMap使用分段的数组和链表</li><li>Hashtable用数组和链表，数组为主体，链表是为了解决哈希冲突的</li></ul></li><li>线程安全的实现方式<ul><li>使用node数组 + 链表 + 红黑树的数据结构来实现，并发控制使用synchronized和CAS操作</li><li>Hashtable是使用synchronized来保证线程安全的，效率相对较低<h2 id="1-2-CopyOnWriteArrayList"><a href="#1-2-CopyOnWriteArrayList" class="headerlink" title="1.2 CopyOnWriteArrayList"></a>1.2 CopyOnWriteArrayList</h2></li></ul></li></ul></li><li><p>针对现实应用场景当中，读操作远远多于写操作，因为读操作不会修改原有数据，所以就不对读进行加锁操作了。允许多个线程同时访问list的内部数据。</p></li><li><p>ReentranReadWriteLock 读写锁是读读共享、写写互斥、读写互斥、写读互斥</p></li><li><p>而CopyOnWriteArrayList 是读取完全不加锁，写入也不会阻塞读取操作，只有写入和写入之间需要进行同步等待。</p></li></ul><ul><li>如何实现的<ul><li>所有可变操作（add，set 等等）都是通过创建底层数组的新副本来实现的。当 List 需要被修改的时候，我并不修改原有内容，而是对原有数据进行一次复制，将修改的内容写入副本。写完之后，再将修改完的副本替换原来的数据，这样就可以保证写操作不会影响读操作了。</li><li>从计算机系统的角度来说，实际上是拷贝内存，在新内存完成写操作，并将原先的内存指针指向新的内存，原有的内存就可以被回收掉了</li></ul></li></ul><pre><code>    /** The array, accessed only via getArray/setArray. */    private transient volatile Object[] array;    public E get(int index) {        return get(getArray(), index);    }    @SuppressWarnings(&quot;unchecked&quot;)    private E get(Object[] a, int index) {        return (E) a[index];    }    final Object[] getArray() {        return array;    }        /**     * Appends the specified element to the end of this list.     *     * @param e element to be appended to this list     * @return {@code true} (as specified by {@link Collection#add})     */    public boolean add(E e) {        final ReentrantLock lock = this.lock;        lock.lock();//加锁        try {            Object[] elements = getArray();            int len = elements.length;            Object[] newElements = Arrays.copyOf(elements, len + 1);//拷贝新数组            newElements[len] = e;            setArray(newElements);            return true;        } finally {            lock.unlock();//释放锁        }    }</code></pre><h2 id="1-3-ConcurrentLinkedQueue"><a href="#1-3-ConcurrentLinkedQueue" class="headerlink" title="1.3 ConcurrentLinkedQueue"></a>1.3 ConcurrentLinkedQueue</h2><p>Java 提供的线程安全的 Queue 可以分为阻塞队列和非阻塞队列，其中阻塞队列的典型例子是 BlockingQueue，非阻塞队列的典型例子是 ConcurrentLinkedQueue，在实际应用中要根据实际需要选用阻塞队列或者非阻塞队列。 阻塞队列可以通过加锁来实现，非阻塞队列可以通过 CAS 操作实现。</p><p>从名字可以看出，ConcurrentLinkedQueue这个队列使用链表作为其数据结构．ConcurrentLinkedQueue 应该算是在高并发环境中性能最好的队列了。它之所有能有很好的性能，是因为其内部复杂的实现。</p><p>其中主要使用CAS非阻塞算法来实现</p><h1 id="2-乐观锁悲观锁"><a href="#2-乐观锁悲观锁" class="headerlink" title="2. 乐观锁悲观锁"></a>2. 乐观锁悲观锁</h1><p>乐观锁适用于写比较少的情况，即冲突本身发生的可能性就比较低，这样就能省去锁的开销，加大整个系统的吞吐量；但是多写的情况下，会比较容易产生冲突，这样就会导致上层不断进行retry，反倒会降低性能，所以一般多写的场景下用悲观锁比较合适。</p><h2 id="2-1-乐观锁"><a href="#2-1-乐观锁" class="headerlink" title="2.1 乐观锁"></a>2.1 乐观锁</h2><p>总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用<strong>版本号机制</strong>和<strong>CAS算法</strong>实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。</p><p>关于CAS算法，实质上就先拿到指定内存上的数据，（读取操作），线程操作处理数据，在要写入之前，再次查询该内存位置上的数据，如果数据一致，那就可以写入，如果数据不一致，就throw exception，告知系统出现了问题。</p><h3 id="2-1-1-乐观锁实现方式"><a href="#2-1-1-乐观锁实现方式" class="headerlink" title="2.1.1 乐观锁实现方式"></a>2.1.1 乐观锁实现方式</h3><p>乐观锁可以使用版本号机制或者CAS算法来进行实现</p><ul><li><p>版本号机制</p><ul><li>在数据表中加上数据版本号version字段，表示数据被修改的次数</li><li>被修改，version值会+1</li><li>当线程A要更新数据时，读数据的同时也会读取version值，提交更新的时候，若刚才读取到的version值和当前数据库的version值相等才更新，否在重试</li></ul></li><li><p>CAS算法</p><ul><li>compare and swap算法，无锁编程</li><li>不使用锁的情况下实现多线程之间的变量同步，即在没有线程被阻塞的情况下实现变量的同步 – 非阻塞同步 Non=blocking synchronization </li></ul></li></ul><h3 id="2-1-2-缺点"><a href="#2-1-2-缺点" class="headerlink" title="2.1.2 缺点"></a>2.1.2 缺点</h3><ul><li><p>ABA 问题</p><ul><li>一个变量初始值为A，在准备赋值的时候仍为A，但是在这段时间当中它有可能已经被改为了其他的值了，CAS操作会认为它从来没有被修改过</li><li>可以使用AtomicStampedReference类，compareAndSet方法首先检查当前引用是否等于预期引用，以及当前标志是否等于预期标志。如果全部相等，就以原子方式将该引用和该标志的值设置为给定的更新值。</li></ul></li><li><p>循环时间开销大</p><ul><li>自旋CAS如果长时间不成功，会给CPU带来很大的执行开销</li></ul></li><li><p>只能保证一个共享变量的原子操作</p><ul><li>CAS只对单个共享变量有效，当操作涉及多个共享变量的时候CAS无效</li><li>AtomicReference这一类能够保证引用对象之间的原子性，可以将多个变量放在一个对象里进行CAS操作</li></ul></li></ul><h2 id="2-2-悲观锁"><a href="#2-2-悲观锁" class="headerlink" title="2.2 悲观锁"></a>2.2 悲观锁</h2><p>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。</p><h1 id="3-线程池"><a href="#3-线程池" class="headerlink" title="3. 线程池"></a>3. 线程池</h1><ul><li>线程池用来限制和管理资源，每个线程池还可以维护一些基本统计信息</li><li>好处<ul><li>降低资源消耗<ul><li>重复利用已经创建的线程，来降低线程创建和销毁造成的消耗</li></ul></li><li>提高响应速度<ul><li>当任务到达时，任务可以不需要的等到线程创建就能立即执行</li></ul></li><li>提高线程的可管理性<ul><li>线程是稀缺资源，无限制创建会消耗系统资源，并且降低系统稳定性；使用线程池可以进行统一分配，调优和监控</li></ul></li></ul></li></ul><h2 id="3-1-ThreadPoolExecutor详解"><a href="#3-1-ThreadPoolExecutor详解" class="headerlink" title="3.1 ThreadPoolExecutor详解"></a>3.1 ThreadPoolExecutor详解</h2><pre><code>/** * 用给定的初始参数创建一个新的ThreadPoolExecutor。 */public ThreadPoolExecutor(int corePoolSize,                          int maximumPoolSize,                          long keepAliveTime,                          TimeUnit unit,                          BlockingQueue&lt;Runnable&gt; workQueue,                          ThreadFactory threadFactory,                          RejectedExecutionHandler handler) {    if (corePoolSize &lt; 0 ||        maximumPoolSize &lt;= 0 ||        maximumPoolSize &lt; corePoolSize ||        keepAliveTime &lt; 0)        throw new IllegalArgumentException();    if (workQueue == null || threadFactory == null || handler == null)        throw new NullPointerException();    this.corePoolSize = corePoolSize;    this.maximumPoolSize = maximumPoolSize;    this.workQueue = workQueue;    this.keepAliveTime = unit.toNanos(keepAliveTime);    this.threadFactory = threadFactory;    this.handler = handler;}</code></pre><ul><li>corePoolSize <ul><li>定义了不会timeout的最小的同时工作的线程数量</li></ul></li><li>maxPoolSize<ul><li>定义了可以被创建的线程的最大数量</li><li>和CorePoolSize的区别在于当提交一个新的任务，当前线程数量小于corePoolSize的时候，哪怕现在存在的线程是空闲的，还是会创建新线程来运行这个任务；maxPoolSize说的是最多能够创建的线程数量，是上限</li></ul></li><li>workQueue<ul><li>当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中</li></ul></li><li>handler 饱和策略 - 当当前同时运行的线程数量达到最大线程数量，并且队列已经被放满了的时候的策略<ul><li>AbortPolicy<ul><li>抛出RejectedExecutionException来拒绝新的任务的处理</li></ul></li><li>CallerRunsPolicy <ul><li>调用执行自己的线程运行任务，会有延迟</li></ul></li><li>DiscardPolicy  <ul><li>不处理新任务，直接丢弃掉</li></ul></li><li>DiscardOldestPolicy <ul><li>丢弃最早的未处理的任务请求</li></ul></li></ul></li></ul><ul><li><p>Executor.execute代码的源码如下： </p><pre><code>  // 存放线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)  private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));  private static int workerCountOf(int c) {      return c &amp; CAPACITY;  }  private final BlockingQueue&lt;Runnable&gt; workQueue;  public void execute(Runnable command) {      // 如果任务为null，则抛出异常。      if (command == null)          throw new NullPointerException();      // ctl 中保存的线程池当前的一些状态信息      int c = ctl.get();      //  下面会涉及到 3 步 操作      // 1.首先判断当前线程池中之行的任务数量是否小于 corePoolSize      // 如果小于的话，通过addWorker(command, true)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。      if (workerCountOf(c) &lt; corePoolSize) {          if (addWorker(command, true))              return;          c = ctl.get();      }      // 2.如果当前之行的任务数量大于等于 corePoolSize 的时候就会走到这里      // 通过 isRunning 方法判断线程池状态，线程池处于 RUNNING 状态才会被并且队列可以加入任务，该任务才会被加入进去      if (isRunning(c) &amp;&amp; workQueue.offer(command)) {          int recheck = ctl.get();          // 再次获取线程池状态，如果线程池状态不是 RUNNING 状态就需要从任务队列中移除任务，并尝试判断线程是否全部执行完毕。同时执行拒绝策略。          if (!isRunning(recheck) &amp;&amp; remove(command))              reject(command);              // 如果当前线程池为空就新创建一个线程并执行。          else if (workerCountOf(recheck) == 0)              addWorker(null, false);      }      //3. 通过addWorker(command, false)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。      //如果addWorker(command, false)执行失败，则通过reject()执行相应的拒绝策略的内容。      else if (!addWorker(command, false))          reject(command);  }</code></pre></li></ul><p><img src="https://i.loli.net/2020/05/02/t7yVTDjNZdnEahw.png" alt="execute process"></p><h2 id="3-2-Executor框架"><a href="#3-2-Executor框架" class="headerlink" title="3.2 Executor框架"></a>3.2 Executor框架</h2><p>Java5以后引入的Executor，用其启动线程比使用Thread的start方法更好，易管理，效率高，还可以帮助避免this逃逸的问题。Executor框架提供了：</p><ul><li>线程池管理</li><li>线程工厂</li><li>队列</li><li>拒绝策略</li></ul><h3 id="3-2-1-框架结构"><a href="#3-2-1-框架结构" class="headerlink" title="3.2.1 框架结构"></a>3.2.1 框架结构</h3><ul><li>任务<ul><li>执行任务实现Runnable或者Callable接口，然后被ThreadPoolExecutor或者ScheduledThreadPoolExecutor来执行</li></ul></li><li>任务执行<ul><li>Executor</li></ul></li><li>异步计算的结果<ul><li>Future接口以及Future接口实现类FutureTask都可以来代表异步计算的结果</li></ul></li></ul><p><img src="https://i.loli.net/2020/05/04/pxtNFGULRe3IT6a.png" alt="Exectuor 流程图"></p><p>整个过程中，主线程首先创建并实现了Runnable或者Callable的任务对象，而后将对象交给ExecutorService来执行，然后拿到返回的Future接口，执行FutureTask.get（）等方法来等待任务执行完成</p><h2 id="3-3-常用线程池"><a href="#3-3-常用线程池" class="headerlink" title="3.3 常用线程池"></a>3.3 常用线程池</h2><h3 id="3-3-1-FixedThreadPool"><a href="#3-3-1-FixedThreadPool" class="headerlink" title="3.3.1 FixedThreadPool"></a>3.3.1 FixedThreadPool</h3><ul><li><p>FixedThreadPool</p><ul><li>如果当前运行的线程数小于 corePoolSize， 如果再来新任务的话，就创建新的线程来执行任务；</li><li>当前运行的线程数等于 corePoolSize 后， 如果再来新任务的话，会将任务加入 LinkedBlockingQueue；</li><li>线程池中的线程执行完 手头的任务后，会在循环中反复从 LinkedBlockingQueue 中获取任务来执行；</li></ul></li><li><p>不推荐使用</p><ul><li><p>线程池中的线程数达到 corePoolSize 后，新任务将在无界队列中等待，因此线程池中的线程数不会超过 corePoolSize</p></li><li><p>由于使用无界队列时 maximumPoolSize 将是一个无效参数，因为不可能存在任务队列满的情况。所以，通过创建 FixedThreadPool的源码可以看出创建的 FixedThreadPool 的 corePoolSize 和 maximumPoolSize 被设置为同一个值</p></li><li><p>由于上述两点，keepAliveTime就会是一个无效参数了</p></li><li><p>因为无法执行shutdown() shutdownNow()，不会拒绝任务，在任务比较多的时候会导致OOM(内存溢出的问题)</p><p>public static ExecutorService newFixedThreadPool(int nThreads) {<br>  return new ThreadPoolExecutor(nThreads, nThreads,</p><pre><code>                            0L, TimeUnit.MILLISECONDS,                            new LinkedBlockingQueue&lt;Runnable&gt;());</code></pre><p>}</p></li></ul></li></ul><h3 id="3-3-2-CachedThreadPool"><a href="#3-3-2-CachedThreadPool" class="headerlink" title="3.3.2 CachedThreadPool"></a>3.3.2 CachedThreadPool</h3><p>可以根据需要来创建新线程的线程池</p><pre><code>    /**     * 创建一个线程池，根据需要创建新线程，但会在先前构建的线程可用时重用它。     */    public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) {        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,                                      60L, TimeUnit.SECONDS,                                      new SynchronousQueue&lt;Runnable&gt;(),                                      threadFactory);    }</code></pre><p>注意看源码中，corePoolSize设置为空，maximumPoolSize设置为无界的了，如果主线程提交任务的速度高于maximumPool中线程处理任务的速度，CachedThreadPool会不断创建新的线程，极端情况下，会耗尽CPU和内存资源的。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://github.com/Snailclimb/JavaGuide/" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide/</a> </li><li><a href="https://howtodoinjava.com/java/multi-threading/compare-and-swap-cas-algorithm/" target="_blank" rel="noopener">https://howtodoinjava.com/java/multi-threading/compare-and-swap-cas-algorithm/</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-并发容器&quot;&gt;&lt;a href=&quot;#1-并发容器&quot; class=&quot;headerlink&quot; title=&quot;1. 并发容器&quot;&gt;&lt;/a&gt;1. 并发容器&lt;/h1&gt;&lt;h2 id=&quot;1-1-ConcurrentHashMap&quot;&gt;&lt;a href=&quot;#1-1-Concurrent
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
      <category term="Multi-threading" scheme="https://www.llchen60.com/tags/Multi-threading/"/>
    
  </entry>
  
  <entry>
    <title>货币,信贷,债务是如何运作的 from Ray Dalio</title>
    <link href="https://www.llchen60.com/%E8%B4%A7%E5%B8%81-%E4%BF%A1%E8%B4%B7-%E5%80%BA%E5%8A%A1%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E4%BD%9C%E7%9A%84-from-Ray-Dalio/"/>
    <id>https://www.llchen60.com/%E8%B4%A7%E5%B8%81-%E4%BF%A1%E8%B4%B7-%E5%80%BA%E5%8A%A1%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E4%BD%9C%E7%9A%84-from-Ray-Dalio/</id>
    <published>2020-05-02T20:55:48.000Z</published>
    <updated>2020-05-02T20:56:34.090Z</updated>
    
    <content type="html"><![CDATA[<p>Ray Dalio在LinkedIn上的长文，主要分析了在长期债务周期当中，货币、信贷、债务之间的相互运作关系，以及它们驱动全球经济和政治变化的方式。</p><h1 id="1-货币和信贷"><a href="#1-货币和信贷" class="headerlink" title="1. 货币和信贷"></a>1. 货币和信贷</h1><p>所有实体（国家、公司、非营利组织和个人）都需处理基本财务，他们的收入和支出构成了净收入，而这些流动是可以用资产负债表中的数字来衡量的。如果一个人赚的比花的多，他就会有利润，从而使他的储蓄增加。而如果一个人的支出大于收入，那么他的储蓄就会减少，或者他不得不通过借钱或来弥补差额。<br>如果一个实体拥有巨额净资产，它的支出将可以高于收入，直到资金耗尽，这时它必须削减开支。如果不削减开支，它将会有大量负债/债务，如果它没有足够的收入来偿还，它就会违约。<br><strong>由于一个人的债务是另一个人的资产，债务违约会减少其他实体的资产，进而要求它们削减开支，从而导致债务下降和经济收缩。</strong></p><p>这种货币和信用体系适用于所有人、公司、非营利组织和政府，但有一个重要的例外。所有国家都可以印钞给人们消费或放贷。然而，<strong>并不是所有政府发行的货币都具有相同的价值</strong>。</p><p>在世界范围内被广泛接受的被称为储备货币。而在当今世界上，占主导地位的储备货币是美元，由美联储发行，占所有国际交易的55%。另一种则是欧元，由欧洲央行发行，占所有国际交易的25%。目前，日元、人民币和英镑都是相对较小的储备货币，尽管人民币的重要性正迅速上升。</p><p>拥有储备货币的国家更容易通过大量借贷摆脱困境。原因在于，世界上其他国家倾向于持有这些债务和货币，因为它们可以用来在世界各地消费。因此，拥有储备货币的国家可以发行大量以储备货币计价的信贷/债务，尤其是在目前这种储备货币短缺的情况下。</p><p>而相比之下，没有储备货币的国家则没有这种选择。它们在以下情况中，特别需要这些储备货币（如美元）：（1）他们有很多以他们不能印刷的储备货币计价的债务（如美元）；（2）他们在这些储备货币上没有多少储蓄；（3）他们获得所需货币的能力下降。当没有储备货币的国家急需储备货币来偿还他们的债务，以储备货币计价和交易的卖家希望它们用储备货币来支付时，它们就只能破产。这就是现在许多国家的情况。</p><p>这也是许多州、地方政府、公司、非营利组织和个人会面临的情况。当它们遭受了收入损失，有没有多少存款来弥补损失时，它们将不得不削减开支或通过其他方式获得资金和信贷。</p><p>这就是现在的世界上正在发生的事情：<strong><em>风险储蓄即将耗尽，以及债务违约的风险。有能力这样做的政府正在印钞，以帮助减轻债务负担，并帮助为以本国货币计价的开支提供资金。但这将削弱本国货币，提高本币的通胀水平，以抵消需求减少和被迫出售资产所造成的通货紧缩，而那些资金紧张的国家就不得不筹集现金</em></strong>。</p><ul><li>Essense<ul><li>一个人的债务是另外一个人的资产，债务违约会减少其他实体的资产，进而要求其消减开支，从而导致债务下降和经济收缩的自我强化。 </li><li>美国最近的大撒钱计划，致使美元指数强势增长，这是市场的避险情绪的体现。美元是全兑换，全流通的。市场的担忧，降息，使得直接持有美元的成本降低了。机构企业采取增加现金流的方式来防止出现流动性危机</li><li>美国政府通过印钞来减轻债务负担，提供商业运作所需的资金。</li></ul></li></ul><h1 id="2-什么是货币"><a href="#2-什么是货币" class="headerlink" title="2. 什么是货币"></a>2. 什么是货币</h1><p>货币本质上是一种交换媒介，也可以用来储存财富。</p><p>不言而喻，“交换媒介”指的是可以用来买东西的工具。而所谓财富储备，指的是在获取和消费之间储存购买力的工具。最合理的方式显然就是把钱存起来，以备不时之需，但人们往往不愿意持有货币，而总想把货币兑换成他们想买的东西。这就是信贷和债务发挥作用的地方。</p><p>当出借人放贷时，他们认为收回的钱会比本身持有的钱购买更多的商品和服务。如果做得好，借贷者就能有效地使用这些钱并获得利润，进而偿还贷款并保留一些额外的钱。当贷款尚未偿还时，它是贷款人的资产，也是借款人的负债。当钱被偿还时，资产和负债就消失了，这种交换对借方和贷方都有好处。他们从本质上分享了这种生产性贷款的利润。整个社会也得益于这种机制所带来的的生产力提高。</p><p>因此，重要的是要意识到：<br>1.大多数货币和信贷（尤其是现存的法定货币）<strong>没有内在价值</strong>；<br>2.它们只是会计系统中的账目，可以很容易地改变；<br>3.系统的目的是<strong>帮助有效地分配资源以便生产力增长</strong>；<br>4.该系统会周期性崩溃。所有的货币不是被摧毁就是贬值，财富随之发生大规模转移，对经济和市场产生巨大影响。</p><p>更具体地说，货币和信贷系统并没有完美地运转，而是<strong>在循环中改变货币的供应、需求和价值，在上升时产生富裕，在下降时产生重组</strong>。</p><h2 id="2-1-从基本面出发研究货币和信贷系统的周期"><a href="#2-1-从基本面出发研究货币和信贷系统的周期" class="headerlink" title="2.1 从基本面出发研究货币和信贷系统的周期"></a>2.1 从基本面出发研究货币和信贷系统的周期</h2><p><strong>虽然金钱和信贷与财富有关，但它们不是财富</strong>。因为钱和信贷可以买到财富（即商品和服务），所以一个人拥有的金钱和信贷的数量和财富的数量看起来差不多。</p><p>但是，一个人不能仅仅通过创造更多的金钱和信贷来创造更多的财富。要创造更多的财富，就必须要有更高的生产力。金钱和信贷的创造与财富（实际商品和服务）的创造之间的关系经常被混淆，但它是经济周期的最大驱动力，因此，让我们更仔细地研究一下这种关系。</p><p>一般来说，货币和信贷的创造与商品、服务和投资资产的数量之间存在正相关关系，因此很容易混淆。当人们有更多的钱和信贷时，他们就会想消费更多。从某种程度上说，消费增加了经济生产，提高了商品、服务和金融资产的价格，这可以说是增加了财富，因为拥有这些资产的人在我们衡量财富的方式下变得“更富有”。</p><p>然而，这种形式的财富增加更像是一种幻觉。原因有二：<strong>推动价格和生产上升的信贷必须偿还；事物的内在价值并不会增加</strong>。</p><p>举个例子，如果你有一套房子，政府创造了大量的货币和信贷，你的房子的价格会上升，但它仍然是原来的样子。你的实际财富没有增加，只是你计算出来的财富增加了。同样地，如果政府创造了大量的货币和信贷，用于购买商品、服务和金融资产（如股票、债券和房地产），那么你计算所得的财富数量就会增加，但实际财富仍将保持不变。换句话说，用一个人所拥有的市场价值来衡量他的财富，会给人一种财富变化的错觉，而这种变化实际上并不存在。</p><p>重要的是，<strong>货币和信贷在发放时具有刺激作用，而在必须偿还时却有抑制作用。</strong>这就是货币、信贷和经济增长如此具有周期性的原因。</p><p>为了控制市场和整体经济，货币和信贷的成本和可获得性各不相同。当经济增长过快，他们想要放缓增长速度时，就会减少货币和信贷投放，导致两者都变得更加昂贵。这鼓励了人们充当贷方而不是借钱和消费。当经济增长太慢，央行想要刺激经济时，他们就会让货币和信贷廉价而充足，从而鼓励人们借贷、投资和/或消费。货币和信贷的成本和可用性的这些变化也会导致商品、服务和金融资产的价格和数量的涨跌。但是，银行只能在其产生货币和信贷增长的能力范围内控制经济，而它们这样做的能力是有限的。</p><p>想象一下，中央银行有一瓶兴奋剂，他们可以根据需要注入经济，而瓶中的兴奋剂数量是有限的。当市场和经济衰退时，他们会提供货币和信贷刺激来提振经济，当市场过热时，他们会减少刺激。这些变动导致货币、信贷、商品、服务和金融资产的数量和价格的周期性涨跌。而这些举措通常以短期债务周期和长期债务周期的形式出现。</p><p>短期债务周期（即通常所说的“商业周期”）通常持续8年左右。时机取决于刺激措施将需求提升至实体经济生产能力极限所需的时间。而长期债务周期就是将这些短期债务周期加起来，通常持续50-75年。因为可能很多人的一生只会出现一次长期债务周期，所以大多数人都没有意识到。</p><p>长期债务周期通常开始于重组后的低水平债务时期，央行的瓶子里有很多刺激，而结束于高水平债务时期，央行的瓶子里就没有多少刺激了。更具体地说，当央行失去通过经济体系产生货币和信贷增长、进而推动实体经济增长的能力时，央行的刺激能力就会终止。当债务水平高企、利率无法充分降低、货币和信贷的创造对金融资产价格的影响大于对实际经济活动的影响时，央行就会丧失这种能力。在这种时候，那些持有债务的人通常想要把他们持有的货币债务换成其他的财富。当人们普遍认为，将获得资金的货币和债务资产并不是良好的财富储备时，长期债务周期就结束了，必须对货币体系进行重组。</p><ul><li>Essense <ul><li>货币和信贷系统在运行过程中，下降周期里会带来重组，会造成财富的巨大转移。</li><li>金钱和信贷不是财富，但可以买到财富。创造更多的金钱和信贷不意味着更多的财富，更多的生产力才是。</li></ul></li></ul><h1 id="3-长期债务周期"><a href="#3-长期债务周期" class="headerlink" title="3. 长期债务周期"></a>3. 长期债务周期</h1><ol><li>始于无或低债务和“硬通货”</li></ol><p>金银（有时还有铜和镍等其他金属）是首选的货币形式，因为它们具有内在价值，而且可以很容易地塑形，便于携带和兑换。具有内在价值很重要，因为与他们进行交易不需要任何的信任或信用。任何交易都可以当场成交，即使买卖双方是陌生人或敌人。</p><ol start="2"><li>“纸币”的诞生</li></ol><p>因为金属货币携带不便的原因，人们很快就把纸上的“货币债权”当成了货币本身。这种类型的货币系统被称为挂钩货币系统，因为货币的价值与某种东西的价值挂钩，通常是“硬通货”，如黄金。</p><p>3.债务增加</p><p>起初，“硬通货”的债权数量与银行里的硬通货数量相同。然而，持有人和银行发现了信贷和债务的奥妙之处：人们可以把“纸币”借给银行，以换取利息；而向他们借钱的银行又可以把钱借给其他人，换取更高的利息；而那些从银行借钱的人获得了前所未有的购买力。这个过程导致了<strong>资产价格和生产的上升</strong>。</p><p>然而，当一个人没有足够的收入/钱来偿还债务时，麻烦就来了。人们期望通过出售这些债权来获得购买商品和服务的资金，其增长速度超过了商品和服务的数量，这使得从这些债务资产（例如债券）的转换变得不可能。这两个问题往往同时出现。<br>关于第一个问题，可以把债务看作是负收益和负资产，负资产吞噬收益（因为收益必须用来偿还债务），吞噬其他资产（因为必须出售其他资产来获得偿还债务的资金）。它具有更高的优先级，意思是它必须在任何其他类型的资产之前得到支付，所以当收入和一个人的资产价值下降时，有必要削减开支和出售资产来筹集所需的现金。当这还不够时，就需要：</p><p>（1）债务重组，减少债务和债务负担。这对债务人和债权人都是有问题的，因为一个人的债务就是另一个人的资产。</p><p>（2）央行印钱、中央政府<strong>发放货币和信贷，以填补收入和资产负债表的漏洞</strong>（这也是现在正在发生的事情）。</p><p>当债务持有者不相信他们将从债务中获得足够的回报时，就会出现第二个问题。债务资产（如债券）是由投资者持有的，他们认为这些资产是可以出售来获得财富（钱）的，而这些钱可以用来买东西。当债务资产的持有者试图将其转换成真实的货币、真实的商品和服务，却发现他们做不到的时候，这个问题就出现了。然后就会发生所谓的“挤兑”。</p><p>无论是商业银行还是央行，都会面临着这样的选择：允许资金从债务资产中流出，从而提高利率，并导致债务和经济问题恶化；或者“印钞”，购买足够的债券，以防止利率上升，并逆转资金耗尽的趋势。</p><p>但如果货币债权和与货币数量和所要购买的商品和服务数量之比过高，银行就会陷入无法摆脱的困境，因为它根本没有足够的钱来满足这些债权，因此它将不得不违约。</p><p>当这种情况发生在央行身上时，它可以选择要么违约，要么印钞并使其贬值。贬值是无法避免的。当这些债务重组和货币贬值规模很大时，它们会导致货币体系崩溃。无论银行或中央银行做什么，债务越多，货币贬值的可能性就越大。记住，商品和服务的数量总是有限的，因为数量受到生产能力的限制。</p><p>在这里，明白金钱和债务的区别是很重要的。</p><p>金钱是用来应对债权的，也就是说，一个人为他的账单付了钱就完了。债务是未来交付金钱的承诺。</p><p>在观察经济机器是如何运作的过程中，重要的是观察a)债务和货币的数量相对于银行中的硬通货（如黄金）的数量，以及b)商品和服务的数量。</p><p>这两者的数量可能会有所不同，但是要记住，债务周期之所以发生，是因为绝大多数人喜欢扩大购买力（一般是通过债务），而中央银行倾向于扩大货币的数量，因为这样做的时候人们会更高兴。</p><p>但这种情况不可能一直持续下去。重要的是要记住，当银行——无论是私有银行还是中央银行——创造了比银行里的硬通货多得多的凭证（纸币和债务）时，终有一天拿来兑换的纸质凭证的数量会超过银行的偿付能力。</p><ol start="4"><li>随之而来的是债务危机、违约和货币贬值</li></ol><p>历史表明，当银行对货币的索取权的增长速度超过银行的货币总量时，“银行挤兑”就发生了。人们可以通过观察银行的资金数量下降，以及由于提款而接近枯竭的程度，准确地判断出什么时候发生了银行挤兑，什么时候银行业危机即将来临。</p><p>如果一家银行无法提供足够的硬通货来满足人们对它的要求，那么无论它是一家商业银行还是一家央行，都会陷入困境，尽管一般而言，央行比商业银行的选择更多一些。这是因为商业银行不能简单地印钞或修改法律以使其更容易地偿还债务，而中央银行可以。当私人银行家陷入困境时，他们要么违约，要么接受政府的救助。如果他们的债务是以本国货币计价的，中央银行可以贬值他们的债权（例如，偿还50-70%）。但如果债务是以他国货币计价的，那么他们最终也势必违约。</p><ol start="5"><li>法定货币</li></ol><p>央行希望拉长货币和信贷周期，使其持续尽可能长的时间，因为这比其他办法要好得多。所以，当 “硬通货”和”对硬通货的追索权”成为他们的严重束缚时，政府通常会放弃它们，转而采用所谓的 “法定”货币。</p><p>在法币体系中不需要硬通货，有的只是中央银行可以无限制”印制”的”纸币”。因此，央行不会面临 “硬通货”被抽干从而违约的风险。</p><p>此时的风险在于，摆脱了对持有有形黄金或其他 “硬”资产的限制，控制印刷厂的人（即与商业银行家一起工作的中央银行家）将不断创造出更多的货币、债务资产和负债，直到有一天，与商品和服务的数量相比，那些持有大量债务的人将试图把它们换成商品和服务时，会产生与银行挤兑一样的效果，导致债务违约或货币贬值。</p><p>这种转变：从a)债务追索权可按固定比例兑换成有形资产(如黄金)的体系转变为b)不在存在这种兑换的法币体系，最近一次发生是在1971年。</p><p>当年8月15日晚上，尼克松告诉全世界，美元将不再与黄金挂钩，我在电视上看到这些，心想，”我的天，我们所熟悉的货币体系就要结束了，”事实的确如此。</p><p>我当时在纽约证券交易所做职员，那个周一早上，我本来以为股票会下跌，从而出现大乱，结果发现股票上涨而导致大乱。</p><p>因为我从来没有见过贬值，不明白它们是如何运作的。然后我查了一下历史，发现在罗斯福发表类似讲话的那个3月5日星期天晚上，他也做了基本相同的事情，在接下来的几个月里，结果基本相同（货币贬值，股市大涨，金价大涨）。这种情况后来我看到很多国家发生过多次，包括国家元首们发表的基本相同的宣言。</p><p>在1971年之前的几年里，美国政府花了很多钱在军事和社会项目上，当时这被称为 “枪支和黄油”政策，它通过借钱来完成支付，而这些钱就产生了债务。</p><p>这些债务就是他人对货币的追索权，而这些追索权就可以用来换取黄金。投资者购买这些债务作为资产，因为他们得到了这笔政府债务的利息，而且美国政府承诺允许这些票据的持有者用这些票据换取美国金库中的黄金。</p><p>随着美国的支出和预算赤字的增长，美国不得不发行更多的债务，也就是说，创造了更多的黄金债权，但银行里的黄金数量却没有增加。</p><p>自然而然，用这种追索权换取黄金的投资者越来越多。明眼人都能看出美国的黄金已经快用完了，而未偿付的黄金债权数量远远大于银行里的黄金数量，所以他们意识到如果这样下去，美国就会违约。</p><p>当然，在那个时候，很多人看到了美国政府表面上的富有，认为它是不可能在偿付黄金债权上违约的。因此，大多数人对这一宣布以及对市场的影响感到惊讶，不过那些了解货币和信贷运作机制的人却不以为然。</p><p>当信贷周期达到极限时，中央政府及其央行的经典反应是创造大量的债务，并印钞，把钱花在商品、服务和投资资产上，以维持经济的发展。</p><p>这就是2008年债务危机期间的做法，当时利率已经达到0%，无法再降低。正如前文所解释的那样，这也是为了应对1929-32年的债务危机而做的，当时利率已经跌到0%。这种债务和货币的创造，现在出现的数额比二战以来的任何时候都要大。</p><p>说白了，央行 “印钱 “并将其用于支出，而不是用债务增长来支持支出，这并非没有好处。例如，钱可以像信贷一样用于消费，但实际上（而不是理论上）不需要偿还。换句话说，只要货币增长而不是信贷/债务增长，只要把钱用在生产性的用途上，就没有错。</p><p>不过采取印钱手段而不是促进信贷增长的主要风险在于：a)市场参与者不会仔细分析这些钱是否用于生产性用途；b)它省去了让还钱的必要性。</p><p>这两点都会增加激进印钱的概率，而且这些钱也不一定用于生产，所以人们就会停止把钱作为财富储藏手段，并将财富转移到其他东西上。</p><p>纵观历史，当硬通货（债务和货币凭证）的未偿还债权远远大于硬通货和商品和服务的数量时，总会发生大量违约或大量印钞和贬值。</p><p>历史已经告诉我们，我们不应该依赖政府在经济上保护我们。相反，我们应该知道，大多数政府会滥用他们作为货币和信贷的创造者和使用者的特权地位。假设你站在他们的立场上，你可能会做出一样的举动。</p><p>这是因为没有一个政策制定者能够驾驭整个周期。每一个人都是周期的某个阶段参与进来，他们只能根据当时的情况，做着对他们有利的事情。</p><p>因为在债务周期的早期，政府是值得信赖的，他们和其他人一样需要钱，甚至比其他人更需要钱，所以他们通常是最大的借款人。</p><p>而在周期的后期，当后续领导人上台执掌政府时，会面临更多债务。这时新的政府领导人和新的央行决策者们就要面对更大的挑战，此时一方面他们的刺激手段较少，同时还要必须偿还债务。</p><p>更为糟糕的是，政府还必须救助债务人，因为他们的倒下又会伤害到整个系统。因此，他们往往会陷入比个人、公司和大多数其他实体更大的现金流困境。</p><p>换句话说，在几乎所有情况下，政府在行动上助长了债务的积累，成为大的债务人，当债务泡沫破灭时，政府通过印钞和贬值来拯救自己和他人。债务危机越大，就越是如此。</p><p>虽然不可取，但出现这种情况也是可以理解的。当你可以制造货币和信贷，并把它传给每个人，让他们高兴的时候，你很难抵挡住诱惑。”这是典型的金融举动。纵观历史上的统治者，他们都会累积起大量在其统治期结束后很久才会到期的债务，让他们的继任者来收拾残局。</p><p>当政府出现债务问题时，他们会如何应对？</p><p>他们会和任何一个实际债务负担沉重的实体一样，用印钞来解决。无一例外，如果债务是以自己的货币计价，他们就会印钱让货币贬值。</p><p>当央行印钱买入债务，这就把钱放进了金融系统，并使金融资产的价格竞相上涨（这也扩大了贫富差距，因为它让那些拥有金融资产的人相对于没有金融资产的人受益更多）。</p><p>同时，它还把大量的债务掌握在央行手中，让央行可以随心所欲地处理这些债务。而且他们印钱和买入金融资产（主要是债券），也就把利率压低了，这就刺激了借钱和买入，并鼓励那些持有这些债券的人卖出债券，鼓励他们以低利率借钱，把钱投资于回报率较高的资产，这就导致央行印更多的钱，买入更多的债券，有时也买入其他金融资产。</p><p>这通常能很好地推高金融资产价格，但在把钱和信贷以及购买力送到最需要的人手中时，效率就很低了。这就是2008年发生的情况，在那之后的大部分时间里，直到最近也是如此。</p><p>然后，当印钞和央行买入金融资产无法把钱和信贷送到需要的地方时，中央政府——它可以决定把钱花在什么地方——从央行（印钞票的央行）那里借钱，这样它就可以把钱花在需要花的地方。在美国，美联储在2020年4月9日宣布了这一计划。</p><p>这种通过印钱买债（称为债务货币化）的方式，作为一种获取金钱和将财富从拥有金钱的人手中转移到需要金钱的人手中的方式，比起征税导致纳税人不满，在政治上要好得多。这就是为什么央行总是印钞票、让货币贬值的原因。</p><p>当政府印了很多钱，买了很多债，这样钱和债的数量都增加了，钱和债的价格就会便宜，这实质上是向拥有这些钱和债的人征税。</p><p>当这种情况发生得足够多，让这些钱和债务资产的持有者意识到发生了什么，他们就会寻求出售他们的债务资产和借钱，以获得他们可以用低廉资金来偿还的债务。</p><p>他们还经常将财富转移到其他的财富存储工具中，如黄金、某些类型的股票和其他地方（如另一个没有这些问题的国家）。在这种时候，央行通常会继续印钱，直接或间接地购买债务（例如，让银行代为购买），并禁止货币流向可以对冲通胀的资产和其他货币及场所。</p><p>这样的通胀期要么刺激货币和信贷扩张，为另一次经济扩张提供资金（这对股票有好处），要么使货币贬值，从而产生货币通胀（这对黄金等通胀对冲资产有好处）。</p><p>在长期债务周期较早的时候，当未偿债务数额不大，有很大的空间通过降息来刺激（如果不降息，就印钱和买入金融资产），那么信贷增长和经济增长的可能性就越大。</p><p>而在长期债务周期较晚的时候，当债务数额较大，没有太多空间通过降息（或印钱和买入金融资产）来刺激，那么伴随着经济疲软而出现货币通胀的可能性就越大。</p><ol start="6"><li>重回硬通货</li></ol><p>过度印制法币会导致债务资产的抛售，以及之前描述的类似银行”挤兑”的情况，最终会降低货币和信贷的价值，促使人们逃离货币和债务（如债券）。他们也就需要决定将使用何种替代性的财富存储方式。</p><p>历史经验告诉我们，他们通常会转向黄金、其他货币、其他国家没有这些问题的资产，以及能够保留其实际价值的股票。</p><p>有些人认为，世界需要另一种可供选择的储备货币，但事实并非如此，因为在没有可供选择的货币的情况下，从历史上看，货币体系崩溃和财富涌向其他资产，也同样会发生。</p><p>货币自身价值的减弱，会导致货币贬值，人们也会抛弃这种货币，并将资产投入其他地方。历史上，当货币贬值的时候，人们会奔向大量其他东西，甚至包括德国魏玛共和国的石头（用于建筑）。</p><p>通常情况下，在这个阶段的债务周期中，也会出现贫富差距过大造成的经济压力，这就导致了更高的税收和贫富之间的争斗，也使得那些拥有财富的人想要转移到硬资产和其他货币和其他国家。</p><p>很自然的，国家会阻止这种外逃。所以，在这种时候，政府就会加大对黄金（例如，通过取缔黄金的交易和所有权）、外国货币（通过取消其交易能力）、外国资产（通过建立外汇管制来防止资金流出国境）的投资难度。</p><p>最终，债务基本上被消灭，通常是通过让还债的钱既多又便宜，使货币和债务都贬值。</p><p>当这种情况变得极端，以至于货币和信贷体系崩溃，债务贬值和/或违约出现时，政府通常不得不回到某种形式的硬通货，以重建人们对货币作为财富存储的价值的信心，从而恢复信贷增长。</p><p>很多时候，尽管并非总是如此，但政府往往会将其货币与某种硬通货（如黄金或硬储备货币）挂钩，并承诺允许新货币的持有者将其兑换成硬通货。</p><p>有时，这些硬通货可能是另一个国家的硬通货。例如，在过去几十年里，许多弱货币国家将其货币与美元挂钩，或者干脆将其经济美元化（即，将美元作为自己的交易媒介和财富储存手段）。</p><p>回顾一下，在长期的债务周期中，将债务作为一种提供利息的资产持有，在周期初期没有大量债务未还的时候，通常会有回报。但这在周期后期有大量债务未还，且更接近于违约或贬值的时候，相对于给出的利息而言，持有债务是有风险的。</p><p>所以，持有债务（如债券）有点像持有一个定时炸弹，在它还在滴答的时候给你奖励，但一旦爆炸也会将你炸飞。而正如我们所看到的，大爆炸（即大违约或大贬值）大概每50-75年就会发生一次。</p><p>这些债务周期和注销债务的周期已经存在了几千年，在某些情况下已经制度化了。知道债务周期会在这个时间表上发生，会让每个人都能以理性的方式行事，为之做准备。帮助你了解这个情况，让你做好准备，而不是被它吓到，这是我写这篇文章的主要目的。</p><p>因为大多数人对这个周期与他们所经历的事情并不太注意，讽刺的是，越是接近被炸的人往往越是觉得安全。</p><p>那是因为他们一直持有债务，并享受着这样做的回报，而且从上一次爆仓的时间越长，随着上一次爆仓的记忆消退，他们就越是舒服——即使持有这笔债务的风险上升，而回报下降。</p><p>盯住需要偿还的债务相对于硬通货的数量，需要偿还的债务总量相对于债务人的现金流，以及借出资金的利息回报，就可以评估持有这颗定时炸弹的风险/回报。</p><h1 id="4-长期债务周期总结"><a href="#4-长期债务周期总结" class="headerlink" title="4. 长期债务周期总结"></a>4. 长期债务周期总结</h1><p>几千年来，货币制度一直有三种类型：</p><ul><li>硬通货（如金属硬币）</li><li>以“纸币”形式存在的对硬通货的的追索权</li><li>法定货币（如今天的美元）</li></ul><p>硬通货是最具限制性的货币体系，因为除非增加金属或其他具有内在价值的商品（即货币）的供应量，否则就无法创造货币。第二种类型更容易创造货币和信贷，因此硬通货债权与实际持有的硬通货之间的比率上升，最终导致银行挤兑。</p><p>结果有二：一是违约，银行关门且储户失去硬资产；二是有可能跟前者一起发生的债权货币贬值，这意味着储户拿回来的钱变少了。而在第三种类型中，政府可以自由地创造货币和信贷。只要人们对货币有信心，这种做法就持续有效，反之则无效。</p><p>纵观历史，各国在这些不同类型的制度之间过渡，都有合乎逻辑的原因。当一个国家需要的货币和信贷比现有数量更多时，无论是出于应对债务、战争还是其他原因，它自然会从第一种类型过渡到第二种类型，或从第二种类型过渡到第三种类型，这样它就有了更多的印钞灵活性。</p><p>此后，过多的货币供应和债务带来了货币贬值，致使人们不再持有债务和货币作为财富储备，转而回流到硬资产（如黄金）和其他货币中。鉴于这种情况一般发生在产生财富冲突或战争时期，人们通常也会想逃离此地。这类国家需要重新建立起以货币作为财富储备的信心，才能恢复信贷市场。</p><p>下图表达了上述不同的过渡历程。从宋朝到魏玛德国，历史上有很多这样的例子。有很多国家从约束型货币（第一类和第二类）全面过渡到法币，然后随着旧的法币超发，又回到约束型货币。</p><p><img src="https://i.loli.net/2020/05/03/sQkeWX7tDlzEGFn.png" alt="过渡历程"></p><p>如前所述，这个巨大的债务周期将会持续很长一段时间——大约50到75年。在周期结束时，其特征是债务和货币体系的重组。重组的突然之处在于，比如在债务和货币危机时期，重组通常发生得很快，且仅持续数月至三年，具体时间取决于政府采取这些措施所需的时间。然而，此后涟漪效应可能是长期的。</p><p>例如，这样的情况会导致储备货币不再是储备货币。在这些货币制度中，通常会有两到四次大的债务危机，大到足以导致银行业危机和债务减记或贬值30%以上的那种，但这还不足以打破货币体系。</p><p>我在许多国家投资了大约50年，经历了几十次债务危机。它们的运行方式都是一样的，我在《Principles for Navigating Big Debt Crises》一书中曾对此进行了更深入的解释。</p><h1 id="5-拥有储备货币给一个国家带来的不可思议的力量"><a href="#5-拥有储备货币给一个国家带来的不可思议的力量" class="headerlink" title="5. 拥有储备货币给一个国家带来的不可思议的力量"></a>5. 拥有储备货币给一个国家带来的不可思议的力量</h1><p>储备货币是一种在世界范围内被广泛用作交换媒介和财富储备的货币。使用越广泛、对其的依赖程度越深，储备货币和拥有储备货币的国家的实力也就越强。在此，我冒着重复一些之前讲过的东西并让你们觉得无聊的风险来回顾一下美国的情况，以及致使美国和美元让世界变成现在这样的环境情况。</p><p>如前文所述，世界新秩序始于1945年第二次世界大战结束之后，而布雷顿森林协定在1944年确立了美元作为世界主要储备货币的地位。</p><p>美国和美元自然而然地符合这一角色，因为战争结束时，美国政府持有全球约三分之二的黄金（当时是世界货币），美国占世界经济产出的50%，还在军事上占主导地位。新的货币制度属于第二类（即硬通货的债权），其他国家的央行可以35美元/盎司的价格将“纸质美元”兑换成黄金。</p><p>当时，个人持有黄金属于非法，其原因在于政府领导人不想让黄金作为财富储备来与货币和信贷竞争。所以，在那个时候，黄金就是银行里的钱，而纸币就像支票簿里的支票一样，可以兑换成真金白银。</p><p>在这个全新货币体系建立的时候，美国政府每持有一盎司黄金就拥有50美元的纸币，所以几乎100%有黄金做后盾。其他主要的美国盟国（如英国、法国和英联邦国家）或受美国控制的国家（德国、日本和意大利）都有受美国控制的货币与美元挂钩。</p><p>在此后的几年里，为了给自己的活动提供资金，美国政府的支出超过了税收收入，因此不得不借钱，从而产生了更多以美元计价的债务。美联储所允许建立的黄金债权数量（如美元计价的货币和信贷），远远超过了能以35美元价格兑换成的黄金实际数量。在纸币被兑换成硬通货（黄金）之后，美国银行之中的黄金数量随之下降，黄金债权则继续上升。其结果就是，在1971年8月15日，布雷顿森林货币体系崩溃了。</p><p>当时，时任美国总统尼克松和1933年3月5日的罗斯福一样，未能履行当局承诺，即允许美元持有者将其兑换成黄金。于是，美元对黄金和和其他货币贬值。这时，美国和所有国家都进入了第三种类型，法币体系。如果你想读一读有关如何从旧货币体系到新货币体系的精彩过程，我推荐保罗·沃尔克的《Changing Fortunes》，在谈判美国新货币体系应该运作时，他是首席谈判代表。</p><p>这种向法币体系的转变使美联储和其他中央银行得以创造大量以美元计价的货币和信贷，从而导致了1970年代的通货膨胀，其特点是从美元和美元债逃向商品、服务以及黄金等可以对冲通胀的资产。这种对美元债的恐慌情绪还导致了利率走高，并将金价从1944年至1971年期间固定的35美元推至当时的历史高位——1980年的670美元。</p><p>20世纪70年代，货币和信贷主要通过上述方式管理。这时，借入美元并将其转换为商品和服务是有利可图的，所以许多国家的许多实体都大量通过美国银行借入美元。结果，以美元计价的债务在全球范围内迅速增长，而美国银行通过把美元放给借款人来赚了很多钱。</p><p>这种贷款导致了债务周期中经典的债务泡沫。恐慌情绪让人逃离美元和美元债资产并转向通胀对冲资产，快速借入美元和背负债务的速度也在加快。这就造成了1979-1982年期间的货币和信贷危机。</p><p>在那期间，美元和美元债面临着不再担任公认财富储备的风险。当然，普通老百姓并不了解这种货币和信贷的动态是如何运作的，但他们以高通胀和高利率的形式感受到了它，这就成了一个巨大的政治问题。时任总统卡特和大多数政治领导人一样并不太了解货币机制，但他知道必须做点什么来阻止危机，于是任命了一位强有力的货币政策制定者——保罗·沃尔克。</p><p>几乎所有关注危机的人，包括我在内，都会注意听他说的每一句话。他足够强大，能够做一些令人痛苦但正确的事情来打破通货膨胀。他成为了我的英雄，最终还因其很棒的性格和出色的能力，成为了我的好朋友，我也喜欢他冷嘲式的幽默。 </p><p>德国前总理赫尔穆特·施密特认为，为了应对这场货币通胀危机并打破通货膨胀，沃尔克收紧了货币供应，将利率推到了”自耶稣基督诞生以来”的最高水平。</p><p>债务人就不得不在收入和资产贬值的同时，支付更多的偿债款。由此，债务人受到压榨，被逼出售资产。由于美元需求巨大，美元走强。基于这些原因，通货膨胀下降，美联储随之降低利率，放松了美国人的货币和信贷。</p><p>当然，许多债务人和贬值资产持有人都破产了。因此，在80年代，这些债务人，尤其是外国债务人，更尤其是新兴国家的债务人，经历了长达十年的经济萧条和债务重组时期。美联储通过向美国银行提供所需的资金来保护他们，而美国的会计制度则不要求银行将这些坏账作为损失来核算，或无需按照实际价格来对这些债务资产进行估值，从而保护美国银行免于破产。</p><p>这一债务管理和重组过程一直持续到1991年，最后以迎来用时任美国财政部长尼古拉斯·布雷迪名字命名的”布雷迪债券协议”而告终。1971-1991年整个周期几乎影响了世界上所有的人，这是美国脱离金本位的结果。</p><p>它导致了70年代的通胀和通胀对冲资产的飙升，随后又带来1979-1981年的紧缩、非美债务人大量的通缩债务重组、通胀率下降，以及1980年代债券和其他通缩资产的出色表现。这整个时期都有力地证明了拥有世界储备货币的美国具有怎样的力量，以及储备货币管理方式对世界各国的影响。</p><p>从1979-1981年期间以美元计价的通货膨胀率和利率双双达到峰值到现在，通胀和利率都降到了接近0%。你可以清楚地看到，自新的美元计价货币体系建立以来，利率和通胀整个大型周期的起起伏伏。</p><p><img src="https://i.loli.net/2020/05/03/QOHUyPVpERgM2AD.jpg" alt="通胀及利率的起伏"></p><p>在整个这段时间里，世界上以美元计价的货币、信贷和债务以及其他非债务性负债（如养老金和医保等）相对于收入而言持续上升。因为美联储有独特的能力来支撑这种债务增长，上述情况在美国尤为明显。</p><p>20世纪80年代债务重组完成后，全球货币、信贷和债务的全新增长又在90年代开始了。这再次带来了经济繁荣，并且导致投资者举债进行投机性投资，最终形成在2000年破裂的科网泡沫。</p><p>泡沫的破裂引出了2000-2001年的经济衰退，并刺激美联储放宽货币和信贷，将债务水平推到了新的高点。接下来，又一次的经济繁荣到来，另一个更大的债务泡沫在2007年诞生，于2008年破裂。</p><p>于是美联储和其他储备货币国家的央行再次宽松，又带来了近期刚刚破裂的下一个泡沫。然而，这一次创造应对经济衰退所需货币和信贷的方式却被设计得十分不同。</p><p>短期利率在2008年达到0%，而这个降息的幅度尚无法满足货币和信贷扩张的需要。通过降息刺激货币和信贷增长是央行的首选货币政策。我称其为”货币政策1”。随着这种方法不再适用于中央银行，他们就转向了第二选择（我称之为”货币政策2”），即印钞和购买以国债、优质债务为主的金融资产。</p><p>央行上一次需要这样做，是因为利率从1933年开始触及0%，且在战争年代也一直保持零利率。这种做法被称为”量化宽松”而不是”债务货币化”，是因为QE听起来没有那么大的威胁性。世界上所有的主要储备货币央行都已经这么做了。</p><p>这就带来了下一个货币/信贷/经济范式，直到我们现在经历的经济衰退之前，这一范式一直在持续。</p><p>自2008年开始的这一范式是这样的。</p><p>正如从1933年开始所做的那样，央行通过印钞和购买债券维持了货币和债务扩张周期。</p><p>通过购买债券，央行推高了债券价格，并为这些债券的卖家提供现金，致使他们去购买其他资产。这就推高了其他资产的价格，而随着这些资产价格上涨，未来的预期回报率随之下降。</p><p>由于利率低于其他投资的预期回报率，而相对于投资者为其各种支出义务提供资金所需的回报率而言，债券收益率和其他未来预期回报率的水平都很低，因此，投资者越来越频繁地借钱购买他们认为收益将高于借贷成本的资产。</p><p>这既推高了上述资产的价格，又造成了新的债务泡沫脆弱性——如果他们所购资产收益低于其借贷成本，就会产生新的债务泡沫。由于长期和短期利率都在0%左右，而且央行购买债券的资金无法刺激经济增长和帮助那些最需要帮助的人，所以我觉得第二种货币政策显然不能很好地发挥作用，这就需要第三种货币政策——“货币政策3”。</p><p>“货币政策3”的工作原理是，储备货币中央政府增加借贷，并将其支出和贷款的目标定在他们想要的地方，而储备货币中央银行则创造货币和信贷，并购买债务（可能还有其他资产，如股票）来提供资金。虽然我不会在这里解释各种方法，但在我的书《Principles for Navigating Big Debt Crises》当中已经解释过了。</p><p>因此，在疫情引发经济衰退之前，我们就已经做好了准备：一旦经济滑入衰退，就必须走这条路。如果你想要看我更为深入地研究相关话题的文章，可以点击economicprinciples.org。</p><p>无论如何，在这段时期内，债务和非债务性负债（如养老金和医保）相对于收入而言继续上升，而中央银行设法压低了偿债成本（详见我的报告”The Big Picture”，里面对此举所导致的、即将到来的“挤兑”解释得更完整）。</p><p>这就把利率推向了零，并使债务长期化，从而使本金偿付水平降低。诸如中央银行拥有大量的债务、利率在0%左右因此不需要支付利息、构建可以长期偿还的债务并使本金可以分散偿还甚至不用偿还之类的条件，意味着中央银行创造货币和信贷的能力几乎没有限制。这一系列的条件为接下来的事情奠定了基础。</p><p>新冠疫情引发了世界各地的经济和市场衰退，造成了收入和资产负债表方面的窟窿，特别是对那些收入受到衰退影响的负债实体来说，更是如此。</p><p>传统上，中央政府和央行必须创造货币和信贷，才能把钱和信贷送到他们想救的实体手中。如果没有这些钱和信贷，这些实体在财务上是无法生存的。</p><p>由此，2020年4月9日，美国中央政府（总统和国会）和美国央行（美联储）宣布了一项大规模的货币和信用创造计划，采用了“货币政策3”之中所有经典的手法，包括直升机撒钱（政府直接给公民发钱）。</p><p>这基本上与罗斯福在1933年3月5日宣布的计划是一样的。虽然是疫情引发了这次特殊的金融和经济衰退，但就算没有疫情，其他东西最终也会触发衰退。</p><p>无论衰退的起因是什么，但动力基本上都是一样的，因为只有“货币政策3”才会起到扭转经济衰退的作用。欧洲央行、日本央行以及中国人民银行也都采取了类似措施，不过最重要的仍是美联储的举动，因为它是美元的创造者，而美元仍然是世界上占主导地位的货币和信贷。</p><p>目前，美元在全球的国际交易、储蓄、借贷中约占55%。欧元区的欧元约占25%。日元占比不到10%。中国的人民币占2%左右。其他大多数货币都没有在国际上用作交换媒介和财富储存手段，仅在各国国内使用。</p><p>无论是上述各国国内的聪明人，还是这些国家以外的几乎所有人，都不会持有这部分货币并将其作为财富储备。相比之下，我提到的储备货币，就是全世界大多数人喜欢储蓄、借贷、交易的货币，大致比例和我上文所说的相同。</p><p>拥有世界储备货币的国家拥有惊人的力量——储备货币可能是最重要的力量，重要程度甚至超过军事力量。</p><p>这是因为当一个国家拥有储备货币时，它可以在合适的时候像美国现在这样印钱、借钱来消费，而那些没有储备货币的国家则必须先获得他们所需要的钱和信贷（以世界储备货币计价）才能进行交易和储蓄。</p><p>比如说现在，截止发稿，那些有很多债务需要偿还的人对美元的需求很强，因其需要更多的美元来购买商品和服务，但他们的美元收入已经下降。</p><p>正如章节一中表明衡量一国国力上升和下降的八项指标的图表所示，储备货币实力（以该货币的交易和储蓄份额来衡量）明显落后于衡量国家实力的其他指标。美国和美元的情况也是如此。</p><p>例如，在1944年，当美元被选定为全球主要储备货币时，美国政府持有的黄金占全球黄金总量的约三分之二（黄金当时被视为货币），美国经济则约占全球GDP的一半。</p><p>如今，美国GDP只占全球的20%左右，但美元仍占全球外汇储备的60%左右，还占有国际交易量的半壁江山。所以，美元和以美元为基础的货币和支付体系仍然占据着至高无上的地位，相对于美国经济的规模而言，它的规模还是特大号。</p><p>和所有印制储备货币的银行一样，美联储现在处于强势但尴尬的地位。其货币政策的运行方式对美国人有利，但对世界上其他依赖美元的国家来说，可能并不是好事。</p><p>比如美国中央政府最近刚刚决定，将借贷给美国人发放美元和美元信贷，美联储则决定购买美国政府的那笔国债和美国人其他的债务，帮助他们度过这次金融危机。可以理解的是，这些钱几乎没有多少会流向外国人。</p><p>欧洲央行也将对欧元区国家采取类似措施。世界影响力仍旧较小的日本央行也会为日本人做同样的事情，中国人民银行同样会为中国人做类似的事情。</p><p>其他几个相对较小的国家（如瑞士）也许可以为本国人民做类似的事情，但世界上大多数人无法像美国人那样，得到他们所需要的钱和信贷来填补收入和资产负债表的窟窿。</p><p>这一动态，即国家无法获得他们所需要的硬通货就像1982-1991年期间发生的事情一样，只是这次无法再靠大幅削减利率解决问题，而那个时候可以。</p><p>与此同时，非美国人（即新兴市场、欧洲国家和中国）持有的美元债总额约为20万亿美元（比2008年时高50%左右），其中短期债务不到一半。这些美元债务人将不得不拿出美元来偿还这些债务，还要拿出更多的美元来在世界市场上购买商品和服务。</p><p>所以，通过拥有美元作为世界储备货币并拥有生产这种货币的银行，且拥有把这些急需的美元放入美国人手中的实力，美国就可以比其他国家的政府更有效地帮助本国公民。</p><p>同时，美国也有可能会因为制造了太多的货币和债务而失去这种特权地位。在本章的附录中，我们将更深入地研究曾经拥有储备货币的国家是如何失去储备货币的，以及货币贬值是如何运作的。</p><h1 id="6-Summary"><a href="#6-Summary" class="headerlink" title="6. Summary"></a>6. Summary</h1><p>回过头来从大格局的角度看这一切，我想谈论的关系包括1）经济之间（即货币、信贷、债务、经济活动和财富）和2）政治之间（国家内部和各国之间），具体起起落落如下图所示。</p><p><img src="https://i.loli.net/2020/05/03/YEnmcZpRXAota3T.png" alt="债务周期"></p><p>通常情况下，大的周期始于一个全新的世界秩序，即一种囊括全新货币体系和政治制度、包含国内和国际运作的一种全新方式。最近的一次大周期始于1945年。</p><p>因为在那样的时期，冲突之后出现了具有主导力量的大国，大家都不愿意打仗，人们也厌倦了战斗，于是就有了和平重建和日益繁荣的局面，而这种繁荣是由可持续的信贷扩张来支撑的。</p><p>之所以说是可持续的，是因为收入的增长超过或跟上了偿还不断增长的债务所需的偿债支出，也是因为央行有能力刺激信贷，经济增速也很强劲。一路走来，过程中会出现短期的债务和经济周期，我们称之为衰退和扩张。</p><p>随着时间的推移，投资者以过去的收益推断未来，并借钱来押注收益可以实现。这就在贫富差距扩大（有些人的收益比其他人更多）的同时产生了债务泡沫。这种情况将一直持续下去，直到各国央行耗尽一切有效刺激信贷和经济增长的能力。</p><p>随着货币紧缩，债务泡沫破裂，信贷收缩，经济也随之萎缩。同时，当出现巨大的贫富差距、严重的债务问题且经济萎缩时，国家内部和国家之间往往会发生争夺财富和权力的斗争。</p><p>在债务和经济出现问题的时候，中央政府和中央银行通常会发行货币和信贷，并有可能使本币贬值。这些事态发展导致了债务、货币体系、国内秩序和世界秩序的重组。然后，事情又开始了。</p><p>虽然没有一个周期完全符合描述，但几乎所有周期都与之相差无几。比如说，虽然债务泡沫破裂一般会导致经济萎缩，经济萎缩叠加巨大的贫富差距通常会导致内斗和外斗，但有时顺序有些不同。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://www.thepaper.cn/newsDetail_forward_7147656" target="_blank" rel="noopener">https://www.thepaper.cn/newsDetail_forward_7147656</a></li><li><a href="https://www.linkedin.com/in/raydalio/detail/recent-activity/" target="_blank" rel="noopener">https://www.linkedin.com/in/raydalio/detail/recent-activity/</a></li><li><a href="https://m.chinanews.com/wap/detail/zw/cj/2020/03-19/9131125.shtml" target="_blank" rel="noopener">https://m.chinanews.com/wap/detail/zw/cj/2020/03-19/9131125.shtml</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Ray Dalio在LinkedIn上的长文，主要分析了在长期债务周期当中，货币、信贷、债务之间的相互运作关系，以及它们驱动全球经济和政治变化的方式。&lt;/p&gt;
&lt;h1 id=&quot;1-货币和信贷&quot;&gt;&lt;a href=&quot;#1-货币和信贷&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="Notes" scheme="https://www.llchen60.com/categories/Notes/"/>
    
    
      <category term="Economy" scheme="https://www.llchen60.com/tags/Economy/"/>
    
  </entry>
  
  <entry>
    <title>Java 多线程 基础知识(一)</title>
    <link href="https://www.llchen60.com/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://www.llchen60.com/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2020-05-01T02:36:12.000Z</published>
    <updated>2020-05-03T05:02:06.294Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-多线程知识基础"><a href="#1-多线程知识基础" class="headerlink" title="1. 多线程知识基础"></a>1. 多线程知识基础</h1><h2 id="1-1-线程-vs-进程"><a href="#1-1-线程-vs-进程" class="headerlink" title="1.1 线程 vs 进程"></a>1.1 线程 vs 进程</h2><p>进程是程序的一次执行过程，java当中，启动main函数就是启动了一个JVM进程，main函数所在的线程是其中之一，也称为主线程。</p><p>线程是比进程更小的执行单位，一个进程执行过程当中可以产生多个线程。同类的多个线程互相之间共享进程的堆和方法区的资源。每个线程有自己的程序计数器，虚拟机栈，和本地方法栈</p><p>线程与进程之间的关系如下图所示</p><p><img src="https://i.loli.net/2020/04/30/3AwhmaPDLkcXKMb.png" alt="线程进程关系.png"> </p><p>运行时堆和方法区，还有常量是共享的。</p><p><strong>线程私有的</strong></p><ul><li>程序计数器<ul><li>当前线程所执行的字节码的行号指示器</li><li>字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成</li><li>为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存</li><li>程序计数器是唯一不会出现OutOfMemoryError的内存区域，声明周期是完全跟着线程的，线程创建即创建，线程结束即结束</li><li>程序计数器的私有主要是为了线程切换以后能够恢复到正确的执行位置上</li></ul></li><li>虚拟机栈<ul><li>描述java方法执行的内存模型</li><li>Java虚拟机栈由一个个栈帧组成，每个栈帧都拥有<ul><li>局部变量表<ul><li>存放了编译器已知的各种数据类型</li><li>对象引用</li></ul></li><li>操作数栈</li><li>动态链接</li><li>方法出口信息</li></ul></li></ul></li><li>本地方法栈<ul><li>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务</li><li>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</li></ul></li></ul><p><strong>线程共享资源</strong></p><ul><li><p>堆 </p><ul><li>存放对象实例</li><li>几乎所有对象实例以及数组都在这里分配内存</li><li>堆是Java垃圾收集器的主要区域，因此也被称作GC堆 Garbage Collected Heap </li><li>堆会根据时间的长度分为多种空间，来方便垃圾收集器来更好的回收内存</li><li>还包括运行时常量池</li></ul></li><li><p>方法区</p><ul><li>用于存储已被虚拟机加载的类的信息，常量，静态变量，即时编译器编译后的代码等数据</li></ul></li><li><p>直接内存</p></li></ul><h2 id="1-2-并发-vs-并行"><a href="#1-2-并发-vs-并行" class="headerlink" title="1.2 并发 vs 并行"></a>1.2 并发 vs 并行</h2><p>并发 - 同一时间段的多个任务都在执行<br>并行 - 单位时间内，多个任务同时执行</p><h2 id="1-3-多线程带来的改变"><a href="#1-3-多线程带来的改变" class="headerlink" title="1.3 多线程带来的改变"></a>1.3 多线程带来的改变</h2><h3 id="1-3-1-优势"><a href="#1-3-1-优势" class="headerlink" title="1.3.1 优势"></a>1.3.1 优势</h3><ul><li>线程，是程序执行的最小单位，线程间的切换和调度成本远远小于进程。而且多核CPU时代意味着多个线程同时进行，这减少了线程上下文切换的开销</li><li>多线程并发变成是开发高并发系统的基础</li><li>单核时代多线程做的优化更多是提高CPU和IO的综合利用率。在一个线程做IO的时候，另外一个线程可以到内核当中做利用CPU的大量计算</li><li>多核时代想做的事情就是同时使用多个内核一起来做这件事，提高整个运行的效率</li></ul><h3 id="1-3-2-可能的问题"><a href="#1-3-2-可能的问题" class="headerlink" title="1.3.2 可能的问题"></a>1.3.2 可能的问题</h3><p>需要解决内存泄漏，死锁，线程不安全相关的问题</p><ul><li>死锁<ul><li>多个线程被同时阻塞，在等待某个资源的释放</li><li>产生死锁的条件<ul><li>互斥条件 – 该资源任意时刻只由一个线程占用</li><li>请求与保持条件 – 一个进程因请求资源而阻塞时，对已获得的资源保持不放 </li><li>不剥夺条件 – 线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源</li><li>循环等待条件 – 若干进程之间形成一种头尾相接的循环等待资源关系</li></ul></li></ul></li></ul><pre><code>public class DeadLockDemo {    private static Object resource1 = new Object();//资源 1    private static Object resource2 = new Object();//资源 2    public static void main(String[] args) {        new Thread(() -&gt; {            synchronized (resource1) {                System.out.println(Thread.currentThread() + &quot;get resource1&quot;);                try {                    Thread.sleep(1000);                } catch (InterruptedException e) {                    e.printStackTrace();                }                System.out.println(Thread.currentThread() + &quot;waiting get resource2&quot;);                synchronized (resource2) {                    System.out.println(Thread.currentThread() + &quot;get resource2&quot;);                }            }        }, &quot;线程 1&quot;).start();        new Thread(() -&gt; {            synchronized (resource2) {                System.out.println(Thread.currentThread() + &quot;get resource2&quot;);                try {                    Thread.sleep(1000);                } catch (InterruptedException e) {                    e.printStackTrace();                }                System.out.println(Thread.currentThread() + &quot;waiting get resource1&quot;);                synchronized (resource1) {                    System.out.println(Thread.currentThread() + &quot;get resource1&quot;);                }            }        }, &quot;线程 2&quot;).start();    }}</code></pre><h2 id="1-4-sleep（）vs-wait（）"><a href="#1-4-sleep（）vs-wait（）" class="headerlink" title="1.4 sleep（）vs wait（）"></a>1.4 sleep（）vs wait（）</h2><ul><li>最主要的区别在于sleep并没有释放锁，而wait方法会释放锁</li><li>二者都暂停了当前线程的执行</li><li>wait用于线程之间的交互和通信，sleep用于暂停执行</li><li>wait()方法被调用以后，线程不会自动苏醒，需要别的线程调用同一个对象上的notify()或者notifyAll()方法</li></ul><h2 id="1-5-并发编程的重要特性"><a href="#1-5-并发编程的重要特性" class="headerlink" title="1.5 并发编程的重要特性"></a>1.5 并发编程的重要特性</h2><ul><li>原子性<ul><li>被修饰的代码块要不全都执行，要不都不执行，synchronized可以保证代码片段的原子性</li></ul></li><li>可见性<ul><li>当一个变量对共享变量进行了修改，那么另外的线程都是立即可以看到修改以后的新值的。volatile关键字可以保证共享变量的可见性</li></ul></li><li>有序性<ul><li>Java 在编译器以及运行期间的优化，代码的执行顺序未必就是编写代码时候的顺序。volatile 关键字可以禁止指令进行重排序优化   </li></ul></li></ul><h2 id="1-6-volatile关键字"><a href="#1-6-volatile关键字" class="headerlink" title="1.6 volatile关键字"></a>1.6 volatile关键字</h2><h3 id="1-6-1-General"><a href="#1-6-1-General" class="headerlink" title="1.6.1 General"></a>1.6.1 General</h3><p>在当前的 Java 内存模型下，线程可以把变量保存本地内存（比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成数据的不一致。要解决这个问题，需要将变量声明为volatile，这就指示JVM，这个变量时不稳定的，每次使用它都到主存当中进行读取。<br>即volatile关键字可以起到：</p><ul><li>保证变量的可见性，从主内存当中拿数据</li><li>防止指令重排序</li></ul><h2 id="1-7-synchronized关键字"><a href="#1-7-synchronized关键字" class="headerlink" title="1.7 synchronized关键字"></a>1.7 synchronized关键字</h2><h3 id="1-7-1-General"><a href="#1-7-1-General" class="headerlink" title="1.7.1 General"></a>1.7.1 General</h3><ul><li>解决多个线程之间访问资源的同步性问题</li><li>可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行</li><li>最开始是基于操作系统的mutex lock来实现，因为有用户态和内核态的转换，需要相对比较长的时间，性能不好；JDK 1.6之后做了大量优化，性能有了不小的提升<ul><li>自旋锁</li><li>适应性自旋锁</li><li>锁消除</li><li>锁粗化</li><li>偏向锁</li><li>轻量级锁</li></ul></li></ul><h3 id="1-7-2-使用方式"><a href="#1-7-2-使用方式" class="headerlink" title="1.7.2 使用方式"></a>1.7.2 使用方式</h3><ul><li>修饰实例方法<ul><li>作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁 </li></ul></li><li>修饰静态方法<ul><li>给当前类加锁，会作用于类的所有对象实例</li></ul></li><li>修饰代码块<ul><li>指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁  </li></ul></li></ul><pre><code>// 线程安全的单例模式的实现public class Singleton {    private volatile static Singleton uniqueInstance;    private Singleton() {    }    public static Singleton getUniqueInstance() {       //先判断对象是否已经实例过，没有实例化过才进入加锁代码        if (uniqueInstance == null) {            //类对象加锁            synchronized (Singleton.class) {                if (uniqueInstance == null) {                    uniqueInstance = new Singleton();                }            }        }        return uniqueInstance;    }}</code></pre><h3 id="1-7-3-底层实现方式"><a href="#1-7-3-底层实现方式" class="headerlink" title="1.7.3 底层实现方式"></a>1.7.3 底层实现方式</h3><ul><li>同步语句块的时候<ul><li>使用的是monitorenter和monitorexit指令</li><li>monitorenter指令指向同步代码块的开始位置</li><li>monitorexit指令指向同步代码块的结束位置</li><li>锁计数器为0时可以获取，释放锁的时候再置为0</li></ul></li><li>同步方法的时候<ul><li>使用的是ACC_SYNCHRONIZED标识，指明该方法为一个同步方法，从而执行相应的同步调用</li></ul></li></ul><h3 id="1-7-4-synchronized-关键字的底层优化"><a href="#1-7-4-synchronized-关键字的底层优化" class="headerlink" title="1.7.4 synchronized 关键字的底层优化"></a>1.7.4 synchronized 关键字的底层优化</h3><p>锁主要存在四中状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率</p><ul><li><p>偏向锁</p><ul><li>为了在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗</li><li>偏向锁在无竞争的情况下会把整个同步都消除掉</li><li>但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失，需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁 </li></ul></li><li><p>轻量级锁</p><ul><li>偏向锁失败的情况下会首先升级为轻量级锁</li><li>在没有多线程竞争的前提下，减少传统重量级锁使用操作系统互斥量产生的性能消耗</li><li>使用轻量级锁，不需要申请互斥量。另外，轻量级锁的加锁和解锁都用到了CAS操作 </li><li>轻量级锁能够提升程序同步性能的依据是“对于绝大部分锁，在整个同步周期内都是不存在竞争的”，这是一个经验数据。如果没有竞争，轻量级锁使用 CAS 操作避免了使用互斥操作的开销。但如果存在锁竞争，除了互斥量开销外，还会额外发生CAS操作，因此在有锁竞争的情况下，轻量级锁比传统的重量级锁更慢！如果锁竞争激烈，那么轻量级将很快膨胀为重量级锁！</li></ul></li><li><p>自旋锁和自适应自旋</p><ul><li>互斥同步对性能最大的影响就是阻塞的实现，因为挂起线程/恢复线程的操作都需要转入内核态中完成</li><li>般线程持有锁的时间都不是太长，所以仅仅为了这一点时间去挂起线程/恢复线程是得不偿失的</li><li>自旋锁就是让线程执行一个忙循环，自旋锁和互斥锁不同之处在于不会休眠，调用者一直在那里循环看锁的保持者是否释放了锁</li></ul></li><li><p>锁消除</p><ul><li>编译器在运行的时候，如果检测到共享数据不可能存在竞争，就执行锁消除，以节省毫无意义的请求锁的时间</li></ul></li></ul><h3 id="1-7-5-synchronized关键字和volatile关键字的区别"><a href="#1-7-5-synchronized关键字和volatile关键字的区别" class="headerlink" title="1.7.5 synchronized关键字和volatile关键字的区别"></a>1.7.5 synchronized关键字和volatile关键字的区别</h3><ul><li>volatile是线程同步的轻量级实现，因此volatile性能会比synchronized关键字好。</li><li>多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会</li><li>volatile关键字能保证数据的可见性，不能保证数据的原子性。synchronized都可以保证</li><li>volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized关键字解决的是多个线程之间访问资源的同步性</li></ul><h1 id="2-ThreadLocal"><a href="#2-ThreadLocal" class="headerlink" title="2. ThreadLocal"></a>2. ThreadLocal</h1><h2 id="2-1-ThreadLocal"><a href="#2-1-ThreadLocal" class="headerlink" title="2.1 ThreadLocal"></a>2.1 ThreadLocal</h2><p>通常情况下，我们创建的变量时可以被任何一个线程访问并修改的，如果想实现每一个线程都有自己的专属的本地变量的话，可以使用JDK提供的ThreadLocal类。ThreadLocal类解决的问题就是想让每个线程都绑定自己的值。</p><p>当我们创建了ThreadLocal变量，访问这个变量的每个线程都会有这个变量的本地副本，使用get()以及set()方法获取默认值或者将指改为当前线程所存的副本的值，从而避免线程安全问题。</p><pre><code>import java.text.SimpleDateFormat;import java.util.Random;public class ThreadLocalExample implements Runnable{     // SimpleDateFormat 不是线程安全的，所以每个线程都要有自己独立的副本    private static final ThreadLocal&lt;SimpleDateFormat&gt; formatter = ThreadLocal.withInitial(() -&gt; new SimpleDateFormat(&quot;yyyyMMdd HHmm&quot;));    public static void main(String[] args) throws InterruptedException {        ThreadLocalExample obj = new ThreadLocalExample();        for(int i=0 ; i&lt;10; i++){            Thread t = new Thread(obj, &quot;&quot;+i);            Thread.sleep(new Random().nextInt(1000));            t.start();        }    }    @Override    public void run() {        System.out.println(&quot;Thread Name= &quot;+Thread.currentThread().getName()+&quot; default Formatter = &quot;+formatter.get().toPattern());        try {            Thread.sleep(new Random().nextInt(1000));        } catch (InterruptedException e) {            e.printStackTrace();        }        //formatter pattern is changed here by thread, but it won&#39;t reflect to other threads        formatter.set(new SimpleDateFormat());        System.out.println(&quot;Thread Name= &quot;+Thread.currentThread().getName()+&quot; formatter = &quot;+formatter.get().toPattern());    }}</code></pre><p>从ThreadLocal原理上来讲</p><pre><code>public class Thread implements Runnable {     ......    //与此线程有关的ThreadLocal值。由ThreadLocal类维护    ThreadLocal.ThreadLocalMap threadLocals = null;    //与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护    ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;     ......}</code></pre><ul><li><p>Thread类中有一个threadLocals和一个inheritableThreadLocals变量，都是由ThreadLocalMap来实现的。默认情况下两个变量的值均为null，只有当前线程调用ThreadLocal类的set/ get方法时才创建他们</p></li><li><p>ThreadLocal类的set()方法</p></li></ul><pre><code>    public void set(T value) {        Thread t = Thread.currentThread();        ThreadLocalMap map = getMap(t);        if (map != null)            map.set(this, value);        else            createMap(t, value);    }    ThreadLocalMap getMap(Thread t) {        return t.threadLocals;    }</code></pre><ul><li>从上面的代码中，可以看出最终的变量是放在了当前线程的ThreadLocalMap当中，并不是直接存在ThreadLocal上，ThreadLocal可以理解为只是ThreadLocalMap的封装，传递了变量值。</li><li>ThreadLocal类可以通过Thread.currentThread()获取当前线程对象之后，直接通过getMap(Thread t) 访问到该线程的ThreadLocalMap对象</li></ul><h1 id="3-AQS"><a href="#3-AQS" class="headerlink" title="3. AQS"></a>3. AQS</h1><p>AQS全称为AbstractQueuedSynchronizer，是一个用来构建锁和同步器的框架。</p><h2 id="3-1-原理分析"><a href="#3-1-原理分析" class="headerlink" title="3.1 原理分析"></a>3.1 原理分析</h2><p>核心思想为如果被请求的共享资源是空闲的，就将现在请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的资源被占用了，那么就需要一整套线程阻塞等待以及被唤醒时锁分配的机制，AQS使用CLH队列锁实现，将暂时获取不到锁的线程加入到队列当中。</p><p>CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS是将每条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node）来实现锁的分配</p><ul><li>AQS使用int变量来表示同步状态</li><li>通过内置的FIFO队列来完成获取资源线程的排队工作</li><li>AQS使用CAS对该同步状态进行原子操作实现对其值的修改</li></ul><pre><code>private volatile int state;//共享变量，使用volatile修饰保证线程可见性//返回同步状态的当前值protected final int getState() {          return state;} // 设置同步状态的值protected final void setState(int newState) {         state = newState;}//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）protected final boolean compareAndSetState(int expect, int update) {        return unsafe.compareAndSwapInt(this, stateOffset, expect, update);}</code></pre><h2 id="3-2-AQS资源共享方式"><a href="#3-2-AQS资源共享方式" class="headerlink" title="3.2 AQS资源共享方式"></a>3.2 AQS资源共享方式</h2><ul><li>共有两种资源共享方式<ul><li>Exclusive 独占 <ul><li>只有一个线程能执行，又分为公平锁和非公平锁</li><li>公平锁<ul><li>按照线程在队列中的排队顺序，先到者先拿到锁 </li></ul></li><li>非公平锁  <ul><li>当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的</li></ul></li></ul></li><li>Share 共享<ul><li>多个线程可同时执行<ul><li>semaphore</li><li>coutDownLatch</li></ul></li></ul></li></ul></li></ul><h2 id="3-3-常用组件"><a href="#3-3-常用组件" class="headerlink" title="3.3 常用组件"></a>3.3 常用组件</h2><ul><li><p>Semaphore 信号量 – 允许多个线程同时访问</p><ul><li>synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。</li></ul></li><li><p>CountDownLatch 倒计时器</p><ul><li>CountDownLatch是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行</li></ul></li><li><p>CyclicBarrier 循环栅栏</p><ul><li>CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）</li><li>它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier默认的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用await()方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞<h1 id="4-Atomic原子类"><a href="#4-Atomic原子类" class="headerlink" title="4. Atomic原子类"></a>4. Atomic原子类</h1></li></ul></li></ul><p>在这里指的是不可中断的操作，即便是多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。原子类体系就是就有原子/原子操作特征的类。</p><h2 id="4-1-General"><a href="#4-1-General" class="headerlink" title="4.1 General"></a>4.1 General</h2><ul><li><p>基本类型 - 使用原子的方式更新基本类型</p><ul><li>AtomicInteger 整形原子类</li><li>AtomicLong 长整形原子类</li><li>AtomicBoolean 布尔型原子类</li></ul></li><li><p>数组类型</p><ul><li>AtomicIntegerArray 整形数组原子类</li><li>AtomicLongArray 长整形数组原子类</li><li>AtomicReferenceArray 引用类型数组原子类</li></ul></li><li><p>引用类型</p><ul><li>AtomicReference 引用类型原子类</li><li>AtomicStampedReference 原子更新引用类型里的字段原子类</li><li>AtomicMarkableReference 原子更新带有标记位的引用类型</li></ul></li><li><p>对象的属性修改类型</p><ul><li>AtomicIntegerFieldUpdater </li><li>AtomicLongFielfUpdater</li><li>AtomicStampedReference </li></ul></li></ul><h2 id="4-2-使用与原理"><a href="#4-2-使用与原理" class="headerlink" title="4.2 使用与原理"></a>4.2 使用与原理</h2><ul><li>以AtomicInteger为例，其方法如下：</li></ul><pre><code>    public final int get() //获取当前的值    public final int getAndSet(int newValue)//获取当前的值，并设置新的值    public final int getAndIncrement()//获取当前的值，并自增    public final int getAndDecrement() //获取当前的值，并自减    public final int getAndAdd(int delta) //获取当前的值，并加上预期的值    boolean compareAndSet(int expect, int update) //如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）    public final void lazySet(int newValue)//最终设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</code></pre><ul><li>AtomicInteger实现原理<ul><li>使用CAS以及volative来保证原子操作，从而避免synchronized的高开销，执行效率大为提升</li><li>CAS的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值</li><li>UnSafe 类的 objectFieldOffset() 方法是一个本地方法，这个方法是用来拿到“原来的值”的内存地址，返回值是 valueOffset</li><li>另外 value 是一个volatile变量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总能拿到该变量的最新值。</li></ul></li></ul><pre><code>    // setup to use Unsafe.compareAndSwapInt for updates（更新操作时提供“比较并替换”的作用）    private static final Unsafe unsafe = Unsafe.getUnsafe();    private static final long valueOffset;    static {        try {            valueOffset = unsafe.objectFieldOffset                (AtomicInteger.class.getDeclaredField(&quot;value&quot;));        } catch (Exception ex) { throw new Error(ex); }    }    private volatile int value;</code></pre><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://gitee.com/SnailClimb/JavaGuide/blob/master/docs/java/Multithread/synchronized.md" target="_blank" rel="noopener">https://gitee.com/SnailClimb/JavaGuide/blob/master/docs/java/Multithread/synchronized.md</a></li><li><a href="https://blog.csdn.net/zqz_zqz/article/details/70233767" target="_blank" rel="noopener">https://blog.csdn.net/zqz_zqz/article/details/70233767</a></li><li><a href="https://www.baeldung.com/java-threadpooltaskexecutor-core-vs-max-poolsize" target="_blank" rel="noopener">https://www.baeldung.com/java-threadpooltaskexecutor-core-vs-max-poolsize</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-多线程知识基础&quot;&gt;&lt;a href=&quot;#1-多线程知识基础&quot; class=&quot;headerlink&quot; title=&quot;1. 多线程知识基础&quot;&gt;&lt;/a&gt;1. 多线程知识基础&lt;/h1&gt;&lt;h2 id=&quot;1-1-线程-vs-进程&quot;&gt;&lt;a href=&quot;#1-1-线程-vs-进
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
      <category term="Multi-threading" scheme="https://www.llchen60.com/tags/Multi-threading/"/>
    
  </entry>
  
  <entry>
    <title>工程上关于SQL数据库 - 你需要知道的事</title>
    <link href="https://www.llchen60.com/%E5%B7%A5%E7%A8%8B%E4%B8%8A%E5%85%B3%E4%BA%8ESQL%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E4%BA%8B/"/>
    <id>https://www.llchen60.com/%E5%B7%A5%E7%A8%8B%E4%B8%8A%E5%85%B3%E4%BA%8ESQL%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E4%BA%8B/</id>
    <published>2020-04-27T20:48:48.000Z</published>
    <updated>2020-04-29T18:39:57.222Z</updated>
    
    <content type="html"><![CDATA[<p>大部分的计算机系统都会有需要维护的状态，大概率就要依赖于一个存储系统。在重数据的系统当中，数据库就会成为整个系统设计的核心，其中会有很多需要考虑到的权衡。我们必须要学习并且了解数据库是如何被使用的，这篇文章会分享一些对于开发者有用的视角和观点。</p><h1 id="1-网络连接问题-–-难以达到的5个9"><a href="#1-网络连接问题-–-难以达到的5个9" class="headerlink" title="1. 网络连接问题 – 难以达到的5个9"></a>1. 网络连接问题 – 难以达到的5个9</h1><p>总有关于当前的网络有多么值得信赖的考量，谷歌云的数据，在服务层面达到99.999%的可访问的程度的时候，大约有7.6%的问题是由于网络造成的。这也同样有相关数据在AWS，甚至阿里云当中。因为挖断光纤，或者网络配置的问题，造成一个数据中心，甚至一个avaliability zone 不可访问。</p><p>根据过往的经验，云服务提供商出现的网络问题，很有可能直接造成使用的公司服务down掉数小时的时间。从用户的角度来看，他们去定位问题所在是很有难度的。首先要尽快判断是IaaS 还是PaaS出现的问题，当判断出是云服务供应商这边出现的问题之后，除了尽快联系，恐怕也别无他法。</p><p>出现网络问题的原因很多，像是硬件炸了，权限更改，停电，光纤被挖断，诸如此类。各大云服务厂商都会在一个地区有多个AZ,每个AZ有多个data center，相互之间再用光纤连接。会需要看哪条光纤无法使用，会对整个系统造成不同程度的影响。</p><h1 id="2-ACID-有多个涵义"><a href="#2-ACID-有多个涵义" class="headerlink" title="2. ACID 有多个涵义"></a>2. ACID 有多个涵义</h1><p>ACID指的是Atomicity, Consistency, Isolation, Durability。这些都是数据库的transaction需要的相关属性，以确保用户的数据属性在程序崩溃，硬件出现错误等各种情况下依旧按照期待来运行。没有ACID的话，开发者无法知道自己的代码的责任，以及数据库的责任，会造成很多问题。当然上述说的还是主要对于SQL数据库而言的，对于NoSQL来说，大部分都没有实现ACID，或者不是默认实现的(譬如AWS DynamoDB，可以选择实现transaction的功能)，因为他们实现起来很昂贵。</p><p>关于为什么NoSQL实现ACID很昂贵，首先需要说的是SQL对于大数据量是有瓶颈的，在上千万的数据规模以上，会难以继续扩容。NoSQL实质上是将传统的纵向扩容改为横向扩容，牺牲了一致性，(保证最终一致性)，来达到对更多数据的支持。</p><p>值得注意的是工业界对于ACID是没有一个非常非常之明确的定义的，首先不是每个数据库都是满足ACID的，然后在那些满足ACID的数据库当中，ACID也可以被不同的方式来做解释。ACID被不同的方式来解释的原因之一是在实现的时候四个特征之间的制衡。他们在处理一个edge case还有“不可能”情况的时候，表现还是会有蛮多不一样的地方的。</p><h1 id="3-每个数据库都有不同的一致性和隔离性能力"><a href="#3-每个数据库都有不同的一致性和隔离性能力" class="headerlink" title="3. 每个数据库都有不同的一致性和隔离性能力"></a>3. 每个数据库都有不同的一致性和隔离性能力</h1><p>在ACID属性当中，一致性和隔离性是在实现的时候最需要权衡的两个属性，因为实现的代价都很高。他们需要协同，在保证数据一致的过程中实质上是加剧了竞争的，竞争共同的资源。</p><p>在云服务的层面，一致性变得尤为困难，尤其是当我们需要横向的去扩展到不同的数据中心当中去的时候。根据CAP理论，一致性，可用性，分区容错性不可能同时满足，当我们要实现一致性的时候，势必会丢失掉一部分可用性，或者分区容错性。</p><p>值得注意的是，工程师是可以在程序的层面去解决一定的一致性的问题的，不一定要完全依赖于数据库层面的一致性检测。</p><p>数据库一般会提供一系列的隔离的层次，因此应用开发者就可以根据他们所需来选择最高效的isolation方式。弱隔离会更快，但也许会带来数据竞争。更强的隔离消减了一些潜在的数据隔离，但是会更慢，而且在慢到一定程度，TPS又相对比较高的情况下，数据库可能会被高TPS拖垮，变得不可访问。</p><p><img src="https://i.loli.net/2020/04/26/wU6biJox59ZanGN.png" alt="Existing concurrency model.png"></p><p>在SQL标准当中，隔离性的层级有：</p><ul><li>Serializable - 最严格，最昂贵的<ul><li>序列化的执行会要求前一个transaction完全执行完，才能去执行下一个transaction  </li><li>常常被称为snapshot isolation </li></ul></li><li>Repeatable reads <ul><li>在当前transaction当中还没提交的读请求对当前transaction是可见的，但是其他transaction做出的改变对当前transaction依旧不可见</li></ul></li><li>Read Committed <ul><li>未提交的读对transaction不可见</li><li>如果另外一个transaction插入并提交了新的行，当前的transaction在query的时候是可以看到的</li></ul></li><li>Read uncommitted <ul><li>脏读是被允许的</li><li>transactions可以看到其他transaction还没有提交的commit。很实用与count这种请求</li></ul></li></ul><p>关于具体的一个数据库，是怎么样对各级别的隔离进行处理的，可以参考 <a href="https://github.com/ept/hermitage" target="_blank" rel="noopener">Github - hermitage</a></p><h1 id="4-当你无法完全锁住的时候，可以选择使用乐观锁"><a href="#4-当你无法完全锁住的时候，可以选择使用乐观锁" class="headerlink" title="4. 当你无法完全锁住的时候，可以选择使用乐观锁"></a>4. 当你无法完全锁住的时候，可以选择使用乐观锁</h1><p>锁是极度昂贵的，这不仅仅是因为在数据库当中造成了强竞争，并且因为他们对于长连接的要求，这种从你的应用服务器到数据库的连接需要一直保持，是非常耗资源的。排它锁收到网络分区的影响更大，并且会导致非常难debug的死锁的问题。在排它锁不易实现的情境下，乐观锁是一个值得考虑的选择。</p><p>乐观锁从实现上是指当你去读一行的时候，记录下来版本号，最后一次修改的时间或者是checksum，想要达成的目的就是知道当前的它还是它。然后我们就可以在修改了数据之后去检测这个数据是否有被改变，如果没有，那么就证实其没有什么问题，我们就可以执行我们接下来的写操作了。</p><pre><code>UPDATE productsSET name = &#39;Telegraph receiver&#39;, version = 2 WHERE id = 1 AND version = 1</code></pre><p>注意乐观锁不是在数据库层面的限制了，而是在应用代码的层面，加以限制。 </p><h1 id="5-除了dirty-reads-和data-loss-你可能遇到其他的一些问题"><a href="#5-除了dirty-reads-和data-loss-你可能遇到其他的一些问题" class="headerlink" title="5. 除了dirty reads 和data loss 你可能遇到其他的一些问题"></a>5. 除了dirty reads 和data loss 你可能遇到其他的一些问题</h1><p>当我们谈论数据一致性的时候，我们会主要将注意力放在可能的race condition当中，其会导致脏读，以及数据的丢失。但是可能出现的问题不仅仅会出现在这个方面的。</p><p>比如说write skew问题 - 写偏序，是指一致性约束下的异常现象，即两个并行事务都基于自己读到的数据去覆盖另一部分数据集，在串行化的情况下两个事务无论何种先后顺序，最终都将达到一致状态，但是在Snapshot Isolation的隔离级别下是无法实现的。</p><pre><code>BEGIN tx1;                      BEGIN tx2;SELECT COUNT(*) FROM operatorsWHERE oncall = true;0                               SELECT COUNT(*)                                FROM operators                                WHERE oncall = TRUE;                                0UPDATE operators           UPDATE operatorsSET oncall = TRUE               SET oncall = TRUEWHERE userId = 4;               WHERE userId = 2;COMMIT tx1;                     COMMIT tx2;</code></pre><p>为了解决write skew问题，需要在事务的运行阶段增加冲突检测，而不是在提交阶段。通过加入事务开始时间戳以及事务结束时间戳，保证一个事务读的数据的最近一个版本的提交时间要早于事务的开始时间。</p><h1 id="6-关于事务提交顺序"><a href="#6-关于事务提交顺序" class="headerlink" title="6. 关于事务提交顺序"></a>6. 关于事务提交顺序</h1><p>数据库首先是提供顺序保证的，但是这个顺序和我们想的可能会又不用。即从数据库的视角来看，关注的是接收到事务(transaction)的顺序，而不是开发者编程看到的顺序。事务执行的顺序是很难预测的，尤其是在高并发的系统当中。</p><p>如果说执行顺序非常关键的话，我们应当将多条命令放到同一个数据库transaction当中。老避开提交时间不确定的问题。</p><h1 id="7-应用层面的数据库分区可以布局在应用之外"><a href="#7-应用层面的数据库分区可以布局在应用之外" class="headerlink" title="7. 应用层面的数据库分区可以布局在应用之外"></a>7. 应用层面的数据库分区可以布局在应用之外</h1><p>有点拗口，想要说明的是当我们的数据库数据量持续增大的时候，横向的分区就变得必不可少了。但是很多数据库可能无法做好横向分区，即traffic会非常不均匀等等。</p><p>标题想要阐述的，这个分区的逻辑不需要必须在你的应用里边，我们可以单独抽取出一个层级，包含分区逻辑。即application server –&gt; shard servers –&gt; database nodes。这样分离的好处是随着数据量的增大以及访问的数据特征的变化，我们需要的分区逻辑也会不断发生变化。分隔开变化，使得分区逻辑的改变不需要重新deploy应用服务器，加速了整个开发的进程。</p><h1 id="8-AUTOINCCREMENT-可能有害"><a href="#8-AUTOINCCREMENT-可能有害" class="headerlink" title="8. AUTOINCCREMENT 可能有害"></a>8. AUTOINCCREMENT 可能有害</h1><p>AUTOINCREMENT是个很常见的生成主键的方式，常常看到数据库被用来作为ID生成器，或者有专门的一个数据库用来负责做ID的生成。这样做有可能会无益，以下是一些原因：</p><ul><li>在分布式数据库系统当中，自动增长是一个很困难的事情。是需要一个global lock来生成ID的。如果你可以用UUID来取而代之的话，那么就不需要各个数据库节点之间的合作了。带锁的自增操作可能会引入冲突，极大的降低插入操作在分布式数据库当中的表现。</li><li>一些数据库根据主键来做分区算法，连续的ID很可能会导致不可测的热点，也许会让一些分区炸掉的同时其他分区很空闲。</li><li>最快访问数据库当中一行的方式就是通过其主键。如果我们能够有更好的定义一条数据的方式，那么使用其他富含意义的属性来作为主键会是个更好的选择。</li></ul><h1 id="9-任何时间源之间可能会有不同"><a href="#9-任何时间源之间可能会有不同" class="headerlink" title="9. 任何时间源之间可能会有不同"></a>9. 任何时间源之间可能会有不同</h1><p>所有的时间相关的API是不准确的，我们的机器并不是清楚的知道当前具体是什么时间的。我们的电脑都包含一个石英晶片，可以用来产生信号，让时间开始走。但是这种方式下，不会非常精准，总会比实际的时间稍微快一些或者慢一些。为了精确性，我们的电脑上的时间就需要根据实际时间来进行同步。</p><p>NTP服务器可以被用来对时间进行同步，但是好玩的是同步本身又会因为网络延时不够准确。谷歌是使用TrueTime服务来做的</p><ul><li>其使用两种不同的资源： GPS和原子钟。他们有不同的失败模式，因此二者并用能够增加可信赖度。</li><li>TrueTime用时间间隔来表示返回的时间，即当前时间一定在一个区间之内，所做的事情就是保证在这个区间的可信度足够高了</li></ul><h1 id="10-评估数据库在单个事务中的表现"><a href="#10-评估数据库在单个事务中的表现" class="headerlink" title="10. 评估数据库在单个事务中的表现"></a>10. 评估数据库在单个事务中的表现</h1><p>有些时候数据库会宣传自己的表现以及特征，然后说自己的latency，读写吞吐量有多么多么的大。但是… 离开具体场景的数据都是耍流氓，我们需要更加细致的衡量方式来评估数据库在一些非常关键的操作或者事务下的表现。</p><p>比如：</p><ul><li>当在一个有5000万行的数据库当中插入新的一行的吞吐量和延时</li><li>当查询用户的朋友的朋友（朋友的平均数量大致为500）的延时</li><li>获取用户时间线上前100条数据的延时，假定用户订阅了500个用户，每个用户每小时会发送n条信息</li></ul><p>我们需要根据使用数据库的实际场景来做针对性的测试，来更加深入的理解这个数据库的特征</p><h1 id="11-事务当中不应该保存应用的状态"><a href="#11-事务当中不应该保存应用的状态" class="headerlink" title="11. 事务当中不应该保存应用的状态"></a>11. 事务当中不应该保存应用的状态</h1><p>还是要注重相互之间的隔离的，client端在网络出现问题的时候常常会不停重试请求。如果事务依赖于一些能够在其他地方被改变的状态，那么事务当中可能就会拿到错误的数据，导致隐含错误的出现，开发者是很难找到这种类型的错误的。</p><pre><code>var seq int64with newTransaction():     newSeq := atomic.Increment(&amp;seq)     Entries.query(newSeq)     // Other operations...</code></pre><p>譬如这种错误，事务当中会对sequence number做累加操作，当网络出现问题，会回滚，但是seq数字已经增加了，这就导致了下次执行的结果和上次本应该获得的结果会出现不同。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://medium.com/@rakyll/things-i-wished-more-developers-knew-about-databases-2d0178464f78" target="_blank" rel="noopener">https://medium.com/@rakyll/things-i-wished-more-developers-knew-about-databases-2d0178464f78</a> </li><li><a href="https://www.quora.com/Why-doesnt-NoSQL-support-an-ACID-property" target="_blank" rel="noopener">https://www.quora.com/Why-doesnt-NoSQL-support-an-ACID-property</a></li><li><a href="https://en.wikipedia.org/wiki/CAP_theorem" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/CAP_theorem</a></li><li><a href="https://jepsen.io/consistency" target="_blank" rel="noopener">https://jepsen.io/consistency</a> </li><li><a href="https://blog.csdn.net/oaa608868/article/details/54866899" target="_blank" rel="noopener">https://blog.csdn.net/oaa608868/article/details/54866899</a></li><li><a href="http://www.nosqlnotes.com/technotes/mvcc-snapshot-isolation/" target="_blank" rel="noopener">http://www.nosqlnotes.com/technotes/mvcc-snapshot-isolation/</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;大部分的计算机系统都会有需要维护的状态，大概率就要依赖于一个存储系统。在重数据的系统当中，数据库就会成为整个系统设计的核心，其中会有很多需要考虑到的权衡。我们必须要学习并且了解数据库是如何被使用的，这篇文章会分享一些对于开发者有用的视角和观点。&lt;/p&gt;
&lt;h1 id=&quot;1-
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="CAP" scheme="https://www.llchen60.com/tags/CAP/"/>
    
      <category term="SQL" scheme="https://www.llchen60.com/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript Dependency Hell - 对于JS依赖树的分析</title>
    <link href="https://www.llchen60.com/JavaScript-Dependency-Hell-%E5%AF%B9%E4%BA%8EJS%E4%BE%9D%E8%B5%96%E6%A0%91%E7%9A%84%E5%88%86%E6%9E%90/"/>
    <id>https://www.llchen60.com/JavaScript-Dependency-Hell-%E5%AF%B9%E4%BA%8EJS%E4%BE%9D%E8%B5%96%E6%A0%91%E7%9A%84%E5%88%86%E6%9E%90/</id>
    <published>2020-04-23T23:32:31.000Z</published>
    <updated>2020-04-23T23:33:13.740Z</updated>
    
    <content type="html"><![CDATA[<p>做前端开发的同学肯定都对npm很熟悉，node package manager，一个非常受欢迎的包管理器。npm通过<code>package.json</code>来对项目当中的包进行管理，在这个json文件当中的包相当于就被npm注册了。</p><h1 id="1-什么是package-json"><a href="#1-什么是package-json" class="headerlink" title="1. 什么是package.json?"></a>1. 什么是package.json?</h1><ul><li><p>其定义了你的项目所依赖的所有包</p></li><li><p>并指定你的项目所用的包的版本号</p></li><li><p>让你的build是可以复制的，方便其他开发者来使用</p><h1 id="2-Package-json-中的依赖种类"><a href="#2-Package-json-中的依赖种类" class="headerlink" title="2. Package.json 中的依赖种类"></a>2. Package.json 中的依赖种类</h1></li><li><p>dependencies </p><ul><li>这里定义了你的代码所需要的关键依赖</li></ul></li><li><p>devDependencies </p><ul><li>这里定义了你的开发所使用的的依赖，比如给代码样式的perttier 库</li></ul></li><li><p>peerDependencies </p><ul><li>这里是告诉其他开发者，当使用了你的这个包以后，他们需要定义在这里的包的特定版本</li></ul></li><li><p>optionalDependencies </p><ul><li>可选的依赖，不安装他们不会毁坏安装的过程</li></ul></li><li><p>bundledDependencies </p><ul><li>这里包含的是一个列表的包，他们会被打包到一起来引入到你的项目当中。这个在你的依赖包不在npm当中的情况下是很有用的。    <h1 id="3-使用package-lock-json的目的"><a href="#3-使用package-lock-json的目的" class="headerlink" title="3. 使用package-lock.json的目的"></a>3. 使用package-lock.json的目的</h1>package-lock的使用目的，我们在前面的博文当中有详细的描述过 – <a href="https://llchen60.com/%E5%85%B3%E4%BA%8Epackage-lock-json/" target="_blank" rel="noopener">相关博文</a>。总的来说，有packge-lock.json 能够给我们更大的自由度，将commit的回退和依赖的回退分隔开，即我可以使用过去的依赖树运行当前的代码，这在没有lock json的时候是很难实现的。</li></ul></li></ul><h1 id="4-依赖树的例子与简化"><a href="#4-依赖树的例子与简化" class="headerlink" title="4. 依赖树的例子与简化"></a>4. 依赖树的例子与简化</h1><pre><code>// 以gatsby为例, know the size of your node_modules overall du -sh node_modules// list the size decending $ du -sh ./node_modules/* | sort -nr | grep &#39;\dM.*&#39; 17M    ./node_modules/rxjs8.4M    ./node_modules/@types7.4M    ./node_modules/core-js6.8M    ./node_modules/@babel5.4M    ./node_modules/gatsby5.2M    ./node_modules/eslint4.8M    ./node_modules/lodash3.6M    ./node_modules/graphql-compose3.6M    ./node_modules/@typescript-eslint3.5M    ./node_modules/webpack3.4M    ./node_modules/moment3.3M    ./node_modules/webpack-dev-server3.2M    ./node_modules/caniuse-lite3.1M    ./node_modules/graphql</code></pre><p>…</p><pre><code>// !!! moved unused modules and dependenciesnpm dedup </code></pre><p>解耦操作的运行机理，就是寻找不同依赖之间的公有的包，然后复用这些共有的包。</p><p>对于可视化，用一些现成的工具可以被用来观察整个包的依赖状态，譬如：</p><ul><li><a href="https://npm.anvaka.com/#/" target="_blank" rel="noopener">https://npm.anvaka.com/#/</a></li><li><a href="http://npm.broofa.com/" target="_blank" rel="noopener">http://npm.broofa.com/</a></li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://blog.appsignal.com/2020/04/09/ride-down-the-javascript-dependency-hell.html" target="_blank" rel="noopener">https://blog.appsignal.com/2020/04/09/ride-down-the-javascript-dependency-hell.html</a> </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;做前端开发的同学肯定都对npm很熟悉，node package manager，一个非常受欢迎的包管理器。npm通过&lt;code&gt;package.json&lt;/code&gt;来对项目当中的包进行管理，在这个json文件当中的包相当于就被npm注册了。&lt;/p&gt;
&lt;h1 id=&quot;1-什
      
    
    </summary>
    
    
      <category term="FrontEnd" scheme="https://www.llchen60.com/categories/FrontEnd/"/>
    
    
      <category term="JaveScript" scheme="https://www.llchen60.com/tags/JaveScript/"/>
    
      <category term="JS Dependency" scheme="https://www.llchen60.com/tags/JS-Dependency/"/>
    
  </entry>
  
  <entry>
    <title>Typescript学习笔记(二)</title>
    <link href="https://www.llchen60.com/Typescript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/"/>
    <id>https://www.llchen60.com/Typescript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/</id>
    <published>2020-04-21T03:25:57.000Z</published>
    <updated>2020-04-21T03:26:33.088Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>类型别名</p><ul><li>用来为一个类型起一个新名字</li></ul></li></ul><pre><code>type Name = string; </code></pre><ul><li>字符串字面量类型</li></ul><pre><code>type EventNames = &#39;click&#39; | &#39;scroll&#39; | &#39;mousemove&#39;;function handleEvent(ele: Element, event: EventNames) {    // do something}handleEvent(document.getElementById(&#39;hello&#39;), &#39;scroll&#39;);  // 没问题handleEvent(document.getElementById(&#39;world&#39;), &#39;dbclick&#39;); // 报错，event 不能为 &#39;dbclick&#39;// index.ts(7,47): error TS2345: Argument of type &#39;&quot;dbclick&quot;&#39; is not assignable to parameter of type &#39;EventNames&#39;.</code></pre><ul><li>元组  - Tuple<ul><li>Tuple可以用于合并不同类型的对象</li></ul></li></ul><pre><code>let tom: [string, number] = [&#39;Tom&#39;, 25];</code></pre><ul><li>枚举<ul><li>用于取值被限定在一定范围内的场景</li><li>使用enum进行定义的</li><li>枚举成员会被赋值为从0开始递增的数字，同时也会对枚举值到枚举名进行反向映射</li></ul></li></ul><pre><code>enum Days {Sun, Mon, Tue, Wed, Thu, Fri, Sat};console.log(Days[&quot;Sun&quot;] === 0); // trueconsole.log(Days[&quot;Mon&quot;] === 1); // trueconsole.log(Days[&quot;Tue&quot;] === 2); // trueconsole.log(Days[&quot;Sat&quot;] === 6); // trueconsole.log(Days[0] === &quot;Sun&quot;); // trueconsole.log(Days[1] === &quot;Mon&quot;); // trueconsole.log(Days[2] === &quot;Tue&quot;); // trueconsole.log(Days[6] === &quot;Sat&quot;); // true</code></pre><ul><li>类，类与接口<ul><li>使用class定义类，使用constructor定义构造函数，通过new生成新实例的时候，是会自动调用构造函数的</li></ul></li></ul><pre><code>class Animal {    constructor(name) {        this.name = name;    }    sayHi() {        return `My name is ${this.name}`;    }}let a = new Animal(&#39;Jack&#39;);console.log(a.sayHi()); // My name is Jack</code></pre><ul><li><p>类通过extends继承</p><ul><li><p>然后通过super关键词来调用父类的构造函数和方法</p><p>class Cat extends Animal {<br>  constructor(name) {</p><pre><code>  super(name); // 调用父类的 constructor(name)  console.log(this.name);</code></pre><p>  }<br>  sayHi() {</p><pre><code>  return &#39;Meow, &#39; + super.sayHi(); // 调用父类的 sayHi()</code></pre><p>  }<br>}</p><p>let c = new Cat(‘Tom’); // Tom<br>console.log(c.sayHi()); // Meow, My name is Tom</p></li></ul></li><li><p>泛型</p><p>  function createArray<T>(length: number, value: T): Array<T> {</p><pre><code>  let result: T[] = [];  for (let i = 0; i &lt; length; i++) {      result[i] = value;  }  return result;</code></pre><p>  }</p><p>  createArray(3, ‘x’); // [‘x’, ‘x’, ‘x’]</p></li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://ts.xcatliu.com/advanced/type-aliases" target="_blank" rel="noopener">https://ts.xcatliu.com/advanced/type-aliases</a> </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;类型别名&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用来为一个类型起一个新名字&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;type Name = string; &lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;字符串字面量类型&lt;/li&gt;
&lt;/ul&gt;

      
    
    </summary>
    
    
      <category term="FrontEnd" scheme="https://www.llchen60.com/categories/FrontEnd/"/>
    
    
      <category term="TypeScript" scheme="https://www.llchen60.com/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript笔记(一)</title>
    <link href="https://www.llchen60.com/TypeScript%E7%AC%94%E8%AE%B0-0/"/>
    <id>https://www.llchen60.com/TypeScript%E7%AC%94%E8%AE%B0-0/</id>
    <published>2020-04-19T17:44:45.000Z</published>
    <updated>2020-04-21T03:26:13.703Z</updated>
    
    <content type="html"><![CDATA[<p>Tl;dr </p><p>这会是一篇很长的博文，大部分内容都直接来自Reference当中的TypeScript教程和ES6教程，只是为了总结一些自己认为重要的知识点，以及一些认为需要深入理解的地方及其延伸的链接，希望有帮助。</p><h1 id="1-Intro"><a href="#1-Intro" class="headerlink" title="1. Intro"></a>1. Intro</h1><h2 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h2><ul><li>JavaScript超集，提供了类型系统和对ES6的支持，由Microsoft开发</li></ul><h2 id="1-2-优势"><a href="#1-2-优势" class="headerlink" title="1.2 优势"></a>1.2 优势</h2><ul><li>增加代码的可读性和可维护性<ul><li>类型系统是很好的文档，看类型的定义我们就能够知道如何使用了</li><li>可以在编译阶段发现大部分错误，比运行时出错好很多</li><li>增强编辑器的功能，包括代码补全，接口提示，跳转到定义，重构等</li></ul></li><li>兼容性好<ul><li>js文件实际上是可以直接重命名为ts文件的</li><li>及时不显式定义类型，也能够自动做出类型推论  </li></ul></li></ul><h2 id="1-3-相对劣势"><a href="#1-3-相对劣势" class="headerlink" title="1.3 相对劣势"></a>1.3 相对劣势</h2><ul><li>学习成本 <ul><li>接口 </li><li>泛型</li><li>类</li></ul></li><li>短期增加开发成本，要多写一些类型的定义，但是对于需要长期维护的项目，TypeScript能够减少其维护成本</li><li>集成到构建流程当中需要一些工作量的 </li></ul><h1 id="2-基础知识"><a href="#2-基础知识" class="headerlink" title="2. 基础知识"></a>2. 基础知识</h1><h2 id="2-1-原始数据类型"><a href="#2-1-原始数据类型" class="headerlink" title="2.1 原始数据类型"></a>2.1 原始数据类型</h2><ul><li><p>布尔值 - boolean</p><pre><code>  let isSuccessful: boolean = true;  let createdByNewBoolean: boolean = new Boolean(1);  // Type &#39;Boolean&#39; is not assignable to type &#39;boolean&#39;.  // &#39;boolean&#39; is a primitive, but &#39;Boolean&#39; is a wrapper object. Prefer using &#39;boolean&#39; when possible.  let createdByNewBoolean: Boolean = new Boolean(1);  // when you new Boolean, it will create a Boolean - a wrapper object  let createdByBoolean: boolean = Boolean(1);   // create a boolean </code></pre></li></ul><ul><li><p>数值 - number</p><pre><code>  let decLiteral: number = 6;</code></pre></li><li><p>字符串 - string</p></li></ul><pre><code>    let myName: string = &#39;Tom&#39;;    let myAge: number = 25;    // 模板字符串  `用来定义模板字符串，${}用来在模板字符串中嵌入表达式    let sentence: string = `Hello, my name is ${myName}.    I&#39;ll be ${myAge + 1} years old next month.`;</code></pre><ul><li>null &amp; undefined<ul><li>null 和 undefined是所有类型的子类型</li><li>void类型的变量不能赋值给number类型的变量</li></ul></li><li>symbol</li></ul><h2 id="2-2-任意值-Any"><a href="#2-2-任意值-Any" class="headerlink" title="2.2 任意值 - Any"></a>2.2 任意值 - Any</h2><p>任意值用来表示允许赋值为任意类型。在Typescript当中，普通类型在复制过程中改变类型是不被允许的，但是如果是any类型，则允许被赋值为任意类型。</p><pre><code>    let myFavoriteNumber: any = &#39;seven&#39;;    myFavoriteNumber = 7;</code></pre><ul><li>任意值上访问任何属性都是允许的，也允许调用任何方法</li><li>返回的类型都是任意值</li><li>对于未声明类型的变量<ul><li>未指定类型，那么会被识别为任意值类型</li></ul></li></ul><h2 id="2-3-类型推论"><a href="#2-3-类型推论" class="headerlink" title="2.3 类型推论"></a>2.3 类型推论</h2><p>如果没有明确的指定类型，那么TypeScript会按照类型推论 - Type Inference的规则推断出一个类型。</p><pre><code>let myFavoriteNumber = &#39;seven&#39;;myFavoriteNumber = 7;// index.ts(2,1): error TS2322: Type &#39;number&#39; is not assignable to type &#39;string&#39;.  编译的时候出错，因为TS自动做了类型推论，并且认定其为一个string类型</code></pre><p>但是如果定义的时候没有赋值，那么不管接下来是否会赋值，都会被推断成any类型而完全不被类型检查</p><pre><code>let myFavoriteNumber;myFavoriteNumber = &#39;seven&#39;;myFavoriteNumber = 7;</code></pre><h2 id="2-4-联合类型-Union-Types"><a href="#2-4-联合类型-Union-Types" class="headerlink" title="2.4 联合类型 - Union Types"></a>2.4 联合类型 - Union Types</h2><pre><code>let myFavoriteNumber: string | number;myFavoriteNumber = &#39;seven&#39;;myFavoriteNumber = 7;</code></pre><p>联合类型当中使用 <code>|</code>来分割每个类型</p><h2 id="2-5-接口"><a href="#2-5-接口" class="headerlink" title="2.5 接口"></a>2.5 接口</h2><ul><li><p>在TypeScript当中，使用接口定义对象的类型，除了可以对类的一部分行为进行抽象以外，也chang’yo个与对 对象的形状进行描述。</p><p>  interface Person {</p><pre><code>  name: string;  age: number;</code></pre><p>  }</p><p>  let tom: Person = {</p><pre><code>  name: &#39;Tom&#39;,  age: 25</code></pre><p>  };</p></li></ul><p>在做赋值的时候，定义的变量需要和接口有一样的属性。</p><ul><li><p>对于我们想要可选择的匹配的属性，我们可以用可选属性的方式：</p><p>  interface Person {</p><pre><code>  name: string;  age?: number;</code></pre><p>  }</p><p>  let tom: Person = {</p><pre><code>  name: &#39;Tom&#39;</code></pre><p>  };</p></li><li><p>也可以配置，是的接口能够接任意的属性： – <code>[propName: string] : any</code></p><ul><li><p>需要注意的是一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集 </p><p>interface Person {<br>  name: string;<br>  age?: number;<br>  [propName: string]: any;<br>}</p><p>let tom: Person = {<br>  name: ‘Tom’,<br>  gender: ‘male’<br>};</p></li></ul></li><li><p>只读属性</p><ul><li>有use case我们希望对象当中的一些字段只能在创建的时候被赋值，那么就可以通过使用readonly定义只读属性</li></ul></li></ul><h2 id="2-6-数组类型"><a href="#2-6-数组类型" class="headerlink" title="2.6 数组类型"></a>2.6 数组类型</h2><ul><li>使用类型+方括号来定义</li></ul><pre><code>let fibonacci: number[] = [1, 1, 2, 3, 5];</code></pre><ul><li>使用数组泛型来表示数组 – <code>Array&lt;elemType&gt;</code></li></ul><pre><code>let fibonacci: Array&lt;number&gt; = [1, 1, 2, 3, 5];</code></pre><ul><li>使用接口表示数组</li></ul><pre><code>interface NumberArray {    [index: number]: number;}let fibonacci: NumberArray = [1, 1, 2, 3, 5];</code></pre><h2 id="2-7-函数类型"><a href="#2-7-函数类型" class="headerlink" title="2.7 函数类型"></a>2.7 函数类型</h2><h3 id="2-7-1-函数声明"><a href="#2-7-1-函数声明" class="headerlink" title="2.7.1 函数声明"></a>2.7.1 函数声明</h3><pre><code>// 函数声明（Function Declaration）function sum(x, y) {    return x + y;}// 函数表达式（Function Expression）let mySum = function (x, y) {    return x + y;};// TypeScript下的函数声明function sum(x: number, y:number):number {    return x + y;}</code></pre><h3 id="2-7-2-函数表达式"><a href="#2-7-2-函数表达式" class="headerlink" title="2.7.2 函数表达式"></a>2.7.2 函数表达式</h3><pre><code>let mySum: (x: number, y: number) =&gt; number = function (x: number, y: number): number {    return x + y;};</code></pre><p>注意在上述代码当中，跟在mySum后面的是对于输入参数和输出参数的规定，中间用箭头来进行连接，这是TypeScript的规范。</p><p>另外我们也可以通过使用接口来定义函数的形状：</p><pre><code>interface SearchFunc {    (source: string, subString: string): boolean;}let mySearch: SearchFunc;mySearch = function(source: string, subString: string) {    return source.search(subString) !== -1;}</code></pre><h3 id="2-7-3-可选参数"><a href="#2-7-3-可选参数" class="headerlink" title="2.7.3 可选参数"></a>2.7.3 可选参数</h3><ul><li>使用问号跟在参数名字之后表示是可选的，注意可选参数需要在参数列表的末尾，其之后不能有必需参数了</li></ul><pre><code>function buildName(firstName: string, lastName?: string) {    if (lastName) {        return firstName + &#39; &#39; + lastName;    } else {        return firstName;    }}</code></pre><h3 id="2-7-4-参数默认与剩余参数"><a href="#2-7-4-参数默认与剩余参数" class="headerlink" title="2.7.4 参数默认与剩余参数"></a>2.7.4 参数默认与剩余参数</h3><pre><code>// 默认参数function buildName(firstName: string, lastName: string = &#39;Cat&#39;) {    return firstName + &#39; &#39; + lastName;}let tomcat = buildName(&#39;Tom&#39;, &#39;Cat&#39;);let tom = buildName(&#39;Tom&#39;);// 使用 ...来获取函数当中的剩余参数function push(array, ...items) {    items.forEach(function(item) {        array.push(item);    });}let a: any[] = [];push(a, 1, 2, 3);</code></pre><h2 id="2-8-声明文件"><a href="#2-8-声明文件" class="headerlink" title="2.8 声明文件"></a>2.8 声明文件</h2><p>当使用第三方库的时候，我们需要引用它的声明文件，以获得对应的代码补全，接口提示的功能</p><h3 id="2-8-1-声明语句"><a href="#2-8-1-声明语句" class="headerlink" title="2.8.1 声明语句"></a>2.8.1 声明语句</h3><p>比如我们想使用jquery，一般来说是加script标签，但是ts当中，我们需要使用declare var来定义其类型</p><pre><code>declare var jQuery: (selector: string) =&gt; any;jQuery(&#39;#foo&#39;);</code></pre><p>我们会将声明语句放到一个单独的文件当中，譬如对于上述的例子，就是放到jQuery.d.ts 当中<br>声明文件必须以<code>.d.ts</code>来结尾</p><p>ts会解析项目当中所有的*.ts文件，也包含了.d.ts结尾的文件，所以当我们定义.d.ts文件以后，里面的内容是会被整个项目共享的。</p><p>另外，我们可以通过@types 来统一管理第三方库的声明文件</p><h3 id="2-8-2-书写声明文件"><a href="#2-8-2-书写声明文件" class="headerlink" title="2.8.2 书写声明文件"></a>2.8.2 书写声明文件</h3><p>当第三方库没有提供声明文件的时候，我们就需要自己书写声明文件了。</p><p>库的使用场景主要有：</p><ul><li>全局变量 </li><li>npm包</li><li>UMD库</li><li>直接扩展全局变量</li></ul><p>详情看 <a href="https://ts.xcatliu.com/basics/declaration-files#xin-yu-fa-suo-yin" target="_blank" rel="noopener">link</a></p><h1 id="2-9-内置对象"><a href="#2-9-内置对象" class="headerlink" title="2.9 内置对象"></a>2.9 内置对象</h1><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects" target="_blank" rel="noopener">ECMAScript 内置对象</a></p><p><a href="https://github.com/Microsoft/TypeScript/tree/master/src/lib" target="_blank" rel="noopener">DOM DOM 内置对象</a></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://ts.xcatliu.com/" target="_blank" rel="noopener">https://ts.xcatliu.com/</a></li><li><a href="https://es6.ruanyifeng.com/" target="_blank" rel="noopener">https://es6.ruanyifeng.com/</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Tl;dr &lt;/p&gt;
&lt;p&gt;这会是一篇很长的博文，大部分内容都直接来自Reference当中的TypeScript教程和ES6教程，只是为了总结一些自己认为重要的知识点，以及一些认为需要深入理解的地方及其延伸的链接，希望有帮助。&lt;/p&gt;
&lt;h1 id=&quot;1-Intro&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="FrontEnd" scheme="https://www.llchen60.com/categories/FrontEnd/"/>
    
    
      <category term="TypeScript" scheme="https://www.llchen60.com/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>关于package-lock.json</title>
    <link href="https://www.llchen60.com/%E5%85%B3%E4%BA%8Epackage-lock-json/"/>
    <id>https://www.llchen60.com/%E5%85%B3%E4%BA%8Epackage-lock-json/</id>
    <published>2020-04-18T01:10:23.000Z</published>
    <updated>2020-04-18T01:11:57.173Z</updated>
    
    <content type="html"><![CDATA[<p>当我们将node package manager (npm) 升级到5.0以上的版本的时候，你会发现npm运行的时候会自动创建一个新文件 – package-lock.json。</p><p>里面包含的是我们的依赖关系，各种依赖的包和版本号。package-lock.json会在npm修改了node_modules 树或者修改了package.json之后自动生成。它精确的描述了整个生成的树，使得接下来任何一次的装配都可以生成完全一致的依赖树.这个生成的文件是需要commit 到remote branch上的，其目的在于：</p><ul><li>描述单个依赖树，使得其他人在做deploy的时候使用的是完全一致的依赖</li><li>使得使用人员有能力直接跳转回原先的依赖状态，而不需要将代码也回退到之前的版本</li><li>加强了依赖改变的阅读性，我们可以相对直观的看到每次的commit都有什么依赖被改变了</li><li>也可以通过是的npm跳过对于原先安装过的包的重复的元数据分析来优化整个安装的进程</li></ul><p>针对其特征，我们是应该将package-lock.json也提交上去的，这会给开发，同步带来不小的帮助。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://medium.com/coinmonks/everything-you-wanted-to-know-about-package-lock-json-b81911aa8ab8" target="_blank" rel="noopener">https://medium.com/coinmonks/everything-you-wanted-to-know-about-package-lock-json-b81911aa8ab8</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当我们将node package manager (npm) 升级到5.0以上的版本的时候，你会发现npm运行的时候会自动创建一个新文件 – package-lock.json。&lt;/p&gt;
&lt;p&gt;里面包含的是我们的依赖关系，各种依赖的包和版本号。package-lock.js
      
    
    </summary>
    
    
      <category term="FrontEnd" scheme="https://www.llchen60.com/categories/FrontEnd/"/>
    
    
      <category term="npm" scheme="https://www.llchen60.com/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>中台(二) - 略深入些的探究</title>
    <link href="https://www.llchen60.com/%E4%B8%AD%E5%8F%B0-%E4%BA%8C-%E7%95%A5%E6%B7%B1%E5%85%A5%E4%BA%9B%E7%9A%84%E6%8E%A2%E7%A9%B6/"/>
    <id>https://www.llchen60.com/%E4%B8%AD%E5%8F%B0-%E4%BA%8C-%E7%95%A5%E6%B7%B1%E5%85%A5%E4%BA%9B%E7%9A%84%E6%8E%A2%E7%A9%B6/</id>
    <published>2020-04-16T00:38:41.000Z</published>
    <updated>2020-04-16T00:39:21.588Z</updated>
    
    <content type="html"><![CDATA[<p>中台是企业级能力复用平台，整个中台的构建，实际上是将业务数据化，将数据业务化。是需要建立业务中台和数据中台的。业务中台通过抽象，封装可复用的逻辑，提升企业的响应力；数据中台通过打通企业的数据，构建自学习服务的数据能力，让企业更加智慧。</p><h1 id="1-通用化通用能力"><a href="#1-通用化通用能力" class="headerlink" title="1. 通用化通用能力"></a>1. 通用化通用能力</h1><p>目前大部分企业实现的中台，主要是将遗留下的后台系统，比如ERP MES CRM的公共部分进行拆解复用，形成类似交易中心，用户中心，订单中心这样的微服务集合供前台调用，从而保证<strong>逻辑的一致性</strong>同时更快响应前台的变化</p><p>Reference <a href="https://www.infoq.cn/article/wCZV6X5uujxDXFP0Eub9?utm_source=rss&utm_medium=article" target="_blank" rel="noopener">1</a> 当中举了订单服务的演进过程的例子，很值得一看。当平台需要开放多渠道来完成订单的时候，保证用户有着类似的体验是很重要的一项，包括整个系统的的scalability。</p><p>在这种情况下，一个数据中台能够使得用户可以看到在各个平台各个渠道自己下的订单。从平台角度来说，有了数据中台，维护成本，发生错误以后的修改成本都会减轻很多。</p><p>略微解释下，如果是分开的系统，那么每个系统都会有自己的数据库，我们需要做数据的join操作，然后返回给前端用户需要的正确的信息。当发生了逻辑上的错误以后，我们很有可能需要在分开的几个子系统当中来做修改，很容易出错，修改的整个时间消耗也会很长。而且数据仓库在多个系统的情况下，抽取数据，再进行分析是有比较大的时延的，一般都是加一天的样子，无法看到实时的数据。</p><h1 id="2-使用中台去ERP化"><a href="#2-使用中台去ERP化" class="headerlink" title="2. 使用中台去ERP化"></a>2. 使用中台去ERP化</h1><p>ERP， 即企业资源管理系统。最最开始的时候，企业的需求是将企业的流程梳理清晰，做到资源的集约化管理，本质上来讲是为了解决流程复用，业务能力化的问题。</p><p>但是当前ERP软件存在着如下的一些问题：</p><ol><li>商业软件，响应慢<br>企业只有使用权，这就导致企业的业务发生变化的时候，需要找到原厂重新配置或者重新开发，响应比较慢</li><li>封闭架构，不开放<br>套装ERP软件是封闭架构，技术不开放，导致企业无法对其进行大的功能上的扩展，只能像打补丁一样，构建一些外挂，而且效果往往不会很好</li><li>单体架构，弹性不够<br>单体架构，很难支持持续增长的各种需求</li><li>升级 维护成本<br>套装软件升级和维护成本非常高</li></ol><p>过去人们需要ERP更多的是因为我们需要流程，需要知道具体应该如何去组织。但是在互联网化的今天，原来静态化，标准化的业务流程已经不足以支撑企业的快速响应了。因此，诉求<strong>从原来的流程化变成了需要能够快速响应前台市场的变化</strong>。</p><p>企业组织结构从流程式协作走向了平台式协作。</p><p>ERP更像是一种计划式的经济，希望每个角色都按照分配的任务来走，共同完成一个任务，但是这种共同完成会导致不同角色之间的利益相互冲突。局部利益大于整体利益。</p><p>需要的转变是 —- 要开始学习以客户为中心去动态组织资源来提供服务，将原本<strong><em>以流程为独立单元的模块拆解为以客户价值为独立单元的模块</em></strong>。</p><p>以客户价值为独立单元，如何评定绩效就是个很关键也很困难的问题，尤其是对于那些为后端赋能的业务单元，如何将其关联到直接的客户价值当中。这需要数据中台提供这方面的能力，来利用全域的数据分析，建模，通过敏感性分析等算法技术来实时计算。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://www.infoq.cn/article/wCZV6X5uujxDXFP0Eub9?utm_source=rss&amp;utm_medium=article" target="_blank" rel="noopener">https://www.infoq.cn/article/wCZV6X5uujxDXFP0Eub9?utm_source=rss&amp;utm_medium=article</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;中台是企业级能力复用平台，整个中台的构建，实际上是将业务数据化，将数据业务化。是需要建立业务中台和数据中台的。业务中台通过抽象，封装可复用的逻辑，提升企业的响应力；数据中台通过打通企业的数据，构建自学习服务的数据能力，让企业更加智慧。&lt;/p&gt;
&lt;h1 id=&quot;1-通用化通用
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="中台" scheme="https://www.llchen60.com/tags/%E4%B8%AD%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>用户画像构建思路</title>
    <link href="https://www.llchen60.com/%E7%94%A8%E6%88%B7%E7%94%BB%E5%83%8F%E6%9E%84%E5%BB%BA%E6%80%9D%E8%B7%AF/"/>
    <id>https://www.llchen60.com/%E7%94%A8%E6%88%B7%E7%94%BB%E5%83%8F%E6%9E%84%E5%BB%BA%E6%80%9D%E8%B7%AF/</id>
    <published>2020-04-14T04:19:03.000Z</published>
    <updated>2020-04-14T04:19:47.832Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a>1. Overview</h1><p>用户画像指的是系统通过用户自己上传的信息以及自己的分析，记录了用户的大量的信息，而后为了便于去给各个系统来使用，将这些信息进行沉淀加工，形成一个标签树的整个过程。</p><p>画像是由标签树及末级标签的标签值构成的，全面定量刻画用户的结构化信息产品。画像是标签的总成，用户标签是具体刻画用户的结构化信息，以下简称标签。</p><p>用户画像对于公司的运营，盈利都有很大的好处：</p><ol><li>可以用于统计，使得对产品，对用户有基本认知</li><li>用于定向营销和精细化运营</li><li>还可以用于算法当中，在搜索推荐，风控广告等策略防线，标签被作为用户特征得以提取和使用</li></ol><h1 id="2-构建标签树"><a href="#2-构建标签树" class="headerlink" title="2. 构建标签树"></a>2. 构建标签树</h1><p>一个好的标签树需要具有高概括性和强延展性，高概括性意味着结构体系能够很好的包含一个用户的<strong>基本属性</strong>和<strong>产品交互的相关行为</strong>，同时对于业务重点单独强调，没有遗漏；“强延展性”意味着结构全面的同时也有一定的抽象概括能力，保证新增的标签可以很好的找到对应的分类，整个体系不会过于收敛局限。</p><p>按照这个原则，画像可以从以下维度进行组织： </p><ul><li><p>基本属性</p><ul><li>指一个用户的基本社会属性和变更频率比较低的特征<ul><li>真实社会年龄</li><li>性别</li><li>婚姻状况</li><li>昵称</li><li>号码</li><li>账号</li><li>lbs </li></ul></li></ul></li><li><p>平台属性</p><ul><li>平台属性是用户在平台上表现出的基本属性特征，是利用用户行为进行算法挖掘，标识用户真实属性的标签</li><li>譬如平台年龄标签  面向例如年龄为20岁，但是心理年龄50岁，穿衣风格50岁的人；反之亦然</li><li>平台属性和基本属性的区别如下：<ul><li>数据源与计算逻辑<ul><li>基础属性是利用用户自行上传的存储在用户基础信息表里的数据，平台属性则利用客户端或者服务端埋点上报采集的用户行为数据进行挖掘计算生成的。</li><li>基本属性是典型的直采型标签，平台属性是典型的算法挖掘型标签</li></ul></li><li>末级标签和输出标签值<ul><li>平台属性代表用户在性别维度上的偏好概率，可以生成类似<code>性别_女_0.80</code>这样的标签，0.8代表了用户的倾向程度</li></ul></li><li>应用场景<ul><li>平台属性通过用户行为进行挖掘，更能代表用户的真实倾向，输出结果比基本属性准确率更高</li></ul></li></ul></li></ul></li><li><p>行为属性</p><ul><li>行为属性记录用户的所有单个点的行为</li><li>包括<ul><li>启动</li><li>登录</li><li>浏览</li><li>点击</li><li>加车</li><li>下单</li></ul></li><li>是可以和不同的产品，不同的模块进行交互的，而且可以在不同的时间窗口进行选取，行为会相对复杂</li><li>按照 产品 x 功能模块 x 用户单点行为 x 时间  这四个要素来进行组织  </li></ul></li><li><p>产品偏好</p><ul><li>对用户使用某些产品，产品核心功能或者其他渠道的偏好程度的刻画，属于挖掘性的标签</li><li>产品可以包括自己公司的，竞品的</li><li>功能渠道包括站内产品功能，包括push、短信、开屏、弹窗等几大运营和产品方式 </li></ul></li><li><p>兴趣偏好</p><ul><li>品牌偏好  nike</li><li>类目偏好  运动</li><li>标签偏好  跑步_0.7</li></ul></li><li><p>敏感度</p><ul><li>营销活动中，会注意到有些用户不需要优惠也会下单，而有些用户一定要通过优惠券刺激才能实现转化，优惠券的额度也会影响用户下单的金额</li><li>需要识别对优惠敏感的用户，发放合理的券额，保证优惠券不浪费，使得整个促销活动的ROI最大</li><li>构建用户的敏感度标签<ul><li>优惠促销敏感度</li><li>活动敏感度</li><li>新品敏感度</li><li>爆款敏感度 </li></ul></li></ul></li><li><p>消费属性</p><ul><li>消费频次</li><li>消费金额</li><li>最近消费时间</li><li>消费能力</li><li>消费意愿 </li></ul></li><li><p>用户生命周期</p><ul><li>新手</li><li>成长</li><li>成熟</li><li>衰退</li><li>流失 </li></ul></li><li><p>用户价值</p><ul><li>活跃度</li><li>裂变拉新等 </li></ul></li></ul><h1 id="3-用户画像的范例"><a href="#3-用户画像的范例" class="headerlink" title="3. 用户画像的范例"></a>3. 用户画像的范例</h1><p><img src="https://i.loli.net/2020/04/14/XnJYc3ejRrMwdul.png" alt="用户画像导图.png"></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://www.infoq.cn/article/oUqJDlfstrYAmTBYzier?utm_source=rss&amp;utm_medium=article" target="_blank" rel="noopener">https://www.infoq.cn/article/oUqJDlfstrYAmTBYzier?utm_source=rss&amp;utm_medium=article</a> </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Overview&quot;&gt;&lt;a href=&quot;#1-Overview&quot; class=&quot;headerlink&quot; title=&quot;1. Overview&quot;&gt;&lt;/a&gt;1. Overview&lt;/h1&gt;&lt;p&gt;用户画像指的是系统通过用户自己上传的信息以及自己的分析，记录了用户的大量
      
    
    </summary>
    
    
      <category term="Notes" scheme="https://www.llchen60.com/categories/Notes/"/>
    
    
      <category term="用户画像" scheme="https://www.llchen60.com/tags/%E7%94%A8%E6%88%B7%E7%94%BB%E5%83%8F/"/>
    
      <category term="运营" scheme="https://www.llchen60.com/tags/%E8%BF%90%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>中台</title>
    <link href="https://www.llchen60.com/%E4%B8%AD%E5%8F%B0/"/>
    <id>https://www.llchen60.com/%E4%B8%AD%E5%8F%B0/</id>
    <published>2020-04-13T00:32:59.000Z</published>
    <updated>2020-04-13T00:34:29.013Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-什么是中台？"><a href="#1-什么是中台？" class="headerlink" title="1. 什么是中台？"></a>1. 什么是中台？</h1><p>看到几篇关于中台的博客，是国内提出的一个新的概念，稍微研究了下，很有意思的概念。</p><p>中台，在我看来，从业务上来讲，可以说是为了解决系统的复用性的问题而出现的。一个简单的例子，阿里刚刚开始的时候只有淘宝，但是后来出现了天猫，二者尽管顶层业务逻辑有不同，但是他们都是需要一套订单，商品，库存，仓储，物流的各种系统的。如果每次我们想做一个新的业务模块的时候，都要来实现这样一套系统，迭代速度会很慢，而且很容易在做改动的时候因为各个类似功能的系统的改动不一致产生错误。</p><p>因此，将这些公用的系统提升，做成–中台，统一来使得各个业务部门重复使用，将需要反复建设的功能和系统进行统一的规划和管理。</p><p>主要解决的问题实质上有两类： </p><ol><li>需要业务需求或者功能需求是高度类似的，通用化程度很高，但是由于没有专门的团队负责规划和开发，大量的系统重复开发、重复建设、导致复用性很低，效率低，研发资源被浪费，用户体验也不够统一</li><li>早起业务发展过程当中，为了解决当下的一些业务问题，垂直的个性化的业务逻辑与基础系统耦合太深，由于没有平台性质的规划，横向系统之间、上下游系统之间的交叉逻辑非常多，导致了在新业务新市场的拓展过程当中，市场没有办法直接复用，甚至没有办法快速迭代。</li></ol><h1 id="2-为什么要中台，为什么要平台化？"><a href="#2-为什么要中台，为什么要平台化？" class="headerlink" title="2. 为什么要中台，为什么要平台化？"></a>2. 为什么要中台，为什么要平台化？</h1><p>引述《白话中台战略》当中的内容，“因为在当今互联网时代，⽤户才是商业战场的中心，为了快速响应用户的需求，借助平台化的力量可以事半功倍”</p><blockquote><p>不断快速响应、探索、挖掘、引领⽤户的需求，才是企业得以⽣存和持续发展的关键因素。</p></blockquote><blockquote><p>那些真正尊重用户，甚⾄不惜调整⾃己颠覆⾃己来响应⽤户的企业将在这场以⽤户为中心的商业战争中得以⽣存和发展；⽽反之，那些在过去的成就上故步⾃封，存在侥幸⼼理希望⽤户会像之前一样继续追随⾃己的企业则会被用户淘汰。很残酷，但这就是这个时代最基本的企业⽣存法则。</p></blockquote><p>平台化能够赋予或加强企业在以用户为中心的现代商业战争当中最为核心的能力 –&gt; 用户响应力。 </p><p>中台，可以说是与前台，后台相对应的。</p><ul><li>前台<ul><li>由各类前台系统组成的前端平台。每个前台系统就是一个用户触点，即企业的最终用户直接使用或者交互的系统，是企业与最终用户的交点。</li></ul></li><li>后台<ul><li>后台系统组成的后端平台，宝具哦企业的核心资源 – 数据 + 计算 <ul><li>财务系统</li><li>产品系统</li><li>客户管理系统</li><li>仓库物流管理系统</li></ul></li></ul></li><li>中台<ul><li>因为企业后台往往不能很好的支撑前台快速创新，响应用户的需求</li><li>前台直接使用后台，会遇到处理复杂，迭代速度缓慢的问题</li><li>前台要处理的是快速响应用户的需求，但是后台拿着整个公司的数据，是需要越稳定越好的，随着公司的发展，按照对速度和稳定的追求的冲突会越来越多</li><li>有了中台以后就可以将前台系统当中的稳定通用业务能力沉降到中台层，恢复前台的响应力</li></ul></li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://www.infoq.cn/article/3tbJZ8aS5pYdWYX5bBfg?utm_source=rss&amp;utm_medium=article" target="_blank" rel="noopener">https://www.infoq.cn/article/3tbJZ8aS5pYdWYX5bBfg?utm_source=rss&amp;utm_medium=article</a></li><li><a href="https://mp.weixin.qq.com/s/yfhaEkO1DG_ihJMhwtkWjA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/yfhaEkO1DG_ihJMhwtkWjA</a></li><li><a href="https://www.infoq.cn/article/hfONAlDdhK3fD9JjduGR" target="_blank" rel="noopener">https://www.infoq.cn/article/hfONAlDdhK3fD9JjduGR</a></li><li><a href="https://www.zhihu.com/question/57717433" target="_blank" rel="noopener">https://www.zhihu.com/question/57717433</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-什么是中台？&quot;&gt;&lt;a href=&quot;#1-什么是中台？&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是中台？&quot;&gt;&lt;/a&gt;1. 什么是中台？&lt;/h1&gt;&lt;p&gt;看到几篇关于中台的博客，是国内提出的一个新的概念，稍微研究了下，很有意思的概念。&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="中台" scheme="https://www.llchen60.com/tags/%E4%B8%AD%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>关于抖音的一些分析</title>
    <link href="https://www.llchen60.com/%E5%85%B3%E4%BA%8E%E6%8A%96%E9%9F%B3%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E6%9E%90/"/>
    <id>https://www.llchen60.com/%E5%85%B3%E4%BA%8E%E6%8A%96%E9%9F%B3%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E6%9E%90/</id>
    <published>2020-04-11T21:29:43.000Z</published>
    <updated>2020-04-11T22:45:17.990Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a>1. Overview</h1><h2 id="1-1-外部环境背景"><a href="#1-1-外部环境背景" class="headerlink" title="1.1 外部环境背景"></a>1.1 外部环境背景</h2><p>短视频是当前超高速发展的赛道，流量持续迅猛增长，越来越多的公司进入这个赛道，头部的国内有抖音快手，主要着眼于1min以内的短视频，主要为UGC(User Generated Content)，少量PGC(Professional Generated Content)产出内容；美国有刚刚成立的quibi，着眼于制作10min左右的优质内容，完全走PGC的路线。</p><p>短视频的兴起是有一些需要的社会以及科技的基础背景的。 </p><ul><li>从经济发展角度<ul><li>经济的持续发展，刺激了人们的休闲娱乐的需求的增长</li></ul></li><li>从用户需求角度<ul><li>需要填补自己的碎片时间</li><li>需要更多的娱乐休闲</li><li>自我表达，自我实现，社会联结的需求</li><li>发泄情绪</li></ul></li><li>从用户使用习惯角度<ul><li>截止2019年6月<ul><li>全国手机网民数量达到8.47亿(根据第44次中国互联网发展状况统计报告)，互联网普及率达到61.2%</li><li>网络购物用户规模6.39亿 </li><li>手机网络购物用户规模6.22亿</li><li>网络视频用户7.59亿</li><li>移动互联网接入流量消费553.9亿GB 同比增长107.3% </li><li>网民平均每周上网时长 27.9小时</li><li>短视频时长占比 11.5%，使用高峰为12点以及21点左右  </li></ul></li></ul></li><li>从技术角度<ul><li>4G 5G兴起，高速网络建设</li><li>手机的广泛普及</li><li>云平台普及，企业架构的相对简化，成本的降低 </li></ul></li><li>政策影响<ul><li>推出《网络短视频平台管理规范》</li><li>推出《网络短视频内容审核标准细则》 </li></ul></li></ul><h2 id="1-2-时间线"><a href="#1-2-时间线" class="headerlink" title="1.2 时间线"></a>1.2 时间线</h2><ul><li>2016年9月上线 <ul><li>A.me 定位为音乐短视频社区 </li><li>年轻人的15秒音乐短视频社区 </li></ul></li><li>2016年11月<ul><li>查找通讯录，邀请QQ 微博好友</li></ul></li><li>2016年11月10日<ul><li>微博话题挑战</li><li>雇佣 召集大学生，舞蹈音乐达人，拍摄视频引流</li></ul></li><li>2016年12月10日<ul><li>抖音 – 音乐视频应用</li></ul></li><li>2016年12月22日<ul><li>推荐热门视频</li><li>捧红一部分人，再带动普通用户的理念 – 偏向于中心化的运营方式出现端倪    </li></ul></li><li>2017年3月<ul><li>邀请岳云鹏等诸多明星加入抖音</li><li>开始有大批用户从明星微博当中看到抖音水印，进入抖音平台</li></ul></li><li>2017年6月开始<ul><li>给视频创作者更多权限<ul><li>对评论的控制，删减</li></ul></li><li>附近 tab，增强社交属性</li><li>抖音故事<ul><li>可以设置只开放24小时，希望普通人可以在上面记录自己的生活</li></ul></li><li>可以绑定微博主页</li></ul></li><li>2017年8月<ul><li>Tik Tok出海</li><li>吴亦凡的抖音挑战</li><li>中国有嘻哈 官方推荐</li><li>抖音开始砸钱到各个节目，增加曝光度了</li></ul></li><li>2017年9月<ul><li>首次线下party，狂欢节</li><li>和汉堡王，摩拜单车等等公司展开合作，联名等</li><li>AR相机</li><li>开启信息流广告，开屏广告的尝试 </li></ul></li><li>2017年10月<ul><li>上线直播功能</li></ul></li><li>2017年11月<ul><li>全新滤镜</li><li>倒计时自动暂停</li><li>直播间优化，增加弹幕功能</li></ul></li><li>2017年12月<ul><li>全新尬舞机功能    </li></ul></li><li>2018年1月<ul><li>百万英雄</li><li>私信功能</li><li>优化举报 评论功能</li></ul></li><li>2018年3月<ul><li>大规模的广告接入和投放开始</li></ul></li><li>2018年8月  <ul><li>直达淘宝功能上线</li><li>反沉迷系统上线        </li><li>增加游戏贴纸</li></ul></li><li>2018年10月<ul><li>个人页背景设置，个性化主页</li></ul></li><li>2018年12月<ul><li>直播粉丝团任务体系</li></ul></li><li>2019年1月<ul><li>地点详情页上传视频图片，用抖音来记录生活</li><li>直播 礼物一键连送</li><li>随拍功能</li><li>春晚独家社交媒体传播平台，五亿现金分享</li></ul></li><li>2019年2月<ul><li>AR画笔功能</li></ul></li><li>2019年3月<ul><li>随拍支持发布纯文字内容</li><li>新增聚焦拍摄模式</li><li>私信可置顶</li><li>热血鼓手道具玩法</li><li>新增位置贴纸</li></ul></li><li>2019年4月   <ul><li>道具玩法 – 橙子脸 </li><li>道具玩法 – 漫画擦拭</li></ul></li><li>2019年5月<ul><li>道具玩法 - change face   </li><li>挡脸变男生</li><li>道具玩法 - LineDancer</li></ul></li><li>2019年6月<ul><li>合拍 测相似度</li><li>道具玩法 – 炫光衣服 </li><li>道具玩法 – 照片连拍</li></ul></li><li>2019年7月<ul><li>道具玩法 – 动感轮廓</li><li>道具玩法 – 擦拭隐身</li><li>增加文字功能，可以在视频上添加文字了</li></ul></li><li>2019年9月<ul><li>青少年模式</li><li>道具玩法 – 百变抖抖秀</li></ul></li><li>2019年10月<ul><li>新增贴纸</li><li>青少年模式优化</li><li>新增变声功能</li></ul></li><li>2020年1月 - 至今<ul><li>春节20亿现金等你拿  </li><li>新增贴纸</li><li>新增特效  <h1 id="2-平台分析"><a href="#2-平台分析" class="headerlink" title="2. 平台分析"></a>2. 平台分析</h1><h2 id="2-1-市场定位"><a href="#2-1-市场定位" class="headerlink" title="2.1 市场定位"></a>2.1 市场定位</h2>从1.1的整个时间轴，我们会发现整个抖音的发展很小步快跑，迅速迭代。刚开始出了产品原型，用初始用户群体开始迅速做迭代，在锚定自己的定位，目标人群之后，通过召集KOL，明星，通过微博，QQ微信引流，实现其迅速的增长。</li></ul></li></ul><p>抖音的slogan是<strong>记录美好生活</strong>，<strong>以一二线城市年轻潮人为目标用户，市场定位突出音乐与创意</strong>，是一个相对中心化的高热度高流量的聚集年轻人的音乐短视频平台。整体是以音乐为核心布局的，用户在拍摄视频前首先选择一首背景音乐，根据音乐内容进行动作编排和加工特效。</p><h2 id="2-2-产品设计"><a href="#2-2-产品设计" class="headerlink" title="2.2 产品设计"></a>2.2 产品设计</h2><h3 id="2-2-1-浏览体验"><a href="#2-2-1-浏览体验" class="headerlink" title="2.2.1 浏览体验"></a>2.2.1 浏览体验</h3><ul><li>整体以黑白灰三色为主，风格简洁，有潮流感</li><li>全屏沉浸式体验<ul><li>无限向下滑动</li></ul></li><li>竖屏播放 – 适用更多的场景(上班，通勤，吃饭，等等) – 也很符合于短视频碎片时间使用的定位</li><li>点击背景音乐会跳转到同款音乐其他的短视频集合</li><li>交互 任意位置双击点赞，上下滑浏览其他视频</li><li>长按 可以看到更多的一些选择<ul><li>不感兴趣</li><li>加到喜欢 </li></ul></li></ul><h3 id="2-2-2-拍摄"><a href="#2-2-2-拍摄" class="headerlink" title="2.2.2 拍摄"></a>2.2.2 拍摄</h3><p>抖音在拍摄方面下了很大功夫，从更新日志上也能很明显看出他在尝试着不断降低拍摄出高质量视频的门槛，通过大量的特效，各种道具，让短视频不至于单调，可以用比较简单的素材，加上特效，音乐，撑起来。</p><ul><li>多种类型音乐<ul><li>国风</li><li>流行</li><li>原创 </li><li>etc.</li></ul></li><li>视频制作的功能<ul><li>速度切换</li><li>多段混剪</li><li>贴纸道具</li><li>美化滤镜</li><li>特效滤镜<h3 id="2-2-3-特色功能"><a href="#2-2-3-特色功能" class="headerlink" title="2.2.3 特色功能"></a>2.2.3 特色功能</h3></li></ul></li><li>热搜榜</li><li>尬舞机</li><li>时间锁</li></ul><h2 id="2-3-内容生产与分发"><a href="#2-3-内容生产与分发" class="headerlink" title="2.3 内容生产与分发"></a>2.3 内容生产与分发</h2><h3 id="2-3-1-内容生产模式"><a href="#2-3-1-内容生产模式" class="headerlink" title="2.3.1 内容生产模式"></a>2.3.1 内容生产模式</h3><p>UGC + PGC模式</p><ul><li>UGC<ul><li>普通用户</li></ul></li><li>PGC<ul><li>明星</li><li>网红</li><li>专业垂直领域KOL</li></ul></li></ul><h3 id="2-3-2-内容分发模式"><a href="#2-3-2-内容分发模式" class="headerlink" title="2.3.2 内容分发模式"></a>2.3.2 内容分发模式</h3><ul><li>算法推荐+人工精选推荐<ul><li>根据用户的观看数据，计算用户内容标签，按照一定频率推送相似的视频内容 </li><li>推荐爆款内容，越优质的内容会得到越多的曝光机会</li><li>推荐机制不太在意内容的发布时间，只要足够精彩，可能<strong><em>已经发布了几个月的视频</em></strong>还会不断推给用户</li></ul></li></ul><h2 id="2-4-营销推广"><a href="#2-4-营销推广" class="headerlink" title="2.4 营销推广"></a>2.4 营销推广</h2><ul><li>开屏广告</li><li>信息流广告</li><li>定制挑战赛<ul><li>为品牌独家定制</li><li>保持剧情，自主拍摄权交给视频制作者</li></ul></li><li>聚合电商<ul><li>同淘宝的直接链接</li></ul></li></ul><h2 id="2-5-技术能力"><a href="#2-5-技术能力" class="headerlink" title="2.5 技术能力"></a>2.5 技术能力</h2><ul><li>监管<ul><li>人工为主，机器学习为辅 <ul><li>通过建立完善数据库，将用户上传的内容与数据库进行匹配，被识别为不良内容就予以直接删除</li></ul></li><li>用户举报  <ul><li><h1 id="3-Thoughts"><a href="#3-Thoughts" class="headerlink" title="3. Thoughts"></a>3. Thoughts</h1></li></ul></li></ul></li></ul><h2 id="3-1-用户的需求"><a href="#3-1-用户的需求" class="headerlink" title="3.1 用户的需求"></a>3.1 用户的需求</h2><p>用户参与到虚拟社区的动机，可以是基于：</p><ul><li>自我认知和需求的满足 </li><li>社会交往需求  – 抖音不太能满足</li><li>获取利益的需求 – 平台盘子的扩大会增大每个人的盘子</li><li>情感归属 – 指跟随自己的偶像，明星，希望获取更多相关的信息</li></ul><p>首先，感到大部分人不习惯自己去主动寻求信息的，或者说，是不太清楚自己应该主动获取什么样的信息，因此app的主动推送，人被选择适时而生。（IOC 容器了解一下,hhh）</p><p>每个App都有自己的味道，抖音的味道能够吸引来追逐潮流的年轻人。可以在这里看到<strong>和自己类似的人</strong>拍的视频，看到的<strong>美好的世界</strong>。</p><p>抖音一定程度上满足了用户的自我认知的需求，会觉得抖音和自己很搭(用户画像和自我认知的部分重合)。</p><p>但在社交方面，有点不尽如人意，这也和抖音的整体 – 偏中心化的音乐短视频平台的初始定位有关了。当大部分的高质内容产出出自PGC, MCN的时候，潜在的内容创作者很可能会因为成为热门的高门槛而放弃。大家看自己向往的生活，而不是自己的生活。</p><p>热门视频大部分是有趣的段子，以及同样的素材音乐下的小哥哥小姐姐的表现，同质化有点严重，同时离日常生活的距离着实有点远，这也致使了用户之间的关联感比较差。  </p><p>一个超漂亮的小姐姐在跳舞，你会“哇，太好看了”，但你不知道该回什么，才能够不太尬的认识。因为这些小姐姐可能离你的物理距离还很远是吧~ 可看没法约 </p><p>抖音其实现在有基于地理位置的模块，有种想两手抓的感觉，不知道后台流量如何，只是当用户对于一个平台的定位是 – 去看好玩的搞笑的，去看小哥哥小姐姐的时候，想改变既定的认知，难度不小。想在保持当前定位的同时，加上一个社交属性，好像有些部分是相互有冲突的。</p><p>看到新闻在灰度测试，陌生人视频聊天，增强社交属性，看来是太不活跃，并没有灰度上。不知道具体是怎么样的过程，有没有足够多的对话题的引导，这种带点“阅后即焚”性质的尝试，会不会一不小心跨过监管允许的限制，lol  拭目以待</p><h2 id="3-2-others"><a href="#3-2-others" class="headerlink" title="3.2 others"></a>3.2 others</h2><ul><li>用户集中于一二线城市<ul><li>如何向三四线城市扩张？<ul><li>囧妈 很酷</li><li>大量的广告，代言<ul><li>这种打法在一二线城市很好用，三四线城市呢，联想趣头条 – 我们要最实在的！请给我钱，lol</li></ul></li><li>内容上的倾斜<ul><li>如何生产更多的小镇青年感兴趣的内容？  </li></ul></li></ul></li></ul></li><li>视频创作的门槛与参与热情<ul><li>刺激计划</li><li>培训平台 <ul><li>2019年11月26日上线创作者学院 </li></ul></li></ul></li><li>内容同质化，低俗化<ul><li>当在娱乐化做到很极致的时候(请看抖音app的极快的迭代频率，以及层出不穷的新道具，新玩法)，需要做更加深度的内容么？ </li><li>当知识付费成为新风口，巫师财经，半佛仙人成功出圈以后，有机会将内容浓缩到1-5min的视频当中，来点先导知识，然后再成功引流到长视频网站上？ </li></ul></li><li>弱社交平台<ul><li>社交是保证一个平台用户粘性的护城河，当抖音选择了沉浸式的无限下滑的交互方式的时候，一定程度上，我们可以说是舍弃了社交的 （对比快手的下滑留评，左滑回退的操作）。</li><li>弱社交也可以从留评数据当中可以看出，尽管抖音的日活月活遥遥领先，但留评，点赞是快手占据优势的，互动率要高出很多</li><li>做不做社交？<ul><li>一直无限想做，先出自己的专属app，没做起来，现在直接放到抖音这个国民app里做了</li></ul></li><li>为什么想做？<ul><li>社交，粘性，带货，看看快手的带货数据，贼酷炫</li><li>社交 - 附近的人 - 一张美丽的类似美团的外卖带动基于地理位置的其他业务的美妙构想</li></ul></li><li>concern<ul><li>社交注定是需要带点“平均人” 的理念的，这不仅仅需要接口，路径，交互方式的改变，更是内容分发逻辑，视频创作方式上的改变。那问题来了，社交有多重要，重要到改变整个平台的现有定位，重要到可能会降低一些格调，少一些fancy，多点生活气息么？ </li></ul></li></ul></li><li>算法 信息茧房<ul><li>用户喜欢的信息和信息广度的tradeoff，算法的单个方向上的相对极致优化，会缩减用户能够接受到的信息范围的</li><li>依旧是平台算法优化的问题了，到底给用户留出多少自己的空间呢？ </li></ul></li><li>政策的限制/要求 - 娱乐属性，社会属性，深入的思考性的东西很少<ul><li>嗯，是这样的~  </li></ul></li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="http://www.woshipm.com/evaluating/994454.html" target="_blank" rel="noopener">http://www.woshipm.com/evaluating/994454.html</a> </li><li><a href="https://tools.lancely.tech/apple/app-version/cn/1142110895" target="_blank" rel="noopener">https://tools.lancely.tech/apple/app-version/cn/1142110895</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Overview&quot;&gt;&lt;a href=&quot;#1-Overview&quot; class=&quot;headerlink&quot; title=&quot;1. Overview&quot;&gt;&lt;/a&gt;1. Overview&lt;/h1&gt;&lt;h2 id=&quot;1-1-外部环境背景&quot;&gt;&lt;a href=&quot;#1-1-外部环境背
      
    
    </summary>
    
    
      <category term="Notes" scheme="https://www.llchen60.com/categories/Notes/"/>
    
    
      <category term="thought" scheme="https://www.llchen60.com/tags/thought/"/>
    
      <category term="抖音" scheme="https://www.llchen60.com/tags/%E6%8A%96%E9%9F%B3/"/>
    
  </entry>
  
</feed>
