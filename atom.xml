<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Leilei&#39;s Blog | 磊磊的博客</title>
  
  <subtitle>Because it&#39;s there</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.llchen60.com/"/>
  <updated>2020-08-16T22:18:46.296Z</updated>
  <id>https://www.llchen60.com/</id>
  
  <author>
    <name>Leilei Chen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>线程池创建: Executors  vs ThreadPoolExecutor</title>
    <link href="https://www.llchen60.com/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%88%9B%E5%BB%BA-Executors-vs-ThreadPoolExecutor/"/>
    <id>https://www.llchen60.com/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%88%9B%E5%BB%BA-Executors-vs-ThreadPoolExecutor/</id>
    <published>2020-08-16T22:17:49.000Z</published>
    <updated>2020-08-16T22:18:46.296Z</updated>
    
    <content type="html"><![CDATA[<p>工程上对于线程池的使用必不可少，很多人会选择使用Executors class定义的<code>newCachedThreadPool</code>以及<code>newFixedThreadPool</code>。这篇博文就稍微分析一下二者适用的场景，以及我们应该使用Executors的方法还是直接调用ThreadPoolExecutor来创建线程池。</p><p>首先让我们一起看看二者的源码</p><pre><code>   /**     * Creates a thread pool that reuses a fixed number of threads     * operating off a shared unbounded queue.  At any point, at most     * {@code nThreads} threads will be active processing tasks.     * If additional tasks are submitted when all threads are active,     * they will wait in the queue until a thread is available.     * If any thread terminates due to a failure during execution     * prior to shutdown, a new one will take its place if needed to     * execute subsequent tasks.  The threads in the pool will exist     * until it is explicitly {@link ExecutorService#shutdown shutdown}.     *     * @param nThreads the number of threads in the pool     * @return the newly created thread pool     * @throws IllegalArgumentException if {@code nThreads &lt;= 0}     */    public static ExecutorService newFixedThreadPool(int nThreads) {        return new ThreadPoolExecutor(nThreads, nThreads,                                      0L, TimeUnit.MILLISECONDS,                                      new LinkedBlockingQueue&lt;Runnable&gt;());    }    /**     * Creates a thread pool that creates new threads as needed, but     * will reuse previously constructed threads when they are     * available.  These pools will typically improve the performance     * of programs that execute many short-lived asynchronous tasks.     * Calls to {@code execute} will reuse previously constructed     * threads if available. If no existing thread is available, a new     * thread will be created and added to the pool. Threads that have     * not been used for sixty seconds are terminated and removed from     * the cache. Thus, a pool that remains idle for long enough will     * not consume any resources. Note that pools with similar     * properties but different details (for example, timeout parameters)     * may be created using {@link ThreadPoolExecutor} constructors.     *     * @return the newly created thread pool     */    public static ExecutorService newCachedThreadPool() {        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,                                      60L, TimeUnit.SECONDS,                                      new SynchronousQueue&lt;Runnable&gt;());    } </code></pre><p>二者对比，你会发现实际上他们都是调用的ThreadPoolExecutor,只是参数是不一样的。那让我们看看ThreadPoolExecutor的源码</p><pre><code>    /**     * Creates a new {@code ThreadPoolExecutor} with the given initial     * parameters and default thread factory and rejected execution handler.     * It may be more convenient to use one of the {@link Executors} factory     * methods instead of this general purpose constructor.     *     * @param corePoolSize the number of threads to keep in the pool, even     *        if they are idle, unless {@code allowCoreThreadTimeOut} is set     * @param maximumPoolSize the maximum number of threads to allow in the     *        pool     * @param keepAliveTime when the number of threads is greater than     *        the core, this is the maximum time that excess idle threads     *        will wait for new tasks before terminating.     * @param unit the time unit for the {@code keepAliveTime} argument     * @param workQueue the queue to use for holding tasks before they are     *        executed.  This queue will hold only the {@code Runnable}     *        tasks submitted by the {@code execute} method.     * @throws IllegalArgumentException if one of the following holds:&lt;br&gt;     *         {@code corePoolSize &lt; 0}&lt;br&gt;     *         {@code keepAliveTime &lt; 0}&lt;br&gt;     *         {@code maximumPoolSize &lt;= 0}&lt;br&gt;     *         {@code maximumPoolSize &lt; corePoolSize}     * @throws NullPointerException if {@code workQueue} is null     */    public ThreadPoolExecutor(int corePoolSize,                              int maximumPoolSize,                              long keepAliveTime,                              TimeUnit unit,                              BlockingQueue&lt;Runnable&gt; workQueue) {        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,             Executors.defaultThreadFactory(), defaultHandler);    }</code></pre><p>看一下其中需要的几个参数：</p><ul><li><p>corePoolSize</p><ul><li>在线程池中最少要保持的线程数量，哪怕已经超过了定义的keepAliveTime </li></ul></li><li><p>maximumPoolSize</p><ul><li>线程池允许的最大线程数量</li></ul></li><li><p>keepAliveTime</p><ul><li>当当前线程数超过核心线程数量的时候，就会检查闲置的线程，如果在这段时间没有新的任务，就暂停当前线程</li></ul></li><li><p>unit</p><ul><li>定义事件单位</li></ul></li><li><p>workQueue</p><ul><li>在任务还没有执行之前，被用来持有这些任务的</li><li>queue之后持有execute方法提交的Runnable任务</li></ul></li></ul><p>带着这些信息我们再来看Executors.newFixedThreadPool的定义，方法传入了线程数量，然后核心线程数和最大线程数被设为一样的数值，让我们来看看在不同情况下他的表现：</p><ul><li><p>任务数小于等于设定的线程数</p><ul><li>一切运行正常</li><li>限制的线程不会被关闭</li></ul></li><li><p>任务数大于设定的线程数</p><ul><li>任务会加入到队列当中，进行等待</li><li>值得注意的是在实例化LinkedBlockingQueue的时候，传入的参数是<code>this(Integer.MAX_VALUE);</code><ul><li>这意味着如果任务在线程中执行的时间非常长，任务可以在队列中堆积到无限大，最终结果会是内存被占满..程序崩溃</li></ul></li></ul></li></ul><p>而对于Executors.newCachedThreadPool来说，其定义的核心线程数量为0，最大线程数是<code>Integer.MAX_VALUE</code>,即理论上是可以有无限多的线程，keepAliveTime是60秒，使用的是SynchrounousQueue。</p><ul><li>当任务进来的时候<ul><li>会增加线程</li><li>有多少任务进来，就会使用ThreadFactory开多少线程，因为允许的最大线程数时无限大，所以可以一直这么开下去</li><li>而其workqueue是SynchrounousQueue,其大小始终为0，在这里我们可以直接任务当任务进来的时候，如果没有空闲的线程，会直接让ThreadFactory来构建新的线程了</li><li>那么当任务无限多的时候，就会创建无数多的线程，直接撑爆内存了</li></ul></li></ul><p>由此可以看出来使用Executors的两个方法直接构建线程池因为设定的参数是无界的，可能会导致OOM的错误，更好的方式是自己根据当前线程池的应用场景，来设定参数。</p><p>根据应用场景的不同，根据doc，我们有三大类的queue可以选择，分别为：</p><ul><li><p><code>Synchronous queue</code></p><ul><li>直接讲任务交给线程</li><li>自己本身不持有任何任务的</li><li>针对的应用场景可以是各个线程之间任务的执行有某些内在的联系，阻碍一个的执行可能会影响另外一个</li><li>为了不拒绝新的线程的创建，就必须设定线程池的大小为Integer.MAX_VALUE</li><li>这样如果处理速度低于新任务的提交速度的话，可能会导致非常非常大的线程池</li></ul></li><li><p><code>LinkedBlockingQueue</code></p><ul><li>使用没有边界的queue</li><li>这样当所有核心线程都忙碌的时候，任务就都会在队列当中排队</li><li>这种方式可以环节突发性的峰值，但是如果处理速度慢于任务堆积的速度，queue会变得很大</li></ul></li><li><p><code>ArrayBlockingQueue</code></p><ul><li>有限长的queue</li><li>这样可以防止资源耗尽，但是也很难做调整和优化</li><li>队列的大小和最大线程数相互影响，很难做到优化</li><li>使用大队列，小线程池可以减少对于CPU的使用，线程切换的损耗，但是单位时间处理速度不会太高</li><li>使用小队列，大线程池可以让CPU更忙碌，但是切换线程会有不小的损耗</li></ul></li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://www.ibm.com/developerworks/library/j-jtp0730/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/library/j-jtp0730/index.html</a> </li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ThreadPoolExecutor.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ThreadPoolExecutor.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;工程上对于线程池的使用必不可少，很多人会选择使用Executors class定义的&lt;code&gt;newCachedThreadPool&lt;/code&gt;以及&lt;code&gt;newFixedThreadPool&lt;/code&gt;。这篇博文就稍微分析一下二者适用的场景，以及我们应该使用Ex
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Executors" scheme="https://www.llchen60.com/tags/Executors/"/>
    
      <category term="ThreadPoolExecutor" scheme="https://www.llchen60.com/tags/ThreadPoolExecutor/"/>
    
  </entry>
  
  <entry>
    <title>AWS CDK Overview</title>
    <link href="https://www.llchen60.com/AWS-CDK-Overview/"/>
    <id>https://www.llchen60.com/AWS-CDK-Overview/</id>
    <published>2020-08-14T03:17:35.000Z</published>
    <updated>2020-08-14T03:18:06.405Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a>1. Overview</h1><ul><li><p>AWS CDK </p><ul><li><p>Open source software development framework </p></li><li><p>Model and provision your cloud application resources</p></li><li><p>To resolve what issue? </p><ul><li>provision cloud applications is challenging cause require<ul><li>manual actions</li><li>custom scripts </li><li>maintain templates </li><li>domain specific languages </li></ul></li></ul></li><li><p>How does CDK resolve the issue?</p><ul><li>Provides with high level component that pre-configure cloud resources with proven defaults</li><li>Provision your resources through AWS CloudFormation </li></ul></li></ul></li></ul><h2 id="1-1-Workflow"><a href="#1-1-Workflow" class="headerlink" title="1.1 Workflow"></a>1.1 Workflow</h2><ul><li>Creating an Amazon ECS service with AWS Fargate launch type </li></ul><pre><code>public class MyEcsConstructStack extends Stack {    public MyEcsConstructStack(final Construct scope, final String id) {        this(scope, id, null);    }    public MyEcsConstructStack(final Construct scope, final String id,            StackProps props) {        super(scope, id, props);        Vpc vpc = Vpc.Builder.create(this, &quot;MyVpc&quot;).maxAzs(3).build();        Cluster cluster = Cluster.Builder.create(this, &quot;MyCluster&quot;)                .vpc(vpc).build();        ApplicationLoadBalancedFargateService.Builder.create(this, &quot;MyFargateService&quot;)                .cluster(cluster)                .cpu(512)                .desiredCount(6)                .taskImageOptions(                       ApplicationLoadBalancedTaskImageOptions.builder()                               .image(ContainerImage                                       .fromRegistry(&quot;amazon/amazon-ecs-sample&quot;))                               .build()).memoryLimitMiB(2048)                .publicLoadBalancer(true).build();    }}</code></pre><ul><li><p>Basic workflow</p><ul><li>create the app from a template provided by the AWS CDK</li><li>add code to the app to create resources within stacks</li><li>build the app </li><li>synthesize one or more stacks in the app to create an AWS CloudFormation template </li><li>deploy one or more stacks to your AWS account </li></ul></li><li><p>Benefits </p><ul><li>Could use logic when defining infrastructure </li><li>Use object-oriented techniques to create a model of system </li><li>Define high level abstractions</li></ul></li><li><p>Tools</p><ul><li><p><a href="https://docs.aws.amazon.com/cdk/latest/guide/cli.html" target="_blank" rel="noopener">CDK Toolkit</a> </p><ul><li>CLI for interacting with CDK apps </li><li>Enable developers to synthesize artifacts such as AWS CloudFormation templates, deploy stacks to development AWS accounts, and diff against a deployed stack to understand the impact of a code change </li></ul></li><li><p><a href="https://docs.aws.amazon.com/cdk/latest/guide/constructs.html" target="_blank" rel="noopener">AWS Construct Library</a></p><ul><li>contains constructs representing AWS resources </li><li>encapsulate the details of how to create resources for an Amazon or AWS service </li></ul></li></ul></li></ul><h2 id="1-1-1-Create-and-build-the-app"><a href="#1-1-1-Create-and-build-the-app" class="headerlink" title="1.1.1 Create and build the app"></a>1.1.1 Create and build the app</h2><pre><code>mkdir hello-cdk &amp;&amp; cd hello-cdkcdk init TEMPLATE --language LANGUAGE cdk init app --language java// In your IDE, import it as maven project mvn compile cdk ls </code></pre><h3 id="1-1-2-Add-an-Amazon-S3-Bucket"><a href="#1-1-2-Add-an-Amazon-S3-Bucket" class="headerlink" title="1.1.2 Add an Amazon S3 Bucket"></a>1.1.2 Add an Amazon S3 Bucket</h3><pre><code>// Add dependencies to pom.xml &lt;dependency&gt;    &lt;groupId&gt;software.amazon.awscdk&lt;/groupId&gt;    &lt;artifactId&gt;s3&lt;/artifactId&gt;    &lt;version&gt;${cdk.version}&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>Define an Amazon S3 bucket in the stack using L2 construct </p><pre><code>package com.myorg;import software.amazon.awscdk.core.*;import software.amazon.awscdk.services.s3.Bucket;public class HelloCdkStack extends Stack {    public HelloCdkStack(final Construct scope, final String id) {        this(scope, id, null);    }    public HelloCdkStack(final Construct scope, final String id, final StackProps props) {        super(scope, id, props);        Bucket.Builder.create(this, &quot;MyFirstBucket&quot;)            .versioned(true).build();    }}</code></pre><h3 id="1-1-3-Systhesize-an-AWS-CloudFormation-Template"><a href="#1-1-3-Systhesize-an-AWS-CloudFormation-Template" class="headerlink" title="1.1.3 Systhesize an AWS CloudFormation Template"></a>1.1.3 Systhesize an AWS CloudFormation Template</h3><pre><code>cdk synth</code></pre><h3 id="1-1-4-Deploying-the-stack"><a href="#1-1-4-Deploying-the-stack" class="headerlink" title="1.1.4 Deploying the stack"></a>1.1.4 Deploying the stack</h3><p><code>cdk deploy</code></p><h3 id="1-1-5-Modifying-the-stack"><a href="#1-1-5-Modifying-the-stack" class="headerlink" title="1.1.5 Modifying the stack"></a>1.1.5 Modifying the stack</h3><pre><code>// after make your change cdk diff cdk deploy // Possibly destroy cdk destroy </code></pre><ul><li>Synthesize before deploying <h1 id="2-Basic-concepts"><a href="#2-Basic-concepts" class="headerlink" title="2. Basic concepts"></a>2. Basic concepts</h1></li></ul><h2 id="2-1-Constructs"><a href="#2-1-Constructs" class="headerlink" title="2.1 Constructs"></a>2.1 Constructs</h2><h3 id="2-1-1-Basics"><a href="#2-1-1-Basics" class="headerlink" title="2.1.1 Basics"></a>2.1.1 Basics</h3><ul><li><p>Constructs </p><ul><li><p>Basic building blocks </p></li><li><p>represents a cloud component, encapsulates everything AWS CloudFormation needs to create the component </p></li><li><p>[AWS Construct Library](<a href="https://docs.aws.amazon.com/cdk/api/latest/docs/aws-construct-library.html" target="_blank" rel="noopener">https://docs.aws.amazon.com/cdk/api/latest/docs/aws-construct-library.html</a></p></li><li><p>defferent level of constructs </p><ul><li><p>CFN Resources/ L1 </p><ul><li>directly represent all of the AWS resources that are available in AWS CloudFormation </li><li>named as CfnXyz, where xyz is name of the resource </li><li><strong>When you use CFN resources, you must explicitly configure all resource properties, which requires a complete understanding of the details of the underlying AWS CloudFormation resource model</strong></li></ul></li><li><p>AWS Reousources/ L2 Constrcuts</p><ul><li>higher level, intent based API </li><li>provide defaults, boilerplate, and glue logic you’d be writing with a CFN resource construct</li><li>Offer convenient defaults thus reduce the need for the detail of AWS resources  </li></ul></li><li><p>Patterns - higher level constructs </p><ul><li>designed to help you complete common tasks in AWS, often involving multiple kinds of resources </li></ul></li></ul></li></ul></li></ul><pre><code>// L1 ConstructCfnBucket bucket = CfnBucket.Builder.create(this, &quot;MyBucket&quot;)                        .bucketName(&quot;MyBucket&quot;)                        .corsConfiguration(new CfnBucket.CorsConfigurationProperty.Builder()                            .corsRules(Arrays.asList(new CfnBucket.CorsRuleProperty.Builder()                                .allowedOrigins(Arrays.asList(&quot;*&quot;))                                .allowedMethods(Arrays.asList(&quot;GET&quot;))                                .build()))                            .build())                        .build();// L2 Constructimport software.amazon.awscdk.services.s3.*;public class HelloCdkStack extends Stack {    public HelloCdkStack(final Construct scope, final String id) {        this(scope, id, null);    }    public HelloCdkStack(final Construct scope, final String id, final StackProps props) {        super(scope, id, props);        Bucket.Builder.create(this, &quot;MyFirstBucket&quot;)                .versioned(true).build();    }}</code></pre><h3 id="2-1-2-Hierarchy-Composition"><a href="#2-1-2-Hierarchy-Composition" class="headerlink" title="2.1.2 Hierarchy - Composition"></a>2.1.2 Hierarchy - Composition</h3><ul><li><p>Composition </p><ul><li>High level construct can be composed from any number of lower level constructs </li><li>In turn, those could be composed from even lower level constructs</li><li>Scoping pattern results in a hierarchy of constructs known as a construct tree </li></ul></li><li><p>Composition means you can define reusable components and share them like any other code </p></li></ul><h3 id="2-1-3-Initialization"><a href="#2-1-3-Initialization" class="headerlink" title="2.1.3 Initialization"></a>2.1.3 Initialization</h3><ul><li><p>Being implemented in classes that extend the Construct base class </p></li><li><p>3 parameters </p><ul><li><p>scope </p><ul><li>the construct within which this construct is defined </li></ul></li><li><p>id </p><ul><li>an identifier that much be unique within this scope </li><li>serves as a namespace for everything that’s encapsulated within the scope’s subtree </li><li>used to allocate unique identities such as resource names and AWS CloudFormation logical IDs </li></ul></li><li><p>props </p><ul><li>a set of properties or keyword arguments </li><li>define the construct’s initial configuration </li></ul></li></ul></li></ul><h1 id="3-Java-Related"><a href="#3-Java-Related" class="headerlink" title="3. Java Related"></a>3. Java Related</h1><h2 id="3-1-AWS-CDK-idioms-in-Java"><a href="#3-1-AWS-CDK-idioms-in-Java" class="headerlink" title="3.1 AWS CDK idioms in Java"></a>3.1 AWS CDK idioms in Java</h2><ul><li>Props <ul><li>expressed with Builder pattern </li><li>define a bundle of key/ value pairs that the construct uses to configure the resources it creates </li></ul></li></ul><pre><code>Bucket bucket = new Bucket(this, &quot;MyBucket&quot;, new BucketProps.Builder()                           .versioned(true)                           .encryption(BucketEncryption.KMS_MANAGED)                           .build());</code></pre><ul><li>missing values <ul><li>it will be represented by <code>null</code></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Overview&quot;&gt;&lt;a href=&quot;#1-Overview&quot; class=&quot;headerlink&quot; title=&quot;1. Overview&quot;&gt;&lt;/a&gt;1. Overview&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;AWS CDK &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Op
      
    
    </summary>
    
    
      <category term="Cloud" scheme="https://www.llchen60.com/categories/Cloud/"/>
    
    
  </entry>
  
  <entry>
    <title>Git 流程</title>
    <link href="https://www.llchen60.com/Git-%E6%B5%81%E7%A8%8B/"/>
    <id>https://www.llchen60.com/Git-%E6%B5%81%E7%A8%8B/</id>
    <published>2020-08-12T00:41:26.000Z</published>
    <updated>2020-08-12T00:41:52.187Z</updated>
    
    <content type="html"><![CDATA[<p>解决git conflict永远都是件很让人头疼的事情，为了让生活更简单，还是需要设定正确的git流程的。现在有如下几种git 流程</p><h1 id="1-基本的Git-流程"><a href="#1-基本的Git-流程" class="headerlink" title="1. 基本的Git 流程"></a>1. 基本的Git 流程</h1><p>只有一个branch – master. 开发者直接commit进去，然后会进入到alpha，beta, gamma, prod等不同的生产状态当中。</p><p>一般来说，除非你在自己单独完成某项小任务，是很不推荐这样做的。</p><p>缺陷在于：</p><ul><li>代码上的合作变得很困难，可能会有多次冲突，需要逐次进行解决</li></ul><h1 id="2-Git-feature分支流程"><a href="#2-Git-feature分支流程" class="headerlink" title="2. Git feature分支流程"></a>2. Git feature分支流程</h1><p>当在同一个codebase我们有多个工程师共同工作的时候，使用feature分治就变成了必不可少的事情了。</p><p>如果现在有两个工程师在同一个branch上工作，来提交自己的代码，那最终一定是冲突不断的，很容易出现各种问题。</p><p>为了避免出现这种情况，两个开发者可以创建两个不同的分支，分别在自己的分治上来开发自己的项目。</p><p>这样做的好处是不用担心大量需要解决的冲突了。</p><h1 id="3-Git-feature分支流程与Develop分支"><a href="#3-Git-feature分支流程与Develop分支" class="headerlink" title="3. Git feature分支流程与Develop分支"></a>3. Git feature分支流程与Develop分支</h1><p>和上述的feature分支流程很类似，只是又加了一个Develop分支，在这个流程下，master 分支永远反映一个prod ready的状态。</p><p>无论何时，当小组想要将代码部署到prod的时候，他们从master分支来进行部署</p><p>develop branch反映的是带着最新的为了下次发布准备的所有改动。开发者fork develop 分支的代码，来做独立开发。一旦项目做好，经过了测试，就合并到develop分支当中，在develop分支来做充分的测试，然后再merge到master分支当中去。</p><p>这样做的好处是能够允许小组持续merge新的功能，做持续集成。不过过程相对比较麻烦。个人观点是在小规模的前提下，使用特征分支就足够了，再加上持续集成的工具，譬如Jerkins，很安全，效率也很不错。</p><p><a href="https://zepel.io/blog/5-git-workflows-to-improve-development/" target="_blank" rel="noopener">https://zepel.io/blog/5-git-workflows-to-improve-development/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;解决git conflict永远都是件很让人头疼的事情，为了让生活更简单，还是需要设定正确的git流程的。现在有如下几种git 流程&lt;/p&gt;
&lt;h1 id=&quot;1-基本的Git-流程&quot;&gt;&lt;a href=&quot;#1-基本的Git-流程&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="git" scheme="https://www.llchen60.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Java Notes</title>
    <link href="https://www.llchen60.com/Java-Notes/"/>
    <id>https://www.llchen60.com/Java-Notes/</id>
    <published>2020-08-04T02:19:37.000Z</published>
    <updated>2020-08-21T03:01:01.558Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-并发"><a href="#1-并发" class="headerlink" title="1. 并发"></a>1. 并发</h1><h2 id="1-1-ThreadLocal复用问题"><a href="#1-1-ThreadLocal复用问题" class="headerlink" title="1.1 ThreadLocal复用问题"></a>1.1 ThreadLocal复用问题</h2><p>ThreadLocal适用于变量在线程间隔离，而在方法或类之间共享的场景。如果用户信息的获取比较昂贵，那么在ThreadLocal中缓存数据时比较合适的做法。</p><pre><code>private static final ThreadLocal&lt;Integer&gt; currentUser = ThreadLocal.withInitial(() -&gt; null);@GetMapping(&quot;wrong&quot;)public Map wrong(@RequestParam(&quot;userId&quot;) Integer userId) {    //设置用户信息之前先查询一次ThreadLocal中的用户信息    String before  = Thread.currentThread().getName() + &quot;:&quot; + currentUser.get();    //设置用户信息到ThreadLocal    currentUser.set(userId);    //设置用户信息之后再查询一次ThreadLocal中的用户信息    String after  = Thread.currentThread().getName() + &quot;:&quot; + currentUser.get();    //汇总输出两次查询结果    Map result = new HashMap();    result.put(&quot;before&quot;, before);    result.put(&quot;after&quot;, after);    return result;}</code></pre><p>上述例子当中，我们在设置前设置后都做了记录，来看threadLocal当中都记录了什么信息，。值得注意的是程序是运行在Tomcat当中的，执行程序的线程是Tomcat的工作线程，而Tomcat的工作线程是基于线程池的。</p><p>即会重用几个固定的线程，一旦线程重用，那么很可能首次从ThreadLocal获取的值是之前其他用户的请求遗留的值。这时ThreadLocal中的用户信息就是其他用户的信息了。</p><p>Take Away: </p><ol><li>代码中没用多线程不以为着你的程序没有使用多线程，Tomcat的Web服务器的业务代码，本身就运行在一个多线程环境当中</li><li>使用线程池处理数据就意味着线程是会被重用的，使用类似ThreadLocal工具来存放一些数据的时候，需要注意在代码运行完之后，显式去清空设置的数据。</li></ol><p>修正复用的问题的bug： </p><pre><code>private static final ThreadLocal&lt;Integer&gt; currentUser = ThreadLocal.withInitial(() -&gt; null);@GetMapping(&quot;right&quot;)public Map right(@RequestParam(&quot;userId&quot;) Integer userId) {    String before  = Thread.currentThread().getName() + &quot;:&quot; + currentUser.get();    currentUser.set(userId);    try {        String after = Thread.currentThread().getName() + &quot;:&quot; + currentUser.get();        Map result = new HashMap();        result.put(&quot;before&quot;, before);        result.put(&quot;after&quot;, after);        return result;    } finally {        //在finally代码块中删除ThreadLocal中的数据，确保数据不串        currentUser.remove();    }}</code></pre><h2 id="1-2-ConcurrentHashMap"><a href="#1-2-ConcurrentHashMap" class="headerlink" title="1.2 ConcurrentHashMap"></a>1.2 ConcurrentHashMap</h2><ul><li>ConcurrentHashMap是线程安全的哈希表容器，这里的线程安全是指原子性读写操作是线程安全的。</li><li>例子 – 10个线程一起来补充总共100个元素进去</li></ul><pre><code>    //线程个数    private static int THREAD_COUNT = 10;    //总元素数量    private static int ITEM_COUNT = 1000;    //帮助方法，用来获得一个指定元素数量模拟数据的ConcurrentHashMap    private ConcurrentHashMap&lt;String, Long&gt; getData(int count) {        return LongStream.rangeClosed(1, count)                .boxed()                .collect(Collectors.toConcurrentMap(i -&gt; UUID.randomUUID().toString(), Function.identity(),                        (o1, o2) -&gt; o1, ConcurrentHashMap::new));    }    @GetMapping(&quot;wrong&quot;)    public String wrong() throws InterruptedException {        ConcurrentHashMap&lt;String, Long&gt; concurrentHashMap = getData(ITEM_COUNT - 100);        //初始900个元素        log.info(&quot;init size:{}&quot;, concurrentHashMap.size());        ForkJoinPool forkJoinPool = new ForkJoinPool(THREAD_COUNT);        //使用线程池并发处理逻辑        forkJoinPool.execute(() -&gt; IntStream.rangeClosed(1, 10).parallel().forEach(i -&gt; {            //查询还需要补充多少个元素            int gap = ITEM_COUNT - concurrentHashMap.size();            log.info(&quot;gap size:{}&quot;, gap);            //补充元素            concurrentHashMap.putAll(getData(gap));        }));        //等待所有任务完成        forkJoinPool.shutdown();        forkJoinPool.awaitTermination(1, TimeUnit.HOURS);        //最后元素个数会是1000吗？        log.info(&quot;finish size:{}&quot;, concurrentHashMap.size());        return &quot;OK&quot;;    }</code></pre><p>这样子执行的结果就是加入远远超过预期的数量，因为ConcurrentHashMap可以保证多个worker工作的时候不会互相干扰，但是无法保证看到的当前ConcurrentHashMap数据数量的同步</p><ul><li>Take Aways<ul><li>使用ConcurrentHashMap，不代表对其多个操作之间的状态是一致的，是没有其他线程在操作它的，如果需要确保，需要手动加锁</li><li>诸如size,isEmpty和containsValue等聚合方法，在并发情况下可能会反映ConcurrentHashMap的<strong>中间状态</strong>，因此在并发情况下，<strong>*这些方法的返回值只能用作参考，而不能用于流程控制</strong></li></ul></li></ul><p>解决方案就是通过加锁，使得同时只有一个线程可以操作ConcurrentHashMap</p><pre><code>@GetMapping(&quot;right&quot;)public String right() throws InterruptedException {    ConcurrentHashMap&lt;String, Long&gt; concurrentHashMap = getData(ITEM_COUNT - 100);    log.info(&quot;init size:{}&quot;, concurrentHashMap.size());    ForkJoinPool forkJoinPool = new ForkJoinPool(THREAD_COUNT);    forkJoinPool.execute(() -&gt; IntStream.rangeClosed(1, 10).parallel().forEach(i -&gt; {        //下面的这段复合逻辑需要锁一下这个ConcurrentHashMap        synchronized (concurrentHashMap) {            int gap = ITEM_COUNT - concurrentHashMap.size();            log.info(&quot;gap size:{}&quot;, gap);            concurrentHashMap.putAll(getData(gap));        }    }));    forkJoinPool.shutdown();    forkJoinPool.awaitTermination(1, TimeUnit.HOURS);    log.info(&quot;finish size:{}&quot;, concurrentHashMap.size());    return &quot;OK&quot;;}</code></pre><ul><li>充分使用ConcurrentHashMap的特性<ul><li>例如面对一个使用Map来统计Key出现次数的场景</li><li>key范围为10， 最多使用10个并发，循环操作1000万次，每次操作累加随机的key</li><li>如果key不存在的话，首次设置值为1 </li></ul></li></ul><pre><code>    //循环次数    private static int LOOP_COUNT = 10000000;    //线程数量    private static int THREAD_COUNT = 10;    //元素数量    private static int ITEM_COUNT = 10;    private Map&lt;String, Long&gt; normaluse() throws InterruptedException {        ConcurrentHashMap&lt;String, Long&gt; freqs = new ConcurrentHashMap&lt;&gt;(ITEM_COUNT);        ForkJoinPool forkJoinPool = new ForkJoinPool(THREAD_COUNT);        forkJoinPool.execute(() -&gt; IntStream.rangeClosed(1, LOOP_COUNT).parallel().forEach(i -&gt; {            //获得一个随机的Key            String key = &quot;item&quot; + ThreadLocalRandom.current().nextInt(ITEM_COUNT);                    synchronized (freqs) {                              if (freqs.containsKey(key)) {                            //Key存在则+1                            freqs.put(key, freqs.get(key) + 1);                        } else {                            //Key不存在则初始化为1                            freqs.put(key, 1L);                        }                    }                }        ));        forkJoinPool.shutdown();        forkJoinPool.awaitTermination(1, TimeUnit.HOURS);        return freqs;    }</code></pre><p>但是实际上ConcurrentHashMap本身是使用的Java自带的CAS操作的，在虚拟机层面确保了写入数据的原子性，比加锁的效率高很多，因此相较于直接加synchronized重量锁，我们可以通过computeIfAbsent()操作，和线程安全累加器LongAdder来更有效率的实现我们的统计目的</p><pre><code>private Map&lt;String, Long&gt; gooduse() throws InterruptedException {    ConcurrentHashMap&lt;String, LongAdder&gt; freqs = new ConcurrentHashMap&lt;&gt;(ITEM_COUNT);    ForkJoinPool forkJoinPool = new ForkJoinPool(THREAD_COUNT);    forkJoinPool.execute(() -&gt; IntStream.rangeClosed(1, LOOP_COUNT).parallel().forEach(i -&gt; {        String key = &quot;item&quot; + ThreadLocalRandom.current().nextInt(ITEM_COUNT);                //利用computeIfAbsent()方法来实例化LongAdder，然后利用LongAdder来进行线程安全计数                freqs.computeIfAbsent(key, k -&gt; new LongAdder()).increment();            }    ));    forkJoinPool.shutdown();    forkJoinPool.awaitTermination(1, TimeUnit.HOURS);    //因为我们的Value是LongAdder而不是Long，所以需要做一次转换才能返回    return freqs.entrySet().stream()            .collect(Collectors.toMap(                    e -&gt; e.getKey(),                    e -&gt; e.getValue().longValue())            );}</code></pre><ul><li>上述代码中，直接使用了ConcurrentHashMap的原子性方法computeIfAbsent来做符合逻辑操作，判断Key是否存在Value，如果不存在则把Lambda表达式运行后的结果放入Map作为Value</li><li>LongAdder是线程安全的累加器，因此可以直接调用其increment()方法来做累加。</li></ul><h2 id="1-3-锁"><a href="#1-3-锁" class="headerlink" title="1.3 锁"></a>1.3 锁</h2><ul><li>加锁前需要知道锁和被保护的对象是不是一个层面上的<ul><li>静态字段属于类，需要类级别的锁来进行保护</li><li>非静态字段属于类实例，实例级别的锁就可以保护</li></ul></li></ul><pre><code>// 定义一个静态int字段counter和一个非静态的wrong方法，实现counter字段的累加操作class Data {    @Getter    private static int counter = 0;    public static int reset() {        counter = 0;        return counter;    }    public synchronized void wrong() {        counter++;    }}// 测试代码@GetMapping(&quot;wrong&quot;)public int wrong(@RequestParam(value = &quot;count&quot;, defaultValue = &quot;1000000&quot;) int count) {    Data.reset();    //多线程循环一定次数调用Data类不同实例的wrong方法    IntStream.rangeClosed(1, count).parallel().forEach(i -&gt; new Data().wrong());    return Data.getCounter();}</code></pre><p>输出结果，因为默认运行100万次，但是页面输出的并不会是100万。</p><ul><li>在非静态的wrong方法上加锁，只能够保证多个线程无法执行同一个实例的wrong方法，但无法保证其不会执行不同实例的wrong方法。而静态的counter是被共享的</li><li>解决方案时保证在一个实例的方法操作静态变量的时候，其他的实例无法操作这个静态变量</li></ul><pre><code>class Data {    @Getter    private static int counter = 0;    private static Object locker = new Object();    public void right() {        synchronized (locker) {            counter++;        }    }}</code></pre><ul><li>除此以外，对锁可以做的优化还包括<ul><li>精细化锁应用的范围</li><li>区分读写场景以及资源的访问冲突，考虑使用悲观锁还是乐观锁<ul><li>对于读写比例差异明显的场景，考虑使用ReentrantReadWriteLock细化区分读写锁，来提高性能</li><li>如果共享资源冲突概率不大，可以考虑使用StampedLock的乐观读的特性，进一步提高性能</li></ul></li></ul></li></ul><h2 id="1-4-线程池"><a href="#1-4-线程池" class="headerlink" title="1.4 线程池"></a>1.4 线程池</h2><p>开发当中，我们会使用各种池化技术来缓存创建昂贵的对象，比如线程池，连接池，内存池。一般是预先创建一些对象放入到池当中，使用的时候直接取出使用，用完归还以便复用。通过一定的策略调整池中缓存对象的数量，实现池的动态伸缩。</p><ul><li>应当手动进行线程池的声明<ul><li>Java Executors定义了一些快捷的工具办法，来帮助我们快速创建线程池</li><li>应当禁止使用这些方法来创建线程池，应当手动new ThreadPoolExecutor来创建线程池<ul><li>资源耗尽导致OOM问题<ul><li>newFixedThreadPool</li><li>newCachedThreadPool</li></ul></li></ul></li></ul></li></ul><h3 id="1-4-1-newFixedThreadPool-OOM-问题"><a href="#1-4-1-newFixedThreadPool-OOM-问题" class="headerlink" title="1.4.1 newFixedThreadPool OOM 问题"></a>1.4.1 newFixedThreadPool OOM 问题</h3><pre><code>    @GetMapping(&quot;oom1&quot;)    public void oom1() throws InterruptedException {        ThreadPoolExecutor threadPool = (ThreadPoolExecutor) Executors.newFixedThreadPool(1);        //打印线程池的信息，稍后我会解释这段代码        printStats(threadPool);         for (int i = 0; i &lt; 100000000; i++) {            threadPool.execute(() -&gt; {                String payload = IntStream.rangeClosed(1, 1000000)                        .mapToObj(__ -&gt; &quot;a&quot;)                        .collect(Collectors.joining(&quot;&quot;)) + UUID.randomUUID().toString();                try {                    TimeUnit.HOURS.sleep(1);                } catch (InterruptedException e) {                }                log.info(payload);            });        }        threadPool.shutdown();        threadPool.awaitTermination(1, TimeUnit.HOURS);    }</code></pre><ul><li>日志显示出现了OOM</li><li>newFixedThreadPool源码：</li></ul><pre><code>    public static ExecutorService newFixedThreadPool(int nThreads) {        return new ThreadPoolExecutor(nThreads, nThreads,                                      0L, TimeUnit.MILLISECONDS,                                      new LinkedBlockingQueue&lt;Runnable&gt;());    }    public class LinkedBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;            implements BlockingQueue&lt;E&gt;, java.io.Serializable {        ...        /**         * Creates a {@code LinkedBlockingQueue} with a capacity of         * {@link Integer#MAX_VALUE}.         */        public LinkedBlockingQueue() {            this(Integer.MAX_VALUE);        }    ...    }</code></pre><ul><li>直接使用了一个LinkedBlockingQueue，而默认构造方法是一个Integer.MAX_VALUE长度的队列，是无界的。</li><li>尽管使用newFixedThreadPool可以把工作线程控制在固定的数量上，但任务队列是无界的。如果任务比较多并且执行比较慢的话，队列可能会迅速积压，撑爆内存导致OOM</li></ul><h3 id="1-4-2-newCachedThreadPool-OOM问题"><a href="#1-4-2-newCachedThreadPool-OOM问题" class="headerlink" title="1.4.2 newCachedThreadPool OOM问题"></a>1.4.2 newCachedThreadPool OOM问题</h3><pre><code>public static ExecutorService newCachedThreadPool() {    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,                                  60L, TimeUnit.SECONDS,                                  new SynchronousQueue&lt;Runnable&gt;());</code></pre><ul><li>线程池最大线程数为Integer.MAX_VALUE，是没有上限的，其工作队列SynchronizedQueue是一个没有存储空间的阻塞队列。</li><li>SynchronousQueue是没有存储空间的阻塞队列，有请求到来的时候，必须要找到一条工作线程来处理，如果当前没有空闲的线程就再创建一条新的</li></ul><h3 id="1-4-3-线程池配置Best-Practice"><a href="#1-4-3-线程池配置Best-Practice" class="headerlink" title="1.4.3 线程池配置Best Practice"></a>1.4.3 线程池配置Best Practice</h3><ul><li><p>根据自己的场景，并发情况来评估线程池的几个核心参数，需要设置有界的工作队列和可控的线程数</p><ul><li>核心线程数</li><li>最大线程数</li><li>线程回收策略</li><li>工作队列的类型</li><li>拒绝策略</li></ul></li><li><p>为线程池指定有意义的名称，来方便问题的排查，当出现线程数暴增，线程死锁，线程占用大量CPU这类问题的时候，会抓取线程栈来进行分析，这个时候有意义的线程名称，可以很大程度上方便我们对问题的定位</p></li><li><p>Metrics， alarm来观察线程池的状态</p></li></ul><ul><li>线程池特性<ul><li>不会初始化corePoolSize个线程，有任务来了才创建工作线程</li><li>当核心线程满了之后不会立即扩容线程池，而是把任务堆积到工作队列当中</li><li>当工作队列满了之后扩容线程池，一直到线程个数达到maximumPoolSize为止</li><li>如果队列已满其达到了最大线程后还有任务来，就按照拒绝策略来处理</li><li>当线程数大于核心线程数时，线程等待KeepAliveTime后还没有任务需要处理的话，收缩线程到核心线程数</li></ul></li></ul><pre><code>@GetMapping(&quot;right&quot;)public int right() throws InterruptedException {    //使用一个计数器跟踪完成的任务数    AtomicInteger atomicInteger = new AtomicInteger();    //创建一个具有2个核心线程、5个最大线程，使用容量为10的ArrayBlockingQueue阻塞队列作为工作队列的线程池，使用默认的AbortPolicy拒绝策略    ThreadPoolExecutor threadPool = new ThreadPoolExecutor(            2, 5,            5, TimeUnit.SECONDS,            new ArrayBlockingQueue&lt;&gt;(10),            new ThreadFactoryBuilder().setNameFormat(&quot;demo-threadpool-%d&quot;).get(),            new ThreadPoolExecutor.AbortPolicy());    printStats(threadPool);    //每隔1秒提交一次，一共提交20次任务    IntStream.rangeClosed(1, 20).forEach(i -&gt; {        try {            TimeUnit.SECONDS.sleep(1);        } catch (InterruptedException e) {            e.printStackTrace();        }        int id = atomicInteger.incrementAndGet();        try {            threadPool.submit(() -&gt; {                log.info(&quot;{} started&quot;, id);                //每个任务耗时10秒                try {                    TimeUnit.SECONDS.sleep(10);                } catch (InterruptedException e) {                }                log.info(&quot;{} finished&quot;, id);            });        } catch (Exception ex) {            //提交出现异常的话，打印出错信息并为计数器减一            log.error(&quot;error submitting task {}&quot;, id, ex);            atomicInteger.decrementAndGet();        }    });    TimeUnit.SECONDS.sleep(60);    return atomicInteger.intValue();}</code></pre><h3 id="1-4-4-线程池本身不复用"><a href="#1-4-4-线程池本身不复用" class="headerlink" title="1.4.4 线程池本身不复用"></a>1.4.4 线程池本身不复用</h3><pre><code>@GetMapping(&quot;wrong&quot;)public String wrong() throws InterruptedException {    ThreadPoolExecutor threadPool = ThreadPoolHelper.getThreadPool();    IntStream.rangeClosed(1, 10).forEach(i -&gt; {        threadPool.execute(() -&gt; {            ...            try {                TimeUnit.SECONDS.sleep(1);            } catch (InterruptedException e) {            }        });    });    return &quot;OK&quot;;}class ThreadPoolHelper {    public static ThreadPoolExecutor getThreadPool() {        //线程池没有复用        return (ThreadPoolExecutor) Executors.newCachedThreadPool();    }}</code></pre><p>通过这种方式，会不停产生新的线程，整个业务程序会不停产生新的threadPool，因为newCachedThreadPool的核心线程数是0， keepAliveTime是60秒，过了60s以后线程就会被回收了。</p><h3 id="1-4-5-线程池的使用策略"><a href="#1-4-5-线程池的使用策略" class="headerlink" title="1.4.5 线程池的使用策略"></a>1.4.5 线程池的使用策略</h3><ul><li>对于线程池如何使用，放什么样的任务进去，是需要根据任务的轻重缓急来指定线程池的核心参数，包括线程数，回收策略和任务队列<ul><li>对于执行比较慢，数量不大的IO任务，可以考虑更多的线程数，而不需要太大的队列</li><li>对于吞吐量比较大的计算型任务，线程数量不应该过多，可以是CPU核心数，或者核心数 x 2。<ul><li>因为线程是需要调度到某个CPU当中进行的，如果任务本身是CPU绑定的任务，那么过多的线程只会增加线程切换的开销，并不能提升吞吐量</li><li>需要比较长的队列来做缓冲</li></ul></li></ul></li></ul><h1 id="2-连接池"><a href="#2-连接池" class="headerlink" title="2. 连接池"></a>2. 连接池</h1><h2 id="2-1-连接池定义"><a href="#2-1-连接池定义" class="headerlink" title="2.1 连接池定义"></a>2.1 连接池定义</h2><ul><li>对外提供获得连接</li><li>归还连接的接口给客户端使用</li><li>暴露最小空闲连接数，最大连接数等可配置参数</li><li>内部实现连接建立，连接心跳保持，连接管理，空闲连接回收，连接可用性检测等功能</li></ul><p><img src="https://i.loli.net/2020/08/21/8qialtrxJoB2MNF.png" alt="连接池.png"></p><ul><li>应用场景<ul><li>数据库连接池</li><li>Redis连接池</li><li>HTTP连接池</li></ul></li></ul><h2 id="2-2-应用场景"><a href="#2-2-应用场景" class="headerlink" title="2.2 应用场景"></a>2.2 应用场景</h2><h3 id="2-2-1-判断客户端SDK是否基于连接池"><a href="#2-2-1-判断客户端SDK是否基于连接池" class="headerlink" title="2.2.1 判断客户端SDK是否基于连接池"></a>2.2.1 判断客户端SDK是否基于连接池</h3><ul><li><p>使用第三方客户端进行网络通信的时候，需要确定客户端SDK是否是基于连接池技术实现的</p><ul><li><p>TCP是面向连接的基于字节流的协议</p><ul><li><p>面向连接</p><ul><li>连接需要先创建，需要先做三次握手，是有开销的</li></ul></li><li><p>基于字节流</p><ul><li>字节是发送数据的最小单元</li><li>TCP是数据读写的通道，本身不知道哪些是完整的消息体，也不知道是否有多个客户端在使用同一个TCP连接</li></ul></li></ul></li></ul></li><li><p>客户端SDK对外提供API的方式</p><ul><li>连接池和连接分离的 API：有一个 XXXPool 类负责连接池实现，先从其获得连接 XXXConnection，然后用获得的连接进行服务端请求，完成后使用者需要归还连接。通常，XXXPool 是线程安全的，可以并发获取和归还连接，而 XXXConnection 是非线程安全的。对应到连接池的结构示意图中，XXXPool 就是右边连接池那个框，左边的客户端是我们自己的代码</li><li>内部带有连接池的 API：对外提供一个 XXXClient 类，通过这个类可以直接进行服务端请求；这个类内部维护了连接池，SDK 使用者无需考虑连接的获取和归还问题。一般而言，XXXClient 是线程安全的。对应到连接池的结构示意图中，整个 API 就是蓝色框包裹的部分</li><li>非连接池的 API：一般命名为 XXXConnection，以区分其是基于连接池还是单连接的，而不建议命名为 XXXClient 或直接是 XXX。直接连接方式的 API 基于单一连接，每次使用都需要创建和断开连接，性能一般，且通常不是线程安全的。对应到连接池的结构示意图中，这种形式相当于没有右边连接池那个框，客户端直接连接服务端创建连接</li></ul></li></ul><h3 id="2-2-2-复用连接池"><a href="#2-2-2-复用连接池" class="headerlink" title="2.2.2 复用连接池"></a>2.2.2 复用连接池</h3><ul><li>创建连接池的时候很可能一次性创建了多个连接，大多数连接池考虑到性能，会在初始化的时候维护一定数量的最小连接（毕竟初始化连接池的过程一般是一次性的），可以直接使用。如果每次使用连接池都按需创建连接池，那么很可能你只用到一个连接，但是创建了 N 个连接</li><li>连接池有管理模块，会有闲置超时，定时来回收闲置的连接，将活跃连接数降到最低连接的配置值，以此减轻服务端的压力</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-并发&quot;&gt;&lt;a href=&quot;#1-并发&quot; class=&quot;headerlink&quot; title=&quot;1. 并发&quot;&gt;&lt;/a&gt;1. 并发&lt;/h1&gt;&lt;h2 id=&quot;1-1-ThreadLocal复用问题&quot;&gt;&lt;a href=&quot;#1-1-ThreadLocal复用问题&quot; cla
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-行为型-备忘录模式</title>
    <link href="https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-07-30T04:06:40.000Z</published>
    <updated>2020-07-30T04:07:06.831Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-备忘录模式的原理与实现"><a href="#1-备忘录模式的原理与实现" class="headerlink" title="1. 备忘录模式的原理与实现"></a>1. 备忘录模式的原理与实现</h1><ul><li>snapshot模式 <ul><li>Memento Design Pattern </li><li>Captures and externalizes an object’s internal state so that it can be restored later, all without violating encapsulation </li><li>在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便之后恢复对象先前的状态。<ul><li>存储副本以便后期恢复</li><li>在不违背封装原则的前提下，进行对象的备份和恢复</li></ul></li></ul></li></ul><pre><code>    public class InputText {      private StringBuilder text = new StringBuilder();      public String getText() {        return text.toString();      }      public void append(String input) {        text.append(input);      }      public Snapshot createSnapshot() {        return new Snapshot(text.toString());      }      public void restoreSnapshot(Snapshot snapshot) {        this.text.replace(0, this.text.length(), snapshot.getText());      }    }    public class Snapshot {      private String text;      public Snapshot(String text) {        this.text = text;      }      public String getText() {        return this.text;      }    }    public class SnapshotHolder {      private Stack&lt;Snapshot&gt; snapshots = new Stack&lt;&gt;();      public Snapshot popSnapshot() {        return snapshots.pop();      }      public void pushSnapshot(Snapshot snapshot) {        snapshots.push(snapshot);      }    }    public class ApplicationMain {      public static void main(String[] args) {        InputText inputText = new InputText();        SnapshotHolder snapshotsHolder = new SnapshotHolder();        Scanner scanner = new Scanner(System.in);        while (scanner.hasNext()) {          String input = scanner.next();          if (input.equals(&quot;:list&quot;)) {            System.out.println(inputText.toString());          } else if (input.equals(&quot;:undo&quot;)) {            Snapshot snapshot = snapshotsHolder.popSnapshot();            inputText.restoreSnapshot(snapshot);          } else {            snapshotsHolder.pushSnapshot(inputText.createSnapshot());            inputText.append(input);          }        }      }    }</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-备忘录模式的原理与实现&quot;&gt;&lt;a href=&quot;#1-备忘录模式的原理与实现&quot; class=&quot;headerlink&quot; title=&quot;1. 备忘录模式的原理与实现&quot;&gt;&lt;/a&gt;1. 备忘录模式的原理与实现&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;snapshot模式 &lt;ul&gt;
&lt;l
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="备忘录模式" scheme="https://www.llchen60.com/tags/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>《目标：简单而有效的常识管理》</title>
    <link href="https://www.llchen60.com/%E3%80%8A%E7%9B%AE%E6%A0%87%EF%BC%9A%E7%AE%80%E5%8D%95%E8%80%8C%E6%9C%89%E6%95%88%E7%9A%84%E5%B8%B8%E8%AF%86%E7%AE%A1%E7%90%86%E3%80%8B/"/>
    <id>https://www.llchen60.com/%E3%80%8A%E7%9B%AE%E6%A0%87%EF%BC%9A%E7%AE%80%E5%8D%95%E8%80%8C%E6%9C%89%E6%95%88%E7%9A%84%E5%B8%B8%E8%AF%86%E7%AE%A1%E7%90%86%E3%80%8B/</id>
    <published>2020-07-27T00:51:12.000Z</published>
    <updated>2020-08-01T04:04:04.970Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-企业问题的着手点"><a href="#1-企业问题的着手点" class="headerlink" title="1. 企业问题的着手点"></a>1. 企业问题的着手点</h1><ul><li><p>着眼于每个环节的改善 vs 从系统视角着手</p></li><li><p>系统</p><ul><li>首先要掌握和妥善处理这个系统内各个环节间的互动关系</li><li>TOC – 希望能够指导企业如何集中利用有限资源，将其用在整个系统中最重要的地方，来达到最大的效益。</li></ul></li><li><p>现状</p><ul><li>企业势必会遇到无数问题<ul><li>而这些问题往往会使得管理人员废寝忘食，疲于奔命</li><li>需要去寻找在这些问题背后，是受到什么东西支配着的，有没有什么规律法则和秩序可以遵循</li></ul></li></ul></li></ul><h1 id="2-TOC"><a href="#2-TOC" class="headerlink" title="2. TOC"></a>2. TOC</h1><h2 id="2-1-目标是什么？"><a href="#2-1-目标是什么？" class="headerlink" title="2.1 目标是什么？"></a>2.1 目标是什么？</h2><ul><li><p>赚钱 目标</p><ul><li><p>本质就是赚钱 – 下述的是具体的方法</p><ul><li>采购发挥成本效益</li><li>雇佣好的人才</li><li>高科技，生产有品质的产品</li><li>销售有品质的产品</li><li>争取市场占有率</li><li>良好的沟通，顾客满意度</li></ul></li><li><p>关注指标</p><ul><li>利润</li><li>投资回报率</li><li>现金流量</li></ul></li><li><p>将实际运作状况和关注的各个指标再连接起来，如何做连接呢？？？？？？？？？？  – 用你建立的指标来表达你的目标</p><ul><li>有效产出 throughput<ul><li>系统通过销售获取金钱的速度</li></ul></li><li>存货 inventory<ul><li>整个系统投资在采购上的钱</li><li>采购的是打算卖出去的东西</li><li>可以借销售回收的投资都算是存货</li></ul></li><li>营运费用  operationalExpense<ul><li>系统为了把存货转为有效产出而花的钱 </li></ul></li></ul></li></ul></li></ul><h2 id="2-2-如何达成目标"><a href="#2-2-如何达成目标" class="headerlink" title="2.2 如何达成目标"></a>2.2 如何达成目标</h2><ul><li><p>一些列详尽的指标</p><ul><li>在改善一个指标的时候，要思考对其他指标的影响</li><li>单纯面向一个指标的改善可能对整个企业的改善并不是最有利的</li></ul></li><li><p>依存关系</p><ul><li>在一条链上，越到下游受影响越大，牛鞭效应，因为上游不确定太大，平均时间无法说明每天的实际状况</li><li>下游只能追上上游的速度，而不能超过上游的速度，因此不会是各种不同速度的相互抵消平均，而会是统计波动的累积</li><li>有效产出要看的是最终端的产出，即要看的是整体生产环节这个角度上的生产效率</li><li>优先解决瓶颈！ </li></ul></li><li><p>统计波动</p><ul><li>生产率的波动</li><li>生产线最后部分的产能应该比开始的时候高，需要能够处理更大的波动</li></ul></li><li><p>区分资源</p><ul><li><p>瓶颈资源</p><ul><li>产能等于或少于其需求</li><li>当出现瓶颈的时候，其成本已不能按照单环节的成本来计算了，相反的，他直接影响了产品的产出，所以要从全局成本的角度来进行考虑。</li><li>制定优先级，严格按照优先级顺序来执行</li></ul></li><li><p>非瓶颈资源</p><ul><li>产能大于需求</li></ul></li><li><p>需要在产品在工厂当中的流量和市场需求之间获取平衡</p></li></ul></li></ul><h2 id="2-3-Under-the-hood"><a href="#2-3-Under-the-hood" class="headerlink" title="2.3 Under the hood"></a>2.3 Under the hood</h2><p>一群人如何试图了解世界运转的窍门，并且因此改善周遭的一切。</p><p>科学代表着的是我们对于这个世界如何运作，以及为何如此运作的理解。但是他也只代表着我们现在所知的。</p><p>没有绝对的真理，绝对的真理反而会阻碍我们追求更深入的理解。</p><h2 id="2-4-制约理论"><a href="#2-4-制约理论" class="headerlink" title="2.4 制约理论"></a>2.4 制约理论</h2><ul><li><p>任何系统都至少存在着一个制约因素 – 瓶颈，否则它就可能有无限的产出。</p></li><li><p>核心步骤</p><ul><li><p>寻找约束</p><ul><li>确定生产速度和需求速度</li></ul></li><li><p>利用约束</p><ul><li>最大限度开发利用瓶颈工序，使得瓶颈工序产出量最大化</li></ul></li><li><p>服从约束</p><ul><li>使得企业的所有其他活动服从关于约束的各种措施，确保企业的所有活动，都是基于最大化利用瓶颈工序而展开的</li></ul></li><li><p>打破约束</p><ul><li>如果无法有效提高瓶颈工序的利用率，就需要采取其他方法来打破约束</li></ul></li><li><p>寻找新的约束</p><ul><li>重新寻找新的约束，重新解决问题</li></ul></li></ul></li></ul><h1 id="3-案例分析"><a href="#3-案例分析" class="headerlink" title="3. 案例分析"></a>3. 案例分析</h1><h2 id="3-1-现状分析"><a href="#3-1-现状分析" class="headerlink" title="3.1 现状分析"></a>3.1 现状分析</h2><ul><li><p>工厂</p><ul><li><p>技术，机器齐备</p></li><li><p>员工</p><ul><li>优质</li><li>技术实力过硬</li></ul></li><li><p>良好的工会关系</p></li><li><p>问题</p><ul><li>无法按时交付</li></ul></li></ul></li><li><p>当你升级机器了以后，真的能够提升效率么？ </p><ul><li><p>宣传当中，升级了机器，效率会提高，即单位时间生产速度会得到提升</p></li><li><p>问题在于</p><ul><li>会解雇人么？ 即生产成本得到降低了么？</li><li>出货数量有提升么？ </li><li>中间生产物的堆积量以及平均存储时间怎么样呢？ </li></ul></li><li><p>回到上述问题，首先要做的是对生产力给一个更合理的定义</p><ul><li>怎么样才算有生产力？ <ul><li>工作上的输出</li><li>通过目标来量化自己的生产力</li><li>能更接近目标的行动才是有生产力的行动</li><li>所以要问的是你的目标到底是什么</li></ul></li></ul></li></ul></li><li><p>窘境</p><ul><li>将人在做事和能带来效益等价</li><li>通过调动人员来保证有事可做？ </li><li>看到的各种数据报表当中的数据真的能够反映出赚钱能力么？ <ul><li>做满工作时数？ </li><li>产品成本？</li><li>直接人工差异？ </li></ul></li></ul></li></ul><h2 id="3-2-策略"><a href="#3-2-策略" class="headerlink" title="3.2 策略"></a>3.2 策略</h2><ul><li><p>thought 1: 通过改变各个环节的在供应链当中的顺序，尝试缓解依存关系； 尝试通过增加机器，缓解某个缓解的瓶颈</p><ul><li>投入成本高</li><li>时间长</li><li>既定工序难以改变</li></ul></li><li><p>thought 2：识别出瓶颈之后，分析瓶颈处机器的时间利用</p><ul><li>人需要按照工会要求每4小时休息30min，但是机器需要尽可能运转</li><li>质检不应该只放在成品前，在瓶颈前就进行检查，确保瓶颈处加工的产品在那个时刻是合格的，相当于省了加工坏损品的时间 </li></ul></li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://zhuanlan.zhihu.com/p/51536566" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/51536566</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-企业问题的着手点&quot;&gt;&lt;a href=&quot;#1-企业问题的着手点&quot; class=&quot;headerlink&quot; title=&quot;1. 企业问题的着手点&quot;&gt;&lt;/a&gt;1. 企业问题的着手点&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;着眼于每个环节的改善 vs 从系统视角着手&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="Notes" scheme="https://www.llchen60.com/categories/Notes/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式-行为型-迭代器模式</title>
    <link href="https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-07-24T06:30:04.000Z</published>
    <updated>2020-07-28T02:36:45.600Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-迭代器模式的原理和实现"><a href="#1-迭代器模式的原理和实现" class="headerlink" title="1. 迭代器模式的原理和实现"></a>1. 迭代器模式的原理和实现</h1><ul><li>迭代器模式<ul><li>Iterator Design Pattern / Cursor Design Patten </li><li>用来遍历集合对象</li><li>编程语言基本上都将迭代器作为一个基础类库来提供了</li><li>集合对象指的是一个容器，而迭代器需要迭代的对象实际上是一组对象的对象</li><li>迭代器模式将集合对象的遍历操作从集合类当中拆分出来，放到迭代器类当中，使得二者的职责更加单一</li></ul></li></ul><ul><li>涉及部分<ul><li>容器<ul><li>接口</li><li>实现类</li></ul></li><li>容器迭代器<ul><li>接口</li><li>实现类</li></ul></li></ul></li></ul><h2 id="1-1-实现一个线性结构容器的迭代器"><a href="#1-1-实现一个线性结构容器的迭代器" class="headerlink" title="1.1 实现一个线性结构容器的迭代器"></a>1.1 实现一个线性结构容器的迭代器</h2><pre><code>// 接口定义方式一public interface Iterator&lt;E&gt; {  boolean hasNext();  void next();  E currentItem();}// 接口定义方式二public interface Iterator&lt;E&gt; {  boolean hasNext();  E next();}</code></pre><ul><li>定义方式一的好处在可以多次获得当前的对象，会更加灵活</li></ul><pre><code>public class ArrayIterator&lt;E&gt; implements Iterator&lt;E&gt; {  private int cursor;  private ArrayList&lt;E&gt; arrayList;  public ArrayIterator(ArrayList&lt;E&gt; arrayList) {    this.cursor = 0;    this.arrayList = arrayList;  }  @Override  public boolean hasNext() {    return cursor != arrayList.size(); //注意这里，cursor在指向最后一个元素的时候，hasNext()仍旧返回true。  }  @Override  public void next() {    cursor++;  }  @Override  public E currentItem() {    if (cursor &gt;= arrayList.size()) {      throw new NoSuchElementException();    }    return arrayList.get(cursor);  }}public class Demo {  public static void main(String[] args) {    ArrayList&lt;String&gt; names = new ArrayList&lt;&gt;();    names.add(&quot;xzg&quot;);    names.add(&quot;wang&quot;);    names.add(&quot;zheng&quot;);    Iterator&lt;String&gt; iterator = new ArrayIterator(names);    while (iterator.hasNext()) {      System.out.println(iterator.currentItem());      iterator.next();    }  }}</code></pre><ul><li>这里一个问题是还需要<code>new ArrayIterator()</code>，我们可以通过在List的接口当中定义迭代器，然后再ArrayList的类当中定义一个iterator()方法。然后在使用的时候，我们就可以通过实例化以后的容器，比如ArrayList，直接来调用iterator()方法了</li></ul><pre><code>public interface List&lt;E&gt; {  Iterator iterator();  //...省略其他接口函数...}public class ArrayList&lt;E&gt; implements List&lt;E&gt; {  //...  public Iterator iterator() {    return new ArrayIterator(this);  }  //...省略其他代码}public class Demo {  public static void main(String[] args) {    List&lt;String&gt; names = new ArrayList&lt;&gt;();    names.add(&quot;xzg&quot;);    names.add(&quot;wang&quot;);    names.add(&quot;zheng&quot;);    Iterator&lt;String&gt; iterator = names.iterator();    while (iterator.hasNext()) {      System.out.println(iterator.currentItem());      iterator.next();    }  }}</code></pre><ul><li><p>实现方式/ 设计思路</p><ul><li><p>迭代器当中实现</p><ul><li>hasNext()</li><li>currentItem()</li><li>next()</li></ul></li><li><p>待遍历的容器</p><ul><li>通过依赖注入传递到迭代器当中</li><li>容器通过iterator()方法来创建迭代器</li></ul></li></ul></li></ul><h2 id="1-2-为什么需要迭代器模式来遍历集合？"><a href="#1-2-为什么需要迭代器模式来遍历集合？" class="headerlink" title="1.2 为什么需要迭代器模式来遍历集合？"></a>1.2 为什么需要迭代器模式来遍历集合？</h2><ol><li>复杂数据结构遍历方式也会非常复杂，比如对于树，对于图来说。我们将遍历的方式定义到迭代器当中，这样就避免了要自己实现这样复杂的操作了。</li><li>通过迭代器模式，可以同时创建多个不同的迭代器，对同一个容器进行遍历而不互相影响</li><li>容器和迭代器都提供了抽象的接口，当我们需要改变遍历算法的时候，对代码的影响会很小，只在依赖注入处使用新的迭代器类所提供的算法即可</li></ol><h2 id="1-3-遍历时的增删"><a href="#1-3-遍历时的增删" class="headerlink" title="1.3 遍历时的增删"></a>1.3 遍历时的增删</h2><p>遍历时进行增删很大的一个问题是数组在做了增删以后，其他元素的位置会随之改变的。这样就会出现在迭代器当中有些元素无法迭代到的问题了</p><p>遍历时增删是会产生不可预期的遍历错误的，可以通过对遍历时候增删元素的限制来解决这个问题</p><ul><li>遍历的时候不允许增删元素<ul><li>比较难以实现</li></ul></li><li>增删元素之后让遍历报错<ul><li>在ArrayList当中定义一个成员变量modCount<ul><li>记录集合被修改的次数</li><li>集合每调用一次增加或删除元素的函数，就会加1 </li><li>当调用集合上的iterator()函数创建迭代器的时候，将modCount值传递给迭代器的expectedModCount成员变量</li><li>然后在每次调用迭代器上的函数的时候，都会检查一下modCount是否改变过</li></ul></li></ul></li></ul><pre><code>public class ArrayIterator implements Iterator {  private int cursor;  private ArrayList arrayList;  private int expectedModCount;  public ArrayIterator(ArrayList arrayList) {    this.cursor = 0;    this.arrayList = arrayList;    this.expectedModCount = arrayList.modCount;  }  @Override  public boolean hasNext() {    checkForComodification();    return cursor &lt; arrayList.size();  }  @Override  public void next() {    checkForComodification();    cursor++;  }  @Override  public Object currentItem() {    checkForComodification();    return arrayList.get(cursor);  }  private void checkForComodification() {    if (arrayList.modCount != expectedModCount)        throw new ConcurrentModificationException();  }}//代码示例public class Demo {  public static void main(String[] args) {    List&lt;String&gt; names = new ArrayList&lt;&gt;();    names.add(&quot;a&quot;);    names.add(&quot;b&quot;);    names.add(&quot;c&quot;);    names.add(&quot;d&quot;);    Iterator&lt;String&gt; iterator = names.iterator();    iterator.next();    names.remove(&quot;a&quot;);    iterator.next();//抛出ConcurrentModificationException异常  }}</code></pre><h1 id="2-实现支持快照功能的iterator"><a href="#2-实现支持快照功能的iterator" class="headerlink" title="2. 实现支持快照功能的iterator"></a>2. 实现支持快照功能的iterator</h1><ul><li>快照<ul><li>为容器创建迭代器的时候，给容器拍的快照</li><li>使得即便我们之后增删容器中的元素，快照中的元素并不会做相应的变动</li><li>这样迭代器使用的对象是快照，而不是容器，这样就避免了在使用迭代器遍历的过程中，因为增删容器中的元素而导致的不可预期的结果或报错。</li></ul></li></ul><ul><li>可以在迭代器类当中定义一个成员变量snapshot来存储快照<ul><li>每当迭代器需要被创建的时候，都拷贝一份容器中的元素到快照当中，后续的遍历操作都基于这个迭代器自己持有的快照来进行</li><li>问题<ul><li>代价高，每次创建迭代器的时候，都要拷贝一份数据到快照当中，会增加内存的消耗</li></ul></li></ul></li></ul><pre><code>public class SnapshotArrayIterator&lt;E&gt; implements Iterator&lt;E&gt; {  private int cursor;  private ArrayList&lt;E&gt; snapshot;  public SnapshotArrayIterator(ArrayList&lt;E&gt; arrayList) {    this.cursor = 0;    this.snapshot = new ArrayList&lt;&gt;();    this.snapshot.addAll(arrayList);  }  @Override  public boolean hasNext() {    return cursor &lt; snapshot.size();  }  @Override  public E next() {    E currentItem = snapshot.get(cursor);    cursor++;    return currentItem;  }}</code></pre><ul><li>可以在容器当中为每个元素保存两个时间戳<ul><li>addTimestamp</li><li>delTimestamp</li><li>当元素被加入到集合当中的时候，addTimestamp设置为当前时间，将delTimestamp设置成最大长整形值。当元素被删除时，将delTimestamp更新为当前时间，表示已经被删除</li><li>每个迭代器也保存一个迭代器创建时间戳 snapshotTimestamp<ul><li>只有满足addTimestamp &lt; snapshotTimestamp &lt; delTimestamp，才是属于这个迭代器的快照</li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-迭代器模式的原理和实现&quot;&gt;&lt;a href=&quot;#1-迭代器模式的原理和实现&quot; class=&quot;headerlink&quot; title=&quot;1. 迭代器模式的原理和实现&quot;&gt;&lt;/a&gt;1. 迭代器模式的原理和实现&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;迭代器模式&lt;ul&gt;
&lt;li&gt;Iter
      
    
    </summary>
    
    
      <category term="SystenDesign" scheme="https://www.llchen60.com/categories/SystenDesign/"/>
    
    
      <category term="迭代器模式" scheme="https://www.llchen60.com/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-行为型-状态模式</title>
    <link href="https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-07-21T05:14:07.000Z</published>
    <updated>2020-07-21T05:14:46.840Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-原理与实现"><a href="#1-原理与实现" class="headerlink" title="1. 原理与实现"></a>1. 原理与实现</h1><p>状态模式一般用来实现状态机，常常用在游戏，工作流引擎等系统开发当中。</p><p>做法是将状态，事件，以及动作都放置到不同的类当中，通过接口与继承，来实现各个方法，其中共享变量可以作为输入传入。 </p><h1 id="2-以有限状态机的实现为例"><a href="#2-以有限状态机的实现为例" class="headerlink" title="2. 以有限状态机的实现为例"></a>2. 以有限状态机的实现为例</h1><ul><li>有限状态机<ul><li>Finite State Machine</li><li>组成部分<ul><li>状态</li><li>事件/ 转移条件<ul><li>触发状态的转移</li><li>动作的执行</li></ul></li><li>动作</li></ul></li></ul></li></ul><p>以下面的状态转移图为例： </p><p><img src="https://i.loli.net/2020/07/21/jzSQHTRxkybDBYE.png" alt="状态转移图"></p><h2 id="2-1-分支逻辑法实现"><a href="#2-1-分支逻辑法实现" class="headerlink" title="2.1 分支逻辑法实现"></a>2.1 分支逻辑法实现</h2><p>会包含大量的if-else语句</p><pre><code>public class MarioStateMachine {  private int score;  private State currentState;  public MarioStateMachine() {    this.score = 0;    this.currentState = State.SMALL;  }  public void obtainMushRoom() {    if (currentState.equals(State.SMALL)) {      this.currentState = State.SUPER;      this.score += 100;    }  }  public void obtainCape() {    if (currentState.equals(State.SMALL) || currentState.equals(State.SUPER) ) {      this.currentState = State.CAPE;      this.score += 200;    }  }  public void obtainFireFlower() {    if (currentState.equals(State.SMALL) || currentState.equals(State.SUPER) ) {      this.currentState = State.FIRE;      this.score += 300;    }  }  public void meetMonster() {    if (currentState.equals(State.SUPER)) {      this.currentState = State.SMALL;      this.score -= 100;      return;    }    if (currentState.equals(State.CAPE)) {      this.currentState = State.SMALL;      this.score -= 200;      return;    }    if (currentState.equals(State.FIRE)) {      this.currentState = State.SMALL;      this.score -= 300;      return;    }  }  public int getScore() {    return this.score;  }  public State getCurrentState() {    return this.currentState;  }}</code></pre><h2 id="2-2-查表法"><a href="#2-2-查表法" class="headerlink" title="2.2 查表法"></a>2.2 查表法</h2><p><img src="https://i.loli.net/2020/07/21/127jeqv5CwsIWKP.png" alt="查表法.png"></p><p>使用一张二维表来表示状态机，纵向表示当前状态，横向表示事件，值表示当前状态经过事件以后，转移到的新状态和其执行的动作</p><pre><code>public enum Event {  GOT_MUSHROOM(0),  GOT_CAPE(1),  GOT_FIRE(2),  MET_MONSTER(3);  private int value;  private Event(int value) {    this.value = value;  }  public int getValue() {    return this.value;  }}public class MarioStateMachine {  private int score;  private State currentState;  private static final State[][] transitionTable = {          {SUPER, CAPE, FIRE, SMALL},          {SUPER, CAPE, FIRE, SMALL},          {CAPE, CAPE, CAPE, SMALL},          {FIRE, FIRE, FIRE, SMALL}  };  private static final int[][] actionTable = {          {+100, +200, +300, +0},          {+0, +200, +300, -100},          {+0, +0, +0, -200},          {+0, +0, +0, -300}  };  public MarioStateMachine() {    this.score = 0;    this.currentState = State.SMALL;  }  public void obtainMushRoom() {    executeEvent(Event.GOT_MUSHROOM);  }  public void obtainCape() {    executeEvent(Event.GOT_CAPE);  }  public void obtainFireFlower() {    executeEvent(Event.GOT_FIRE);  }  public void meetMonster() {    executeEvent(Event.MET_MONSTER);  }  private void executeEvent(Event event) {    int stateValue = currentState.getValue();    int eventValue = event.getValue();    this.currentState = transitionTable[stateValue][eventValue];    this.score = actionTable[stateValue][eventValue];  }  public int getScore() {    return this.score;  }  public State getCurrentState() {    return this.currentState;  }}</code></pre><h2 id="2-3-状态模式"><a href="#2-3-状态模式" class="headerlink" title="2.3 状态模式"></a>2.3 状态模式</h2><p>当要执行的动作是比较复杂的一系列逻辑操作的时候，我们就无法使用二维数组来表示了。状态模式是将事件触发的状态转移和动作执行来拆分到不同的状态类当中，来避免分支判断逻辑。</p><pre><code>public interface IMario {  State getName();  void obtainMushRoom(MarioStateMachine stateMachine);  void obtainCape(MarioStateMachine stateMachine);  void obtainFireFlower(MarioStateMachine stateMachine);  void meetMonster(MarioStateMachine stateMachine);}public class SmallMario implements IMario {  private static final SmallMario instance = new SmallMario();  private SmallMario() {}  public static SmallMario getInstance() {    return instance;  }  @Override  public State getName() {    return State.SMALL;  }  @Override  public void obtainMushRoom(MarioStateMachine stateMachine) {    stateMachine.setCurrentState(SuperMario.getInstance());    stateMachine.setScore(stateMachine.getScore() + 100);  }  @Override  public void obtainCape(MarioStateMachine stateMachine) {    stateMachine.setCurrentState(CapeMario.getInstance());    stateMachine.setScore(stateMachine.getScore() + 200);  }  @Override  public void obtainFireFlower(MarioStateMachine stateMachine) {    stateMachine.setCurrentState(FireMario.getInstance());    stateMachine.setScore(stateMachine.getScore() + 300);  }  @Override  public void meetMonster(MarioStateMachine stateMachine) {    // do nothing...  }}// 省略SuperMario、CapeMario、FireMario类...public class MarioStateMachine {  private int score;  private IMario currentState;  public MarioStateMachine() {    this.score = 0;    this.currentState = SmallMario.getInstance();  }  public void obtainMushRoom() {    this.currentState.obtainMushRoom(this);  }  public void obtainCape() {    this.currentState.obtainCape(this);  }  public void obtainFireFlower() {    this.currentState.obtainFireFlower(this);  }  public void meetMonster() {    this.currentState.meetMonster(this);  }  public int getScore() {    return this.score;  }  public State getCurrentState() {    return this.currentState.getName();  }  public void setScore(int score) {    this.score = score;  }  public void setCurrentState(IMario currentState) {    this.currentState = currentState;  }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-原理与实现&quot;&gt;&lt;a href=&quot;#1-原理与实现&quot; class=&quot;headerlink&quot; title=&quot;1. 原理与实现&quot;&gt;&lt;/a&gt;1. 原理与实现&lt;/h1&gt;&lt;p&gt;状态模式一般用来实现状态机，常常用在游戏，工作流引擎等系统开发当中。&lt;/p&gt;
&lt;p&gt;做法是将状态
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="状态模式" scheme="https://www.llchen60.com/tags/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-行为型-职责链模式</title>
    <link href="https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-07-12T01:22:10.000Z</published>
    <updated>2020-07-16T04:33:00.386Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-原理与实现"><a href="#1-原理与实现" class="headerlink" title="1. 原理与实现"></a>1. 原理与实现</h1><ul><li>职责链模式<ul><li>Chian of Responsibility Design Pattern </li><li>Avoid coupling the sender of a request to its receiver by giving more than one object a chance to hadle the request. Chain the receiving objects and pass the request along the chain until an object handles it. </li><li>将请求的发送和接收解耦，让多个接收对象都有机会处理这个请求。将这些接收对象串成一条链，并沿着这条链传递这个请求，直到链上的某个接收对象能够处理它为止</li><li>在职责链模式当中，多个处理器依次处理同一个请求，一个请求先经过A处理器处理，再把请求传递给B处理器，B处理器处理完以后再传递给C处理器。各个处理器之间形成了一个链条，链条上的每个处理器各自承担各自的处理职责，所以叫做职责链模式。</li></ul></li></ul><h2 id="1-1-使用链表实现HandlerChain"><a href="#1-1-使用链表实现HandlerChain" class="headerlink" title="1.1 使用链表实现HandlerChain"></a>1.1 使用链表实现HandlerChain</h2><ul><li>Handler是所有处理器的抽象父类</li><li>handle()是抽象方法</li><li>每个具体的处理器类的handle()函数结构会比较类似，如果能处理请求，则进行处理；如果不能，则交由后面的处理器来进行处理</li><li>HandlerChain是处理器链，从数据结构来看，是一个记录了链头、链尾的链表。</li></ul><p>public abstract class Handler {<br>  protected Handler successor = null;</p><p>  public void setSuccessor(Handler successor) {<br>    this.successor = successor;<br>  }</p><p>  public final void handle() {<br>    boolean handled = doHandle();</p><pre><code>if (successor != null &amp;&amp; !handled) {    successor.handle();}</code></pre><p>  }<br>  public abstract boolean doHandle();<br>}</p><p>public class HandlerA extends Handler {<br>  @Override<br>  public void doHandle() {<br>    boolean handled = false;<br>    //…<br>    return handled;<br>  }<br>}</p><p>public class HandlerB extends Handler {<br>  @Override<br>  public void doHandle() {<br>    boolean handled = false;<br>    //…<br>    return handled;<br>  }<br>}</p><p>public class HandlerChain {<br>  private Handler head = null;<br>  private Handler tail = null;</p><p>  public void addHandler(Handler handler) {<br>    handler.setSuccessor(null);</p><pre><code>if (head == null) {  head = handler;  tail = handler;  return;}tail.setSuccessor(handler);tail = handler;</code></pre><p>  }</p><p>  public void handle() {<br>    if (head != null) {<br>      head.handle();<br>    }<br>  }<br>}</p><p>// 使用举例<br>public class Application {<br>  public static void main(String[] args) {<br>    HandlerChain chain = new HandlerChain();<br>    chain.addHandler(new HandlerA());<br>    chain.addHandler(new HandlerB());<br>    chain.handle();<br>  }<br>}</p><h2 id="1-2-使用数组实现HandlerChain"><a href="#1-2-使用数组实现HandlerChain" class="headerlink" title="1.2 使用数组实现HandlerChain"></a>1.2 使用数组实现HandlerChain</h2><pre><code>public interface IHandler {  boolean handle();}public class HandlerA implements IHandler {  @Override  public boolean handle() {    boolean handled = false;    //...    return handled;  }}public class HandlerB implements IHandler {  @Override  public boolean handle() {    boolean handled = false;    //...    return handled;  }}public class HandlerChain {  private List&lt;IHandler&gt; handlers = new ArrayList&lt;&gt;();  public void addHandler(IHandler handler) {    this.handlers.add(handler);  }  public void handle() {    for (IHandler handler : handlers) {      boolean handled = handler.handle();      if (handled) {        break;      }    }  }}// 使用举例public class Application {  public static void main(String[] args) {    HandlerChain chain = new HandlerChain();    chain.addHandler(new HandlerA());    chain.addHandler(new HandlerB());    chain.handle();  }}</code></pre><h1 id="2-过滤器、拦截器的实现"><a href="#2-过滤器、拦截器的实现" class="headerlink" title="2. 过滤器、拦截器的实现"></a>2. 过滤器、拦截器的实现</h1><p>职责链模式最长建的使用位置是在框架的开发当中，比如过滤器和拦截器。</p><h2 id="2-1-Servlet-Filter"><a href="#2-1-Servlet-Filter" class="headerlink" title="2.1 Servlet Filter"></a>2.1 Servlet Filter</h2><ul><li><p>实现堆HTTP请求的过滤功能</p><ul><li>鉴权</li><li>限流</li><li>记录日志</li><li>验证参数等</li></ul></li><li><p>在实际使用当中，定义一个实现<code>javax.servlet.Filter</code>接口的过滤器类，并且将其配置在web.xml配置文件当中。Web容器启动的时候，会读取web.xml中的配置，创建过滤器对象。</p></li><li><p>当有请求到来的时候，就会先经过过滤器，然后经由Servlet来进行处理</p></li></ul><pre><code>public class LogFilter implements Filter {  @Override  public void init(FilterConfig filterConfig) throws ServletException {    // 在创建Filter时自动调用，    // 其中filterConfig包含这个Filter的配置参数，比如name之类的（从配置文件中读取的）  }  @Override  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {    System.out.println(&quot;拦截客户端发送来的请求.&quot;);    chain.doFilter(request, response);    System.out.println(&quot;拦截发送给客户端的响应.&quot;);  }  @Override  public void destroy() {    // 在销毁Filter时自动调用  }}// 在web.xml配置文件中如下配置：&lt;filter&gt;  &lt;filter-name&gt;logFilter&lt;/filter-name&gt;  &lt;filter-class&gt;com.xzg.cd.LogFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt;    &lt;filter-name&gt;logFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;</code></pre><ul><li>FilterChain的实现</li></ul><pre><code>public final class ApplicationFilterChain implements FilterChain {  private int pos = 0; //当前执行到了哪个filter  private int n; //filter的个数  private ApplicationFilterConfig[] filters;  private Servlet servlet;  @Override  public void doFilter(ServletRequest request, ServletResponse response) {    if (pos &lt; n) {      ApplicationFilterConfig filterConfig = filters[pos++];      Filter filter = filterConfig.getFilter();      filter.doFilter(request, response, this);    } else {      // filter都处理完毕后，执行servlet      servlet.service(request, response);    }  }  public void addFilter(ApplicationFilterConfig filterConfig) {    for (ApplicationFilterConfig filter:filters)      if (filter==filterConfig)         return;    if (n == filters.length) {//扩容      ApplicationFilterConfig[] newFilters = new ApplicationFilterConfig[n + INCREMENT];      System.arraycopy(filters, 0, newFilters, 0, n);      filters = newFilters;    }    filters[n++] = filterConfig;  }}</code></pre><h2 id="2-2-Spring-Interceptor"><a href="#2-2-Spring-Interceptor" class="headerlink" title="2.2 Spring Interceptor"></a>2.2 Spring Interceptor</h2><p>有Spring MVC框架来提供实现，客户端发送的请求，会先经过Servlet Filter，然后在经过Spring Interceptor，最后再到达具体的业务代码当中。 </p><pre><code>// 代码实现public class LogInterceptor implements HandlerInterceptor {  @Override  public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {    System.out.println(&quot;拦截客户端发送来的请求.&quot;);    return true; // 继续后续的处理  }  @Override  public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {    System.out.println(&quot;拦截发送给客户端的响应.&quot;);  }  @Override  public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {    System.out.println(&quot;这里总是被执行.&quot;);  }}//在Spring MVC配置文件中配置interceptors&lt;mvc:interceptors&gt;   &lt;mvc:interceptor&gt;       &lt;mvc:mapping path=&quot;/*&quot;/&gt;       &lt;bean class=&quot;com.xzg.cd.LogInterceptor&quot; /&gt;   &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt;</code></pre><ul><li>Spring Interceptor底层实现<ul><li>基于职责链模式</li><li>使用HandlerExecutionChain来处理</li></ul></li></ul><pre><code>public class HandlerExecutionChain { private final Object handler; private HandlerInterceptor[] interceptors; public void addInterceptor(HandlerInterceptor interceptor) {  initInterceptorList().add(interceptor); } boolean applyPreHandle(HttpServletRequest request, HttpServletResponse response) throws Exception {  HandlerInterceptor[] interceptors = getInterceptors();  if (!ObjectUtils.isEmpty(interceptors)) {   for (int i = 0; i &lt; interceptors.length; i++) {    HandlerInterceptor interceptor = interceptors[i];    if (!interceptor.preHandle(request, response, this.handler)) {     triggerAfterCompletion(request, response, null);     return false;    }   }  }  return true; } void applyPostHandle(HttpServletRequest request, HttpServletResponse response, ModelAndView mv) throws Exception {  HandlerInterceptor[] interceptors = getInterceptors();  if (!ObjectUtils.isEmpty(interceptors)) {   for (int i = interceptors.length - 1; i &gt;= 0; i--) {    HandlerInterceptor interceptor = interceptors[i];    interceptor.postHandle(request, response, this.handler, mv);   }  } } void triggerAfterCompletion(HttpServletRequest request, HttpServletResponse response, Exception ex)   throws Exception {  HandlerInterceptor[] interceptors = getInterceptors();  if (!ObjectUtils.isEmpty(interceptors)) {   for (int i = this.interceptorIndex; i &gt;= 0; i--) {    HandlerInterceptor interceptor = interceptors[i];    try {     interceptor.afterCompletion(request, response, this.handler, ex);    } catch (Throwable ex2) {     logger.error(&quot;HandlerInterceptor.afterCompletion threw exception&quot;, ex2);    }   }  } }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-原理与实现&quot;&gt;&lt;a href=&quot;#1-原理与实现&quot; class=&quot;headerlink&quot; title=&quot;1. 原理与实现&quot;&gt;&lt;/a&gt;1. 原理与实现&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;职责链模式&lt;ul&gt;
&lt;li&gt;Chian of Responsibility Desi
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="职责链模式" scheme="https://www.llchen60.com/tags/%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-行为型-策略模式</title>
    <link href="https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-07-10T05:19:17.000Z</published>
    <updated>2020-07-10T22:10:09.405Z</updated>
    
    <content type="html"><![CDATA[<p>策略模式，用于避免冗长的if else或者switch分支判断，并且可以像模板模式那样提供框架的扩展点。</p><h1 id="1-原理与实现"><a href="#1-原理与实现" class="headerlink" title="1. 原理与实现"></a>1. 原理与实现</h1><ul><li>策略模式<ul><li>Strategy Design Pattern </li><li>Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it. </li><li>对策略的定义，创建和使用进行解耦</li></ul></li></ul><h2 id="1-1-策略的定义"><a href="#1-1-策略的定义" class="headerlink" title="1.1 策略的定义"></a>1.1 策略的定义</h2><ul><li>策略接口</li><li>一组实现了这个接口的策略类</li></ul><pre><code>public interface Strategy {  void algorithmInterface();}public class ConcreteStrategyA implements Strategy {  @Override  public void  algorithmInterface() {    //具体的算法...  }}public class ConcreteStrategyB implements Strategy {  @Override  public void  algorithmInterface() {    //具体的算法...  }}</code></pre><h2 id="1-2-策略的创建"><a href="#1-2-策略的创建" class="headerlink" title="1.2 策略的创建"></a>1.2 策略的创建</h2><ul><li><p>策略在使用的时候需要根据类型来判断创建哪个策略来使用</p></li><li><p>因此，为了封装创建逻辑，需要对客户端代码屏蔽创建细节</p><p>  public class StrategyFactory {</p><pre><code>private static final Map&lt;String, Strategy&gt; strategies = new HashMap&lt;&gt;();static {  strategies.put(&quot;A&quot;, new ConcreteStrategyA());  strategies.put(&quot;B&quot;, new ConcreteStrategyB());}public static Strategy getStrategy(String type) {  if (type == null || type.isEmpty()) {    throw new IllegalArgumentException(&quot;type should not be empty.&quot;);  }  return strategies.get(type);}</code></pre><p>  }</p></li></ul><p>这里是需要根据策略是否是有状态的，根据业务场景的需要，来看是否需要返回新创建的对象，或者来复用已经创建好的对象。</p><pre><code>// 返回新创建好的对象的范例public class StrategyFactory {  public static Strategy getStrategy(String type) {    if (type == null || type.isEmpty()) {      throw new IllegalArgumentException(&quot;type should not be empty.&quot;);    }    if (type.equals(&quot;A&quot;)) {      return new ConcreteStrategyA();    } else if (type.equals(&quot;B&quot;)) {      return new ConcreteStrategyB();    }    return null;  }}</code></pre><h2 id="1-3-策略的使用"><a href="#1-3-策略的使用" class="headerlink" title="1.3 策略的使用"></a>1.3 策略的使用</h2><p>使用的时候一般是运行时动态来决定使用哪一种策略。即根据配置，用户的输入，计算结果等因素，来决定 </p><pre><code>// 策略接口：EvictionStrategy// 策略类：LruEvictionStrategy、FifoEvictionStrategy、LfuEvictionStrategy...// 策略工厂：EvictionStrategyFactorypublic class UserCache {  private Map&lt;String, User&gt; cacheData = new HashMap&lt;&gt;();  private EvictionStrategy eviction;  public UserCache(EvictionStrategy eviction) {    this.eviction = eviction;  }  //...}// 运行时动态确定，根据配置文件的配置决定使用哪种策略public class Application {  public static void main(String[] args) throws Exception {    EvictionStrategy evictionStrategy = null;    Properties props = new Properties();    props.load(new FileInputStream(&quot;./config.properties&quot;));    String type = props.getProperty(&quot;eviction_type&quot;);    evictionStrategy = EvictionStrategyFactory.getEvictionStrategy(type);    UserCache userCache = new UserCache(evictionStrategy);    //...  }}// 非运行时动态确定，在代码中指定使用哪种策略public class Application {  public static void main(String[] args) {    //...    EvictionStrategy evictionStrategy = new LruEvictionStrategy();    UserCache userCache = new UserCache(evictionStrategy);    //...  }}</code></pre><h1 id="2-实例"><a href="#2-实例" class="headerlink" title="2. 实例"></a>2. 实例</h1><h2 id="2-1-策略模式避免分支判断"><a href="#2-1-策略模式避免分支判断" class="headerlink" title="2.1 策略模式避免分支判断"></a>2.1 策略模式避免分支判断</h2><pre><code>public class OrderService {  public double discount(Order order) {    double discount = 0.0;    OrderType type = order.getType();    if (type.equals(OrderType.NORMAL)) { // 普通订单      //...省略折扣计算算法代码    } else if (type.equals(OrderType.GROUPON)) { // 团购订单      //...省略折扣计算算法代码    } else if (type.equals(OrderType.PROMOTION)) { // 促销订单      //...省略折扣计算算法代码    }    return discount;  }}// 策略的定义public interface DiscountStrategy {  double calDiscount(Order order);}// 省略NormalDiscountStrategy、GrouponDiscountStrategy、PromotionDiscountStrategy类代码...// 策略的创建public class DiscountStrategyFactory {  private static final Map&lt;OrderType, DiscountStrategy&gt; strategies = new HashMap&lt;&gt;();  static {    strategies.put(OrderType.NORMAL, new NormalDiscountStrategy());    strategies.put(OrderType.GROUPON, new GrouponDiscountStrategy());    strategies.put(OrderType.PROMOTION, new PromotionDiscountStrategy());  }  public static DiscountStrategy getDiscountStrategy(OrderType type) {    return strategies.get(type);  }}// 策略的使用public class OrderService {  public double discount(Order order) {    OrderType type = order.getType();    DiscountStrategy discountStrategy = DiscountStrategyFactory.getDiscountStrategy(type);    return discountStrategy.calDiscount(order);  }}</code></pre><h2 id="2-2-根据大小对文件排序"><a href="#2-2-根据大小对文件排序" class="headerlink" title="2.2 根据大小对文件排序"></a>2.2 根据大小对文件排序</h2><ul><li><p>对文件进行排序</p><ul><li>整型数</li><li>逗号间隔</li></ul></li><li><p>100GB大小的话</p><ul><li>利用外部排序算法  – MapReduce框架</li></ul></li></ul><pre><code>public class SortAlgFactory {  private static final Map&lt;String, ISortAlg&gt; algs = new HashMap&lt;&gt;();  static {    algs.put(&quot;QuickSort&quot;, new QuickSort());    algs.put(&quot;ExternalSort&quot;, new ExternalSort());    algs.put(&quot;ConcurrentExternalSort&quot;, new ConcurrentExternalSort());    algs.put(&quot;MapReduceSort&quot;, new MapReduceSort());  }  public static ISortAlg getSortAlg(String type) {    if (type == null || type.isEmpty()) {      throw new IllegalArgumentException(&quot;type should not be empty.&quot;);    }    return algs.get(type);  }}public class Sorter {  private static final long GB = 1000 * 1000 * 1000;  public void sortFile(String filePath) {    // 省略校验逻辑    File file = new File(filePath);    long fileSize = file.length();    ISortAlg sortAlg;    if (fileSize &lt; 6 * GB) { // [0, 6GB)      sortAlg = SortAlgFactory.getSortAlg(&quot;QuickSort&quot;);    } else if (fileSize &lt; 10 * GB) { // [6GB, 10GB)      sortAlg = SortAlgFactory.getSortAlg(&quot;ExternalSort&quot;);    } else if (fileSize &lt; 100 * GB) { // [10GB, 100GB)      sortAlg = SortAlgFactory.getSortAlg(&quot;ConcurrentExternalSort&quot;);    } else { // [100GB, ~)      sortAlg = SortAlgFactory.getSortAlg(&quot;MapReduceSort&quot;);    }    sortAlg.sort(filePath);  }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;策略模式，用于避免冗长的if else或者switch分支判断，并且可以像模板模式那样提供框架的扩展点。&lt;/p&gt;
&lt;h1 id=&quot;1-原理与实现&quot;&gt;&lt;a href=&quot;#1-原理与实现&quot; class=&quot;headerlink&quot; title=&quot;1. 原理与实现&quot;&gt;&lt;/a&gt;1. 原
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="策略模式" scheme="https://www.llchen60.com/tags/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Intellij IDEA tips and tricks</title>
    <link href="https://www.llchen60.com/Intellij-IDEA-tips-and-tricks/"/>
    <id>https://www.llchen60.com/Intellij-IDEA-tips-and-tricks/</id>
    <published>2020-07-06T04:39:57.000Z</published>
    <updated>2020-07-06T04:40:23.103Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>Magic shortcut for almost everything<br>Alt + Enter </p></li><li><p>Jump to next error  </p></li></ol><p>F2 </p><ol start="3"><li><p>Project window<br>cmd + 1 </p></li><li><p>focus on editor  </p></li></ol><p>esc </p><ol start="5"><li>The recent file box  </li></ol><p>cmd E </p><ol start="6"><li>Go to declaration </li></ol><p>cmd + B </p><ol start="7"><li>Find usage </li></ol><p>Alt + F7 </p><ol start="8"><li>Run Anything </li></ol><p>double ctrl </p><p>*<em>9. Extend/ shrink selection *</em></p><p>option + up arrow </p><p>option + down arrow </p><ol start="10"><li>Add/ Remove comments</li></ol><p>cmd + / </p><ol start="11"><li>Complete current statement </li></ol><p>shift + cmd + enter </p><ol start="12"><li>Reformat file </li></ol><p>alt + cmd + l</p><ol start="13"><li>Refactor </li></ol><p>ctrl + t </p><p>Show all the refactor option </p><ol start="14"><li>Find action </li></ol><p>shift + cmd + A </p><ol start="15"><li>Search everywhere </li></ol><p>shift + shift </p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://www.youtube.com/watch?v=QYO5_riePOQ" target="_blank" rel="noopener">https://www.youtube.com/watch?v=QYO5_riePOQ</a> </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;Magic shortcut for almost everything&lt;br&gt;Alt + Enter &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Jump to next error  &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;F2 &lt;/p&gt;
&lt;ol start=
      
    
    </summary>
    
    
      <category term="Tools" scheme="https://www.llchen60.com/categories/Tools/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式-行为型-模板模式</title>
    <link href="https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-07-05T17:54:08.000Z</published>
    <updated>2020-07-07T05:11:42.063Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-原理与实现"><a href="#1-原理与实现" class="headerlink" title="1. 原理与实现"></a>1. 原理与实现</h1><ul><li>模板方法设计模式<ul><li>Template Method Design Pattern </li><li>Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template method lets subclasses redefine certain steps of an algorithm without changing the algorithm’s structure </li><li>在一个方法中定义一个算法股价，并将某些步骤推迟到子类当中进行实现，模板方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些不好走。</li></ul></li></ul><p>实现的基本方式就是设置一个抽象类，对于不想被子类重写的方法可以加上final关键字，其余的可以设置为抽象方法，让子类来实现。</p><pre><code>public abstract class AbstractClass {  public final void templateMethod() {    //...    method1();    //...    method2();    //...  }  protected abstract void method1();  protected abstract void method2();}public class ConcreteClass1 extends AbstractClass {  @Override  protected void method1() {    //...  }  @Override  protected void method2() {    //...  }}public class ConcreteClass2 extends AbstractClass {  @Override  protected void method1() {    //...  }  @Override  protected void method2() {    //...  }}AbstractClass demo = ConcreteClass1();demo.templateMethod();</code></pre><h1 id="2-功能实现的例子"><a href="#2-功能实现的例子" class="headerlink" title="2. 功能实现的例子"></a>2. 功能实现的例子</h1><h2 id="2-1-以复用为目的"><a href="#2-1-以复用为目的" class="headerlink" title="2.1 以复用为目的"></a>2.1 以复用为目的</h2><ol><li><p>InputStream 类的实现</p><p> public abstract class InputStream implements Closeable {<br>   //…省略其他代码…</p><p>   public int read(byte b[], int off, int len) throws IOException {</p><pre><code> if (b == null) {   throw new NullPointerException(); } else if (off &lt; 0 || len &lt; 0 || len &gt; b.length - off) {   throw new IndexOutOfBoundsException(); } else if (len == 0) {   return 0; } int c = read(); if (c == -1) {   return -1; } b[off] = (byte)c; int i = 1; try {   for (; i &lt; len ; i++) {     c = read();     if (c == -1) {       break;     }     b[off + i] = (byte)c;   } } catch (IOException ee) { } return i;</code></pre><p>   }</p><p>   // 在这里定义了一个可以供子类实现的抽象方法<br>   public abstract int read() throws IOException;<br> }</p><p> public class ByteArrayInputStream extends InputStream {<br>   //…省略其他代码…</p><p>   @Override<br>   public synchronized int read() {</p><pre><code> return (pos &lt; count) ? (buf[pos++] &amp; 0xff) : -1;</code></pre><p>   }<br> }</p></li></ol><ol start="2"><li>AbstractList的实现</li></ol><pre><code>public boolean addAll(int index, Collection&lt;? extends E&gt; c) {    rangeCheckForAdd(index);    boolean modified = false;    for (E e : c) {        add(index++, e);        modified = true;    }    return modified;}public void add(int index, E element) {    throw new UnsupportedOperationException();}</code></pre><h2 id="2-2-以扩展为目的"><a href="#2-2-以扩展为目的" class="headerlink" title="2.2 以扩展为目的"></a>2.2 以扩展为目的</h2><ol><li>Java Servlet</li></ol><p>抛开框架直接使用Servlet做开发的话，Servlet在接收到请求之后，会根据URL和Servlet的映射关系，找到对应的Servlet，然后来执行它的service()方法。service方法定义在父类HttpServelet当中，会调用doGet()还有doPost()方法。</p><p>为了实现上述的整个流程，我们需要继承HttpServlet，重新实现我们自己的doGet()以及doPost()方法。</p><pre><code>public class HelloServlet extends HttpServlet {  @Override  protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {    this.doPost(req, resp);  }  @Override  protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {    resp.getWriter().write(&quot;Hello World.&quot;);  }}// 存储映射关系的xml，也可以使用annotation来实现映射&lt;servlet&gt;    &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;com.xzg.cd.HelloServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;public void service(ServletRequest req, ServletResponse res)    throws ServletException, IOException{    HttpServletRequest  request;    HttpServletResponse response;    if (!(req instanceof HttpServletRequest &amp;&amp;            res instanceof HttpServletResponse)) {        throw new ServletException(&quot;non-HTTP request or response&quot;);    }    request = (HttpServletRequest) req;    response = (HttpServletResponse) res;    service(request, response);}protected void service(HttpServletRequest req, HttpServletResponse resp)    throws ServletException, IOException{    String method = req.getMethod();    if (method.equals(METHOD_GET)) {        long lastModified = getLastModified(req);        if (lastModified == -1) {            // servlet doesn&#39;t support if-modified-since, no reason            // to go through further expensive logic            doGet(req, resp);        } else {            long ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE);            if (ifModifiedSince &lt; lastModified) {                // If the servlet mod time is later, call doGet()                // Round down to the nearest second for a proper compare                // A ifModifiedSince of -1 will always be less                maybeSetLastModified(resp, lastModified);                doGet(req, resp);            } else {                resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);            }        }    } else if (method.equals(METHOD_HEAD)) {        long lastModified = getLastModified(req);        maybeSetLastModified(resp, lastModified);        doHead(req, resp);    } else if (method.equals(METHOD_POST)) {        doPost(req, resp);    } else if (method.equals(METHOD_PUT)) {        doPut(req, resp);    } else if (method.equals(METHOD_DELETE)) {        doDelete(req, resp);    } else if (method.equals(METHOD_OPTIONS)) {        doOptions(req,resp);    } else if (method.equals(METHOD_TRACE)) {        doTrace(req,resp);    } else {        String errMsg = lStrings.getString(&quot;http.method_not_implemented&quot;);        Object[] errArgs = new Object[1];        errArgs[0] = method;        errMsg = MessageFormat.format(errMsg, errArgs);        resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);    }}</code></pre><ol start="2"><li>JUnit TestCase</li></ol><p>Junit定义的功能扩展点为：</p><ul><li>setUp() </li><li>tearDown()</li><li>etc.</li></ul><p>写的测试类都是继承框架提供的testCase类，在这个类当中，runBare()函数是模板方法，定义了执行测试用例的整体流程:先执行setUp()做准备工作，然后执行runTest()运行真正的测试代码，最后执行tearDown()做扫尾工作。</p><pre><code>public abstract class TestCase extends Assert implements Test {  public void runBare() throws Throwable {    Throwable exception = null;    setUp();    try {      runTest();    } catch (Throwable running) {      exception = running;    } finally {      try {        tearDown();      } catch (Throwable tearingDown) {        if (exception == null) exception = tearingDown;      }    }    if (exception != null) throw exception;  }  /**  * Sets up the fixture, for example, open a network connection.  * This method is called before a test is executed.  */  protected void setUp() throws Exception {  }  /**  * Tears down the fixture, for example, close a network connection.  * This method is called after a test is executed.  */  protected void tearDown() throws Exception {  }}</code></pre><h2 id="2-3-模板模式对比Callback函数"><a href="#2-3-模板模式对比Callback函数" class="headerlink" title="2.3 模板模式对比Callback函数"></a>2.3 模板模式对比Callback函数</h2><p>回调函数可以起到和模板模式相同的作用，回调是一种双向调用关系</p><p>A 类事先注册某个函数 F 到 B 类，A 类在调用 B 类的 P 函数的时候，B 类反过来调用 A 类注册给它的 F 函数。这里的 F 函数就是“回调函数”。A 调用 B，B 反过来又调用 A，这种调用机制就叫作“回调”。</p><p>回调分为同步回调和异步回调，同步回调指函数返回之前执行回调函数；异步回调指函数返回之后执行回调函数。</p><pre><code>public interface ICallback {  void methodToCallback();}public class BClass {  public void process(ICallback callback) {    //...    callback.methodToCallback();    //...  }}public class AClass {  public static void main(String[] args) {    BClass b = new BClass();    b.process(new ICallback() { //回调对象      @Override      public void methodToCallback() {        System.out.println(&quot;Call back me.&quot;);      }    });  }}</code></pre><ul><li>使用Callback函数实现的JDBCTemplate</li></ul><pre><code>@Overridepublic &lt;T&gt; List&lt;T&gt; query(String sql, RowMapper&lt;T&gt; rowMapper) throws DataAccessException { return query(sql, new RowMapperResultSetExtractor&lt;T&gt;(rowMapper));}@Overridepublic &lt;T&gt; T query(final String sql, final ResultSetExtractor&lt;T&gt; rse) throws DataAccessException { Assert.notNull(sql, &quot;SQL must not be null&quot;); Assert.notNull(rse, &quot;ResultSetExtractor must not be null&quot;); if (logger.isDebugEnabled()) {  logger.debug(&quot;Executing SQL query [&quot; + sql + &quot;]&quot;); } class QueryStatementCallback implements StatementCallback&lt;T&gt;, SqlProvider {  @Override  public T doInStatement(Statement stmt) throws SQLException {   ResultSet rs = null;   try {    rs = stmt.executeQuery(sql);    ResultSet rsToUse = rs;    if (nativeJdbcExtractor != null) {     rsToUse = nativeJdbcExtractor.getNativeResultSet(rs);    }    return rse.extractData(rsToUse);   }   finally {    JdbcUtils.closeResultSet(rs);   }  }  @Override  public String getSql() {   return sql;  } } return execute(new QueryStatementCallback());}@Overridepublic &lt;T&gt; T execute(StatementCallback&lt;T&gt; action) throws DataAccessException { Assert.notNull(action, &quot;Callback object must not be null&quot;); Connection con = DataSourceUtils.getConnection(getDataSource()); Statement stmt = null; try {  Connection conToUse = con;  if (this.nativeJdbcExtractor != null &amp;&amp;    this.nativeJdbcExtractor.isNativeConnectionNecessaryForNativeStatements()) {   conToUse = this.nativeJdbcExtractor.getNativeConnection(con);  }  stmt = conToUse.createStatement();  applyStatementSettings(stmt);  Statement stmtToUse = stmt;  if (this.nativeJdbcExtractor != null) {   stmtToUse = this.nativeJdbcExtractor.getNativeStatement(stmt);  }  T result = action.doInStatement(stmtToUse);  handleWarnings(stmt);  return result; } catch (SQLException ex) {  // Release Connection early, to avoid potential connection pool deadlock  // in the case when the exception translator hasn&#39;t been initialized yet.  JdbcUtils.closeStatement(stmt);  stmt = null;  DataSourceUtils.releaseConnection(con, getDataSource());  con = null;  throw getExceptionTranslator().translate(&quot;StatementCallback&quot;, getSql(action), ex); } finally {  JdbcUtils.closeStatement(stmt);  DataSourceUtils.releaseConnection(con, getDataSource()); }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-原理与实现&quot;&gt;&lt;a href=&quot;#1-原理与实现&quot; class=&quot;headerlink&quot; title=&quot;1. 原理与实现&quot;&gt;&lt;/a&gt;1. 原理与实现&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;模板方法设计模式&lt;ul&gt;
&lt;li&gt;Template Method Design Pa
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="模板模式" scheme="https://www.llchen60.com/tags/%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-行为型-观察者模式</title>
    <link href="https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-06-30T03:48:34.000Z</published>
    <updated>2020-07-01T03:21:33.006Z</updated>
    
    <content type="html"><![CDATA[<ul><li>创建型设计模式<ul><li>解决对象创建的问题</li></ul></li></ul><ul><li><p>结构型设计模式</p><ul><li>解决类或者对象的组合或组装问题</li></ul></li><li><p>行为型设计模式</p><ul><li>解决类或对象之间的交互问题</li></ul></li></ul><h1 id="1-观察者模式原理"><a href="#1-观察者模式原理" class="headerlink" title="1. 观察者模式原理"></a>1. 观察者模式原理</h1><p>根据应用场景的不同，观察者模式是会有不同的代码实现的<br>    + 同步阻塞<br>    + 异步非阻塞<br>    + 进程内的实现方式<br>    + 跨进程的实现方式</p><ul><li>观察者模式  Observer Design Pattern<ul><li>发布订阅模式 Publish - Subscribe Design Pattern </li><li>Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically. </li><li>角色划分<ul><li>observable and observer </li><li>publisher and subscriber </li><li>producer and consumer </li><li>subject and observer </li><li>dispatcher and listener </li><li>eventEmitter and EventListener </li></ul></li></ul></li></ul><pre><code>// Example public interface RegObserver {  void handleRegSuccess(long userId);}public class RegPromotionObserver implements RegObserver {  private PromotionService promotionService; // 依赖注入  @Override  public void handleRegSuccess(long userId) {    promotionService.issueNewUserExperienceCash(userId);  }}public class RegNotificationObserver implements RegObserver {  private NotificationService notificationService;  @Override  public void handleRegSuccess(long userId) {    notificationService.sendInboxMessage(userId, &quot;Welcome...&quot;);  }}public class UserController {  private UserService userService; // 依赖注入  private List&lt;RegObserver&gt; regObservers = new ArrayList&lt;&gt;();  // 一次性设置好，之后也不可能动态的修改  public void setRegObservers(List&lt;RegObserver&gt; observers) {    regObservers.addAll(observers);  }  public Long register(String telephone, String password) {    //省略输入参数的校验代码    //省略userService.register()异常的try-catch代码    long userId = userService.register(telephone, password);    for (RegObserver observer : regObservers) {      observer.handleRegSuccess(userId);    }    return userId;  }}</code></pre><h1 id="2-探究异步非阻塞的EventBus框架"><a href="#2-探究异步非阻塞的EventBus框架" class="headerlink" title="2. 探究异步非阻塞的EventBus框架"></a>2. 探究异步非阻塞的EventBus框架</h1><h2 id="2-1-基本的异步非阻塞模式"><a href="#2-1-基本的异步非阻塞模式" class="headerlink" title="2.1 基本的异步非阻塞模式"></a>2.1 基本的异步非阻塞模式</h2><pre><code>// 第一种实现方式，其他类代码不变，就没有再重复罗列public class RegPromotionObserver implements RegObserver {  private PromotionService promotionService; // 依赖注入  @Override  public void handleRegSuccess(long userId) {    Thread thread = new Thread(new Runnable() {      @Override      public void run() {        promotionService.issueNewUserExperienceCash(userId);      }    });    thread.start();  }}// 第二种实现方式，其他类代码不变，就没有再重复罗列public class UserController {  private UserService userService; // 依赖注入  private List&lt;RegObserver&gt; regObservers = new ArrayList&lt;&gt;();  private Executor executor;  public UserController(Executor executor) {    this.executor = executor;  }  public void setRegObservers(List&lt;RegObserver&gt; observers) {    regObservers.addAll(observers);  }  public Long register(String telephone, String password) {    //省略输入参数的校验代码    //省略userService.register()异常的try-catch代码    long userId = userService.register(telephone, password);    for (RegObserver observer : regObservers) {      executor.execute(new Runnable() {        @Override        public void run() {          observer.handleRegSuccess(userId);        }      });    }    return userId;  }}</code></pre><ul><li><p>方法1 </p><ul><li>频繁创建销毁线程比较耗时</li><li>并且创建过多线程会导致堆栈溢出</li></ul></li><li><p>方法2 </p><ul><li>线程池，异步执行的逻辑耦合在了register()函数当中，维护成本会提高</li></ul></li></ul><h2 id="2-2-EventBus功能需求"><a href="#2-2-EventBus功能需求" class="headerlink" title="2.2 EventBus功能需求"></a>2.2 EventBus功能需求</h2><p>以google guava eventBus为例</p><pre><code>public class UserController {  private UserService userService; // 依赖注入  private EventBus eventBus;  private static final int DEFAULT_EVENTBUS_THREAD_POOL_SIZE = 20;  public UserController() {    //eventBus = new EventBus(); // 同步阻塞模式    eventBus = new AsyncEventBus(Executors.newFixedThreadPool(DEFAULT_EVENTBUS_THREAD_POOL_SIZE)); // 异步非阻塞模式  }  public void setRegObservers(List&lt;Object&gt; observers) {    for (Object observer : observers) {      eventBus.register(observer);    }  }  public Long register(String telephone, String password) {    //省略输入参数的校验代码    //省略userService.register()异常的try-catch代码    long userId = userService.register(telephone, password);    eventBus.post(userId);    return userId;  }}public class RegPromotionObserver {  private PromotionService promotionService; // 依赖注入  @Subscribe  public void handleRegSuccess(long userId) {    promotionService.issueNewUserExperienceCash(userId);  }}public class RegNotificationObserver {  private NotificationService notificationService;  @Subscribe  public void handleRegSuccess(long userId) {    notificationService.sendInboxMessage(userId, &quot;...&quot;);  }}</code></pre><ul><li>使用EventBus框架实现的观察者模式，大流程上相同，但是区别在于<ul><li>不用定义Observer接口了</li><li>任意类型的对象都可以注册到EventBus当中，通过<code>@Subscribe</code>注解来标明类当中哪个函数可以接收被观察者发送的消息</li></ul></li></ul><ul><li>EventBus, AsyncEventBus <ul><li>Guava EventBus 的所有可调用接口</li></ul></li></ul><pre><code>EventBus eventBus = new EventBus(); // 同步阻塞模式EventBus eventBus = new AsyncEventBus(Executors.newFixedThreadPool(8))；// 异步阻塞模式</code></pre><ul><li><p><code>register()</code>函数</p><ul><li>用来注册观察者</li><li>可以接受任何类型的观察者</li></ul></li><li><p><code>unregister()</code>函数</p><ul><li>删除某个观察者</li></ul></li><li><p><code>post()</code>函数</p><ul><li>用于给观察者发送消息</li></ul></li><li><p><code>@Subscribe</code>注解</p><ul><li>通过注解说明某个函数能够接收哪种类型的消息</li></ul></li></ul><p>最关键的一个数据结构是 Observer 注册表，记录了消息类型和可接收消息函数的对应关系。当调用 register() 函数注册观察者的时候，EventBus 通过解析 @Subscribe 注解，生成 Observer 注册表。当调用 post() 函数发送消息的时候，EventBus 通过注册表找到相应的可接收消息的函数，然后通过 Java 的反射语法来动态地创建对象、执行函数。对于同步阻塞模式，EventBus 在一个线程内依次执行相应的函数。对于异步非阻塞模式，EventBus 通过一个线程池来执行相应的函数。</p><h2 id="2-3-EventBus的实现"><a href="#2-3-EventBus的实现" class="headerlink" title="2.3 EventBus的实现"></a>2.3 EventBus的实现</h2><ol><li>Subscirbe 注解</li></ol><p>用于标明观察者中的哪个函数可以接收信息</p><pre><code>@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)@Betapublic @interface Subscribe {}</code></pre><ol start="2"><li>ObserverAction</li></ol><p>ObserverAction类用来表示Subscribe注解的方法，其中target表示观察者类，method表示方法，主要用在ObserverRegistry观察者注册表当中。</p><pre><code>public class ObserverAction {  private Object target;  private Method method;  public ObserverAction(Object target, Method method) {    this.target = Preconditions.checkNotNull(target);    this.method = method;    this.method.setAccessible(true);  }  public void execute(Object event) { // event是method方法的参数    try {      method.invoke(target, event);    } catch (InvocationTargetException | IllegalAccessException e) {      e.printStackTrace();    }  }}</code></pre><ol start="3"><li>ObserverRegistry</li></ol><p>Observer注册表类，大量使用Java的反射语法</p><pre><code>public class ObserverRegistry {  private ConcurrentMap&lt;Class&lt;?&gt;, CopyOnWriteArraySet&lt;ObserverAction&gt;&gt; registry = new ConcurrentHashMap&lt;&gt;();  public void register(Object observer) {    Map&lt;Class&lt;?&gt;, Collection&lt;ObserverAction&gt;&gt; observerActions = findAllObserverActions(observer);    for (Map.Entry&lt;Class&lt;?&gt;, Collection&lt;ObserverAction&gt;&gt; entry : observerActions.entrySet()) {      Class&lt;?&gt; eventType = entry.getKey();      Collection&lt;ObserverAction&gt; eventActions = entry.getValue();      CopyOnWriteArraySet&lt;ObserverAction&gt; registeredEventActions = registry.get(eventType);      if (registeredEventActions == null) {        registry.putIfAbsent(eventType, new CopyOnWriteArraySet&lt;&gt;());        registeredEventActions = registry.get(eventType);      }      registeredEventActions.addAll(eventActions);    }  }  public List&lt;ObserverAction&gt; getMatchedObserverActions(Object event) {    List&lt;ObserverAction&gt; matchedObservers = new ArrayList&lt;&gt;();    Class&lt;?&gt; postedEventType = event.getClass();    for (Map.Entry&lt;Class&lt;?&gt;, CopyOnWriteArraySet&lt;ObserverAction&gt;&gt; entry : registry.entrySet()) {      Class&lt;?&gt; eventType = entry.getKey();      Collection&lt;ObserverAction&gt; eventActions = entry.getValue();      if (postedEventType.isAssignableFrom(eventType)) {        matchedObservers.addAll(eventActions);      }    }    return matchedObservers;  }  private Map&lt;Class&lt;?&gt;, Collection&lt;ObserverAction&gt;&gt; findAllObserverActions(Object observer) {    Map&lt;Class&lt;?&gt;, Collection&lt;ObserverAction&gt;&gt; observerActions = new HashMap&lt;&gt;();    Class&lt;?&gt; clazz = observer.getClass();    for (Method method : getAnnotatedMethods(clazz)) {      Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();      Class&lt;?&gt; eventType = parameterTypes[0];      if (!observerActions.containsKey(eventType)) {        observerActions.put(eventType, new ArrayList&lt;&gt;());      }      observerActions.get(eventType).add(new ObserverAction(observer, method));    }    return observerActions;  }  private List&lt;Method&gt; getAnnotatedMethods(Class&lt;?&gt; clazz) {    List&lt;Method&gt; annotatedMethods = new ArrayList&lt;&gt;();    for (Method method : clazz.getDeclaredMethods()) {      if (method.isAnnotationPresent(Subscribe.class)) {        Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();        Preconditions.checkArgument(parameterTypes.length == 1,                &quot;Method %s has @Subscribe annotation but has %s parameters.&quot;                        + &quot;Subscriber methods must have exactly 1 parameter.&quot;,                method, parameterTypes.length);        annotatedMethods.add(method);      }    }    return annotatedMethods;  }}</code></pre><ol start="4"><li>EventBus</li></ol><pre><code>public class EventBus {  private Executor executor;  private ObserverRegistry registry = new ObserverRegistry();  public EventBus() {    this(MoreExecutors.directExecutor());  }  protected EventBus(Executor executor) {    this.executor = executor;  }  public void register(Object object) {    registry.register(object);  }  public void post(Object event) {    List&lt;ObserverAction&gt; observerActions = registry.getMatchedObserverActions(event);    for (ObserverAction observerAction : observerActions) {      executor.execute(new Runnable() {        @Override        public void run() {          observerAction.execute(event);        }      });    }  }}</code></pre><ol start="5"><li>AsyncEventBus</li></ol><pre><code>public class AsyncEventBus extends EventBus {  public AsyncEventBus(Executor executor) {    super(executor);  }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;创建型设计模式&lt;ul&gt;
&lt;li&gt;解决对象创建的问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;结构型设计模式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;解决类或者对象的组合或组装问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;行为型设计模式&lt;/
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="观察者模式" scheme="https://www.llchen60.com/tags/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>微观经济学 课程学习</title>
    <link href="https://www.llchen60.com/%E5%BE%AE%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6-%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    <id>https://www.llchen60.com/%E5%BE%AE%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6-%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-06-29T02:11:58.000Z</published>
    <updated>2020-06-29T02:12:28.351Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-导论"><a href="#1-导论" class="headerlink" title="1. 导论"></a>1. 导论</h1><h2 id="1-1-经济学发展史"><a href="#1-1-经济学发展史" class="headerlink" title="1.1 经济学发展史"></a>1.1 经济学发展史</h2><ul><li><p>国富论</p><ul><li>工业革命开始</li><li>市场的运作方式</li><li>自由市场经济是自我平衡的，人人皆会受益</li></ul></li><li><p>微观经济学</p><ul><li>单个生产者，管理者的研究</li></ul></li><li><p>资本论</p><ul><li>有辩证方法 批判 得出结论</li><li>资本主义制度是暂时的，潜在的本质性的矛盾</li></ul></li><li><p>就业、利息和货币通论</p></li></ul><ul><li>经济学分类<ul><li>微观经济学<ul><li>对于大的经济体系的某个经济单位</li></ul></li><li>宏观经济学<ul><li>整个经济系统的总体分析</li></ul></li></ul></li></ul><h2 id="1-2-经济学研究什么"><a href="#1-2-经济学研究什么" class="headerlink" title="1.2 经济学研究什么"></a>1.2 经济学研究什么</h2><p>根源是稀缺性，因为稀缺，所以要选择，机会成本是我们做出选择的方法论。</p><ul><li>经济学 – 稀缺资源配置的学科<ul><li>稀缺<ul><li>生产的产品资源无法满足人们的需要的情况 </li><li>稀缺是经济学最重要的假定</li><li>稀缺是普遍存在的</li><li>选择A还是选择B</li></ul></li><li>选择</li><li>机会成本<ul><li>因为稀缺，所以我们需要是的有限的物品，劳务在有限的时间内满足人们最急需的欲望</li><li>因此人们需要去选择</li><li>选择A B 选择A的机会成本是B的收益</li></ul></li></ul></li></ul><h2 id="1-3-十大经济学原理"><a href="#1-3-十大经济学原理" class="headerlink" title="1.3 十大经济学原理"></a>1.3 十大经济学原理</h2><p>看整个的学习框架</p><h3 id="1-3-1-关于个人的"><a href="#1-3-1-关于个人的" class="headerlink" title="1.3.1 关于个人的"></a>1.3.1 关于个人的</h3><ul><li>基本思想：人会通过权衡取舍来对激励做出反应</li><li>基本概念： <ul><li>收益</li><li>(机会)成本</li><li>激励</li></ul></li><li>分析方法<ul><li>边际分析</li></ul></li></ul><ol><li>People face tradeoffs. </li></ol><p>鱼和熊掌不可兼得</p><ul><li>国防 vs 消费</li><li>食品 vs 衣服</li><li>工作 vs 休息</li><li>效率 vs 公平</li></ul><ol start="2"><li>The cost of something is what you give up to get it </li></ol><ul><li>机会成本<ul><li>为了得到某种东西所必须放弃的东西</li></ul></li></ul><ol start="3"><li>Rational people think at the margin </li></ol><ul><li>理性人<ul><li>理性人 会使用所有可获得的信息来进行判断 </li><li>对某个决策的收益和成本进行比较</li></ul></li><li>边际<ul><li>微分的理念</li><li>对当前行动进行的微小的调整</li><li>边际成本–增量成本，指的是每增产以单位的产品所造成的总成本的增量</li><li>边际成本和单位平均成本不同，单位平均成本考虑了全部的产品，而边际成本忽略了最后一个产品之前的。例如每辆汽车的平均成本包括生产第一辆车的很大的固定成本，而边际成本根本不考虑固定成本<ul><li>因为固定成本几乎沉没了，理论上边际成本是可以让企业无损失的继续运转下去的 </li></ul></li><li>一个决策的额外或者追加的成本</li><li>E.G<ul><li>上两节课，很累，是否要上第三节课</li><li>第三节课的收益  边际收益</li><li>成本 休息一下 这个带来的收益就是你第三节课翘课的边际成本了</li></ul></li></ul></li></ul><ol start="4"><li>People respond to incentives 人们对激励做出反应</li></ol><ul><li><p>人们会对激励产生反应</p></li><li><p>对于价格的反应</p></li><li><p>对于竞争的反应</p></li><li><p>对产权 契约制度做出的反应</p></li><li><p><strong>最大值 边际收益 == 边际成本</strong></p></li></ul><h3 id="1-3-2-关于人和人之间的"><a href="#1-3-2-关于人和人之间的" class="headerlink" title="1.3.2 关于人和人之间的"></a>1.3.2 关于人和人之间的</h3><ol start="5"><li>Trade can make everyone better off </li></ol><ul><li>竞争 促进了交易的盈利</li><li>贸易造成的分工</li></ul><ol start="6"><li>Markets are usually a good way to organize economic activity </li></ol><ul><li>市场经济<ul><li>资源配置的办法</li><li>通过卖家买家单独分别的决策来做出最好的选择</li><li>公司  以及 家庭会分别决定怎么生产，生产多少</li></ul></li></ul><p>As if guided by an invisible hand. </p><p>通过价格来决定自己的买卖行为</p><ul><li>市场是否真的有效？<ul><li>法治体系不能由商人 利益集团来左右  亚当斯密</li><li>马克思 自由放任的市场会爆发周期性经济危机  因为人非理性</li><li>凯恩斯 非理性  动物精神  市场波动与宏观波动</li></ul></li></ul><ol start="7"><li>Governments can sometimes improve market outcomes </li></ol><ul><li>因为市场本身弊病，即非理性人的非理性决策</li><li>市场有可能在一些时候无法自身去有效的配置资源，那就需要政府的帮助了</li><li>譬如效率和公平的问题</li><li>市场失灵，无法调控的现象<ul><li>收入与财富分配不公</li><li>外部负效应问题<ul><li>污染</li></ul></li><li>竞争失败和市场垄断的形成</li><li>失业问题</li><li>区域经济的不协调问题</li><li>公共产品供给不足</li><li>公共资源的过度使用</li></ul></li></ul><h3 id="1-3-3-根据宏观经济现象提出的原理"><a href="#1-3-3-根据宏观经济现象提出的原理" class="headerlink" title="1.3.3 根据宏观经济现象提出的原理"></a>1.3.3 根据宏观经济现象提出的原理</h3><ol start="8"><li>一国的生活水平取决于它生产物品与劳务的能力</li><li>当政府发行了过多货币的时候，物价上升</li><li>社会面临通货膨胀与失业之间的短期权衡取舍</li></ol><h1 id="2-像经济学家一样思考"><a href="#2-像经济学家一样思考" class="headerlink" title="2.  像经济学家一样思考"></a>2.  像经济学家一样思考</h1><h2 id="2-1-经济学的社会科学属性"><a href="#2-1-经济学的社会科学属性" class="headerlink" title="2.1 经济学的社会科学属性"></a>2.1 经济学的社会科学属性</h2><ul><li>经济学家<ul><li>一方面，另一方面，lol  </li><li>考虑问题常常两个方面<ul><li>作为科学家<ul><li>经济分析</li></ul></li><li>作为政策顾问<ul><li>时政分析</li></ul></li></ul></li></ul></li></ul><ul><li><p>什么是科学？</p><ul><li><p>通常当我们定义一个概念的时候，需要一个外延更宽泛的概念</p></li><li><p>用科学定义经济学</p></li><li><p>用认识定义科学</p><ul><li>认识： 人们通过实践和思维，对单个事物的属性和事物之间联系的理解和判断</li></ul></li><li><p>科学的本质</p><ul><li>用实证的方法，实证性</li><li>解释对象是怎么样的问题，以及应该怎么样的规范性问题</li></ul></li><li><p>科学的性质</p><ul><li>可证伪性</li><li>假设与简化</li><li>内部一致性<ul><li>统一的假设系统，能够解释多种现象</li></ul></li><li>经验一致性<ul><li>观察事实等经验证据与理论相对照</li><li>通过可控制的试验来进行检验<ul><li>经济学</li><li>符合科学的可证伪原则</li><li>采用假设手段构造理论，并使用简化的模型表达理论</li><li>坚持内部逻辑的一致性</li><li>不断将卢纶假设和经验事实相对照，来检验理论的真伪 </li><li>主题</li><li>人们的选择如何引导他们的生活，以及他们是如何相互影响的</li></ul></li></ul></li></ul></li></ul></li></ul><h2 id="2-2-经济学的研究步骤"><a href="#2-2-经济学的研究步骤" class="headerlink" title="2.2 经济学的研究步骤"></a>2.2 经济学的研究步骤</h2><ol><li>确定研究问题</li><li>形成假设</li><li>建立模型</li><li>经验检验，也测货解释现实</li><li>通过检验结果决定放弃，修改模型</li></ol><ul><li>研究方法<ul><li>描述性的方法</li><li>分析性的办法 – 抽象推理</li></ul></li></ul><p>下面描述一些经常使用的经济模型：</p><h3 id="2-2-1-循环流量图"><a href="#2-2-1-循环流量图" class="headerlink" title="2.2.1 循环流量图"></a>2.2.1 循环流量图</h3><ul><li><p>说明货币如何通过市场在家庭和企业之间流动</p></li><li><p>主体</p><ul><li>家庭<ul><li>拥有并出售或出租生产要素给企业来获得收入</li><li>购买并消费物品与劳务</li></ul></li><li>企业<ul><li>购买或雇佣生产要素并用以生产物品与劳务</li><li>出售物品与劳务</li></ul></li></ul></li><li><p>两个市场</p><ul><li>物品与劳务市场</li><li>生产要素市场<ul><li>生产要素指经济体用来生产物品与劳务的资源<ul><li>劳动</li><li>土地</li><li>资本<ul><li>建筑物</li><li>用来生产的机器<h3 id="2-2-2-生产可能性边界"><a href="#2-2-2-生产可能性边界" class="headerlink" title="2.2.2 生产可能性边界"></a>2.2.2 生产可能性边界</h3></li></ul></li></ul></li></ul></li></ul></li><li><p>表明的是在生产要素和生产技术既定的情况下，一个经济所能生产的产品的各种数量的组合</p><ul><li>一条凹下去的曲线</li><li>在内部，失业，窝工</li><li>外部，无法实现</li><li>生产力提升，边界，y，x轴点的提升</li></ul></li><li><p>为什么不是直线呢？ </p><ul><li>边际转化率<ul><li>一个产品的增加导致另外一个产品的减少</li><li>转化率会有很大的变化<ul><li>比如边际状态，一个产品制造的转移，会使得做这个产品最熟练的工人转移，生产力大大减小，而对于另外一个产品的生产力的提升并不会有同等程度的增加</li></ul></li></ul></li></ul></li></ul><h2 id="2-3-作为政策顾问的经济学家"><a href="#2-3-作为政策顾问的经济学家" class="headerlink" title="2.3 作为政策顾问的经济学家"></a>2.3 作为政策顾问的经济学家</h2><ul><li>作为政策顾问，试图做出关于世界应该是什么样子的规范表述<ul><li>不是已经发生的，或者是能够规范到</li><li>是不能证伪的</li></ul></li></ul><h1 id="3-相互依存性与贸易的好处"><a href="#3-相互依存性与贸易的好处" class="headerlink" title="3. 相互依存性与贸易的好处"></a>3. 相互依存性与贸易的好处</h1><h2 id="3-1-相互依存性与贸易好处"><a href="#3-1-相互依存性与贸易好处" class="headerlink" title="3.1 相互依存性与贸易好处"></a>3.1 相互依存性与贸易好处</h2><ul><li><p>我们正在享用世界上的人给我们提供的服务</p><ul><li>为什么我们要相互依赖？ <ul><li>贸易使得每个人的状况会更好。</li><li>为什么国家之间会相互依存？</li><li>为什么还会存在贸易保护呢？ </li></ul></li></ul></li><li><p>贸易的必要性</p><ul><li><p>贸易有可能使得生产可能性曲线更凹 </p><ul><li>对双方都会有利</li></ul></li><li><p>绝对优势</p><ul><li>用比另一个生产者更少的投入来生产某种物品的能力</li></ul></li><li><p>比较优势原理</p><ul><li>用比另一个生产者更少的机会成本来生产某种物品的能力</li></ul></li><li><p>贸易获得的利益来源于比较优势。当每个国家专门生产它具有比较优势的物品的时候，所有国家的总产量会更高，世界的经济蛋糕也会更大。</p></li></ul></li></ul><h2 id="3-2-实际应用"><a href="#3-2-实际应用" class="headerlink" title="3.2 实际应用"></a>3.2 实际应用</h2><ul><li><p>小国更容易在贸易当中获利 </p><ul><li>亚洲四小龙  – 出口导向<ul><li>经济腾飞</li><li>劳动密集型</li><li>贸易获利，经济同质性强</li></ul></li></ul></li><li><p>中美贸易</p><ul><li>产品摩擦变大</li><li>中国对美国进出口依赖度降低，然而美国对中国的是呈上升趋势的</li></ul></li><li><p>我国强调产业升级，开始出现重叠了</p></li></ul><h1 id="4-供给与需求的市场力量"><a href="#4-供给与需求的市场力量" class="headerlink" title="4. 供给与需求的市场力量"></a>4. 供给与需求的市场力量</h1><ul><li><p>供给与供给量</p></li><li><p>需求与需求量</p></li><li><p>供需曲线的研究，对实际场景的分析</p><h2 id="4-1-物品需求"><a href="#4-1-物品需求" class="headerlink" title="4.1 物品需求"></a>4.1 物品需求</h2></li><li><p>市场</p><ul><li>买方卖方在一起</li></ul></li><li><p>市场势力</p><ul><li>卖方买方不适当的影响商品价格的能力</li></ul></li><li><p>完全竞争市场</p><ul><li>可供销售物品完全相同</li><li>买方卖方人数众多，以至于没有任何一个买方或卖方可以影响市场价格，每个人都是价格接受者(price taker)</li><li>比如农贸市场，地摊</li></ul></li><li><p>垄断</p><ul><li>电网</li><li>铁路</li><li>烟草</li></ul></li><li><p>寡头市场</p><ul><li>汽车</li><li>钢铁</li><li>造船</li><li>石油化工</li><li>有色冶金</li><li>飞机制造</li><li>航空运输</li></ul></li><li><p>垄断竞争</p><ul><li>洗发水</li><li>服装</li><li>药品</li></ul></li><li><p>需求</p><ul><li>物品需求量</li><li>买者愿意并且能够购买的一种物品的数量</li></ul></li><li><p>需求定理</p><ul><li>认为在其他条件不变的时候，一种物品的价格上升，对该物品的需求量会减少</li></ul></li><li><p>需求曲线</p><ul><li><p>表示在其他条件不变的情况下，价格和需求量之间的关系的图形</p></li><li><p>纵轴为价格，横轴为需求量，斜率为负，因为二者的增长态势是相反的</p></li><li><p>价格为自变量，需求为因变量</p></li><li><p>常见的其他条件 – 影响需求曲线变动的因素</p><ul><li><p>买者数量</p><ul><li>买者数量的增加会增加每一种价格水平下的需求量，从而使需求曲线向右移动</li></ul></li><li><p>收入</p><ul><li>正常商品<ul><li>收入上升，需求上升</li></ul></li><li>低档商品<ul><li>收入上升，需求下降</li></ul></li></ul></li><li><p>相关物品的价格</p><ul><li>替代品<ul><li>披萨和汉堡</li><li>可口可乐和百事可乐</li></ul></li><li>互补品<ul><li>电脑和软件</li><li>汽车和石油</li></ul></li></ul></li><li><p>嗜好</p></li><li><p>预期</p><ul><li>对未来的价格的预期</li><li>预期未来收入增加，那么对一些高档品的需求现在就有可能增加</li></ul></li></ul></li></ul></li><li><p>市场需求量</p><ul><li>所有买者在每一个价格水平下的需求量的总和</li></ul></li><li><p>需求 vs 需求量</p><ul><li>需求的变动指除了商品价格以外的其他因素引起的变动，图上表现为需求曲线的平行移动</li><li>供给量的变动指由价格变动引起的变动<h2 id="4-2-物品供给"><a href="#4-2-物品供给" class="headerlink" title="4.2 物品供给"></a>4.2 物品供给</h2></li></ul></li><li><p>从卖方角度来看</p></li><li><p>供给量</p><ul><li>卖者愿意并且能够出售的一种物品的数量</li></ul></li><li><p>供给定理</p><ul><li>认为在其他条件不变的时候，一种物品价格的上升，会使得该物品的供给量增加</li></ul></li><li><p>市场供给</p><ul><li>在每种价格水平下所有卖者的供给量之和</li></ul></li><li><p>市场供给曲线</p><ul><li>价格为纵轴，横轴为供给量，价格为自变量</li><li>影响曲线移动的因素<ul><li>投入品的价格<ul><li>价格下降，供给量提高</li></ul></li><li>技术水平</li><li>卖者的数量</li><li>预期</li></ul></li></ul></li></ul><h2 id="4-3-需求与供给的结合"><a href="#4-3-需求与供给的结合" class="headerlink" title="4.3 需求与供给的结合"></a>4.3 需求与供给的结合</h2><ul><li><p>供给需求曲线 – 大剪刀图 lol </p><ul><li>交点<ul><li>均衡<ul><li>供给量和需求量的相等</li></ul></li></ul></li><li>过剩  <ul><li>供给大于需求</li><li>厂商需要降价</li><li>需求量会相对上升</li></ul></li><li>短缺<ul><li>厂商愿意供给量少</li><li>想买，买不到，买者提高价格买</li><li>厂商来更多生产</li></ul></li></ul></li><li><p>分析市场价格的变动</p><ul><li><ol><li>使供给曲线移动还是需求曲线移动还是都移动</li></ol></li><li><ol start="2"><li>确定曲线的移动方向</li></ol></li><li><ol start="3"><li>用供求图来说明这种移动如何改变均衡价格和均衡数量的</li></ol></li></ul></li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li>学堂在线 经济学原理(微观部分) <a href="https://next.xuetangx.com/learn/THU02011001169" target="_blank" rel="noopener">https://next.xuetangx.com/learn/THU02011001169</a> </li><li>曼昆 经济学原理 第6版</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-导论&quot;&gt;&lt;a href=&quot;#1-导论&quot; class=&quot;headerlink&quot; title=&quot;1. 导论&quot;&gt;&lt;/a&gt;1. 导论&lt;/h1&gt;&lt;h2 id=&quot;1-1-经济学发展史&quot;&gt;&lt;a href=&quot;#1-1-经济学发展史&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="Notes" scheme="https://www.llchen60.com/categories/Notes/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式-结构型-享元模式</title>
    <link href="https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-06-28T03:14:26.000Z</published>
    <updated>2020-06-28T03:14:52.407Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-原理与实现"><a href="#1-原理与实现" class="headerlink" title="1. 原理与实现"></a>1. 原理与实现</h1><ul><li><p>享元模式 Flyweight Design Pattern </p><ul><li><p>用来复用对象，节省内存，</p></li><li><p>前提条件，享元对象是不可变对象</p><ul><li>不可以暴露任何set（）等修改内部状态的方法</li></ul></li><li><p>当一个系统中存在大量重复对象的时候，如果重复对象都是不可变对象，我们就可以利用享元模式将对象设计成享元，在内存中只保留一份实例，供多处代码来引用。</p></li></ul></li></ul><ul><li>是通过工厂模式，在工厂类当中，通过一个Map来缓存已经创建过的享元对象，来达到复用的目的</li></ul><ul><li>文本文件对于字体格式进行享元操作</li></ul><pre><code>public class CharacterStyle {  private Font font;  private int size;  private int colorRGB;  public CharacterStyle(Font font, int size, int colorRGB) {    this.font = font;    this.size = size;    this.colorRGB = colorRGB;  }  @Override  public boolean equals(Object o) {    CharacterStyle otherStyle = (CharacterStyle) o;    return font.equals(otherStyle.font)            &amp;&amp; size == otherStyle.size            &amp;&amp; colorRGB == otherStyle.colorRGB;  }}public class CharacterStyleFactory {  private static final List&lt;CharacterStyle&gt; styles = new ArrayList&lt;&gt;();  public static CharacterStyle getStyle(Font font, int size, int colorRGB) {    CharacterStyle newStyle = new CharacterStyle(font, size, colorRGB);    for (CharacterStyle style : styles) {      if (style.equals(newStyle)) {        return style;      }    }    styles.add(newStyle);    return newStyle;  }}public class Character {  private char c;  private CharacterStyle style;  public Character(char c, CharacterStyle style) {    this.c = c;    this.style = style;  }}public class Editor {  private List&lt;Character&gt; chars = new ArrayList&lt;&gt;();  public void appendCharacter(char c, Font font, int size, int colorRGB) {    Character character = new Character(c, CharacterStyleFactory.getStyle(font, size, colorRGB));    chars.add(character);  }}</code></pre><h1 id="2-享元模式在Java-Integer以及String当中的应用"><a href="#2-享元模式在Java-Integer以及String当中的应用" class="headerlink" title="2. 享元模式在Java Integer以及String当中的应用"></a>2. 享元模式在Java Integer以及String当中的应用</h1><pre><code>/** * Cache to support the object identity semantics of autoboxing for values between * -128 and 127 (inclusive) as required by JLS. * * The cache is initialized on first usage.  The size of the cache * may be controlled by the {@code -XX:AutoBoxCacheMax=&lt;size&gt;} option. * During VM initialization, java.lang.Integer.IntegerCache.high property * may be set and saved in the private system properties in the * sun.misc.VM class. */private static class IntegerCache {    static final int low = -128;    static final int high;    static final Integer cache[];    static {        // high value may be configured by property        int h = 127;        String integerCacheHighPropValue =            sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;);        if (integerCacheHighPropValue != null) {            try {                int i = parseInt(integerCacheHighPropValue);                i = Math.max(i, 127);                // Maximum array size is Integer.MAX_VALUE                h = Math.min(i, Integer.MAX_VALUE - (-low) -1);            } catch( NumberFormatException nfe) {                // If the property cannot be parsed into an int, ignore it.            }        }        high = h;        cache = new Integer[(high - low) + 1];        int j = low;        for(int k = 0; k &lt; cache.length; k++)            cache[k] = new Integer(j++);        // range [-128, 127] must be interned (JLS7 5.1.7)        assert IntegerCache.high &gt;= 127;    }    private IntegerCache() {}}</code></pre><p>IntegerCache 缓存在-128到127之间的内容，即指向的是同样的内存地址的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-原理与实现&quot;&gt;&lt;a href=&quot;#1-原理与实现&quot; class=&quot;headerlink&quot; title=&quot;1. 原理与实现&quot;&gt;&lt;/a&gt;1. 原理与实现&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;享元模式 Flyweight Design Pattern &lt;/p&gt;
&lt;ul&gt;
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="享元模式" scheme="https://www.llchen60.com/tags/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-结构型-组合模式</title>
    <link href="https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-06-25T03:32:25.000Z</published>
    <updated>2020-06-25T03:32:55.978Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-原理和实现"><a href="#1-原理和实现" class="headerlink" title="1. 原理和实现"></a>1. 原理和实现</h1><p>组合模式，是用来处理树形结构的数据的。</p><ul><li>Compose objects into tree structure to represent part-whole hierarchies. Composite lets client treat individual objects and compositions of objects uniformly. </li><li>将一组对象组织成树形结构，来表示一种 部分-整体的层次结构，组合让客户端可以统一单个对象和组合对象的处理逻辑。</li></ul><h1 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="2. 应用场景"></a>2. 应用场景</h1><ul><li>现在设计一个类来表示文件系统中的目录，来方便地实现下面的功能：<ul><li>动态添加、删除某个目录下的子目录或文件</li><li>统计指定目录下的文件个数</li><li>统计指定目录下的文件总大小</li></ul></li></ul><pre><code>public class FileSystemNode {  private String path;  private boolean isFile;  private List&lt;FileSystemNode&gt; subNodes = new ArrayList&lt;&gt;();  public FileSystemNode(String path, boolean isFile) {    this.path = path;    this.isFile = isFile;  }  public int countNumOfFiles() {    if (isFile) { return 1; }     int numOfFiles = 0;     for (FileSystemNode fileOrDir : subNodes) {         numOfFiles += fileOrDir.countNumOfFiles();     }     return numOfFiles;  }  public long countSizeOfFiles() {    if (isFile) {              File file = new File(path);              if (!file.exists()) return 0;              return file.length();        }        long sizeofFiles = 0;        for (FileSystemNode fileOrDir : subNodes) {              sizeofFiles += fileOrDir.countSizeOfFiles();        }        return sizeofFiles;  }  public String getPath() {    return path;  }  public void addSubNode(FileSystemNode fileOrDir) {    subNodes.add(fileOrDir);  }  public void removeSubNode(FileSystemNode fileOrDir) {    int size = subNodes.size();    int i = 0;    for (; i &lt; size; ++i) {      if (subNodes.get(i).getPath().equalsIgnoreCase(fileOrDir.getPath())) {        break;      }    }    if (i &lt; size) {      subNodes.remove(i);    }  }}</code></pre><ul><li>而后对文件和目录进行区分设计</li></ul><pre><code>public abstract class FileSystemNode {  protected String path;  public FileSystemNode(String path) {    this.path = path;  }  public abstract int countNumOfFiles();  public abstract long countSizeOfFiles();  public String getPath() {    return path;  }}public class File extends FileSystemNode {  public File(String path) {    super(path);  }  @Override  public int countNumOfFiles() {    return 1;  }  @Override  public long countSizeOfFiles() {    java.io.File file = new java.io.File(path);    if (!file.exists()) return 0;    return file.length();  }}public class Directory extends FileSystemNode {  private List&lt;FileSystemNode&gt; subNodes = new ArrayList&lt;&gt;();  public Directory(String path) {    super(path);  }  @Override  public int countNumOfFiles() {    int numOfFiles = 0;    for (FileSystemNode fileOrDir : subNodes) {      numOfFiles += fileOrDir.countNumOfFiles();    }    return numOfFiles;  }  @Override  public long countSizeOfFiles() {    long sizeofFiles = 0;    for (FileSystemNode fileOrDir : subNodes) {      sizeofFiles += fileOrDir.countSizeOfFiles();    }    return sizeofFiles;  }  public void addSubNode(FileSystemNode fileOrDir) {    subNodes.add(fileOrDir);  }  public void removeSubNode(FileSystemNode fileOrDir) {    int size = subNodes.size();    int i = 0;    for (; i &lt; size; ++i) {      if (subNodes.get(i).getPath().equalsIgnoreCase(fileOrDir.getPath())) {        break;      }    }    if (i &lt; size) {      subNodes.remove(i);    }  }}public class Demo {  public static void main(String[] args) {    /**     * /     * /wz/     * /wz/a.txt     * /wz/b.txt     * /wz/movies/     * /wz/movies/c.avi     * /xzg/     * /xzg/docs/     * /xzg/docs/d.txt     */    Directory fileSystemTree = new Directory(&quot;/&quot;);    Directory node_wz = new Directory(&quot;/wz/&quot;);    Directory node_xzg = new Directory(&quot;/xzg/&quot;);    fileSystemTree.addSubNode(node_wz);    fileSystemTree.addSubNode(node_xzg);    File node_wz_a = new File(&quot;/wz/a.txt&quot;);    File node_wz_b = new File(&quot;/wz/b.txt&quot;);    Directory node_wz_movies = new Directory(&quot;/wz/movies/&quot;);    node_wz.addSubNode(node_wz_a);    node_wz.addSubNode(node_wz_b);    node_wz.addSubNode(node_wz_movies);    File node_wz_movies_c = new File(&quot;/wz/movies/c.avi&quot;);    node_wz_movies.addSubNode(node_wz_movies_c);    Directory node_xzg_docs = new Directory(&quot;/xzg/docs/&quot;);    node_xzg.addSubNode(node_xzg_docs);    File node_xzg_docs_d = new File(&quot;/xzg/docs/d.txt&quot;);    node_xzg_docs.addSubNode(node_xzg_docs_d);    System.out.println(&quot;/ files num:&quot; + fileSystemTree.countNumOfFiles());    System.out.println(&quot;/wz/ files num:&quot; + node_wz.countNumOfFiles());  }}</code></pre><blockquote><p>将一组对象（文件和目录）组织成树形结构，以表示一种‘部分 - 整体’的层次结构（目录与子目录的嵌套结构）。组合模式让客户端可以统一单个对象（文件）和组合对象（目录）的处理逻辑（递归遍历）</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-原理和实现&quot;&gt;&lt;a href=&quot;#1-原理和实现&quot; class=&quot;headerlink&quot; title=&quot;1. 原理和实现&quot;&gt;&lt;/a&gt;1. 原理和实现&lt;/h1&gt;&lt;p&gt;组合模式，是用来处理树形结构的数据的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Compose objects
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="组合模式" scheme="https://www.llchen60.com/tags/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-结构型-门面模式</title>
    <link href="https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-06-24T05:39:48.000Z</published>
    <updated>2020-06-24T05:40:23.631Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-原理与实现"><a href="#1-原理与实现" class="headerlink" title="1. 原理与实现"></a>1. 原理与实现</h1><p>门面模式应用场景主要在于接口设计方面，是为了处理和解决接口粒度的相关问题。</p><p>为了保证接口的可复用性(通用性)，我们需要将接口设计的粒度细一些，职责单一。但是，如果接口的粒度过小，在接口使用者开发一个业务功能的时候，就需要开发不同的接口来满足，这样会导致系统的接口无限膨胀。</p><ul><li>门面模式  Facade Design Pattern <ul><li>provide a unified interface to a set of interfaces in a subsystem</li><li>facade pattern defines a higher level interface that makes the subsystem easier to use </li></ul></li></ul><ul><li>场景举例<ul><li>比如系统A提供a,b,c,d四个接口，系统B完成某个业务功能，需要调用A系统的a,b,d接口。利用门面模式，提供一个包裹a,b,d接口调用的门面接口x，给系统B直接使用</li><li>如果上述AB一个是后端，一个是APP端的话，那么他们之间网络通信耗时会比较多</li></ul></li></ul><h1 id="2-门面模式的应用场景"><a href="#2-门面模式的应用场景" class="headerlink" title="2. 门面模式的应用场景"></a>2. 门面模式的应用场景</h1><h2 id="2-1-解决易用性问题"><a href="#2-1-解决易用性问题" class="headerlink" title="2.1 解决易用性问题"></a>2.1 解决易用性问题</h2><ul><li>封装系统的底层实现，隐藏系统的复杂性</li><li>提供一组更加简单易用，更高层的接口</li><li>例子<ul><li>Linux系统调用函数<ul><li>封装了底层Linux内核的调用</li></ul></li><li>Shell指令<ul><li>封装系统调用</li><li>提供更加友好的指令</li></ul></li></ul></li></ul><h2 id="2-2-解决性能问题"><a href="#2-2-解决性能问题" class="headerlink" title="2.2 解决性能问题"></a>2.2 解决性能问题</h2><ul><li>当使用一个门面接口替换多个接口的调用的时候，减少了网络通信成本</li><li>如果门面接口比较多<ul><li>可以抽象出一层，专门放置门面接口</li><li>如果跨多个子系统，可以将门面接口放到一个新的子系统当中</li></ul></li></ul><h2 id="2-3-解决分布式事务问题"><a href="#2-3-解决分布式事务问题" class="headerlink" title="2.3 解决分布式事务问题"></a>2.3 解决分布式事务问题</h2><p>在一个金融系统中，有两个业务领域模型，用户和钱包。这两个业务领域模型都对外暴露了一系列接口，比如用户的增删改查接口、钱包的增删改查接口。假设有这样一个业务场景：在用户注册的时候，我们不仅会创建用户（在数据库 User 表中），还会给用户创建一个钱包（在数据库的 Wallet 表中）。</p><p>对于这样一个简单的业务需求，我们可以通过依次调用用户的创建接口和钱包的创建接口来完成。但是，用户注册需要支持事务，也就是说，创建用户和钱包的两个操作，要么都成功，要么都失败，不能一个成功、一个失败。</p><p>要支持两个接口调用在一个事务中执行，是比较难实现的，这涉及分布式事务问题。虽然我们可以通过引入分布式事务框架或者事后补偿的机制来解决，但代码实现都比较复杂。而最简单的解决方案是，利用数据库事务或者 Spring 框架提供的事务（如果是 Java 语言的话），在一个事务中，执行创建用户和创建钱包这两个 SQL 操作。这就要求两个 SQL 操作要在一个接口中完成，所以，我们可以借鉴门面模式的思想，再设计一个包裹这两个操作的新接口，让新接口在一个事务中执行两个 SQL 操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-原理与实现&quot;&gt;&lt;a href=&quot;#1-原理与实现&quot; class=&quot;headerlink&quot; title=&quot;1. 原理与实现&quot;&gt;&lt;/a&gt;1. 原理与实现&lt;/h1&gt;&lt;p&gt;门面模式应用场景主要在于接口设计方面，是为了处理和解决接口粒度的相关问题。&lt;/p&gt;
&lt;p&gt;为了保
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="门面模式" scheme="https://www.llchen60.com/tags/%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-结构型-适配器模式</title>
    <link href="https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-06-24T03:55:54.000Z</published>
    <updated>2020-06-23T03:56:23.132Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-适配器模式原理和实现"><a href="#1-适配器模式原理和实现" class="headerlink" title="1. 适配器模式原理和实现"></a>1. 适配器模式原理和实现</h1><ul><li><p>Adapter Design Pattern </p><ul><li>做适配的，将不兼容的接口转换为可兼容的接口</li><li>将原本由于接口不兼容而不能一起工作的类一起工作</li></ul></li><li><p>实现方式</p><ul><li>类适配器<ul><li>使用继承关系实现</li></ul></li><li>对象适配器<ul><li>使用组合关系实现</li></ul></li></ul></li></ul><pre><code>// 类适配器: 基于继承public interface ITarget {  void f1();  void f2();  void fc();}public class Adaptee {  public void fa() { //... }  public void fb() { //... }  public void fc() { //... }}public class Adaptor extends Adaptee implements ITarget {  public void f1() {    super.fa();  }  public void f2() {    //...重新实现f2()...  }  // 这里fc()不需要实现，直接继承自Adaptee，这是跟对象适配器最大的不同点}// 对象适配器：基于组合public interface ITarget {  void f1();  void f2();  void fc();}public class Adaptee {  public void fa() { //... }  public void fb() { //... }  public void fc() { //... }}public class Adaptor implements ITarget {  private Adaptee adaptee;  public Adaptor(Adaptee adaptee) {    this.adaptee = adaptee;  }  public void f1() {    adaptee.fa(); //委托给Adaptee  }  public void f2() {    //...重新实现f2()...  }  public void fc() {    adaptee.fc();  }}</code></pre><ul><li><p>类适配器和对象适配器的选择取决于</p><ul><li>Adaptee接口的个数</li><li>Adaptee 和Itarget的契合程度</li></ul></li><li><p>如果 Adaptee 接口并不多，那两种实现方式都可以。</p></li><li><p>如果 Adaptee 接口很多，而且 Adaptee 和 ITarget 接口定义大部分都相同，那我们推荐使用类适配器，因为 Adaptor 复用父类 Adaptee 的接口，比起对象适配器的实现方式，Adaptor 的代码量要少一些。</p></li><li><p>如果 Adaptee 接口很多，而且 Adaptee 和 ITarget 接口定义大部分都不相同，那我们推荐使用对象适配器，因为组合结构相对于继承更加灵活。</p></li></ul><h1 id="2-应用场景总结"><a href="#2-应用场景总结" class="headerlink" title="2. 应用场景总结"></a>2. 应用场景总结</h1><ul><li>适配器模式 – 一种补偿模式<ul><li>主要用来弥补一些设计上的缺陷</li><li>主要用来解决接口不兼容的问题</li></ul></li></ul><h2 id="2-1-封装有缺陷的接口设计"><a href="#2-1-封装有缺陷的接口设计" class="headerlink" title="2.1 封装有缺陷的接口设计"></a>2.1 封装有缺陷的接口设计</h2><p>譬如我们依赖的外部系统在接口设计上有缺陷（包含大量的静态方法），引入后会影响到我们自身代码的可测试性。为了隔离设计上的缺陷，我们希望对外部系统提供的接口进行二次封装，抽象出更好的接口设计。</p><pre><code>public class CD { //这个类来自外部sdk，我们无权修改它的代码  //...  public static void staticFunction1() { //... }  public void uglyNamingFunction2() { //... }  public void tooManyParamsFunction3(int paramA, int paramB, ...) { //... }   public void lowPerformanceFunction4() { //... }}// 使用适配器模式进行重构public class ITarget {  void function1();  void function2();  void fucntion3(ParamsWrapperDefinition paramsWrapper);  void function4();  //...}// 注意：适配器类的命名不一定非得末尾带Adaptorpublic class CDAdaptor extends CD implements ITarget {  //...  public void function1() {     super.staticFunction1();  }  public void function2() {    super.uglyNamingFucntion2();  }  public void function3(ParamsWrapperDefinition paramsWrapper) {     super.tooManyParamsFunction3(paramsWrapper.getParamA(), ...);  }  public void function4() {    //...reimplement it...  }}</code></pre><h2 id="2-2-统一多个类的接口设计"><a href="#2-2-统一多个类的接口设计" class="headerlink" title="2.2 统一多个类的接口设计"></a>2.2 统一多个类的接口设计</h2><p>某个功能的实现依赖多个外部系统，通过适配器模式，将其接口适配为统一的接口定义，然后使用多态的特性来复用代码逻辑。</p><p>下述代码使用适配器模式来处理有不同的接口设计的几个来自第三方做词汇过滤的API</p><pre><code>public class ASensitiveWordsFilter { // A敏感词过滤系统提供的接口  //text是原始文本，函数输出用***替换敏感词之后的文本  public String filterSexyWords(String text) {    // ...  }  public String filterPoliticalWords(String text) {    // ...  } }public class BSensitiveWordsFilter  { // B敏感词过滤系统提供的接口  public String filter(String text) {    //...  }}public class CSensitiveWordsFilter { // C敏感词过滤系统提供的接口  public String filter(String text, String mask) {    //...  }}// 未使用适配器模式之前的代码：代码的可测试性、扩展性不好public class RiskManagement {  private ASensitiveWordsFilter aFilter = new ASensitiveWordsFilter();  private BSensitiveWordsFilter bFilter = new BSensitiveWordsFilter();  private CSensitiveWordsFilter cFilter = new CSensitiveWordsFilter();  public String filterSensitiveWords(String text) {    String maskedText = aFilter.filterSexyWords(text);    maskedText = aFilter.filterPoliticalWords(maskedText);    maskedText = bFilter.filter(maskedText);    maskedText = cFilter.filter(maskedText, &quot;***&quot;);    return maskedText;  }}// 使用适配器模式进行改造public interface ISensitiveWordsFilter { // 统一接口定义  String filter(String text);}public class ASensitiveWordsFilterAdaptor implements ISensitiveWordsFilter {  private ASensitiveWordsFilter aFilter;  public String filter(String text) {    String maskedText = aFilter.filterSexyWords(text);    maskedText = aFilter.filterPoliticalWords(maskedText);    return maskedText;  }}//...省略BSensitiveWordsFilterAdaptor、CSensitiveWordsFilterAdaptor...// 扩展性更好，更加符合开闭原则，如果添加一个新的敏感词过滤系统，// 这个类完全不需要改动；而且基于接口而非实现编程，代码的可测试性更好。public class RiskManagement {   private List&lt;ISensitiveWordsFilter&gt; filters = new ArrayList&lt;&gt;();  public void addSensitiveWordsFilter(ISensitiveWordsFilter filter) {    filters.add(filter);  }  public String filterSensitiveWords(String text) {    String maskedText = text;    for (ISensitiveWordsFilter filter : filters) {      maskedText = filter.filter(maskedText);    }    return maskedText;  }}</code></pre><h2 id="2-3-替换依赖的外部系统"><a href="#2-3-替换依赖的外部系统" class="headerlink" title="2.3 替换依赖的外部系统"></a>2.3 替换依赖的外部系统</h2><pre><code>// 外部系统Apublic interface IA {  //...  void fa();}public class A implements IA {  //...  public void fa() { //... }}// 在我们的项目中，外部系统A的使用示例public class Demo {  private IA a;  public Demo(IA a) {    this.a = a;  }  //...}Demo d = new Demo(new A());// 将外部系统A替换成外部系统Bpublic class BAdaptor implemnts IA {  private B b;  public BAdaptor(B b) {    this.b= b;  }  public void fa() {    //...    b.fb();  }}// 借助BAdaptor，Demo的代码中，调用IA接口的地方都无需改动，// 只需要将BAdaptor如下注入到Demo即可。Demo d = new Demo(new BAdaptor(new B()));</code></pre><h2 id="2-4-兼容老版本的接口"><a href="#2-4-兼容老版本的接口" class="headerlink" title="2.4 兼容老版本的接口"></a>2.4 兼容老版本的接口</h2><p>做版本升级的时候，对于一些要废弃的接口，不能直接将其删除，而是暂时保留，并且标注为deprecated，并将内部实现逻辑委托为新的接口实现。这样就可以是的项目有个过渡期。</p><p>Enumeration –&gt; Iterator的升级</p><pre><code>public class Collections {  public static Emueration emumeration(final Collection c) {    return new Enumeration() {      Iterator i = c.iterator();      public boolean hasMoreElments() {        return i.hashNext();      }      public Object nextElement() {        return i.next():      }    }  }}</code></pre><h1 id="3-代理-vs-桥接-vs-装饰器-vs-适配器"><a href="#3-代理-vs-桥接-vs-装饰器-vs-适配器" class="headerlink" title="3. 代理 vs 桥接 vs 装饰器 vs 适配器"></a>3. 代理 vs 桥接 vs 装饰器 vs 适配器</h1><ul><li><p>代理模式</p><ul><li>在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是访问控制，而非加强功能</li></ul></li><li><p>桥接模式</p><ul><li>将接口部分和实现部分分离，使得其能够相对独立的进行改变</li></ul></li><li><p>装饰器模式</p><ul><li>在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用</li></ul></li><li><p>适配器模式</p><ul><li>事后补救策略，适配器提供跟原始类不同的接口</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-适配器模式原理和实现&quot;&gt;&lt;a href=&quot;#1-适配器模式原理和实现&quot; class=&quot;headerlink&quot; title=&quot;1. 适配器模式原理和实现&quot;&gt;&lt;/a&gt;1. 适配器模式原理和实现&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Adapter Design Patt
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="适配器模式" scheme="https://www.llchen60.com/tags/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-结构型-装饰器模式</title>
    <link href="https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-06-23T03:09:04.000Z</published>
    <updated>2020-06-23T03:09:29.625Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a>1. Overview</h1><h2 id="1-1-Java-IO类的使用"><a href="#1-1-Java-IO类的使用" class="headerlink" title="1.1 Java IO类的使用"></a>1.1 Java IO类的使用</h2><table><thead><tr><th></th><th>字节流</th><th>字符流</th></tr></thead><tbody><tr><td>输入流</td><td>InputStream</td><td>Reader</td></tr><tr><td>输出流</td><td>OutputStream</td><td>Writer</td></tr></tbody></table><p>JavaIO库非常庞大，几十个类一同来负责IO数据的读取和写入。</p><pre><code>InputStream in = new FileInputStream(&quot;/user/wangzheng/test.txt&quot;);InputStream bin = new BufferedInputStream(in);byte[] data = new byte[128];while (bin.read(data) != -1) {  //...}</code></pre><p>上述代码先使用了FileInputStream来读取文件流，然后又使用了BufferedInputStream，来支持缓存。</p><p>问题来了，为什么不能设置一个继承了FileInputStream并且支持缓存的BufferedFileInputStream类呢？ </p><p>问题在于各种use case太多，如果为了各种功能的组合都设置一个类的话，那么类的继承结构会变得非常负责，代码会变得很难扩展和维护。</p><p>Java IO的设计思路，就是使用组合来替代继承</p><pre><code>public abstract class InputStream {  //...  public int read(byte b[]) throws IOException {    return read(b, 0, b.length);  }  public int read(byte b[], int off, int len) throws IOException {    //...  }  public long skip(long n) throws IOException {    //...  }  public int available() throws IOException {    return 0;  }  public void close() throws IOException {}  public synchronized void mark(int readlimit) {}  public synchronized void reset() throws IOException {    throw new IOException(&quot;mark/reset not supported&quot;);  }  public boolean markSupported() {    return false;  }}public class BufferedInputStream extends InputStream {  protected volatile InputStream in;  protected BufferedInputStream(InputStream in) {    this.in = in;  }  //...实现基于缓存的读数据接口...  }public class DataInputStream extends InputStream {  protected volatile InputStream in;  protected DataInputStream(InputStream in) {    this.in = in;  }  //...实现读取基本类型数据的接口}</code></pre><h2 id="1-2-装饰器模式"><a href="#1-2-装饰器模式" class="headerlink" title="1.2 装饰器模式"></a>1.2 装饰器模式</h2><ul><li>使用组合来替代继承关系</li><li>装饰器类和原始类继承同样的父类，这样我们就可以对原始类嵌套多个装饰器类</li><li>是对功能的增强，是和原始功能相关的</li><li>为了解决继承关系过于复杂的问题</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Overview&quot;&gt;&lt;a href=&quot;#1-Overview&quot; class=&quot;headerlink&quot; title=&quot;1. Overview&quot;&gt;&lt;/a&gt;1. Overview&lt;/h1&gt;&lt;h2 id=&quot;1-1-Java-IO类的使用&quot;&gt;&lt;a href=&quot;#1-1-
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="装饰器模式" scheme="https://www.llchen60.com/tags/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-结构型-桥接模式</title>
    <link href="https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-06-21T21:54:45.000Z</published>
    <updated>2020-06-21T21:55:09.965Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-原理解析"><a href="#1-原理解析" class="headerlink" title="1. 原理解析"></a>1. 原理解析</h1><ul><li>桥接模式 Bridge Design Pattern<ul><li>将抽象和实现解耦，使之可以独立变化</li><li>一个类存在两个或者多个独立变化的维度，通过组合的方式，让这几个维度都可以独立进行扩展<ul><li>通过组合关系来替代继承关系，避免继承层次的指数级爆炸</li></ul></li></ul></li></ul><h2 id="1-1-JDBC驱动的实现"><a href="#1-1-JDBC驱动的实现" class="headerlink" title="1.1 JDBC驱动的实现"></a>1.1 JDBC驱动的实现</h2><pre><code>    Class.forName(&quot;com.mysql.jdbc.Driver&quot;);//加载及注册JDBC驱动程序    String url = &quot;jdbc:mysql://localhost:3306/sample_db?user=root&amp;password=your_password&quot;;    Connection con = DriverManager.getConnection(url);    Statement stmt = con.createStatement()；    String query = &quot;select * from test&quot;;    ResultSet rs=stmt.executeQuery(query);    while(rs.next()) {      rs.getString(1);      rs.getInt(2);    }</code></pre><ul><li>上述代码中只要改变forName中的路径，就可以改变数据库了</li><li>或者我们可以通过将加载的Driver类写到配置文件当中，来实现数据库的切换，只需要修改配置文件就可以完成数据库的切换了</li></ul><pre><code>package com.mysql.jdbc;import java.sql.SQLException;public class Driver extends NonRegisteringDriver implements java.sql.Driver {  static {    try {      java.sql.DriverManager.registerDriver(new Driver());    } catch (SQLException E) {      throw new RuntimeException(&quot;Can&#39;t register driver!&quot;);    }  }  /**   * Construct a new driver and register it with DriverManager   * @throws SQLException if a database error occurs.   */  public Driver() throws SQLException {    // Required for Class.forName().newInstance()  }}</code></pre><ul><li>在执行<code>Class.forName</code>的时候，首先是使得JVM查找并加载指定的Driver类，</li><li>其次是执行该类的静态代码<ul><li>实例变量需要在类实例化以后才能存在</li><li>静态变量是该类素有对象公有的，不需要实例化就已经存在了</li><li>静态代码会在类被加载的时候自动执行</li></ul></li></ul><pre><code>public class DriverManager {  private final static CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers = new CopyOnWriteArrayList&lt;DriverInfo&gt;();  //...  static {    loadInitialDrivers();    println(&quot;JDBC DriverManager initialized&quot;);  }  //...  public static synchronized void registerDriver(java.sql.Driver driver) throws SQLException {    if (driver != null) {      registeredDrivers.addIfAbsent(new DriverInfo(driver));    } else {      throw new NullPointerException();    }  }  public static Connection getConnection(String url, String user, String password) throws SQLException {    java.util.Properties info = new java.util.Properties();    if (user != null) {      info.put(&quot;user&quot;, user);    }    if (password != null) {      info.put(&quot;password&quot;, password);    }    return (getConnection(url, info, Reflection.getCallerClass()));  }  //...}</code></pre><ul><li>JDBC本身相当于抽象，即和具体的数据库无关的被抽象出来的一套类库</li><li>具体的Driver相当于实现</li></ul><h2 id="1-2-实例"><a href="#1-2-实例" class="headerlink" title="1.2 实例"></a>1.2 实例</h2><p>设计一个根据不同的告警规则，触发不同的类型的告警。</p><ul><li><p>紧急程度</p><ul><li>SEVERE</li><li>URGENCY</li><li>NORMAL</li><li>TRIVIAL</li></ul></li><li><p>通知渠道</p><ul><li>邮件</li><li>短信</li><li>微信</li><li>自动语音通话</li></ul></li><li><p>下述代码实质上就是在实现一个解耦，希望避免复杂的if else逻辑，让代码更易懂，修改更方便。</p></li></ul><pre><code>public interface MsgSender {  void send(String message);}public class TelephoneMsgSender implements MsgSender {  private List&lt;String&gt; telephones;  public TelephoneMsgSender(List&lt;String&gt; telephones) {    this.telephones = telephones;  }  @Override  public void send(String message) {    //...  }}public class EmailMsgSender implements MsgSender {  // 与TelephoneMsgSender代码结构类似，所以省略...}public class WechatMsgSender implements MsgSender {  // 与TelephoneMsgSender代码结构类似，所以省略...}public abstract class Notification {  protected MsgSender msgSender;  public Notification(MsgSender msgSender) {    this.msgSender = msgSender;  }  public abstract void notify(String message);}public class SevereNotification extends Notification {  public SevereNotification(MsgSender msgSender) {    super(msgSender);  }  @Override  public void notify(String message) {    msgSender.send(message);  }}public class UrgencyNotification extends Notification {  // 与SevereNotification代码结构类似，所以省略...}public class NormalNotification extends Notification {  // 与SevereNotification代码结构类似，所以省略...}public class TrivialNotification extends Notification {  // 与SevereNotification代码结构类似，所以省略...}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-原理解析&quot;&gt;&lt;a href=&quot;#1-原理解析&quot; class=&quot;headerlink&quot; title=&quot;1. 原理解析&quot;&gt;&lt;/a&gt;1. 原理解析&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;桥接模式 Bridge Design Pattern&lt;ul&gt;
&lt;li&gt;将抽象和实现解耦，使之
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="桥接模式" scheme="https://www.llchen60.com/tags/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
