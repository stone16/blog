<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Leilei&#39;s Blog | 磊磊的博客</title>
  
  <subtitle>Because it&#39;s there</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.llchen60.com/"/>
  <updated>2020-05-02T20:56:34.090Z</updated>
  <id>https://www.llchen60.com/</id>
  
  <author>
    <name>Leilei Chen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>货币,信贷,债务是如何运作的 from Ray Dalio</title>
    <link href="https://www.llchen60.com/%E8%B4%A7%E5%B8%81-%E4%BF%A1%E8%B4%B7-%E5%80%BA%E5%8A%A1%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E4%BD%9C%E7%9A%84-from-Ray-Dalio/"/>
    <id>https://www.llchen60.com/%E8%B4%A7%E5%B8%81-%E4%BF%A1%E8%B4%B7-%E5%80%BA%E5%8A%A1%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E4%BD%9C%E7%9A%84-from-Ray-Dalio/</id>
    <published>2020-05-02T20:55:48.000Z</published>
    <updated>2020-05-02T20:56:34.090Z</updated>
    
    <content type="html"><![CDATA[<p>Ray Dalio在LinkedIn上的长文，主要分析了在长期债务周期当中，货币、信贷、债务之间的相互运作关系，以及它们驱动全球经济和政治变化的方式。</p><h1 id="1-货币和信贷"><a href="#1-货币和信贷" class="headerlink" title="1. 货币和信贷"></a>1. 货币和信贷</h1><p>所有实体（国家、公司、非营利组织和个人）都需处理基本财务，他们的收入和支出构成了净收入，而这些流动是可以用资产负债表中的数字来衡量的。如果一个人赚的比花的多，他就会有利润，从而使他的储蓄增加。而如果一个人的支出大于收入，那么他的储蓄就会减少，或者他不得不通过借钱或来弥补差额。<br>如果一个实体拥有巨额净资产，它的支出将可以高于收入，直到资金耗尽，这时它必须削减开支。如果不削减开支，它将会有大量负债/债务，如果它没有足够的收入来偿还，它就会违约。<br><strong>由于一个人的债务是另一个人的资产，债务违约会减少其他实体的资产，进而要求它们削减开支，从而导致债务下降和经济收缩。</strong></p><p>这种货币和信用体系适用于所有人、公司、非营利组织和政府，但有一个重要的例外。所有国家都可以印钞给人们消费或放贷。然而，<strong>并不是所有政府发行的货币都具有相同的价值</strong>。</p><p>在世界范围内被广泛接受的被称为储备货币。而在当今世界上，占主导地位的储备货币是美元，由美联储发行，占所有国际交易的55%。另一种则是欧元，由欧洲央行发行，占所有国际交易的25%。目前，日元、人民币和英镑都是相对较小的储备货币，尽管人民币的重要性正迅速上升。</p><p>拥有储备货币的国家更容易通过大量借贷摆脱困境。原因在于，世界上其他国家倾向于持有这些债务和货币，因为它们可以用来在世界各地消费。因此，拥有储备货币的国家可以发行大量以储备货币计价的信贷/债务，尤其是在目前这种储备货币短缺的情况下。</p><p>而相比之下，没有储备货币的国家则没有这种选择。它们在以下情况中，特别需要这些储备货币（如美元）：（1）他们有很多以他们不能印刷的储备货币计价的债务（如美元）；（2）他们在这些储备货币上没有多少储蓄；（3）他们获得所需货币的能力下降。当没有储备货币的国家急需储备货币来偿还他们的债务，以储备货币计价和交易的卖家希望它们用储备货币来支付时，它们就只能破产。这就是现在许多国家的情况。</p><p>这也是许多州、地方政府、公司、非营利组织和个人会面临的情况。当它们遭受了收入损失，有没有多少存款来弥补损失时，它们将不得不削减开支或通过其他方式获得资金和信贷。</p><p>这就是现在的世界上正在发生的事情：<strong><em>风险储蓄即将耗尽，以及债务违约的风险。有能力这样做的政府正在印钞，以帮助减轻债务负担，并帮助为以本国货币计价的开支提供资金。但这将削弱本国货币，提高本币的通胀水平，以抵消需求减少和被迫出售资产所造成的通货紧缩，而那些资金紧张的国家就不得不筹集现金</em></strong>。</p><ul><li>Essense<ul><li>一个人的债务是另外一个人的资产，债务违约会减少其他实体的资产，进而要求其消减开支，从而导致债务下降和经济收缩的自我强化。 </li><li>美国最近的大撒钱计划，致使美元指数强势增长，这是市场的避险情绪的体现。美元是全兑换，全流通的。市场的担忧，降息，使得直接持有美元的成本降低了。机构企业采取增加现金流的方式来防止出现流动性危机</li><li>美国政府通过印钞来减轻债务负担，提供商业运作所需的资金。</li></ul></li></ul><h1 id="2-什么是货币"><a href="#2-什么是货币" class="headerlink" title="2. 什么是货币"></a>2. 什么是货币</h1><p>货币本质上是一种交换媒介，也可以用来储存财富。</p><p>不言而喻，“交换媒介”指的是可以用来买东西的工具。而所谓财富储备，指的是在获取和消费之间储存购买力的工具。最合理的方式显然就是把钱存起来，以备不时之需，但人们往往不愿意持有货币，而总想把货币兑换成他们想买的东西。这就是信贷和债务发挥作用的地方。</p><p>当出借人放贷时，他们认为收回的钱会比本身持有的钱购买更多的商品和服务。如果做得好，借贷者就能有效地使用这些钱并获得利润，进而偿还贷款并保留一些额外的钱。当贷款尚未偿还时，它是贷款人的资产，也是借款人的负债。当钱被偿还时，资产和负债就消失了，这种交换对借方和贷方都有好处。他们从本质上分享了这种生产性贷款的利润。整个社会也得益于这种机制所带来的的生产力提高。</p><p>因此，重要的是要意识到：<br>1.大多数货币和信贷（尤其是现存的法定货币）<strong>没有内在价值</strong>；<br>2.它们只是会计系统中的账目，可以很容易地改变；<br>3.系统的目的是<strong>帮助有效地分配资源以便生产力增长</strong>；<br>4.该系统会周期性崩溃。所有的货币不是被摧毁就是贬值，财富随之发生大规模转移，对经济和市场产生巨大影响。</p><p>更具体地说，货币和信贷系统并没有完美地运转，而是<strong>在循环中改变货币的供应、需求和价值，在上升时产生富裕，在下降时产生重组</strong>。</p><h2 id="2-1-从基本面出发研究货币和信贷系统的周期"><a href="#2-1-从基本面出发研究货币和信贷系统的周期" class="headerlink" title="2.1 从基本面出发研究货币和信贷系统的周期"></a>2.1 从基本面出发研究货币和信贷系统的周期</h2><p><strong>虽然金钱和信贷与财富有关，但它们不是财富</strong>。因为钱和信贷可以买到财富（即商品和服务），所以一个人拥有的金钱和信贷的数量和财富的数量看起来差不多。</p><p>但是，一个人不能仅仅通过创造更多的金钱和信贷来创造更多的财富。要创造更多的财富，就必须要有更高的生产力。金钱和信贷的创造与财富（实际商品和服务）的创造之间的关系经常被混淆，但它是经济周期的最大驱动力，因此，让我们更仔细地研究一下这种关系。</p><p>一般来说，货币和信贷的创造与商品、服务和投资资产的数量之间存在正相关关系，因此很容易混淆。当人们有更多的钱和信贷时，他们就会想消费更多。从某种程度上说，消费增加了经济生产，提高了商品、服务和金融资产的价格，这可以说是增加了财富，因为拥有这些资产的人在我们衡量财富的方式下变得“更富有”。</p><p>然而，这种形式的财富增加更像是一种幻觉。原因有二：<strong>推动价格和生产上升的信贷必须偿还；事物的内在价值并不会增加</strong>。</p><p>举个例子，如果你有一套房子，政府创造了大量的货币和信贷，你的房子的价格会上升，但它仍然是原来的样子。你的实际财富没有增加，只是你计算出来的财富增加了。同样地，如果政府创造了大量的货币和信贷，用于购买商品、服务和金融资产（如股票、债券和房地产），那么你计算所得的财富数量就会增加，但实际财富仍将保持不变。换句话说，用一个人所拥有的市场价值来衡量他的财富，会给人一种财富变化的错觉，而这种变化实际上并不存在。</p><p>重要的是，<strong>货币和信贷在发放时具有刺激作用，而在必须偿还时却有抑制作用。</strong>这就是货币、信贷和经济增长如此具有周期性的原因。</p><p>为了控制市场和整体经济，货币和信贷的成本和可获得性各不相同。当经济增长过快，他们想要放缓增长速度时，就会减少货币和信贷投放，导致两者都变得更加昂贵。这鼓励了人们充当贷方而不是借钱和消费。当经济增长太慢，央行想要刺激经济时，他们就会让货币和信贷廉价而充足，从而鼓励人们借贷、投资和/或消费。货币和信贷的成本和可用性的这些变化也会导致商品、服务和金融资产的价格和数量的涨跌。但是，银行只能在其产生货币和信贷增长的能力范围内控制经济，而它们这样做的能力是有限的。</p><p>想象一下，中央银行有一瓶兴奋剂，他们可以根据需要注入经济，而瓶中的兴奋剂数量是有限的。当市场和经济衰退时，他们会提供货币和信贷刺激来提振经济，当市场过热时，他们会减少刺激。这些变动导致货币、信贷、商品、服务和金融资产的数量和价格的周期性涨跌。而这些举措通常以短期债务周期和长期债务周期的形式出现。</p><p>短期债务周期（即通常所说的“商业周期”）通常持续8年左右。时机取决于刺激措施将需求提升至实体经济生产能力极限所需的时间。而长期债务周期就是将这些短期债务周期加起来，通常持续50-75年。因为可能很多人的一生只会出现一次长期债务周期，所以大多数人都没有意识到。</p><p>长期债务周期通常开始于重组后的低水平债务时期，央行的瓶子里有很多刺激，而结束于高水平债务时期，央行的瓶子里就没有多少刺激了。更具体地说，当央行失去通过经济体系产生货币和信贷增长、进而推动实体经济增长的能力时，央行的刺激能力就会终止。当债务水平高企、利率无法充分降低、货币和信贷的创造对金融资产价格的影响大于对实际经济活动的影响时，央行就会丧失这种能力。在这种时候，那些持有债务的人通常想要把他们持有的货币债务换成其他的财富。当人们普遍认为，将获得资金的货币和债务资产并不是良好的财富储备时，长期债务周期就结束了，必须对货币体系进行重组。</p><ul><li>Essense <ul><li>货币和信贷系统在运行过程中，下降周期里会带来重组，会造成财富的巨大转移。</li><li>金钱和信贷不是财富，但可以买到财富。创造更多的金钱和信贷不意味着更多的财富，更多的生产力才是。</li></ul></li></ul><h1 id="3-长期债务周期"><a href="#3-长期债务周期" class="headerlink" title="3. 长期债务周期"></a>3. 长期债务周期</h1><ol><li>始于无或低债务和“硬通货”</li></ol><p>金银（有时还有铜和镍等其他金属）是首选的货币形式，因为它们具有内在价值，而且可以很容易地塑形，便于携带和兑换。具有内在价值很重要，因为与他们进行交易不需要任何的信任或信用。任何交易都可以当场成交，即使买卖双方是陌生人或敌人。</p><ol start="2"><li>“纸币”的诞生</li></ol><p>因为金属货币携带不便的原因，人们很快就把纸上的“货币债权”当成了货币本身。这种类型的货币系统被称为挂钩货币系统，因为货币的价值与某种东西的价值挂钩，通常是“硬通货”，如黄金。</p><p>3.债务增加</p><p>起初，“硬通货”的债权数量与银行里的硬通货数量相同。然而，持有人和银行发现了信贷和债务的奥妙之处：人们可以把“纸币”借给银行，以换取利息；而向他们借钱的银行又可以把钱借给其他人，换取更高的利息；而那些从银行借钱的人获得了前所未有的购买力。这个过程导致了<strong>资产价格和生产的上升</strong>。</p><p>然而，当一个人没有足够的收入/钱来偿还债务时，麻烦就来了。人们期望通过出售这些债权来获得购买商品和服务的资金，其增长速度超过了商品和服务的数量，这使得从这些债务资产（例如债券）的转换变得不可能。这两个问题往往同时出现。<br>关于第一个问题，可以把债务看作是负收益和负资产，负资产吞噬收益（因为收益必须用来偿还债务），吞噬其他资产（因为必须出售其他资产来获得偿还债务的资金）。它具有更高的优先级，意思是它必须在任何其他类型的资产之前得到支付，所以当收入和一个人的资产价值下降时，有必要削减开支和出售资产来筹集所需的现金。当这还不够时，就需要：</p><p>（1）债务重组，减少债务和债务负担。这对债务人和债权人都是有问题的，因为一个人的债务就是另一个人的资产。</p><p>（2）央行印钱、中央政府<strong>发放货币和信贷，以填补收入和资产负债表的漏洞</strong>（这也是现在正在发生的事情）。</p><p>当债务持有者不相信他们将从债务中获得足够的回报时，就会出现第二个问题。债务资产（如债券）是由投资者持有的，他们认为这些资产是可以出售来获得财富（钱）的，而这些钱可以用来买东西。当债务资产的持有者试图将其转换成真实的货币、真实的商品和服务，却发现他们做不到的时候，这个问题就出现了。然后就会发生所谓的“挤兑”。</p><p>无论是商业银行还是央行，都会面临着这样的选择：允许资金从债务资产中流出，从而提高利率，并导致债务和经济问题恶化；或者“印钞”，购买足够的债券，以防止利率上升，并逆转资金耗尽的趋势。</p><p>但如果货币债权和与货币数量和所要购买的商品和服务数量之比过高，银行就会陷入无法摆脱的困境，因为它根本没有足够的钱来满足这些债权，因此它将不得不违约。</p><p>当这种情况发生在央行身上时，它可以选择要么违约，要么印钞并使其贬值。贬值是无法避免的。当这些债务重组和货币贬值规模很大时，它们会导致货币体系崩溃。无论银行或中央银行做什么，债务越多，货币贬值的可能性就越大。记住，商品和服务的数量总是有限的，因为数量受到生产能力的限制。</p><p>在这里，明白金钱和债务的区别是很重要的。</p><p>金钱是用来应对债权的，也就是说，一个人为他的账单付了钱就完了。债务是未来交付金钱的承诺。</p><p>在观察经济机器是如何运作的过程中，重要的是观察a)债务和货币的数量相对于银行中的硬通货（如黄金）的数量，以及b)商品和服务的数量。</p><p>这两者的数量可能会有所不同，但是要记住，债务周期之所以发生，是因为绝大多数人喜欢扩大购买力（一般是通过债务），而中央银行倾向于扩大货币的数量，因为这样做的时候人们会更高兴。</p><p>但这种情况不可能一直持续下去。重要的是要记住，当银行——无论是私有银行还是中央银行——创造了比银行里的硬通货多得多的凭证（纸币和债务）时，终有一天拿来兑换的纸质凭证的数量会超过银行的偿付能力。</p><ol start="4"><li>随之而来的是债务危机、违约和货币贬值</li></ol><p>历史表明，当银行对货币的索取权的增长速度超过银行的货币总量时，“银行挤兑”就发生了。人们可以通过观察银行的资金数量下降，以及由于提款而接近枯竭的程度，准确地判断出什么时候发生了银行挤兑，什么时候银行业危机即将来临。</p><p>如果一家银行无法提供足够的硬通货来满足人们对它的要求，那么无论它是一家商业银行还是一家央行，都会陷入困境，尽管一般而言，央行比商业银行的选择更多一些。这是因为商业银行不能简单地印钞或修改法律以使其更容易地偿还债务，而中央银行可以。当私人银行家陷入困境时，他们要么违约，要么接受政府的救助。如果他们的债务是以本国货币计价的，中央银行可以贬值他们的债权（例如，偿还50-70%）。但如果债务是以他国货币计价的，那么他们最终也势必违约。</p><ol start="5"><li>法定货币</li></ol><p>央行希望拉长货币和信贷周期，使其持续尽可能长的时间，因为这比其他办法要好得多。所以，当 “硬通货”和”对硬通货的追索权”成为他们的严重束缚时，政府通常会放弃它们，转而采用所谓的 “法定”货币。</p><p>在法币体系中不需要硬通货，有的只是中央银行可以无限制”印制”的”纸币”。因此，央行不会面临 “硬通货”被抽干从而违约的风险。</p><p>此时的风险在于，摆脱了对持有有形黄金或其他 “硬”资产的限制，控制印刷厂的人（即与商业银行家一起工作的中央银行家）将不断创造出更多的货币、债务资产和负债，直到有一天，与商品和服务的数量相比，那些持有大量债务的人将试图把它们换成商品和服务时，会产生与银行挤兑一样的效果，导致债务违约或货币贬值。</p><p>这种转变：从a)债务追索权可按固定比例兑换成有形资产(如黄金)的体系转变为b)不在存在这种兑换的法币体系，最近一次发生是在1971年。</p><p>当年8月15日晚上，尼克松告诉全世界，美元将不再与黄金挂钩，我在电视上看到这些，心想，”我的天，我们所熟悉的货币体系就要结束了，”事实的确如此。</p><p>我当时在纽约证券交易所做职员，那个周一早上，我本来以为股票会下跌，从而出现大乱，结果发现股票上涨而导致大乱。</p><p>因为我从来没有见过贬值，不明白它们是如何运作的。然后我查了一下历史，发现在罗斯福发表类似讲话的那个3月5日星期天晚上，他也做了基本相同的事情，在接下来的几个月里，结果基本相同（货币贬值，股市大涨，金价大涨）。这种情况后来我看到很多国家发生过多次，包括国家元首们发表的基本相同的宣言。</p><p>在1971年之前的几年里，美国政府花了很多钱在军事和社会项目上，当时这被称为 “枪支和黄油”政策，它通过借钱来完成支付，而这些钱就产生了债务。</p><p>这些债务就是他人对货币的追索权，而这些追索权就可以用来换取黄金。投资者购买这些债务作为资产，因为他们得到了这笔政府债务的利息，而且美国政府承诺允许这些票据的持有者用这些票据换取美国金库中的黄金。</p><p>随着美国的支出和预算赤字的增长，美国不得不发行更多的债务，也就是说，创造了更多的黄金债权，但银行里的黄金数量却没有增加。</p><p>自然而然，用这种追索权换取黄金的投资者越来越多。明眼人都能看出美国的黄金已经快用完了，而未偿付的黄金债权数量远远大于银行里的黄金数量，所以他们意识到如果这样下去，美国就会违约。</p><p>当然，在那个时候，很多人看到了美国政府表面上的富有，认为它是不可能在偿付黄金债权上违约的。因此，大多数人对这一宣布以及对市场的影响感到惊讶，不过那些了解货币和信贷运作机制的人却不以为然。</p><p>当信贷周期达到极限时，中央政府及其央行的经典反应是创造大量的债务，并印钞，把钱花在商品、服务和投资资产上，以维持经济的发展。</p><p>这就是2008年债务危机期间的做法，当时利率已经达到0%，无法再降低。正如前文所解释的那样，这也是为了应对1929-32年的债务危机而做的，当时利率已经跌到0%。这种债务和货币的创造，现在出现的数额比二战以来的任何时候都要大。</p><p>说白了，央行 “印钱 “并将其用于支出，而不是用债务增长来支持支出，这并非没有好处。例如，钱可以像信贷一样用于消费，但实际上（而不是理论上）不需要偿还。换句话说，只要货币增长而不是信贷/债务增长，只要把钱用在生产性的用途上，就没有错。</p><p>不过采取印钱手段而不是促进信贷增长的主要风险在于：a)市场参与者不会仔细分析这些钱是否用于生产性用途；b)它省去了让还钱的必要性。</p><p>这两点都会增加激进印钱的概率，而且这些钱也不一定用于生产，所以人们就会停止把钱作为财富储藏手段，并将财富转移到其他东西上。</p><p>纵观历史，当硬通货（债务和货币凭证）的未偿还债权远远大于硬通货和商品和服务的数量时，总会发生大量违约或大量印钞和贬值。</p><p>历史已经告诉我们，我们不应该依赖政府在经济上保护我们。相反，我们应该知道，大多数政府会滥用他们作为货币和信贷的创造者和使用者的特权地位。假设你站在他们的立场上，你可能会做出一样的举动。</p><p>这是因为没有一个政策制定者能够驾驭整个周期。每一个人都是周期的某个阶段参与进来，他们只能根据当时的情况，做着对他们有利的事情。</p><p>因为在债务周期的早期，政府是值得信赖的，他们和其他人一样需要钱，甚至比其他人更需要钱，所以他们通常是最大的借款人。</p><p>而在周期的后期，当后续领导人上台执掌政府时，会面临更多债务。这时新的政府领导人和新的央行决策者们就要面对更大的挑战，此时一方面他们的刺激手段较少，同时还要必须偿还债务。</p><p>更为糟糕的是，政府还必须救助债务人，因为他们的倒下又会伤害到整个系统。因此，他们往往会陷入比个人、公司和大多数其他实体更大的现金流困境。</p><p>换句话说，在几乎所有情况下，政府在行动上助长了债务的积累，成为大的债务人，当债务泡沫破灭时，政府通过印钞和贬值来拯救自己和他人。债务危机越大，就越是如此。</p><p>虽然不可取，但出现这种情况也是可以理解的。当你可以制造货币和信贷，并把它传给每个人，让他们高兴的时候，你很难抵挡住诱惑。”这是典型的金融举动。纵观历史上的统治者，他们都会累积起大量在其统治期结束后很久才会到期的债务，让他们的继任者来收拾残局。</p><p>当政府出现债务问题时，他们会如何应对？</p><p>他们会和任何一个实际债务负担沉重的实体一样，用印钞来解决。无一例外，如果债务是以自己的货币计价，他们就会印钱让货币贬值。</p><p>当央行印钱买入债务，这就把钱放进了金融系统，并使金融资产的价格竞相上涨（这也扩大了贫富差距，因为它让那些拥有金融资产的人相对于没有金融资产的人受益更多）。</p><p>同时，它还把大量的债务掌握在央行手中，让央行可以随心所欲地处理这些债务。而且他们印钱和买入金融资产（主要是债券），也就把利率压低了，这就刺激了借钱和买入，并鼓励那些持有这些债券的人卖出债券，鼓励他们以低利率借钱，把钱投资于回报率较高的资产，这就导致央行印更多的钱，买入更多的债券，有时也买入其他金融资产。</p><p>这通常能很好地推高金融资产价格，但在把钱和信贷以及购买力送到最需要的人手中时，效率就很低了。这就是2008年发生的情况，在那之后的大部分时间里，直到最近也是如此。</p><p>然后，当印钞和央行买入金融资产无法把钱和信贷送到需要的地方时，中央政府——它可以决定把钱花在什么地方——从央行（印钞票的央行）那里借钱，这样它就可以把钱花在需要花的地方。在美国，美联储在2020年4月9日宣布了这一计划。</p><p>这种通过印钱买债（称为债务货币化）的方式，作为一种获取金钱和将财富从拥有金钱的人手中转移到需要金钱的人手中的方式，比起征税导致纳税人不满，在政治上要好得多。这就是为什么央行总是印钞票、让货币贬值的原因。</p><p>当政府印了很多钱，买了很多债，这样钱和债的数量都增加了，钱和债的价格就会便宜，这实质上是向拥有这些钱和债的人征税。</p><p>当这种情况发生得足够多，让这些钱和债务资产的持有者意识到发生了什么，他们就会寻求出售他们的债务资产和借钱，以获得他们可以用低廉资金来偿还的债务。</p><p>他们还经常将财富转移到其他的财富存储工具中，如黄金、某些类型的股票和其他地方（如另一个没有这些问题的国家）。在这种时候，央行通常会继续印钱，直接或间接地购买债务（例如，让银行代为购买），并禁止货币流向可以对冲通胀的资产和其他货币及场所。</p><p>这样的通胀期要么刺激货币和信贷扩张，为另一次经济扩张提供资金（这对股票有好处），要么使货币贬值，从而产生货币通胀（这对黄金等通胀对冲资产有好处）。</p><p>在长期债务周期较早的时候，当未偿债务数额不大，有很大的空间通过降息来刺激（如果不降息，就印钱和买入金融资产），那么信贷增长和经济增长的可能性就越大。</p><p>而在长期债务周期较晚的时候，当债务数额较大，没有太多空间通过降息（或印钱和买入金融资产）来刺激，那么伴随着经济疲软而出现货币通胀的可能性就越大。</p><ol start="6"><li>重回硬通货</li></ol><p>过度印制法币会导致债务资产的抛售，以及之前描述的类似银行”挤兑”的情况，最终会降低货币和信贷的价值，促使人们逃离货币和债务（如债券）。他们也就需要决定将使用何种替代性的财富存储方式。</p><p>历史经验告诉我们，他们通常会转向黄金、其他货币、其他国家没有这些问题的资产，以及能够保留其实际价值的股票。</p><p>有些人认为，世界需要另一种可供选择的储备货币，但事实并非如此，因为在没有可供选择的货币的情况下，从历史上看，货币体系崩溃和财富涌向其他资产，也同样会发生。</p><p>货币自身价值的减弱，会导致货币贬值，人们也会抛弃这种货币，并将资产投入其他地方。历史上，当货币贬值的时候，人们会奔向大量其他东西，甚至包括德国魏玛共和国的石头（用于建筑）。</p><p>通常情况下，在这个阶段的债务周期中，也会出现贫富差距过大造成的经济压力，这就导致了更高的税收和贫富之间的争斗，也使得那些拥有财富的人想要转移到硬资产和其他货币和其他国家。</p><p>很自然的，国家会阻止这种外逃。所以，在这种时候，政府就会加大对黄金（例如，通过取缔黄金的交易和所有权）、外国货币（通过取消其交易能力）、外国资产（通过建立外汇管制来防止资金流出国境）的投资难度。</p><p>最终，债务基本上被消灭，通常是通过让还债的钱既多又便宜，使货币和债务都贬值。</p><p>当这种情况变得极端，以至于货币和信贷体系崩溃，债务贬值和/或违约出现时，政府通常不得不回到某种形式的硬通货，以重建人们对货币作为财富存储的价值的信心，从而恢复信贷增长。</p><p>很多时候，尽管并非总是如此，但政府往往会将其货币与某种硬通货（如黄金或硬储备货币）挂钩，并承诺允许新货币的持有者将其兑换成硬通货。</p><p>有时，这些硬通货可能是另一个国家的硬通货。例如，在过去几十年里，许多弱货币国家将其货币与美元挂钩，或者干脆将其经济美元化（即，将美元作为自己的交易媒介和财富储存手段）。</p><p>回顾一下，在长期的债务周期中，将债务作为一种提供利息的资产持有，在周期初期没有大量债务未还的时候，通常会有回报。但这在周期后期有大量债务未还，且更接近于违约或贬值的时候，相对于给出的利息而言，持有债务是有风险的。</p><p>所以，持有债务（如债券）有点像持有一个定时炸弹，在它还在滴答的时候给你奖励，但一旦爆炸也会将你炸飞。而正如我们所看到的，大爆炸（即大违约或大贬值）大概每50-75年就会发生一次。</p><p>这些债务周期和注销债务的周期已经存在了几千年，在某些情况下已经制度化了。知道债务周期会在这个时间表上发生，会让每个人都能以理性的方式行事，为之做准备。帮助你了解这个情况，让你做好准备，而不是被它吓到，这是我写这篇文章的主要目的。</p><p>因为大多数人对这个周期与他们所经历的事情并不太注意，讽刺的是，越是接近被炸的人往往越是觉得安全。</p><p>那是因为他们一直持有债务，并享受着这样做的回报，而且从上一次爆仓的时间越长，随着上一次爆仓的记忆消退，他们就越是舒服——即使持有这笔债务的风险上升，而回报下降。</p><p>盯住需要偿还的债务相对于硬通货的数量，需要偿还的债务总量相对于债务人的现金流，以及借出资金的利息回报，就可以评估持有这颗定时炸弹的风险/回报。</p><h1 id="4-长期债务周期总结"><a href="#4-长期债务周期总结" class="headerlink" title="4. 长期债务周期总结"></a>4. 长期债务周期总结</h1><p>几千年来，货币制度一直有三种类型：</p><ul><li>硬通货（如金属硬币）</li><li>以“纸币”形式存在的对硬通货的的追索权</li><li>法定货币（如今天的美元）</li></ul><p>硬通货是最具限制性的货币体系，因为除非增加金属或其他具有内在价值的商品（即货币）的供应量，否则就无法创造货币。第二种类型更容易创造货币和信贷，因此硬通货债权与实际持有的硬通货之间的比率上升，最终导致银行挤兑。</p><p>结果有二：一是违约，银行关门且储户失去硬资产；二是有可能跟前者一起发生的债权货币贬值，这意味着储户拿回来的钱变少了。而在第三种类型中，政府可以自由地创造货币和信贷。只要人们对货币有信心，这种做法就持续有效，反之则无效。</p><p>纵观历史，各国在这些不同类型的制度之间过渡，都有合乎逻辑的原因。当一个国家需要的货币和信贷比现有数量更多时，无论是出于应对债务、战争还是其他原因，它自然会从第一种类型过渡到第二种类型，或从第二种类型过渡到第三种类型，这样它就有了更多的印钞灵活性。</p><p>此后，过多的货币供应和债务带来了货币贬值，致使人们不再持有债务和货币作为财富储备，转而回流到硬资产（如黄金）和其他货币中。鉴于这种情况一般发生在产生财富冲突或战争时期，人们通常也会想逃离此地。这类国家需要重新建立起以货币作为财富储备的信心，才能恢复信贷市场。</p><p>下图表达了上述不同的过渡历程。从宋朝到魏玛德国，历史上有很多这样的例子。有很多国家从约束型货币（第一类和第二类）全面过渡到法币，然后随着旧的法币超发，又回到约束型货币。</p><p><img src="https://i.loli.net/2020/05/03/sQkeWX7tDlzEGFn.png" alt="过渡历程"></p><p>如前所述，这个巨大的债务周期将会持续很长一段时间——大约50到75年。在周期结束时，其特征是债务和货币体系的重组。重组的突然之处在于，比如在债务和货币危机时期，重组通常发生得很快，且仅持续数月至三年，具体时间取决于政府采取这些措施所需的时间。然而，此后涟漪效应可能是长期的。</p><p>例如，这样的情况会导致储备货币不再是储备货币。在这些货币制度中，通常会有两到四次大的债务危机，大到足以导致银行业危机和债务减记或贬值30%以上的那种，但这还不足以打破货币体系。</p><p>我在许多国家投资了大约50年，经历了几十次债务危机。它们的运行方式都是一样的，我在《Principles for Navigating Big Debt Crises》一书中曾对此进行了更深入的解释。</p><h1 id="5-拥有储备货币给一个国家带来的不可思议的力量"><a href="#5-拥有储备货币给一个国家带来的不可思议的力量" class="headerlink" title="5. 拥有储备货币给一个国家带来的不可思议的力量"></a>5. 拥有储备货币给一个国家带来的不可思议的力量</h1><p>储备货币是一种在世界范围内被广泛用作交换媒介和财富储备的货币。使用越广泛、对其的依赖程度越深，储备货币和拥有储备货币的国家的实力也就越强。在此，我冒着重复一些之前讲过的东西并让你们觉得无聊的风险来回顾一下美国的情况，以及致使美国和美元让世界变成现在这样的环境情况。</p><p>如前文所述，世界新秩序始于1945年第二次世界大战结束之后，而布雷顿森林协定在1944年确立了美元作为世界主要储备货币的地位。</p><p>美国和美元自然而然地符合这一角色，因为战争结束时，美国政府持有全球约三分之二的黄金（当时是世界货币），美国占世界经济产出的50%，还在军事上占主导地位。新的货币制度属于第二类（即硬通货的债权），其他国家的央行可以35美元/盎司的价格将“纸质美元”兑换成黄金。</p><p>当时，个人持有黄金属于非法，其原因在于政府领导人不想让黄金作为财富储备来与货币和信贷竞争。所以，在那个时候，黄金就是银行里的钱，而纸币就像支票簿里的支票一样，可以兑换成真金白银。</p><p>在这个全新货币体系建立的时候，美国政府每持有一盎司黄金就拥有50美元的纸币，所以几乎100%有黄金做后盾。其他主要的美国盟国（如英国、法国和英联邦国家）或受美国控制的国家（德国、日本和意大利）都有受美国控制的货币与美元挂钩。</p><p>在此后的几年里，为了给自己的活动提供资金，美国政府的支出超过了税收收入，因此不得不借钱，从而产生了更多以美元计价的债务。美联储所允许建立的黄金债权数量（如美元计价的货币和信贷），远远超过了能以35美元价格兑换成的黄金实际数量。在纸币被兑换成硬通货（黄金）之后，美国银行之中的黄金数量随之下降，黄金债权则继续上升。其结果就是，在1971年8月15日，布雷顿森林货币体系崩溃了。</p><p>当时，时任美国总统尼克松和1933年3月5日的罗斯福一样，未能履行当局承诺，即允许美元持有者将其兑换成黄金。于是，美元对黄金和和其他货币贬值。这时，美国和所有国家都进入了第三种类型，法币体系。如果你想读一读有关如何从旧货币体系到新货币体系的精彩过程，我推荐保罗·沃尔克的《Changing Fortunes》，在谈判美国新货币体系应该运作时，他是首席谈判代表。</p><p>这种向法币体系的转变使美联储和其他中央银行得以创造大量以美元计价的货币和信贷，从而导致了1970年代的通货膨胀，其特点是从美元和美元债逃向商品、服务以及黄金等可以对冲通胀的资产。这种对美元债的恐慌情绪还导致了利率走高，并将金价从1944年至1971年期间固定的35美元推至当时的历史高位——1980年的670美元。</p><p>20世纪70年代，货币和信贷主要通过上述方式管理。这时，借入美元并将其转换为商品和服务是有利可图的，所以许多国家的许多实体都大量通过美国银行借入美元。结果，以美元计价的债务在全球范围内迅速增长，而美国银行通过把美元放给借款人来赚了很多钱。</p><p>这种贷款导致了债务周期中经典的债务泡沫。恐慌情绪让人逃离美元和美元债资产并转向通胀对冲资产，快速借入美元和背负债务的速度也在加快。这就造成了1979-1982年期间的货币和信贷危机。</p><p>在那期间，美元和美元债面临着不再担任公认财富储备的风险。当然，普通老百姓并不了解这种货币和信贷的动态是如何运作的，但他们以高通胀和高利率的形式感受到了它，这就成了一个巨大的政治问题。时任总统卡特和大多数政治领导人一样并不太了解货币机制，但他知道必须做点什么来阻止危机，于是任命了一位强有力的货币政策制定者——保罗·沃尔克。</p><p>几乎所有关注危机的人，包括我在内，都会注意听他说的每一句话。他足够强大，能够做一些令人痛苦但正确的事情来打破通货膨胀。他成为了我的英雄，最终还因其很棒的性格和出色的能力，成为了我的好朋友，我也喜欢他冷嘲式的幽默。 </p><p>德国前总理赫尔穆特·施密特认为，为了应对这场货币通胀危机并打破通货膨胀，沃尔克收紧了货币供应，将利率推到了”自耶稣基督诞生以来”的最高水平。</p><p>债务人就不得不在收入和资产贬值的同时，支付更多的偿债款。由此，债务人受到压榨，被逼出售资产。由于美元需求巨大，美元走强。基于这些原因，通货膨胀下降，美联储随之降低利率，放松了美国人的货币和信贷。</p><p>当然，许多债务人和贬值资产持有人都破产了。因此，在80年代，这些债务人，尤其是外国债务人，更尤其是新兴国家的债务人，经历了长达十年的经济萧条和债务重组时期。美联储通过向美国银行提供所需的资金来保护他们，而美国的会计制度则不要求银行将这些坏账作为损失来核算，或无需按照实际价格来对这些债务资产进行估值，从而保护美国银行免于破产。</p><p>这一债务管理和重组过程一直持续到1991年，最后以迎来用时任美国财政部长尼古拉斯·布雷迪名字命名的”布雷迪债券协议”而告终。1971-1991年整个周期几乎影响了世界上所有的人，这是美国脱离金本位的结果。</p><p>它导致了70年代的通胀和通胀对冲资产的飙升，随后又带来1979-1981年的紧缩、非美债务人大量的通缩债务重组、通胀率下降，以及1980年代债券和其他通缩资产的出色表现。这整个时期都有力地证明了拥有世界储备货币的美国具有怎样的力量，以及储备货币管理方式对世界各国的影响。</p><p>从1979-1981年期间以美元计价的通货膨胀率和利率双双达到峰值到现在，通胀和利率都降到了接近0%。你可以清楚地看到，自新的美元计价货币体系建立以来，利率和通胀整个大型周期的起起伏伏。</p><p><img src="https://i.loli.net/2020/05/03/QOHUyPVpERgM2AD.jpg" alt="通胀及利率的起伏"></p><p>在整个这段时间里，世界上以美元计价的货币、信贷和债务以及其他非债务性负债（如养老金和医保等）相对于收入而言持续上升。因为美联储有独特的能力来支撑这种债务增长，上述情况在美国尤为明显。</p><p>20世纪80年代债务重组完成后，全球货币、信贷和债务的全新增长又在90年代开始了。这再次带来了经济繁荣，并且导致投资者举债进行投机性投资，最终形成在2000年破裂的科网泡沫。</p><p>泡沫的破裂引出了2000-2001年的经济衰退，并刺激美联储放宽货币和信贷，将债务水平推到了新的高点。接下来，又一次的经济繁荣到来，另一个更大的债务泡沫在2007年诞生，于2008年破裂。</p><p>于是美联储和其他储备货币国家的央行再次宽松，又带来了近期刚刚破裂的下一个泡沫。然而，这一次创造应对经济衰退所需货币和信贷的方式却被设计得十分不同。</p><p>短期利率在2008年达到0%，而这个降息的幅度尚无法满足货币和信贷扩张的需要。通过降息刺激货币和信贷增长是央行的首选货币政策。我称其为”货币政策1”。随着这种方法不再适用于中央银行，他们就转向了第二选择（我称之为”货币政策2”），即印钞和购买以国债、优质债务为主的金融资产。</p><p>央行上一次需要这样做，是因为利率从1933年开始触及0%，且在战争年代也一直保持零利率。这种做法被称为”量化宽松”而不是”债务货币化”，是因为QE听起来没有那么大的威胁性。世界上所有的主要储备货币央行都已经这么做了。</p><p>这就带来了下一个货币/信贷/经济范式，直到我们现在经历的经济衰退之前，这一范式一直在持续。</p><p>自2008年开始的这一范式是这样的。</p><p>正如从1933年开始所做的那样，央行通过印钞和购买债券维持了货币和债务扩张周期。</p><p>通过购买债券，央行推高了债券价格，并为这些债券的卖家提供现金，致使他们去购买其他资产。这就推高了其他资产的价格，而随着这些资产价格上涨，未来的预期回报率随之下降。</p><p>由于利率低于其他投资的预期回报率，而相对于投资者为其各种支出义务提供资金所需的回报率而言，债券收益率和其他未来预期回报率的水平都很低，因此，投资者越来越频繁地借钱购买他们认为收益将高于借贷成本的资产。</p><p>这既推高了上述资产的价格，又造成了新的债务泡沫脆弱性——如果他们所购资产收益低于其借贷成本，就会产生新的债务泡沫。由于长期和短期利率都在0%左右，而且央行购买债券的资金无法刺激经济增长和帮助那些最需要帮助的人，所以我觉得第二种货币政策显然不能很好地发挥作用，这就需要第三种货币政策——“货币政策3”。</p><p>“货币政策3”的工作原理是，储备货币中央政府增加借贷，并将其支出和贷款的目标定在他们想要的地方，而储备货币中央银行则创造货币和信贷，并购买债务（可能还有其他资产，如股票）来提供资金。虽然我不会在这里解释各种方法，但在我的书《Principles for Navigating Big Debt Crises》当中已经解释过了。</p><p>因此，在疫情引发经济衰退之前，我们就已经做好了准备：一旦经济滑入衰退，就必须走这条路。如果你想要看我更为深入地研究相关话题的文章，可以点击economicprinciples.org。</p><p>无论如何，在这段时期内，债务和非债务性负债（如养老金和医保）相对于收入而言继续上升，而中央银行设法压低了偿债成本（详见我的报告”The Big Picture”，里面对此举所导致的、即将到来的“挤兑”解释得更完整）。</p><p>这就把利率推向了零，并使债务长期化，从而使本金偿付水平降低。诸如中央银行拥有大量的债务、利率在0%左右因此不需要支付利息、构建可以长期偿还的债务并使本金可以分散偿还甚至不用偿还之类的条件，意味着中央银行创造货币和信贷的能力几乎没有限制。这一系列的条件为接下来的事情奠定了基础。</p><p>新冠疫情引发了世界各地的经济和市场衰退，造成了收入和资产负债表方面的窟窿，特别是对那些收入受到衰退影响的负债实体来说，更是如此。</p><p>传统上，中央政府和央行必须创造货币和信贷，才能把钱和信贷送到他们想救的实体手中。如果没有这些钱和信贷，这些实体在财务上是无法生存的。</p><p>由此，2020年4月9日，美国中央政府（总统和国会）和美国央行（美联储）宣布了一项大规模的货币和信用创造计划，采用了“货币政策3”之中所有经典的手法，包括直升机撒钱（政府直接给公民发钱）。</p><p>这基本上与罗斯福在1933年3月5日宣布的计划是一样的。虽然是疫情引发了这次特殊的金融和经济衰退，但就算没有疫情，其他东西最终也会触发衰退。</p><p>无论衰退的起因是什么，但动力基本上都是一样的，因为只有“货币政策3”才会起到扭转经济衰退的作用。欧洲央行、日本央行以及中国人民银行也都采取了类似措施，不过最重要的仍是美联储的举动，因为它是美元的创造者，而美元仍然是世界上占主导地位的货币和信贷。</p><p>目前，美元在全球的国际交易、储蓄、借贷中约占55%。欧元区的欧元约占25%。日元占比不到10%。中国的人民币占2%左右。其他大多数货币都没有在国际上用作交换媒介和财富储存手段，仅在各国国内使用。</p><p>无论是上述各国国内的聪明人，还是这些国家以外的几乎所有人，都不会持有这部分货币并将其作为财富储备。相比之下，我提到的储备货币，就是全世界大多数人喜欢储蓄、借贷、交易的货币，大致比例和我上文所说的相同。</p><p>拥有世界储备货币的国家拥有惊人的力量——储备货币可能是最重要的力量，重要程度甚至超过军事力量。</p><p>这是因为当一个国家拥有储备货币时，它可以在合适的时候像美国现在这样印钱、借钱来消费，而那些没有储备货币的国家则必须先获得他们所需要的钱和信贷（以世界储备货币计价）才能进行交易和储蓄。</p><p>比如说现在，截止发稿，那些有很多债务需要偿还的人对美元的需求很强，因其需要更多的美元来购买商品和服务，但他们的美元收入已经下降。</p><p>正如章节一中表明衡量一国国力上升和下降的八项指标的图表所示，储备货币实力（以该货币的交易和储蓄份额来衡量）明显落后于衡量国家实力的其他指标。美国和美元的情况也是如此。</p><p>例如，在1944年，当美元被选定为全球主要储备货币时，美国政府持有的黄金占全球黄金总量的约三分之二（黄金当时被视为货币），美国经济则约占全球GDP的一半。</p><p>如今，美国GDP只占全球的20%左右，但美元仍占全球外汇储备的60%左右，还占有国际交易量的半壁江山。所以，美元和以美元为基础的货币和支付体系仍然占据着至高无上的地位，相对于美国经济的规模而言，它的规模还是特大号。</p><p>和所有印制储备货币的银行一样，美联储现在处于强势但尴尬的地位。其货币政策的运行方式对美国人有利，但对世界上其他依赖美元的国家来说，可能并不是好事。</p><p>比如美国中央政府最近刚刚决定，将借贷给美国人发放美元和美元信贷，美联储则决定购买美国政府的那笔国债和美国人其他的债务，帮助他们度过这次金融危机。可以理解的是，这些钱几乎没有多少会流向外国人。</p><p>欧洲央行也将对欧元区国家采取类似措施。世界影响力仍旧较小的日本央行也会为日本人做同样的事情，中国人民银行同样会为中国人做类似的事情。</p><p>其他几个相对较小的国家（如瑞士）也许可以为本国人民做类似的事情，但世界上大多数人无法像美国人那样，得到他们所需要的钱和信贷来填补收入和资产负债表的窟窿。</p><p>这一动态，即国家无法获得他们所需要的硬通货就像1982-1991年期间发生的事情一样，只是这次无法再靠大幅削减利率解决问题，而那个时候可以。</p><p>与此同时，非美国人（即新兴市场、欧洲国家和中国）持有的美元债总额约为20万亿美元（比2008年时高50%左右），其中短期债务不到一半。这些美元债务人将不得不拿出美元来偿还这些债务，还要拿出更多的美元来在世界市场上购买商品和服务。</p><p>所以，通过拥有美元作为世界储备货币并拥有生产这种货币的银行，且拥有把这些急需的美元放入美国人手中的实力，美国就可以比其他国家的政府更有效地帮助本国公民。</p><p>同时，美国也有可能会因为制造了太多的货币和债务而失去这种特权地位。在本章的附录中，我们将更深入地研究曾经拥有储备货币的国家是如何失去储备货币的，以及货币贬值是如何运作的。</p><h1 id="6-Summary"><a href="#6-Summary" class="headerlink" title="6. Summary"></a>6. Summary</h1><p>回过头来从大格局的角度看这一切，我想谈论的关系包括1）经济之间（即货币、信贷、债务、经济活动和财富）和2）政治之间（国家内部和各国之间），具体起起落落如下图所示。</p><p><img src="https://i.loli.net/2020/05/03/YEnmcZpRXAota3T.png" alt="债务周期"></p><p>通常情况下，大的周期始于一个全新的世界秩序，即一种囊括全新货币体系和政治制度、包含国内和国际运作的一种全新方式。最近的一次大周期始于1945年。</p><p>因为在那样的时期，冲突之后出现了具有主导力量的大国，大家都不愿意打仗，人们也厌倦了战斗，于是就有了和平重建和日益繁荣的局面，而这种繁荣是由可持续的信贷扩张来支撑的。</p><p>之所以说是可持续的，是因为收入的增长超过或跟上了偿还不断增长的债务所需的偿债支出，也是因为央行有能力刺激信贷，经济增速也很强劲。一路走来，过程中会出现短期的债务和经济周期，我们称之为衰退和扩张。</p><p>随着时间的推移，投资者以过去的收益推断未来，并借钱来押注收益可以实现。这就在贫富差距扩大（有些人的收益比其他人更多）的同时产生了债务泡沫。这种情况将一直持续下去，直到各国央行耗尽一切有效刺激信贷和经济增长的能力。</p><p>随着货币紧缩，债务泡沫破裂，信贷收缩，经济也随之萎缩。同时，当出现巨大的贫富差距、严重的债务问题且经济萎缩时，国家内部和国家之间往往会发生争夺财富和权力的斗争。</p><p>在债务和经济出现问题的时候，中央政府和中央银行通常会发行货币和信贷，并有可能使本币贬值。这些事态发展导致了债务、货币体系、国内秩序和世界秩序的重组。然后，事情又开始了。</p><p>虽然没有一个周期完全符合描述，但几乎所有周期都与之相差无几。比如说，虽然债务泡沫破裂一般会导致经济萎缩，经济萎缩叠加巨大的贫富差距通常会导致内斗和外斗，但有时顺序有些不同。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://www.thepaper.cn/newsDetail_forward_7147656" target="_blank" rel="noopener">https://www.thepaper.cn/newsDetail_forward_7147656</a></li><li><a href="https://www.linkedin.com/in/raydalio/detail/recent-activity/" target="_blank" rel="noopener">https://www.linkedin.com/in/raydalio/detail/recent-activity/</a></li><li><a href="https://m.chinanews.com/wap/detail/zw/cj/2020/03-19/9131125.shtml" target="_blank" rel="noopener">https://m.chinanews.com/wap/detail/zw/cj/2020/03-19/9131125.shtml</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Ray Dalio在LinkedIn上的长文，主要分析了在长期债务周期当中，货币、信贷、债务之间的相互运作关系，以及它们驱动全球经济和政治变化的方式。&lt;/p&gt;
&lt;h1 id=&quot;1-货币和信贷&quot;&gt;&lt;a href=&quot;#1-货币和信贷&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="Notes" scheme="https://www.llchen60.com/categories/Notes/"/>
    
    
      <category term="Economy" scheme="https://www.llchen60.com/tags/Economy/"/>
    
  </entry>
  
  <entry>
    <title>Java 多线程 基础知识(一)</title>
    <link href="https://www.llchen60.com/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://www.llchen60.com/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2020-05-01T02:36:12.000Z</published>
    <updated>2020-05-03T05:02:06.294Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-多线程知识基础"><a href="#1-多线程知识基础" class="headerlink" title="1. 多线程知识基础"></a>1. 多线程知识基础</h1><h2 id="1-1-线程-vs-进程"><a href="#1-1-线程-vs-进程" class="headerlink" title="1.1 线程 vs 进程"></a>1.1 线程 vs 进程</h2><p>进程是程序的一次执行过程，java当中，启动main函数就是启动了一个JVM进程，main函数所在的线程是其中之一，也称为主线程。</p><p>线程是比进程更小的执行单位，一个进程执行过程当中可以产生多个线程。同类的多个线程互相之间共享进程的堆和方法区的资源。每个线程有自己的程序计数器，虚拟机栈，和本地方法栈</p><p>线程与进程之间的关系如下图所示</p><p><img src="https://i.loli.net/2020/04/30/3AwhmaPDLkcXKMb.png" alt="线程进程关系.png"> </p><p>运行时堆和方法区，还有常量是共享的。</p><p><strong>线程私有的</strong></p><ul><li>程序计数器<ul><li>当前线程所执行的字节码的行号指示器</li><li>字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成</li><li>为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存</li><li>程序计数器是唯一不会出现OutOfMemoryError的内存区域，声明周期是完全跟着线程的，线程创建即创建，线程结束即结束</li><li>程序计数器的私有主要是为了线程切换以后能够恢复到正确的执行位置上</li></ul></li><li>虚拟机栈<ul><li>描述java方法执行的内存模型</li><li>Java虚拟机栈由一个个栈帧组成，每个栈帧都拥有<ul><li>局部变量表<ul><li>存放了编译器已知的各种数据类型</li><li>对象引用</li></ul></li><li>操作数栈</li><li>动态链接</li><li>方法出口信息</li></ul></li></ul></li><li>本地方法栈<ul><li>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务</li><li>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</li></ul></li></ul><p><strong>线程共享资源</strong></p><ul><li><p>堆 </p><ul><li>存放对象实例</li><li>几乎所有对象实例以及数组都在这里分配内存</li><li>堆是Java垃圾收集器的主要区域，因此也被称作GC堆 Garbage Collected Heap </li><li>堆会根据时间的长度分为多种空间，来方便垃圾收集器来更好的回收内存</li><li>还包括运行时常量池</li></ul></li><li><p>方法区</p><ul><li>用于存储已被虚拟机加载的类的信息，常量，静态变量，即时编译器编译后的代码等数据</li></ul></li><li><p>直接内存</p></li></ul><h2 id="1-2-并发-vs-并行"><a href="#1-2-并发-vs-并行" class="headerlink" title="1.2 并发 vs 并行"></a>1.2 并发 vs 并行</h2><p>并发 - 同一时间段的多个任务都在执行<br>并行 - 单位时间内，多个任务同时执行</p><h2 id="1-3-多线程带来的改变"><a href="#1-3-多线程带来的改变" class="headerlink" title="1.3 多线程带来的改变"></a>1.3 多线程带来的改变</h2><h3 id="1-3-1-优势"><a href="#1-3-1-优势" class="headerlink" title="1.3.1 优势"></a>1.3.1 优势</h3><ul><li>线程，是程序执行的最小单位，线程间的切换和调度成本远远小于进程。而且多核CPU时代意味着多个线程同时进行，这减少了线程上下文切换的开销</li><li>多线程并发变成是开发高并发系统的基础</li><li>单核时代多线程做的优化更多是提高CPU和IO的综合利用率。在一个线程做IO的时候，另外一个线程可以到内核当中做利用CPU的大量计算</li><li>多核时代想做的事情就是同时使用多个内核一起来做这件事，提高整个运行的效率</li></ul><h3 id="1-3-2-可能的问题"><a href="#1-3-2-可能的问题" class="headerlink" title="1.3.2 可能的问题"></a>1.3.2 可能的问题</h3><p>需要解决内存泄漏，死锁，线程不安全相关的问题</p><ul><li>死锁<ul><li>多个线程被同时阻塞，在等待某个资源的释放</li><li>产生死锁的条件<ul><li>互斥条件 – 该资源任意时刻只由一个线程占用</li><li>请求与保持条件 – 一个进程因请求资源而阻塞时，对已获得的资源保持不放 </li><li>不剥夺条件 – 线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源</li><li>循环等待条件 – 若干进程之间形成一种头尾相接的循环等待资源关系</li></ul></li></ul></li></ul><pre><code>public class DeadLockDemo {    private static Object resource1 = new Object();//资源 1    private static Object resource2 = new Object();//资源 2    public static void main(String[] args) {        new Thread(() -&gt; {            synchronized (resource1) {                System.out.println(Thread.currentThread() + &quot;get resource1&quot;);                try {                    Thread.sleep(1000);                } catch (InterruptedException e) {                    e.printStackTrace();                }                System.out.println(Thread.currentThread() + &quot;waiting get resource2&quot;);                synchronized (resource2) {                    System.out.println(Thread.currentThread() + &quot;get resource2&quot;);                }            }        }, &quot;线程 1&quot;).start();        new Thread(() -&gt; {            synchronized (resource2) {                System.out.println(Thread.currentThread() + &quot;get resource2&quot;);                try {                    Thread.sleep(1000);                } catch (InterruptedException e) {                    e.printStackTrace();                }                System.out.println(Thread.currentThread() + &quot;waiting get resource1&quot;);                synchronized (resource1) {                    System.out.println(Thread.currentThread() + &quot;get resource1&quot;);                }            }        }, &quot;线程 2&quot;).start();    }}</code></pre><h2 id="1-4-sleep（）vs-wait（）"><a href="#1-4-sleep（）vs-wait（）" class="headerlink" title="1.4 sleep（）vs wait（）"></a>1.4 sleep（）vs wait（）</h2><ul><li>最主要的区别在于sleep并没有释放锁，而wait方法会释放锁</li><li>二者都暂停了当前线程的执行</li><li>wait用于线程之间的交互和通信，sleep用于暂停执行</li><li>wait()方法被调用以后，线程不会自动苏醒，需要别的线程调用同一个对象上的notify()或者notifyAll()方法</li></ul><h2 id="1-5-并发编程的重要特性"><a href="#1-5-并发编程的重要特性" class="headerlink" title="1.5 并发编程的重要特性"></a>1.5 并发编程的重要特性</h2><ul><li>原子性<ul><li>被修饰的代码块要不全都执行，要不都不执行，synchronized可以保证代码片段的原子性</li></ul></li><li>可见性<ul><li>当一个变量对共享变量进行了修改，那么另外的线程都是立即可以看到修改以后的新值的。volatile关键字可以保证共享变量的可见性</li></ul></li><li>有序性<ul><li>Java 在编译器以及运行期间的优化，代码的执行顺序未必就是编写代码时候的顺序。volatile 关键字可以禁止指令进行重排序优化   </li></ul></li></ul><h2 id="1-6-volatile关键字"><a href="#1-6-volatile关键字" class="headerlink" title="1.6 volatile关键字"></a>1.6 volatile关键字</h2><h3 id="1-6-1-General"><a href="#1-6-1-General" class="headerlink" title="1.6.1 General"></a>1.6.1 General</h3><p>在当前的 Java 内存模型下，线程可以把变量保存本地内存（比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成数据的不一致。要解决这个问题，需要将变量声明为volatile，这就指示JVM，这个变量时不稳定的，每次使用它都到主存当中进行读取。<br>即volatile关键字可以起到：</p><ul><li>保证变量的可见性，从主内存当中拿数据</li><li>防止指令重排序</li></ul><h2 id="1-7-synchronized关键字"><a href="#1-7-synchronized关键字" class="headerlink" title="1.7 synchronized关键字"></a>1.7 synchronized关键字</h2><h3 id="1-7-1-General"><a href="#1-7-1-General" class="headerlink" title="1.7.1 General"></a>1.7.1 General</h3><ul><li>解决多个线程之间访问资源的同步性问题</li><li>可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行</li><li>最开始是基于操作系统的mutex lock来实现，因为有用户态和内核态的转换，需要相对比较长的时间，性能不好；JDK 1.6之后做了大量优化，性能有了不小的提升<ul><li>自旋锁</li><li>适应性自旋锁</li><li>锁消除</li><li>锁粗化</li><li>偏向锁</li><li>轻量级锁</li></ul></li></ul><h3 id="1-7-2-使用方式"><a href="#1-7-2-使用方式" class="headerlink" title="1.7.2 使用方式"></a>1.7.2 使用方式</h3><ul><li>修饰实例方法<ul><li>作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁 </li></ul></li><li>修饰静态方法<ul><li>给当前类加锁，会作用于类的所有对象实例</li></ul></li><li>修饰代码块<ul><li>指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁  </li></ul></li></ul><pre><code>// 线程安全的单例模式的实现public class Singleton {    private volatile static Singleton uniqueInstance;    private Singleton() {    }    public static Singleton getUniqueInstance() {       //先判断对象是否已经实例过，没有实例化过才进入加锁代码        if (uniqueInstance == null) {            //类对象加锁            synchronized (Singleton.class) {                if (uniqueInstance == null) {                    uniqueInstance = new Singleton();                }            }        }        return uniqueInstance;    }}</code></pre><h3 id="1-7-3-底层实现方式"><a href="#1-7-3-底层实现方式" class="headerlink" title="1.7.3 底层实现方式"></a>1.7.3 底层实现方式</h3><ul><li>同步语句块的时候<ul><li>使用的是monitorenter和monitorexit指令</li><li>monitorenter指令指向同步代码块的开始位置</li><li>monitorexit指令指向同步代码块的结束位置</li><li>锁计数器为0时可以获取，释放锁的时候再置为0</li></ul></li><li>同步方法的时候<ul><li>使用的是ACC_SYNCHRONIZED标识，指明该方法为一个同步方法，从而执行相应的同步调用</li></ul></li></ul><h3 id="1-7-4-synchronized-关键字的底层优化"><a href="#1-7-4-synchronized-关键字的底层优化" class="headerlink" title="1.7.4 synchronized 关键字的底层优化"></a>1.7.4 synchronized 关键字的底层优化</h3><p>锁主要存在四中状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率</p><ul><li><p>偏向锁</p><ul><li>为了在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗</li><li>偏向锁在无竞争的情况下会把整个同步都消除掉</li><li>但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失，需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁 </li></ul></li><li><p>轻量级锁</p><ul><li>偏向锁失败的情况下会首先升级为轻量级锁</li><li>在没有多线程竞争的前提下，减少传统重量级锁使用操作系统互斥量产生的性能消耗</li><li>使用轻量级锁，不需要申请互斥量。另外，轻量级锁的加锁和解锁都用到了CAS操作 </li><li>轻量级锁能够提升程序同步性能的依据是“对于绝大部分锁，在整个同步周期内都是不存在竞争的”，这是一个经验数据。如果没有竞争，轻量级锁使用 CAS 操作避免了使用互斥操作的开销。但如果存在锁竞争，除了互斥量开销外，还会额外发生CAS操作，因此在有锁竞争的情况下，轻量级锁比传统的重量级锁更慢！如果锁竞争激烈，那么轻量级将很快膨胀为重量级锁！</li></ul></li><li><p>自旋锁和自适应自旋</p><ul><li>互斥同步对性能最大的影响就是阻塞的实现，因为挂起线程/恢复线程的操作都需要转入内核态中完成</li><li>般线程持有锁的时间都不是太长，所以仅仅为了这一点时间去挂起线程/恢复线程是得不偿失的</li><li>自旋锁就是让线程执行一个忙循环，自旋锁和互斥锁不同之处在于不会休眠，调用者一直在那里循环看锁的保持者是否释放了锁</li></ul></li><li><p>锁消除</p><ul><li>编译器在运行的时候，如果检测到共享数据不可能存在竞争，就执行锁消除，以节省毫无意义的请求锁的时间</li></ul></li></ul><h3 id="1-7-5-synchronized关键字和volatile关键字的区别"><a href="#1-7-5-synchronized关键字和volatile关键字的区别" class="headerlink" title="1.7.5 synchronized关键字和volatile关键字的区别"></a>1.7.5 synchronized关键字和volatile关键字的区别</h3><ul><li>volatile是线程同步的轻量级实现，因此volatile性能会比synchronized关键字好。</li><li>多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会</li><li>volatile关键字能保证数据的可见性，不能保证数据的原子性。synchronized都可以保证</li><li>volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized关键字解决的是多个线程之间访问资源的同步性</li></ul><h1 id="2-ThreadLocal"><a href="#2-ThreadLocal" class="headerlink" title="2. ThreadLocal"></a>2. ThreadLocal</h1><h2 id="2-1-ThreadLocal"><a href="#2-1-ThreadLocal" class="headerlink" title="2.1 ThreadLocal"></a>2.1 ThreadLocal</h2><p>通常情况下，我们创建的变量时可以被任何一个线程访问并修改的，如果想实现每一个线程都有自己的专属的本地变量的话，可以使用JDK提供的ThreadLocal类。ThreadLocal类解决的问题就是想让每个线程都绑定自己的值。</p><p>当我们创建了ThreadLocal变量，访问这个变量的每个线程都会有这个变量的本地副本，使用get()以及set()方法获取默认值或者将指改为当前线程所存的副本的值，从而避免线程安全问题。</p><pre><code>import java.text.SimpleDateFormat;import java.util.Random;public class ThreadLocalExample implements Runnable{     // SimpleDateFormat 不是线程安全的，所以每个线程都要有自己独立的副本    private static final ThreadLocal&lt;SimpleDateFormat&gt; formatter = ThreadLocal.withInitial(() -&gt; new SimpleDateFormat(&quot;yyyyMMdd HHmm&quot;));    public static void main(String[] args) throws InterruptedException {        ThreadLocalExample obj = new ThreadLocalExample();        for(int i=0 ; i&lt;10; i++){            Thread t = new Thread(obj, &quot;&quot;+i);            Thread.sleep(new Random().nextInt(1000));            t.start();        }    }    @Override    public void run() {        System.out.println(&quot;Thread Name= &quot;+Thread.currentThread().getName()+&quot; default Formatter = &quot;+formatter.get().toPattern());        try {            Thread.sleep(new Random().nextInt(1000));        } catch (InterruptedException e) {            e.printStackTrace();        }        //formatter pattern is changed here by thread, but it won&#39;t reflect to other threads        formatter.set(new SimpleDateFormat());        System.out.println(&quot;Thread Name= &quot;+Thread.currentThread().getName()+&quot; formatter = &quot;+formatter.get().toPattern());    }}</code></pre><p>从ThreadLocal原理上来讲</p><pre><code>public class Thread implements Runnable {     ......    //与此线程有关的ThreadLocal值。由ThreadLocal类维护    ThreadLocal.ThreadLocalMap threadLocals = null;    //与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护    ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;     ......}</code></pre><ul><li><p>Thread类中有一个threadLocals和一个inheritableThreadLocals变量，都是由ThreadLocalMap来实现的。默认情况下两个变量的值均为null，只有当前线程调用ThreadLocal类的set/ get方法时才创建他们</p></li><li><p>ThreadLocal类的set()方法</p></li></ul><pre><code>    public void set(T value) {        Thread t = Thread.currentThread();        ThreadLocalMap map = getMap(t);        if (map != null)            map.set(this, value);        else            createMap(t, value);    }    ThreadLocalMap getMap(Thread t) {        return t.threadLocals;    }</code></pre><ul><li>从上面的代码中，可以看出最终的变量是放在了当前线程的ThreadLocalMap当中，并不是直接存在ThreadLocal上，ThreadLocal可以理解为只是ThreadLocalMap的封装，传递了变量值。</li><li>ThreadLocal类可以通过Thread.currentThread()获取当前线程对象之后，直接通过getMap(Thread t) 访问到该线程的ThreadLocalMap对象</li></ul><h1 id="3-AQS"><a href="#3-AQS" class="headerlink" title="3. AQS"></a>3. AQS</h1><p>AQS全称为AbstractQueuedSynchronizer，是一个用来构建锁和同步器的框架。</p><h2 id="3-1-原理分析"><a href="#3-1-原理分析" class="headerlink" title="3.1 原理分析"></a>3.1 原理分析</h2><p>核心思想为如果被请求的共享资源是空闲的，就将现在请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的资源被占用了，那么就需要一整套线程阻塞等待以及被唤醒时锁分配的机制，AQS使用CLH队列锁实现，将暂时获取不到锁的线程加入到队列当中。</p><p>CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS是将每条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node）来实现锁的分配</p><ul><li>AQS使用int变量来表示同步状态</li><li>通过内置的FIFO队列来完成获取资源线程的排队工作</li><li>AQS使用CAS对该同步状态进行原子操作实现对其值的修改</li></ul><pre><code>private volatile int state;//共享变量，使用volatile修饰保证线程可见性//返回同步状态的当前值protected final int getState() {          return state;} // 设置同步状态的值protected final void setState(int newState) {         state = newState;}//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）protected final boolean compareAndSetState(int expect, int update) {        return unsafe.compareAndSwapInt(this, stateOffset, expect, update);}</code></pre><h2 id="3-2-AQS资源共享方式"><a href="#3-2-AQS资源共享方式" class="headerlink" title="3.2 AQS资源共享方式"></a>3.2 AQS资源共享方式</h2><ul><li>共有两种资源共享方式<ul><li>Exclusive 独占 <ul><li>只有一个线程能执行，又分为公平锁和非公平锁</li><li>公平锁<ul><li>按照线程在队列中的排队顺序，先到者先拿到锁 </li></ul></li><li>非公平锁  <ul><li>当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的</li></ul></li></ul></li><li>Share 共享<ul><li>多个线程可同时执行<ul><li>semaphore</li><li>coutDownLatch</li></ul></li></ul></li></ul></li></ul><h2 id="3-3-常用组件"><a href="#3-3-常用组件" class="headerlink" title="3.3 常用组件"></a>3.3 常用组件</h2><ul><li><p>Semaphore 信号量 – 允许多个线程同时访问</p><ul><li>synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。</li></ul></li><li><p>CountDownLatch 倒计时器</p><ul><li>CountDownLatch是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行</li></ul></li><li><p>CyclicBarrier 循环栅栏</p><ul><li>CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）</li><li>它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier默认的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用await()方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞<h1 id="4-Atomic原子类"><a href="#4-Atomic原子类" class="headerlink" title="4. Atomic原子类"></a>4. Atomic原子类</h1></li></ul></li></ul><p>在这里指的是不可中断的操作，即便是多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。原子类体系就是就有原子/原子操作特征的类。</p><h2 id="4-1-General"><a href="#4-1-General" class="headerlink" title="4.1 General"></a>4.1 General</h2><ul><li><p>基本类型 - 使用原子的方式更新基本类型</p><ul><li>AtomicInteger 整形原子类</li><li>AtomicLong 长整形原子类</li><li>AtomicBoolean 布尔型原子类</li></ul></li><li><p>数组类型</p><ul><li>AtomicIntegerArray 整形数组原子类</li><li>AtomicLongArray 长整形数组原子类</li><li>AtomicReferenceArray 引用类型数组原子类</li></ul></li><li><p>引用类型</p><ul><li>AtomicReference 引用类型原子类</li><li>AtomicStampedReference 原子更新引用类型里的字段原子类</li><li>AtomicMarkableReference 原子更新带有标记位的引用类型</li></ul></li><li><p>对象的属性修改类型</p><ul><li>AtomicIntegerFieldUpdater </li><li>AtomicLongFielfUpdater</li><li>AtomicStampedReference </li></ul></li></ul><h2 id="4-2-使用与原理"><a href="#4-2-使用与原理" class="headerlink" title="4.2 使用与原理"></a>4.2 使用与原理</h2><ul><li>以AtomicInteger为例，其方法如下：</li></ul><pre><code>    public final int get() //获取当前的值    public final int getAndSet(int newValue)//获取当前的值，并设置新的值    public final int getAndIncrement()//获取当前的值，并自增    public final int getAndDecrement() //获取当前的值，并自减    public final int getAndAdd(int delta) //获取当前的值，并加上预期的值    boolean compareAndSet(int expect, int update) //如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）    public final void lazySet(int newValue)//最终设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</code></pre><ul><li>AtomicInteger实现原理<ul><li>使用CAS以及volative来保证原子操作，从而避免synchronized的高开销，执行效率大为提升</li><li>CAS的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值</li><li>UnSafe 类的 objectFieldOffset() 方法是一个本地方法，这个方法是用来拿到“原来的值”的内存地址，返回值是 valueOffset</li><li>另外 value 是一个volatile变量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总能拿到该变量的最新值。</li></ul></li></ul><pre><code>    // setup to use Unsafe.compareAndSwapInt for updates（更新操作时提供“比较并替换”的作用）    private static final Unsafe unsafe = Unsafe.getUnsafe();    private static final long valueOffset;    static {        try {            valueOffset = unsafe.objectFieldOffset                (AtomicInteger.class.getDeclaredField(&quot;value&quot;));        } catch (Exception ex) { throw new Error(ex); }    }    private volatile int value;</code></pre><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://gitee.com/SnailClimb/JavaGuide/blob/master/docs/java/Multithread/synchronized.md" target="_blank" rel="noopener">https://gitee.com/SnailClimb/JavaGuide/blob/master/docs/java/Multithread/synchronized.md</a></li><li><a href="https://blog.csdn.net/zqz_zqz/article/details/70233767" target="_blank" rel="noopener">https://blog.csdn.net/zqz_zqz/article/details/70233767</a></li><li><a href="https://www.baeldung.com/java-threadpooltaskexecutor-core-vs-max-poolsize" target="_blank" rel="noopener">https://www.baeldung.com/java-threadpooltaskexecutor-core-vs-max-poolsize</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-多线程知识基础&quot;&gt;&lt;a href=&quot;#1-多线程知识基础&quot; class=&quot;headerlink&quot; title=&quot;1. 多线程知识基础&quot;&gt;&lt;/a&gt;1. 多线程知识基础&lt;/h1&gt;&lt;h2 id=&quot;1-1-线程-vs-进程&quot;&gt;&lt;a href=&quot;#1-1-线程-vs-进
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
      <category term="Multi-threading" scheme="https://www.llchen60.com/tags/Multi-threading/"/>
    
  </entry>
  
  <entry>
    <title>工程上关于SQL数据库 - 你需要知道的事</title>
    <link href="https://www.llchen60.com/%E5%B7%A5%E7%A8%8B%E4%B8%8A%E5%85%B3%E4%BA%8ESQL%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E4%BA%8B/"/>
    <id>https://www.llchen60.com/%E5%B7%A5%E7%A8%8B%E4%B8%8A%E5%85%B3%E4%BA%8ESQL%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E4%BA%8B/</id>
    <published>2020-04-27T20:48:48.000Z</published>
    <updated>2020-04-29T18:39:57.222Z</updated>
    
    <content type="html"><![CDATA[<p>大部分的计算机系统都会有需要维护的状态，大概率就要依赖于一个存储系统。在重数据的系统当中，数据库就会成为整个系统设计的核心，其中会有很多需要考虑到的权衡。我们必须要学习并且了解数据库是如何被使用的，这篇文章会分享一些对于开发者有用的视角和观点。</p><h1 id="1-网络连接问题-–-难以达到的5个9"><a href="#1-网络连接问题-–-难以达到的5个9" class="headerlink" title="1. 网络连接问题 – 难以达到的5个9"></a>1. 网络连接问题 – 难以达到的5个9</h1><p>总有关于当前的网络有多么值得信赖的考量，谷歌云的数据，在服务层面达到99.999%的可访问的程度的时候，大约有7.6%的问题是由于网络造成的。这也同样有相关数据在AWS，甚至阿里云当中。因为挖断光纤，或者网络配置的问题，造成一个数据中心，甚至一个avaliability zone 不可访问。</p><p>根据过往的经验，云服务提供商出现的网络问题，很有可能直接造成使用的公司服务down掉数小时的时间。从用户的角度来看，他们去定位问题所在是很有难度的。首先要尽快判断是IaaS 还是PaaS出现的问题，当判断出是云服务供应商这边出现的问题之后，除了尽快联系，恐怕也别无他法。</p><p>出现网络问题的原因很多，像是硬件炸了，权限更改，停电，光纤被挖断，诸如此类。各大云服务厂商都会在一个地区有多个AZ,每个AZ有多个data center，相互之间再用光纤连接。会需要看哪条光纤无法使用，会对整个系统造成不同程度的影响。</p><h1 id="2-ACID-有多个涵义"><a href="#2-ACID-有多个涵义" class="headerlink" title="2. ACID 有多个涵义"></a>2. ACID 有多个涵义</h1><p>ACID指的是Atomicity, Consistency, Isolation, Durability。这些都是数据库的transaction需要的相关属性，以确保用户的数据属性在程序崩溃，硬件出现错误等各种情况下依旧按照期待来运行。没有ACID的话，开发者无法知道自己的代码的责任，以及数据库的责任，会造成很多问题。当然上述说的还是主要对于SQL数据库而言的，对于NoSQL来说，大部分都没有实现ACID，或者不是默认实现的(譬如AWS DynamoDB，可以选择实现transaction的功能)，因为他们实现起来很昂贵。</p><p>关于为什么NoSQL实现ACID很昂贵，首先需要说的是SQL对于大数据量是有瓶颈的，在上千万的数据规模以上，会难以继续扩容。NoSQL实质上是将传统的纵向扩容改为横向扩容，牺牲了一致性，(保证最终一致性)，来达到对更多数据的支持。</p><p>值得注意的是工业界对于ACID是没有一个非常非常之明确的定义的，首先不是每个数据库都是满足ACID的，然后在那些满足ACID的数据库当中，ACID也可以被不同的方式来做解释。ACID被不同的方式来解释的原因之一是在实现的时候四个特征之间的制衡。他们在处理一个edge case还有“不可能”情况的时候，表现还是会有蛮多不一样的地方的。</p><h1 id="3-每个数据库都有不同的一致性和隔离性能力"><a href="#3-每个数据库都有不同的一致性和隔离性能力" class="headerlink" title="3. 每个数据库都有不同的一致性和隔离性能力"></a>3. 每个数据库都有不同的一致性和隔离性能力</h1><p>在ACID属性当中，一致性和隔离性是在实现的时候最需要权衡的两个属性，因为实现的代价都很高。他们需要协同，在保证数据一致的过程中实质上是加剧了竞争的，竞争共同的资源。</p><p>在云服务的层面，一致性变得尤为困难，尤其是当我们需要横向的去扩展到不同的数据中心当中去的时候。根据CAP理论，一致性，可用性，分区容错性不可能同时满足，当我们要实现一致性的时候，势必会丢失掉一部分可用性，或者分区容错性。</p><p>值得注意的是，工程师是可以在程序的层面去解决一定的一致性的问题的，不一定要完全依赖于数据库层面的一致性检测。</p><p>数据库一般会提供一系列的隔离的层次，因此应用开发者就可以根据他们所需来选择最高效的isolation方式。弱隔离会更快，但也许会带来数据竞争。更强的隔离消减了一些潜在的数据隔离，但是会更慢，而且在慢到一定程度，TPS又相对比较高的情况下，数据库可能会被高TPS拖垮，变得不可访问。</p><p><img src="https://i.loli.net/2020/04/26/wU6biJox59ZanGN.png" alt="Existing concurrency model.png"></p><p>在SQL标准当中，隔离性的层级有：</p><ul><li>Serializable - 最严格，最昂贵的<ul><li>序列化的执行会要求前一个transaction完全执行完，才能去执行下一个transaction  </li><li>常常被称为snapshot isolation </li></ul></li><li>Repeatable reads <ul><li>在当前transaction当中还没提交的读请求对当前transaction是可见的，但是其他transaction做出的改变对当前transaction依旧不可见</li></ul></li><li>Read Committed <ul><li>未提交的读对transaction不可见</li><li>如果另外一个transaction插入并提交了新的行，当前的transaction在query的时候是可以看到的</li></ul></li><li>Read uncommitted <ul><li>脏读是被允许的</li><li>transactions可以看到其他transaction还没有提交的commit。很实用与count这种请求</li></ul></li></ul><p>关于具体的一个数据库，是怎么样对各级别的隔离进行处理的，可以参考 <a href="https://github.com/ept/hermitage" target="_blank" rel="noopener">Github - hermitage</a></p><h1 id="4-当你无法完全锁住的时候，可以选择使用乐观锁"><a href="#4-当你无法完全锁住的时候，可以选择使用乐观锁" class="headerlink" title="4. 当你无法完全锁住的时候，可以选择使用乐观锁"></a>4. 当你无法完全锁住的时候，可以选择使用乐观锁</h1><p>锁是极度昂贵的，这不仅仅是因为在数据库当中造成了强竞争，并且因为他们对于长连接的要求，这种从你的应用服务器到数据库的连接需要一直保持，是非常耗资源的。排它锁收到网络分区的影响更大，并且会导致非常难debug的死锁的问题。在排它锁不易实现的情境下，乐观锁是一个值得考虑的选择。</p><p>乐观锁从实现上是指当你去读一行的时候，记录下来版本号，最后一次修改的时间或者是checksum，想要达成的目的就是知道当前的它还是它。然后我们就可以在修改了数据之后去检测这个数据是否有被改变，如果没有，那么就证实其没有什么问题，我们就可以执行我们接下来的写操作了。</p><pre><code>UPDATE productsSET name = &#39;Telegraph receiver&#39;, version = 2 WHERE id = 1 AND version = 1</code></pre><p>注意乐观锁不是在数据库层面的限制了，而是在应用代码的层面，加以限制。 </p><h1 id="5-除了dirty-reads-和data-loss-你可能遇到其他的一些问题"><a href="#5-除了dirty-reads-和data-loss-你可能遇到其他的一些问题" class="headerlink" title="5. 除了dirty reads 和data loss 你可能遇到其他的一些问题"></a>5. 除了dirty reads 和data loss 你可能遇到其他的一些问题</h1><p>当我们谈论数据一致性的时候，我们会主要将注意力放在可能的race condition当中，其会导致脏读，以及数据的丢失。但是可能出现的问题不仅仅会出现在这个方面的。</p><p>比如说write skew问题 - 写偏序，是指一致性约束下的异常现象，即两个并行事务都基于自己读到的数据去覆盖另一部分数据集，在串行化的情况下两个事务无论何种先后顺序，最终都将达到一致状态，但是在Snapshot Isolation的隔离级别下是无法实现的。</p><pre><code>BEGIN tx1;                      BEGIN tx2;SELECT COUNT(*) FROM operatorsWHERE oncall = true;0                               SELECT COUNT(*)                                FROM operators                                WHERE oncall = TRUE;                                0UPDATE operators           UPDATE operatorsSET oncall = TRUE               SET oncall = TRUEWHERE userId = 4;               WHERE userId = 2;COMMIT tx1;                     COMMIT tx2;</code></pre><p>为了解决write skew问题，需要在事务的运行阶段增加冲突检测，而不是在提交阶段。通过加入事务开始时间戳以及事务结束时间戳，保证一个事务读的数据的最近一个版本的提交时间要早于事务的开始时间。</p><h1 id="6-关于事务提交顺序"><a href="#6-关于事务提交顺序" class="headerlink" title="6. 关于事务提交顺序"></a>6. 关于事务提交顺序</h1><p>数据库首先是提供顺序保证的，但是这个顺序和我们想的可能会又不用。即从数据库的视角来看，关注的是接收到事务(transaction)的顺序，而不是开发者编程看到的顺序。事务执行的顺序是很难预测的，尤其是在高并发的系统当中。</p><p>如果说执行顺序非常关键的话，我们应当将多条命令放到同一个数据库transaction当中。老避开提交时间不确定的问题。</p><h1 id="7-应用层面的数据库分区可以布局在应用之外"><a href="#7-应用层面的数据库分区可以布局在应用之外" class="headerlink" title="7. 应用层面的数据库分区可以布局在应用之外"></a>7. 应用层面的数据库分区可以布局在应用之外</h1><p>有点拗口，想要说明的是当我们的数据库数据量持续增大的时候，横向的分区就变得必不可少了。但是很多数据库可能无法做好横向分区，即traffic会非常不均匀等等。</p><p>标题想要阐述的，这个分区的逻辑不需要必须在你的应用里边，我们可以单独抽取出一个层级，包含分区逻辑。即application server –&gt; shard servers –&gt; database nodes。这样分离的好处是随着数据量的增大以及访问的数据特征的变化，我们需要的分区逻辑也会不断发生变化。分隔开变化，使得分区逻辑的改变不需要重新deploy应用服务器，加速了整个开发的进程。</p><h1 id="8-AUTOINCCREMENT-可能有害"><a href="#8-AUTOINCCREMENT-可能有害" class="headerlink" title="8. AUTOINCCREMENT 可能有害"></a>8. AUTOINCCREMENT 可能有害</h1><p>AUTOINCREMENT是个很常见的生成主键的方式，常常看到数据库被用来作为ID生成器，或者有专门的一个数据库用来负责做ID的生成。这样做有可能会无益，以下是一些原因：</p><ul><li>在分布式数据库系统当中，自动增长是一个很困难的事情。是需要一个global lock来生成ID的。如果你可以用UUID来取而代之的话，那么就不需要各个数据库节点之间的合作了。带锁的自增操作可能会引入冲突，极大的降低插入操作在分布式数据库当中的表现。</li><li>一些数据库根据主键来做分区算法，连续的ID很可能会导致不可测的热点，也许会让一些分区炸掉的同时其他分区很空闲。</li><li>最快访问数据库当中一行的方式就是通过其主键。如果我们能够有更好的定义一条数据的方式，那么使用其他富含意义的属性来作为主键会是个更好的选择。</li></ul><h1 id="9-任何时间源之间可能会有不同"><a href="#9-任何时间源之间可能会有不同" class="headerlink" title="9. 任何时间源之间可能会有不同"></a>9. 任何时间源之间可能会有不同</h1><p>所有的时间相关的API是不准确的，我们的机器并不是清楚的知道当前具体是什么时间的。我们的电脑都包含一个石英晶片，可以用来产生信号，让时间开始走。但是这种方式下，不会非常精准，总会比实际的时间稍微快一些或者慢一些。为了精确性，我们的电脑上的时间就需要根据实际时间来进行同步。</p><p>NTP服务器可以被用来对时间进行同步，但是好玩的是同步本身又会因为网络延时不够准确。谷歌是使用TrueTime服务来做的</p><ul><li>其使用两种不同的资源： GPS和原子钟。他们有不同的失败模式，因此二者并用能够增加可信赖度。</li><li>TrueTime用时间间隔来表示返回的时间，即当前时间一定在一个区间之内，所做的事情就是保证在这个区间的可信度足够高了</li></ul><h1 id="10-评估数据库在单个事务中的表现"><a href="#10-评估数据库在单个事务中的表现" class="headerlink" title="10. 评估数据库在单个事务中的表现"></a>10. 评估数据库在单个事务中的表现</h1><p>有些时候数据库会宣传自己的表现以及特征，然后说自己的latency，读写吞吐量有多么多么的大。但是… 离开具体场景的数据都是耍流氓，我们需要更加细致的衡量方式来评估数据库在一些非常关键的操作或者事务下的表现。</p><p>比如：</p><ul><li>当在一个有5000万行的数据库当中插入新的一行的吞吐量和延时</li><li>当查询用户的朋友的朋友（朋友的平均数量大致为500）的延时</li><li>获取用户时间线上前100条数据的延时，假定用户订阅了500个用户，每个用户每小时会发送n条信息</li></ul><p>我们需要根据使用数据库的实际场景来做针对性的测试，来更加深入的理解这个数据库的特征</p><h1 id="11-事务当中不应该保存应用的状态"><a href="#11-事务当中不应该保存应用的状态" class="headerlink" title="11. 事务当中不应该保存应用的状态"></a>11. 事务当中不应该保存应用的状态</h1><p>还是要注重相互之间的隔离的，client端在网络出现问题的时候常常会不停重试请求。如果事务依赖于一些能够在其他地方被改变的状态，那么事务当中可能就会拿到错误的数据，导致隐含错误的出现，开发者是很难找到这种类型的错误的。</p><pre><code>var seq int64with newTransaction():     newSeq := atomic.Increment(&amp;seq)     Entries.query(newSeq)     // Other operations...</code></pre><p>譬如这种错误，事务当中会对sequence number做累加操作，当网络出现问题，会回滚，但是seq数字已经增加了，这就导致了下次执行的结果和上次本应该获得的结果会出现不同。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://medium.com/@rakyll/things-i-wished-more-developers-knew-about-databases-2d0178464f78" target="_blank" rel="noopener">https://medium.com/@rakyll/things-i-wished-more-developers-knew-about-databases-2d0178464f78</a> </li><li><a href="https://www.quora.com/Why-doesnt-NoSQL-support-an-ACID-property" target="_blank" rel="noopener">https://www.quora.com/Why-doesnt-NoSQL-support-an-ACID-property</a></li><li><a href="https://en.wikipedia.org/wiki/CAP_theorem" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/CAP_theorem</a></li><li><a href="https://jepsen.io/consistency" target="_blank" rel="noopener">https://jepsen.io/consistency</a> </li><li><a href="https://blog.csdn.net/oaa608868/article/details/54866899" target="_blank" rel="noopener">https://blog.csdn.net/oaa608868/article/details/54866899</a></li><li><a href="http://www.nosqlnotes.com/technotes/mvcc-snapshot-isolation/" target="_blank" rel="noopener">http://www.nosqlnotes.com/technotes/mvcc-snapshot-isolation/</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;大部分的计算机系统都会有需要维护的状态，大概率就要依赖于一个存储系统。在重数据的系统当中，数据库就会成为整个系统设计的核心，其中会有很多需要考虑到的权衡。我们必须要学习并且了解数据库是如何被使用的，这篇文章会分享一些对于开发者有用的视角和观点。&lt;/p&gt;
&lt;h1 id=&quot;1-
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="CAP" scheme="https://www.llchen60.com/tags/CAP/"/>
    
      <category term="SQL" scheme="https://www.llchen60.com/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript Dependency Hell - 对于JS依赖树的分析</title>
    <link href="https://www.llchen60.com/JavaScript-Dependency-Hell-%E5%AF%B9%E4%BA%8EJS%E4%BE%9D%E8%B5%96%E6%A0%91%E7%9A%84%E5%88%86%E6%9E%90/"/>
    <id>https://www.llchen60.com/JavaScript-Dependency-Hell-%E5%AF%B9%E4%BA%8EJS%E4%BE%9D%E8%B5%96%E6%A0%91%E7%9A%84%E5%88%86%E6%9E%90/</id>
    <published>2020-04-23T23:32:31.000Z</published>
    <updated>2020-04-23T23:33:13.740Z</updated>
    
    <content type="html"><![CDATA[<p>做前端开发的同学肯定都对npm很熟悉，node package manager，一个非常受欢迎的包管理器。npm通过<code>package.json</code>来对项目当中的包进行管理，在这个json文件当中的包相当于就被npm注册了。</p><h1 id="1-什么是package-json"><a href="#1-什么是package-json" class="headerlink" title="1. 什么是package.json?"></a>1. 什么是package.json?</h1><ul><li><p>其定义了你的项目所依赖的所有包</p></li><li><p>并指定你的项目所用的包的版本号</p></li><li><p>让你的build是可以复制的，方便其他开发者来使用</p><h1 id="2-Package-json-中的依赖种类"><a href="#2-Package-json-中的依赖种类" class="headerlink" title="2. Package.json 中的依赖种类"></a>2. Package.json 中的依赖种类</h1></li><li><p>dependencies </p><ul><li>这里定义了你的代码所需要的关键依赖</li></ul></li><li><p>devDependencies </p><ul><li>这里定义了你的开发所使用的的依赖，比如给代码样式的perttier 库</li></ul></li><li><p>peerDependencies </p><ul><li>这里是告诉其他开发者，当使用了你的这个包以后，他们需要定义在这里的包的特定版本</li></ul></li><li><p>optionalDependencies </p><ul><li>可选的依赖，不安装他们不会毁坏安装的过程</li></ul></li><li><p>bundledDependencies </p><ul><li>这里包含的是一个列表的包，他们会被打包到一起来引入到你的项目当中。这个在你的依赖包不在npm当中的情况下是很有用的。    <h1 id="3-使用package-lock-json的目的"><a href="#3-使用package-lock-json的目的" class="headerlink" title="3. 使用package-lock.json的目的"></a>3. 使用package-lock.json的目的</h1>package-lock的使用目的，我们在前面的博文当中有详细的描述过 – <a href="https://llchen60.com/%E5%85%B3%E4%BA%8Epackage-lock-json/" target="_blank" rel="noopener">相关博文</a>。总的来说，有packge-lock.json 能够给我们更大的自由度，将commit的回退和依赖的回退分隔开，即我可以使用过去的依赖树运行当前的代码，这在没有lock json的时候是很难实现的。</li></ul></li></ul><h1 id="4-依赖树的例子与简化"><a href="#4-依赖树的例子与简化" class="headerlink" title="4. 依赖树的例子与简化"></a>4. 依赖树的例子与简化</h1><pre><code>// 以gatsby为例, know the size of your node_modules overall du -sh node_modules// list the size decending $ du -sh ./node_modules/* | sort -nr | grep &#39;\dM.*&#39; 17M    ./node_modules/rxjs8.4M    ./node_modules/@types7.4M    ./node_modules/core-js6.8M    ./node_modules/@babel5.4M    ./node_modules/gatsby5.2M    ./node_modules/eslint4.8M    ./node_modules/lodash3.6M    ./node_modules/graphql-compose3.6M    ./node_modules/@typescript-eslint3.5M    ./node_modules/webpack3.4M    ./node_modules/moment3.3M    ./node_modules/webpack-dev-server3.2M    ./node_modules/caniuse-lite3.1M    ./node_modules/graphql</code></pre><p>…</p><pre><code>// !!! moved unused modules and dependenciesnpm dedup </code></pre><p>解耦操作的运行机理，就是寻找不同依赖之间的公有的包，然后复用这些共有的包。</p><p>对于可视化，用一些现成的工具可以被用来观察整个包的依赖状态，譬如：</p><ul><li><a href="https://npm.anvaka.com/#/" target="_blank" rel="noopener">https://npm.anvaka.com/#/</a></li><li><a href="http://npm.broofa.com/" target="_blank" rel="noopener">http://npm.broofa.com/</a></li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://blog.appsignal.com/2020/04/09/ride-down-the-javascript-dependency-hell.html" target="_blank" rel="noopener">https://blog.appsignal.com/2020/04/09/ride-down-the-javascript-dependency-hell.html</a> </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;做前端开发的同学肯定都对npm很熟悉，node package manager，一个非常受欢迎的包管理器。npm通过&lt;code&gt;package.json&lt;/code&gt;来对项目当中的包进行管理，在这个json文件当中的包相当于就被npm注册了。&lt;/p&gt;
&lt;h1 id=&quot;1-什
      
    
    </summary>
    
    
      <category term="FrontEnd" scheme="https://www.llchen60.com/categories/FrontEnd/"/>
    
    
      <category term="JaveScript" scheme="https://www.llchen60.com/tags/JaveScript/"/>
    
      <category term="JS Dependency" scheme="https://www.llchen60.com/tags/JS-Dependency/"/>
    
  </entry>
  
  <entry>
    <title>Typescript学习笔记(二)</title>
    <link href="https://www.llchen60.com/Typescript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/"/>
    <id>https://www.llchen60.com/Typescript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/</id>
    <published>2020-04-21T03:25:57.000Z</published>
    <updated>2020-04-21T03:26:33.088Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>类型别名</p><ul><li>用来为一个类型起一个新名字</li></ul></li></ul><pre><code>type Name = string; </code></pre><ul><li>字符串字面量类型</li></ul><pre><code>type EventNames = &#39;click&#39; | &#39;scroll&#39; | &#39;mousemove&#39;;function handleEvent(ele: Element, event: EventNames) {    // do something}handleEvent(document.getElementById(&#39;hello&#39;), &#39;scroll&#39;);  // 没问题handleEvent(document.getElementById(&#39;world&#39;), &#39;dbclick&#39;); // 报错，event 不能为 &#39;dbclick&#39;// index.ts(7,47): error TS2345: Argument of type &#39;&quot;dbclick&quot;&#39; is not assignable to parameter of type &#39;EventNames&#39;.</code></pre><ul><li>元组  - Tuple<ul><li>Tuple可以用于合并不同类型的对象</li></ul></li></ul><pre><code>let tom: [string, number] = [&#39;Tom&#39;, 25];</code></pre><ul><li>枚举<ul><li>用于取值被限定在一定范围内的场景</li><li>使用enum进行定义的</li><li>枚举成员会被赋值为从0开始递增的数字，同时也会对枚举值到枚举名进行反向映射</li></ul></li></ul><pre><code>enum Days {Sun, Mon, Tue, Wed, Thu, Fri, Sat};console.log(Days[&quot;Sun&quot;] === 0); // trueconsole.log(Days[&quot;Mon&quot;] === 1); // trueconsole.log(Days[&quot;Tue&quot;] === 2); // trueconsole.log(Days[&quot;Sat&quot;] === 6); // trueconsole.log(Days[0] === &quot;Sun&quot;); // trueconsole.log(Days[1] === &quot;Mon&quot;); // trueconsole.log(Days[2] === &quot;Tue&quot;); // trueconsole.log(Days[6] === &quot;Sat&quot;); // true</code></pre><ul><li>类，类与接口<ul><li>使用class定义类，使用constructor定义构造函数，通过new生成新实例的时候，是会自动调用构造函数的</li></ul></li></ul><pre><code>class Animal {    constructor(name) {        this.name = name;    }    sayHi() {        return `My name is ${this.name}`;    }}let a = new Animal(&#39;Jack&#39;);console.log(a.sayHi()); // My name is Jack</code></pre><ul><li><p>类通过extends继承</p><ul><li><p>然后通过super关键词来调用父类的构造函数和方法</p><p>class Cat extends Animal {<br>  constructor(name) {</p><pre><code>  super(name); // 调用父类的 constructor(name)  console.log(this.name);</code></pre><p>  }<br>  sayHi() {</p><pre><code>  return &#39;Meow, &#39; + super.sayHi(); // 调用父类的 sayHi()</code></pre><p>  }<br>}</p><p>let c = new Cat(‘Tom’); // Tom<br>console.log(c.sayHi()); // Meow, My name is Tom</p></li></ul></li><li><p>泛型</p><p>  function createArray<T>(length: number, value: T): Array<T> {</p><pre><code>  let result: T[] = [];  for (let i = 0; i &lt; length; i++) {      result[i] = value;  }  return result;</code></pre><p>  }</p><p>  createArray(3, ‘x’); // [‘x’, ‘x’, ‘x’]</p></li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://ts.xcatliu.com/advanced/type-aliases" target="_blank" rel="noopener">https://ts.xcatliu.com/advanced/type-aliases</a> </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;类型别名&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用来为一个类型起一个新名字&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;type Name = string; &lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;字符串字面量类型&lt;/li&gt;
&lt;/ul&gt;

      
    
    </summary>
    
    
      <category term="FrontEnd" scheme="https://www.llchen60.com/categories/FrontEnd/"/>
    
    
      <category term="TypeScript" scheme="https://www.llchen60.com/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript笔记(一)</title>
    <link href="https://www.llchen60.com/TypeScript%E7%AC%94%E8%AE%B0-0/"/>
    <id>https://www.llchen60.com/TypeScript%E7%AC%94%E8%AE%B0-0/</id>
    <published>2020-04-19T17:44:45.000Z</published>
    <updated>2020-04-21T03:26:13.703Z</updated>
    
    <content type="html"><![CDATA[<p>Tl;dr </p><p>这会是一篇很长的博文，大部分内容都直接来自Reference当中的TypeScript教程和ES6教程，只是为了总结一些自己认为重要的知识点，以及一些认为需要深入理解的地方及其延伸的链接，希望有帮助。</p><h1 id="1-Intro"><a href="#1-Intro" class="headerlink" title="1. Intro"></a>1. Intro</h1><h2 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h2><ul><li>JavaScript超集，提供了类型系统和对ES6的支持，由Microsoft开发</li></ul><h2 id="1-2-优势"><a href="#1-2-优势" class="headerlink" title="1.2 优势"></a>1.2 优势</h2><ul><li>增加代码的可读性和可维护性<ul><li>类型系统是很好的文档，看类型的定义我们就能够知道如何使用了</li><li>可以在编译阶段发现大部分错误，比运行时出错好很多</li><li>增强编辑器的功能，包括代码补全，接口提示，跳转到定义，重构等</li></ul></li><li>兼容性好<ul><li>js文件实际上是可以直接重命名为ts文件的</li><li>及时不显式定义类型，也能够自动做出类型推论  </li></ul></li></ul><h2 id="1-3-相对劣势"><a href="#1-3-相对劣势" class="headerlink" title="1.3 相对劣势"></a>1.3 相对劣势</h2><ul><li>学习成本 <ul><li>接口 </li><li>泛型</li><li>类</li></ul></li><li>短期增加开发成本，要多写一些类型的定义，但是对于需要长期维护的项目，TypeScript能够减少其维护成本</li><li>集成到构建流程当中需要一些工作量的 </li></ul><h1 id="2-基础知识"><a href="#2-基础知识" class="headerlink" title="2. 基础知识"></a>2. 基础知识</h1><h2 id="2-1-原始数据类型"><a href="#2-1-原始数据类型" class="headerlink" title="2.1 原始数据类型"></a>2.1 原始数据类型</h2><ul><li><p>布尔值 - boolean</p><pre><code>  let isSuccessful: boolean = true;  let createdByNewBoolean: boolean = new Boolean(1);  // Type &#39;Boolean&#39; is not assignable to type &#39;boolean&#39;.  // &#39;boolean&#39; is a primitive, but &#39;Boolean&#39; is a wrapper object. Prefer using &#39;boolean&#39; when possible.  let createdByNewBoolean: Boolean = new Boolean(1);  // when you new Boolean, it will create a Boolean - a wrapper object  let createdByBoolean: boolean = Boolean(1);   // create a boolean </code></pre></li></ul><ul><li><p>数值 - number</p><pre><code>  let decLiteral: number = 6;</code></pre></li><li><p>字符串 - string</p></li></ul><pre><code>    let myName: string = &#39;Tom&#39;;    let myAge: number = 25;    // 模板字符串  `用来定义模板字符串，${}用来在模板字符串中嵌入表达式    let sentence: string = `Hello, my name is ${myName}.    I&#39;ll be ${myAge + 1} years old next month.`;</code></pre><ul><li>null &amp; undefined<ul><li>null 和 undefined是所有类型的子类型</li><li>void类型的变量不能赋值给number类型的变量</li></ul></li><li>symbol</li></ul><h2 id="2-2-任意值-Any"><a href="#2-2-任意值-Any" class="headerlink" title="2.2 任意值 - Any"></a>2.2 任意值 - Any</h2><p>任意值用来表示允许赋值为任意类型。在Typescript当中，普通类型在复制过程中改变类型是不被允许的，但是如果是any类型，则允许被赋值为任意类型。</p><pre><code>    let myFavoriteNumber: any = &#39;seven&#39;;    myFavoriteNumber = 7;</code></pre><ul><li>任意值上访问任何属性都是允许的，也允许调用任何方法</li><li>返回的类型都是任意值</li><li>对于未声明类型的变量<ul><li>未指定类型，那么会被识别为任意值类型</li></ul></li></ul><h2 id="2-3-类型推论"><a href="#2-3-类型推论" class="headerlink" title="2.3 类型推论"></a>2.3 类型推论</h2><p>如果没有明确的指定类型，那么TypeScript会按照类型推论 - Type Inference的规则推断出一个类型。</p><pre><code>let myFavoriteNumber = &#39;seven&#39;;myFavoriteNumber = 7;// index.ts(2,1): error TS2322: Type &#39;number&#39; is not assignable to type &#39;string&#39;.  编译的时候出错，因为TS自动做了类型推论，并且认定其为一个string类型</code></pre><p>但是如果定义的时候没有赋值，那么不管接下来是否会赋值，都会被推断成any类型而完全不被类型检查</p><pre><code>let myFavoriteNumber;myFavoriteNumber = &#39;seven&#39;;myFavoriteNumber = 7;</code></pre><h2 id="2-4-联合类型-Union-Types"><a href="#2-4-联合类型-Union-Types" class="headerlink" title="2.4 联合类型 - Union Types"></a>2.4 联合类型 - Union Types</h2><pre><code>let myFavoriteNumber: string | number;myFavoriteNumber = &#39;seven&#39;;myFavoriteNumber = 7;</code></pre><p>联合类型当中使用 <code>|</code>来分割每个类型</p><h2 id="2-5-接口"><a href="#2-5-接口" class="headerlink" title="2.5 接口"></a>2.5 接口</h2><ul><li><p>在TypeScript当中，使用接口定义对象的类型，除了可以对类的一部分行为进行抽象以外，也chang’yo个与对 对象的形状进行描述。</p><p>  interface Person {</p><pre><code>  name: string;  age: number;</code></pre><p>  }</p><p>  let tom: Person = {</p><pre><code>  name: &#39;Tom&#39;,  age: 25</code></pre><p>  };</p></li></ul><p>在做赋值的时候，定义的变量需要和接口有一样的属性。</p><ul><li><p>对于我们想要可选择的匹配的属性，我们可以用可选属性的方式：</p><p>  interface Person {</p><pre><code>  name: string;  age?: number;</code></pre><p>  }</p><p>  let tom: Person = {</p><pre><code>  name: &#39;Tom&#39;</code></pre><p>  };</p></li><li><p>也可以配置，是的接口能够接任意的属性： – <code>[propName: string] : any</code></p><ul><li><p>需要注意的是一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集 </p><p>interface Person {<br>  name: string;<br>  age?: number;<br>  [propName: string]: any;<br>}</p><p>let tom: Person = {<br>  name: ‘Tom’,<br>  gender: ‘male’<br>};</p></li></ul></li><li><p>只读属性</p><ul><li>有use case我们希望对象当中的一些字段只能在创建的时候被赋值，那么就可以通过使用readonly定义只读属性</li></ul></li></ul><h2 id="2-6-数组类型"><a href="#2-6-数组类型" class="headerlink" title="2.6 数组类型"></a>2.6 数组类型</h2><ul><li>使用类型+方括号来定义</li></ul><pre><code>let fibonacci: number[] = [1, 1, 2, 3, 5];</code></pre><ul><li>使用数组泛型来表示数组 – <code>Array&lt;elemType&gt;</code></li></ul><pre><code>let fibonacci: Array&lt;number&gt; = [1, 1, 2, 3, 5];</code></pre><ul><li>使用接口表示数组</li></ul><pre><code>interface NumberArray {    [index: number]: number;}let fibonacci: NumberArray = [1, 1, 2, 3, 5];</code></pre><h2 id="2-7-函数类型"><a href="#2-7-函数类型" class="headerlink" title="2.7 函数类型"></a>2.7 函数类型</h2><h3 id="2-7-1-函数声明"><a href="#2-7-1-函数声明" class="headerlink" title="2.7.1 函数声明"></a>2.7.1 函数声明</h3><pre><code>// 函数声明（Function Declaration）function sum(x, y) {    return x + y;}// 函数表达式（Function Expression）let mySum = function (x, y) {    return x + y;};// TypeScript下的函数声明function sum(x: number, y:number):number {    return x + y;}</code></pre><h3 id="2-7-2-函数表达式"><a href="#2-7-2-函数表达式" class="headerlink" title="2.7.2 函数表达式"></a>2.7.2 函数表达式</h3><pre><code>let mySum: (x: number, y: number) =&gt; number = function (x: number, y: number): number {    return x + y;};</code></pre><p>注意在上述代码当中，跟在mySum后面的是对于输入参数和输出参数的规定，中间用箭头来进行连接，这是TypeScript的规范。</p><p>另外我们也可以通过使用接口来定义函数的形状：</p><pre><code>interface SearchFunc {    (source: string, subString: string): boolean;}let mySearch: SearchFunc;mySearch = function(source: string, subString: string) {    return source.search(subString) !== -1;}</code></pre><h3 id="2-7-3-可选参数"><a href="#2-7-3-可选参数" class="headerlink" title="2.7.3 可选参数"></a>2.7.3 可选参数</h3><ul><li>使用问号跟在参数名字之后表示是可选的，注意可选参数需要在参数列表的末尾，其之后不能有必需参数了</li></ul><pre><code>function buildName(firstName: string, lastName?: string) {    if (lastName) {        return firstName + &#39; &#39; + lastName;    } else {        return firstName;    }}</code></pre><h3 id="2-7-4-参数默认与剩余参数"><a href="#2-7-4-参数默认与剩余参数" class="headerlink" title="2.7.4 参数默认与剩余参数"></a>2.7.4 参数默认与剩余参数</h3><pre><code>// 默认参数function buildName(firstName: string, lastName: string = &#39;Cat&#39;) {    return firstName + &#39; &#39; + lastName;}let tomcat = buildName(&#39;Tom&#39;, &#39;Cat&#39;);let tom = buildName(&#39;Tom&#39;);// 使用 ...来获取函数当中的剩余参数function push(array, ...items) {    items.forEach(function(item) {        array.push(item);    });}let a: any[] = [];push(a, 1, 2, 3);</code></pre><h2 id="2-8-声明文件"><a href="#2-8-声明文件" class="headerlink" title="2.8 声明文件"></a>2.8 声明文件</h2><p>当使用第三方库的时候，我们需要引用它的声明文件，以获得对应的代码补全，接口提示的功能</p><h3 id="2-8-1-声明语句"><a href="#2-8-1-声明语句" class="headerlink" title="2.8.1 声明语句"></a>2.8.1 声明语句</h3><p>比如我们想使用jquery，一般来说是加script标签，但是ts当中，我们需要使用declare var来定义其类型</p><pre><code>declare var jQuery: (selector: string) =&gt; any;jQuery(&#39;#foo&#39;);</code></pre><p>我们会将声明语句放到一个单独的文件当中，譬如对于上述的例子，就是放到jQuery.d.ts 当中<br>声明文件必须以<code>.d.ts</code>来结尾</p><p>ts会解析项目当中所有的*.ts文件，也包含了.d.ts结尾的文件，所以当我们定义.d.ts文件以后，里面的内容是会被整个项目共享的。</p><p>另外，我们可以通过@types 来统一管理第三方库的声明文件</p><h3 id="2-8-2-书写声明文件"><a href="#2-8-2-书写声明文件" class="headerlink" title="2.8.2 书写声明文件"></a>2.8.2 书写声明文件</h3><p>当第三方库没有提供声明文件的时候，我们就需要自己书写声明文件了。</p><p>库的使用场景主要有：</p><ul><li>全局变量 </li><li>npm包</li><li>UMD库</li><li>直接扩展全局变量</li></ul><p>详情看 <a href="https://ts.xcatliu.com/basics/declaration-files#xin-yu-fa-suo-yin" target="_blank" rel="noopener">link</a></p><h1 id="2-9-内置对象"><a href="#2-9-内置对象" class="headerlink" title="2.9 内置对象"></a>2.9 内置对象</h1><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects" target="_blank" rel="noopener">ECMAScript 内置对象</a></p><p><a href="https://github.com/Microsoft/TypeScript/tree/master/src/lib" target="_blank" rel="noopener">DOM DOM 内置对象</a></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://ts.xcatliu.com/" target="_blank" rel="noopener">https://ts.xcatliu.com/</a></li><li><a href="https://es6.ruanyifeng.com/" target="_blank" rel="noopener">https://es6.ruanyifeng.com/</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Tl;dr &lt;/p&gt;
&lt;p&gt;这会是一篇很长的博文，大部分内容都直接来自Reference当中的TypeScript教程和ES6教程，只是为了总结一些自己认为重要的知识点，以及一些认为需要深入理解的地方及其延伸的链接，希望有帮助。&lt;/p&gt;
&lt;h1 id=&quot;1-Intro&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="FrontEnd" scheme="https://www.llchen60.com/categories/FrontEnd/"/>
    
    
      <category term="TypeScript" scheme="https://www.llchen60.com/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>关于package-lock.json</title>
    <link href="https://www.llchen60.com/%E5%85%B3%E4%BA%8Epackage-lock-json/"/>
    <id>https://www.llchen60.com/%E5%85%B3%E4%BA%8Epackage-lock-json/</id>
    <published>2020-04-18T01:10:23.000Z</published>
    <updated>2020-04-18T01:11:57.173Z</updated>
    
    <content type="html"><![CDATA[<p>当我们将node package manager (npm) 升级到5.0以上的版本的时候，你会发现npm运行的时候会自动创建一个新文件 – package-lock.json。</p><p>里面包含的是我们的依赖关系，各种依赖的包和版本号。package-lock.json会在npm修改了node_modules 树或者修改了package.json之后自动生成。它精确的描述了整个生成的树，使得接下来任何一次的装配都可以生成完全一致的依赖树.这个生成的文件是需要commit 到remote branch上的，其目的在于：</p><ul><li>描述单个依赖树，使得其他人在做deploy的时候使用的是完全一致的依赖</li><li>使得使用人员有能力直接跳转回原先的依赖状态，而不需要将代码也回退到之前的版本</li><li>加强了依赖改变的阅读性，我们可以相对直观的看到每次的commit都有什么依赖被改变了</li><li>也可以通过是的npm跳过对于原先安装过的包的重复的元数据分析来优化整个安装的进程</li></ul><p>针对其特征，我们是应该将package-lock.json也提交上去的，这会给开发，同步带来不小的帮助。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://medium.com/coinmonks/everything-you-wanted-to-know-about-package-lock-json-b81911aa8ab8" target="_blank" rel="noopener">https://medium.com/coinmonks/everything-you-wanted-to-know-about-package-lock-json-b81911aa8ab8</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当我们将node package manager (npm) 升级到5.0以上的版本的时候，你会发现npm运行的时候会自动创建一个新文件 – package-lock.json。&lt;/p&gt;
&lt;p&gt;里面包含的是我们的依赖关系，各种依赖的包和版本号。package-lock.js
      
    
    </summary>
    
    
      <category term="FrontEnd" scheme="https://www.llchen60.com/categories/FrontEnd/"/>
    
    
      <category term="npm" scheme="https://www.llchen60.com/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>中台(二) - 略深入些的探究</title>
    <link href="https://www.llchen60.com/%E4%B8%AD%E5%8F%B0-%E4%BA%8C-%E7%95%A5%E6%B7%B1%E5%85%A5%E4%BA%9B%E7%9A%84%E6%8E%A2%E7%A9%B6/"/>
    <id>https://www.llchen60.com/%E4%B8%AD%E5%8F%B0-%E4%BA%8C-%E7%95%A5%E6%B7%B1%E5%85%A5%E4%BA%9B%E7%9A%84%E6%8E%A2%E7%A9%B6/</id>
    <published>2020-04-16T00:38:41.000Z</published>
    <updated>2020-04-16T00:39:21.588Z</updated>
    
    <content type="html"><![CDATA[<p>中台是企业级能力复用平台，整个中台的构建，实际上是将业务数据化，将数据业务化。是需要建立业务中台和数据中台的。业务中台通过抽象，封装可复用的逻辑，提升企业的响应力；数据中台通过打通企业的数据，构建自学习服务的数据能力，让企业更加智慧。</p><h1 id="1-通用化通用能力"><a href="#1-通用化通用能力" class="headerlink" title="1. 通用化通用能力"></a>1. 通用化通用能力</h1><p>目前大部分企业实现的中台，主要是将遗留下的后台系统，比如ERP MES CRM的公共部分进行拆解复用，形成类似交易中心，用户中心，订单中心这样的微服务集合供前台调用，从而保证<strong>逻辑的一致性</strong>同时更快响应前台的变化</p><p>Reference <a href="https://www.infoq.cn/article/wCZV6X5uujxDXFP0Eub9?utm_source=rss&utm_medium=article" target="_blank" rel="noopener">1</a> 当中举了订单服务的演进过程的例子，很值得一看。当平台需要开放多渠道来完成订单的时候，保证用户有着类似的体验是很重要的一项，包括整个系统的的scalability。</p><p>在这种情况下，一个数据中台能够使得用户可以看到在各个平台各个渠道自己下的订单。从平台角度来说，有了数据中台，维护成本，发生错误以后的修改成本都会减轻很多。</p><p>略微解释下，如果是分开的系统，那么每个系统都会有自己的数据库，我们需要做数据的join操作，然后返回给前端用户需要的正确的信息。当发生了逻辑上的错误以后，我们很有可能需要在分开的几个子系统当中来做修改，很容易出错，修改的整个时间消耗也会很长。而且数据仓库在多个系统的情况下，抽取数据，再进行分析是有比较大的时延的，一般都是加一天的样子，无法看到实时的数据。</p><h1 id="2-使用中台去ERP化"><a href="#2-使用中台去ERP化" class="headerlink" title="2. 使用中台去ERP化"></a>2. 使用中台去ERP化</h1><p>ERP， 即企业资源管理系统。最最开始的时候，企业的需求是将企业的流程梳理清晰，做到资源的集约化管理，本质上来讲是为了解决流程复用，业务能力化的问题。</p><p>但是当前ERP软件存在着如下的一些问题：</p><ol><li>商业软件，响应慢<br>企业只有使用权，这就导致企业的业务发生变化的时候，需要找到原厂重新配置或者重新开发，响应比较慢</li><li>封闭架构，不开放<br>套装ERP软件是封闭架构，技术不开放，导致企业无法对其进行大的功能上的扩展，只能像打补丁一样，构建一些外挂，而且效果往往不会很好</li><li>单体架构，弹性不够<br>单体架构，很难支持持续增长的各种需求</li><li>升级 维护成本<br>套装软件升级和维护成本非常高</li></ol><p>过去人们需要ERP更多的是因为我们需要流程，需要知道具体应该如何去组织。但是在互联网化的今天，原来静态化，标准化的业务流程已经不足以支撑企业的快速响应了。因此，诉求<strong>从原来的流程化变成了需要能够快速响应前台市场的变化</strong>。</p><p>企业组织结构从流程式协作走向了平台式协作。</p><p>ERP更像是一种计划式的经济，希望每个角色都按照分配的任务来走，共同完成一个任务，但是这种共同完成会导致不同角色之间的利益相互冲突。局部利益大于整体利益。</p><p>需要的转变是 —- 要开始学习以客户为中心去动态组织资源来提供服务，将原本<strong><em>以流程为独立单元的模块拆解为以客户价值为独立单元的模块</em></strong>。</p><p>以客户价值为独立单元，如何评定绩效就是个很关键也很困难的问题，尤其是对于那些为后端赋能的业务单元，如何将其关联到直接的客户价值当中。这需要数据中台提供这方面的能力，来利用全域的数据分析，建模，通过敏感性分析等算法技术来实时计算。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://www.infoq.cn/article/wCZV6X5uujxDXFP0Eub9?utm_source=rss&amp;utm_medium=article" target="_blank" rel="noopener">https://www.infoq.cn/article/wCZV6X5uujxDXFP0Eub9?utm_source=rss&amp;utm_medium=article</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;中台是企业级能力复用平台，整个中台的构建，实际上是将业务数据化，将数据业务化。是需要建立业务中台和数据中台的。业务中台通过抽象，封装可复用的逻辑，提升企业的响应力；数据中台通过打通企业的数据，构建自学习服务的数据能力，让企业更加智慧。&lt;/p&gt;
&lt;h1 id=&quot;1-通用化通用
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="中台" scheme="https://www.llchen60.com/tags/%E4%B8%AD%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>用户画像构建思路</title>
    <link href="https://www.llchen60.com/%E7%94%A8%E6%88%B7%E7%94%BB%E5%83%8F%E6%9E%84%E5%BB%BA%E6%80%9D%E8%B7%AF/"/>
    <id>https://www.llchen60.com/%E7%94%A8%E6%88%B7%E7%94%BB%E5%83%8F%E6%9E%84%E5%BB%BA%E6%80%9D%E8%B7%AF/</id>
    <published>2020-04-14T04:19:03.000Z</published>
    <updated>2020-04-14T04:19:47.832Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a>1. Overview</h1><p>用户画像指的是系统通过用户自己上传的信息以及自己的分析，记录了用户的大量的信息，而后为了便于去给各个系统来使用，将这些信息进行沉淀加工，形成一个标签树的整个过程。</p><p>画像是由标签树及末级标签的标签值构成的，全面定量刻画用户的结构化信息产品。画像是标签的总成，用户标签是具体刻画用户的结构化信息，以下简称标签。</p><p>用户画像对于公司的运营，盈利都有很大的好处：</p><ol><li>可以用于统计，使得对产品，对用户有基本认知</li><li>用于定向营销和精细化运营</li><li>还可以用于算法当中，在搜索推荐，风控广告等策略防线，标签被作为用户特征得以提取和使用</li></ol><h1 id="2-构建标签树"><a href="#2-构建标签树" class="headerlink" title="2. 构建标签树"></a>2. 构建标签树</h1><p>一个好的标签树需要具有高概括性和强延展性，高概括性意味着结构体系能够很好的包含一个用户的<strong>基本属性</strong>和<strong>产品交互的相关行为</strong>，同时对于业务重点单独强调，没有遗漏；“强延展性”意味着结构全面的同时也有一定的抽象概括能力，保证新增的标签可以很好的找到对应的分类，整个体系不会过于收敛局限。</p><p>按照这个原则，画像可以从以下维度进行组织： </p><ul><li><p>基本属性</p><ul><li>指一个用户的基本社会属性和变更频率比较低的特征<ul><li>真实社会年龄</li><li>性别</li><li>婚姻状况</li><li>昵称</li><li>号码</li><li>账号</li><li>lbs </li></ul></li></ul></li><li><p>平台属性</p><ul><li>平台属性是用户在平台上表现出的基本属性特征，是利用用户行为进行算法挖掘，标识用户真实属性的标签</li><li>譬如平台年龄标签  面向例如年龄为20岁，但是心理年龄50岁，穿衣风格50岁的人；反之亦然</li><li>平台属性和基本属性的区别如下：<ul><li>数据源与计算逻辑<ul><li>基础属性是利用用户自行上传的存储在用户基础信息表里的数据，平台属性则利用客户端或者服务端埋点上报采集的用户行为数据进行挖掘计算生成的。</li><li>基本属性是典型的直采型标签，平台属性是典型的算法挖掘型标签</li></ul></li><li>末级标签和输出标签值<ul><li>平台属性代表用户在性别维度上的偏好概率，可以生成类似<code>性别_女_0.80</code>这样的标签，0.8代表了用户的倾向程度</li></ul></li><li>应用场景<ul><li>平台属性通过用户行为进行挖掘，更能代表用户的真实倾向，输出结果比基本属性准确率更高</li></ul></li></ul></li></ul></li><li><p>行为属性</p><ul><li>行为属性记录用户的所有单个点的行为</li><li>包括<ul><li>启动</li><li>登录</li><li>浏览</li><li>点击</li><li>加车</li><li>下单</li></ul></li><li>是可以和不同的产品，不同的模块进行交互的，而且可以在不同的时间窗口进行选取，行为会相对复杂</li><li>按照 产品 x 功能模块 x 用户单点行为 x 时间  这四个要素来进行组织  </li></ul></li><li><p>产品偏好</p><ul><li>对用户使用某些产品，产品核心功能或者其他渠道的偏好程度的刻画，属于挖掘性的标签</li><li>产品可以包括自己公司的，竞品的</li><li>功能渠道包括站内产品功能，包括push、短信、开屏、弹窗等几大运营和产品方式 </li></ul></li><li><p>兴趣偏好</p><ul><li>品牌偏好  nike</li><li>类目偏好  运动</li><li>标签偏好  跑步_0.7</li></ul></li><li><p>敏感度</p><ul><li>营销活动中，会注意到有些用户不需要优惠也会下单，而有些用户一定要通过优惠券刺激才能实现转化，优惠券的额度也会影响用户下单的金额</li><li>需要识别对优惠敏感的用户，发放合理的券额，保证优惠券不浪费，使得整个促销活动的ROI最大</li><li>构建用户的敏感度标签<ul><li>优惠促销敏感度</li><li>活动敏感度</li><li>新品敏感度</li><li>爆款敏感度 </li></ul></li></ul></li><li><p>消费属性</p><ul><li>消费频次</li><li>消费金额</li><li>最近消费时间</li><li>消费能力</li><li>消费意愿 </li></ul></li><li><p>用户生命周期</p><ul><li>新手</li><li>成长</li><li>成熟</li><li>衰退</li><li>流失 </li></ul></li><li><p>用户价值</p><ul><li>活跃度</li><li>裂变拉新等 </li></ul></li></ul><h1 id="3-用户画像的范例"><a href="#3-用户画像的范例" class="headerlink" title="3. 用户画像的范例"></a>3. 用户画像的范例</h1><p><img src="https://i.loli.net/2020/04/14/XnJYc3ejRrMwdul.png" alt="用户画像导图.png"></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://www.infoq.cn/article/oUqJDlfstrYAmTBYzier?utm_source=rss&amp;utm_medium=article" target="_blank" rel="noopener">https://www.infoq.cn/article/oUqJDlfstrYAmTBYzier?utm_source=rss&amp;utm_medium=article</a> </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Overview&quot;&gt;&lt;a href=&quot;#1-Overview&quot; class=&quot;headerlink&quot; title=&quot;1. Overview&quot;&gt;&lt;/a&gt;1. Overview&lt;/h1&gt;&lt;p&gt;用户画像指的是系统通过用户自己上传的信息以及自己的分析，记录了用户的大量
      
    
    </summary>
    
    
      <category term="Notes" scheme="https://www.llchen60.com/categories/Notes/"/>
    
    
      <category term="用户画像" scheme="https://www.llchen60.com/tags/%E7%94%A8%E6%88%B7%E7%94%BB%E5%83%8F/"/>
    
      <category term="运营" scheme="https://www.llchen60.com/tags/%E8%BF%90%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>中台</title>
    <link href="https://www.llchen60.com/%E4%B8%AD%E5%8F%B0/"/>
    <id>https://www.llchen60.com/%E4%B8%AD%E5%8F%B0/</id>
    <published>2020-04-13T00:32:59.000Z</published>
    <updated>2020-04-13T00:34:29.013Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-什么是中台？"><a href="#1-什么是中台？" class="headerlink" title="1. 什么是中台？"></a>1. 什么是中台？</h1><p>看到几篇关于中台的博客，是国内提出的一个新的概念，稍微研究了下，很有意思的概念。</p><p>中台，在我看来，从业务上来讲，可以说是为了解决系统的复用性的问题而出现的。一个简单的例子，阿里刚刚开始的时候只有淘宝，但是后来出现了天猫，二者尽管顶层业务逻辑有不同，但是他们都是需要一套订单，商品，库存，仓储，物流的各种系统的。如果每次我们想做一个新的业务模块的时候，都要来实现这样一套系统，迭代速度会很慢，而且很容易在做改动的时候因为各个类似功能的系统的改动不一致产生错误。</p><p>因此，将这些公用的系统提升，做成–中台，统一来使得各个业务部门重复使用，将需要反复建设的功能和系统进行统一的规划和管理。</p><p>主要解决的问题实质上有两类： </p><ol><li>需要业务需求或者功能需求是高度类似的，通用化程度很高，但是由于没有专门的团队负责规划和开发，大量的系统重复开发、重复建设、导致复用性很低，效率低，研发资源被浪费，用户体验也不够统一</li><li>早起业务发展过程当中，为了解决当下的一些业务问题，垂直的个性化的业务逻辑与基础系统耦合太深，由于没有平台性质的规划，横向系统之间、上下游系统之间的交叉逻辑非常多，导致了在新业务新市场的拓展过程当中，市场没有办法直接复用，甚至没有办法快速迭代。</li></ol><h1 id="2-为什么要中台，为什么要平台化？"><a href="#2-为什么要中台，为什么要平台化？" class="headerlink" title="2. 为什么要中台，为什么要平台化？"></a>2. 为什么要中台，为什么要平台化？</h1><p>引述《白话中台战略》当中的内容，“因为在当今互联网时代，⽤户才是商业战场的中心，为了快速响应用户的需求，借助平台化的力量可以事半功倍”</p><blockquote><p>不断快速响应、探索、挖掘、引领⽤户的需求，才是企业得以⽣存和持续发展的关键因素。</p></blockquote><blockquote><p>那些真正尊重用户，甚⾄不惜调整⾃己颠覆⾃己来响应⽤户的企业将在这场以⽤户为中心的商业战争中得以⽣存和发展；⽽反之，那些在过去的成就上故步⾃封，存在侥幸⼼理希望⽤户会像之前一样继续追随⾃己的企业则会被用户淘汰。很残酷，但这就是这个时代最基本的企业⽣存法则。</p></blockquote><p>平台化能够赋予或加强企业在以用户为中心的现代商业战争当中最为核心的能力 –&gt; 用户响应力。 </p><p>中台，可以说是与前台，后台相对应的。</p><ul><li>前台<ul><li>由各类前台系统组成的前端平台。每个前台系统就是一个用户触点，即企业的最终用户直接使用或者交互的系统，是企业与最终用户的交点。</li></ul></li><li>后台<ul><li>后台系统组成的后端平台，宝具哦企业的核心资源 – 数据 + 计算 <ul><li>财务系统</li><li>产品系统</li><li>客户管理系统</li><li>仓库物流管理系统</li></ul></li></ul></li><li>中台<ul><li>因为企业后台往往不能很好的支撑前台快速创新，响应用户的需求</li><li>前台直接使用后台，会遇到处理复杂，迭代速度缓慢的问题</li><li>前台要处理的是快速响应用户的需求，但是后台拿着整个公司的数据，是需要越稳定越好的，随着公司的发展，按照对速度和稳定的追求的冲突会越来越多</li><li>有了中台以后就可以将前台系统当中的稳定通用业务能力沉降到中台层，恢复前台的响应力</li></ul></li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://www.infoq.cn/article/3tbJZ8aS5pYdWYX5bBfg?utm_source=rss&amp;utm_medium=article" target="_blank" rel="noopener">https://www.infoq.cn/article/3tbJZ8aS5pYdWYX5bBfg?utm_source=rss&amp;utm_medium=article</a></li><li><a href="https://mp.weixin.qq.com/s/yfhaEkO1DG_ihJMhwtkWjA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/yfhaEkO1DG_ihJMhwtkWjA</a></li><li><a href="https://www.infoq.cn/article/hfONAlDdhK3fD9JjduGR" target="_blank" rel="noopener">https://www.infoq.cn/article/hfONAlDdhK3fD9JjduGR</a></li><li><a href="https://www.zhihu.com/question/57717433" target="_blank" rel="noopener">https://www.zhihu.com/question/57717433</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-什么是中台？&quot;&gt;&lt;a href=&quot;#1-什么是中台？&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是中台？&quot;&gt;&lt;/a&gt;1. 什么是中台？&lt;/h1&gt;&lt;p&gt;看到几篇关于中台的博客，是国内提出的一个新的概念，稍微研究了下，很有意思的概念。&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="中台" scheme="https://www.llchen60.com/tags/%E4%B8%AD%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>关于抖音的一些分析</title>
    <link href="https://www.llchen60.com/%E5%85%B3%E4%BA%8E%E6%8A%96%E9%9F%B3%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E6%9E%90/"/>
    <id>https://www.llchen60.com/%E5%85%B3%E4%BA%8E%E6%8A%96%E9%9F%B3%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E6%9E%90/</id>
    <published>2020-04-11T21:29:43.000Z</published>
    <updated>2020-04-11T22:45:17.990Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a>1. Overview</h1><h2 id="1-1-外部环境背景"><a href="#1-1-外部环境背景" class="headerlink" title="1.1 外部环境背景"></a>1.1 外部环境背景</h2><p>短视频是当前超高速发展的赛道，流量持续迅猛增长，越来越多的公司进入这个赛道，头部的国内有抖音快手，主要着眼于1min以内的短视频，主要为UGC(User Generated Content)，少量PGC(Professional Generated Content)产出内容；美国有刚刚成立的quibi，着眼于制作10min左右的优质内容，完全走PGC的路线。</p><p>短视频的兴起是有一些需要的社会以及科技的基础背景的。 </p><ul><li>从经济发展角度<ul><li>经济的持续发展，刺激了人们的休闲娱乐的需求的增长</li></ul></li><li>从用户需求角度<ul><li>需要填补自己的碎片时间</li><li>需要更多的娱乐休闲</li><li>自我表达，自我实现，社会联结的需求</li><li>发泄情绪</li></ul></li><li>从用户使用习惯角度<ul><li>截止2019年6月<ul><li>全国手机网民数量达到8.47亿(根据第44次中国互联网发展状况统计报告)，互联网普及率达到61.2%</li><li>网络购物用户规模6.39亿 </li><li>手机网络购物用户规模6.22亿</li><li>网络视频用户7.59亿</li><li>移动互联网接入流量消费553.9亿GB 同比增长107.3% </li><li>网民平均每周上网时长 27.9小时</li><li>短视频时长占比 11.5%，使用高峰为12点以及21点左右  </li></ul></li></ul></li><li>从技术角度<ul><li>4G 5G兴起，高速网络建设</li><li>手机的广泛普及</li><li>云平台普及，企业架构的相对简化，成本的降低 </li></ul></li><li>政策影响<ul><li>推出《网络短视频平台管理规范》</li><li>推出《网络短视频内容审核标准细则》 </li></ul></li></ul><h2 id="1-2-时间线"><a href="#1-2-时间线" class="headerlink" title="1.2 时间线"></a>1.2 时间线</h2><ul><li>2016年9月上线 <ul><li>A.me 定位为音乐短视频社区 </li><li>年轻人的15秒音乐短视频社区 </li></ul></li><li>2016年11月<ul><li>查找通讯录，邀请QQ 微博好友</li></ul></li><li>2016年11月10日<ul><li>微博话题挑战</li><li>雇佣 召集大学生，舞蹈音乐达人，拍摄视频引流</li></ul></li><li>2016年12月10日<ul><li>抖音 – 音乐视频应用</li></ul></li><li>2016年12月22日<ul><li>推荐热门视频</li><li>捧红一部分人，再带动普通用户的理念 – 偏向于中心化的运营方式出现端倪    </li></ul></li><li>2017年3月<ul><li>邀请岳云鹏等诸多明星加入抖音</li><li>开始有大批用户从明星微博当中看到抖音水印，进入抖音平台</li></ul></li><li>2017年6月开始<ul><li>给视频创作者更多权限<ul><li>对评论的控制，删减</li></ul></li><li>附近 tab，增强社交属性</li><li>抖音故事<ul><li>可以设置只开放24小时，希望普通人可以在上面记录自己的生活</li></ul></li><li>可以绑定微博主页</li></ul></li><li>2017年8月<ul><li>Tik Tok出海</li><li>吴亦凡的抖音挑战</li><li>中国有嘻哈 官方推荐</li><li>抖音开始砸钱到各个节目，增加曝光度了</li></ul></li><li>2017年9月<ul><li>首次线下party，狂欢节</li><li>和汉堡王，摩拜单车等等公司展开合作，联名等</li><li>AR相机</li><li>开启信息流广告，开屏广告的尝试 </li></ul></li><li>2017年10月<ul><li>上线直播功能</li></ul></li><li>2017年11月<ul><li>全新滤镜</li><li>倒计时自动暂停</li><li>直播间优化，增加弹幕功能</li></ul></li><li>2017年12月<ul><li>全新尬舞机功能    </li></ul></li><li>2018年1月<ul><li>百万英雄</li><li>私信功能</li><li>优化举报 评论功能</li></ul></li><li>2018年3月<ul><li>大规模的广告接入和投放开始</li></ul></li><li>2018年8月  <ul><li>直达淘宝功能上线</li><li>反沉迷系统上线        </li><li>增加游戏贴纸</li></ul></li><li>2018年10月<ul><li>个人页背景设置，个性化主页</li></ul></li><li>2018年12月<ul><li>直播粉丝团任务体系</li></ul></li><li>2019年1月<ul><li>地点详情页上传视频图片，用抖音来记录生活</li><li>直播 礼物一键连送</li><li>随拍功能</li><li>春晚独家社交媒体传播平台，五亿现金分享</li></ul></li><li>2019年2月<ul><li>AR画笔功能</li></ul></li><li>2019年3月<ul><li>随拍支持发布纯文字内容</li><li>新增聚焦拍摄模式</li><li>私信可置顶</li><li>热血鼓手道具玩法</li><li>新增位置贴纸</li></ul></li><li>2019年4月   <ul><li>道具玩法 – 橙子脸 </li><li>道具玩法 – 漫画擦拭</li></ul></li><li>2019年5月<ul><li>道具玩法 - change face   </li><li>挡脸变男生</li><li>道具玩法 - LineDancer</li></ul></li><li>2019年6月<ul><li>合拍 测相似度</li><li>道具玩法 – 炫光衣服 </li><li>道具玩法 – 照片连拍</li></ul></li><li>2019年7月<ul><li>道具玩法 – 动感轮廓</li><li>道具玩法 – 擦拭隐身</li><li>增加文字功能，可以在视频上添加文字了</li></ul></li><li>2019年9月<ul><li>青少年模式</li><li>道具玩法 – 百变抖抖秀</li></ul></li><li>2019年10月<ul><li>新增贴纸</li><li>青少年模式优化</li><li>新增变声功能</li></ul></li><li>2020年1月 - 至今<ul><li>春节20亿现金等你拿  </li><li>新增贴纸</li><li>新增特效  <h1 id="2-平台分析"><a href="#2-平台分析" class="headerlink" title="2. 平台分析"></a>2. 平台分析</h1><h2 id="2-1-市场定位"><a href="#2-1-市场定位" class="headerlink" title="2.1 市场定位"></a>2.1 市场定位</h2>从1.1的整个时间轴，我们会发现整个抖音的发展很小步快跑，迅速迭代。刚开始出了产品原型，用初始用户群体开始迅速做迭代，在锚定自己的定位，目标人群之后，通过召集KOL，明星，通过微博，QQ微信引流，实现其迅速的增长。</li></ul></li></ul><p>抖音的slogan是<strong>记录美好生活</strong>，<strong>以一二线城市年轻潮人为目标用户，市场定位突出音乐与创意</strong>，是一个相对中心化的高热度高流量的聚集年轻人的音乐短视频平台。整体是以音乐为核心布局的，用户在拍摄视频前首先选择一首背景音乐，根据音乐内容进行动作编排和加工特效。</p><h2 id="2-2-产品设计"><a href="#2-2-产品设计" class="headerlink" title="2.2 产品设计"></a>2.2 产品设计</h2><h3 id="2-2-1-浏览体验"><a href="#2-2-1-浏览体验" class="headerlink" title="2.2.1 浏览体验"></a>2.2.1 浏览体验</h3><ul><li>整体以黑白灰三色为主，风格简洁，有潮流感</li><li>全屏沉浸式体验<ul><li>无限向下滑动</li></ul></li><li>竖屏播放 – 适用更多的场景(上班，通勤，吃饭，等等) – 也很符合于短视频碎片时间使用的定位</li><li>点击背景音乐会跳转到同款音乐其他的短视频集合</li><li>交互 任意位置双击点赞，上下滑浏览其他视频</li><li>长按 可以看到更多的一些选择<ul><li>不感兴趣</li><li>加到喜欢 </li></ul></li></ul><h3 id="2-2-2-拍摄"><a href="#2-2-2-拍摄" class="headerlink" title="2.2.2 拍摄"></a>2.2.2 拍摄</h3><p>抖音在拍摄方面下了很大功夫，从更新日志上也能很明显看出他在尝试着不断降低拍摄出高质量视频的门槛，通过大量的特效，各种道具，让短视频不至于单调，可以用比较简单的素材，加上特效，音乐，撑起来。</p><ul><li>多种类型音乐<ul><li>国风</li><li>流行</li><li>原创 </li><li>etc.</li></ul></li><li>视频制作的功能<ul><li>速度切换</li><li>多段混剪</li><li>贴纸道具</li><li>美化滤镜</li><li>特效滤镜<h3 id="2-2-3-特色功能"><a href="#2-2-3-特色功能" class="headerlink" title="2.2.3 特色功能"></a>2.2.3 特色功能</h3></li></ul></li><li>热搜榜</li><li>尬舞机</li><li>时间锁</li></ul><h2 id="2-3-内容生产与分发"><a href="#2-3-内容生产与分发" class="headerlink" title="2.3 内容生产与分发"></a>2.3 内容生产与分发</h2><h3 id="2-3-1-内容生产模式"><a href="#2-3-1-内容生产模式" class="headerlink" title="2.3.1 内容生产模式"></a>2.3.1 内容生产模式</h3><p>UGC + PGC模式</p><ul><li>UGC<ul><li>普通用户</li></ul></li><li>PGC<ul><li>明星</li><li>网红</li><li>专业垂直领域KOL</li></ul></li></ul><h3 id="2-3-2-内容分发模式"><a href="#2-3-2-内容分发模式" class="headerlink" title="2.3.2 内容分发模式"></a>2.3.2 内容分发模式</h3><ul><li>算法推荐+人工精选推荐<ul><li>根据用户的观看数据，计算用户内容标签，按照一定频率推送相似的视频内容 </li><li>推荐爆款内容，越优质的内容会得到越多的曝光机会</li><li>推荐机制不太在意内容的发布时间，只要足够精彩，可能<strong><em>已经发布了几个月的视频</em></strong>还会不断推给用户</li></ul></li></ul><h2 id="2-4-营销推广"><a href="#2-4-营销推广" class="headerlink" title="2.4 营销推广"></a>2.4 营销推广</h2><ul><li>开屏广告</li><li>信息流广告</li><li>定制挑战赛<ul><li>为品牌独家定制</li><li>保持剧情，自主拍摄权交给视频制作者</li></ul></li><li>聚合电商<ul><li>同淘宝的直接链接</li></ul></li></ul><h2 id="2-5-技术能力"><a href="#2-5-技术能力" class="headerlink" title="2.5 技术能力"></a>2.5 技术能力</h2><ul><li>监管<ul><li>人工为主，机器学习为辅 <ul><li>通过建立完善数据库，将用户上传的内容与数据库进行匹配，被识别为不良内容就予以直接删除</li></ul></li><li>用户举报  <ul><li><h1 id="3-Thoughts"><a href="#3-Thoughts" class="headerlink" title="3. Thoughts"></a>3. Thoughts</h1></li></ul></li></ul></li></ul><h2 id="3-1-用户的需求"><a href="#3-1-用户的需求" class="headerlink" title="3.1 用户的需求"></a>3.1 用户的需求</h2><p>用户参与到虚拟社区的动机，可以是基于：</p><ul><li>自我认知和需求的满足 </li><li>社会交往需求  – 抖音不太能满足</li><li>获取利益的需求 – 平台盘子的扩大会增大每个人的盘子</li><li>情感归属 – 指跟随自己的偶像，明星，希望获取更多相关的信息</li></ul><p>首先，感到大部分人不习惯自己去主动寻求信息的，或者说，是不太清楚自己应该主动获取什么样的信息，因此app的主动推送，人被选择适时而生。（IOC 容器了解一下,hhh）</p><p>每个App都有自己的味道，抖音的味道能够吸引来追逐潮流的年轻人。可以在这里看到<strong>和自己类似的人</strong>拍的视频，看到的<strong>美好的世界</strong>。</p><p>抖音一定程度上满足了用户的自我认知的需求，会觉得抖音和自己很搭(用户画像和自我认知的部分重合)。</p><p>但在社交方面，有点不尽如人意，这也和抖音的整体 – 偏中心化的音乐短视频平台的初始定位有关了。当大部分的高质内容产出出自PGC, MCN的时候，潜在的内容创作者很可能会因为成为热门的高门槛而放弃。大家看自己向往的生活，而不是自己的生活。</p><p>热门视频大部分是有趣的段子，以及同样的素材音乐下的小哥哥小姐姐的表现，同质化有点严重，同时离日常生活的距离着实有点远，这也致使了用户之间的关联感比较差。  </p><p>一个超漂亮的小姐姐在跳舞，你会“哇，太好看了”，但你不知道该回什么，才能够不太尬的认识。因为这些小姐姐可能离你的物理距离还很远是吧~ 可看没法约 </p><p>抖音其实现在有基于地理位置的模块，有种想两手抓的感觉，不知道后台流量如何，只是当用户对于一个平台的定位是 – 去看好玩的搞笑的，去看小哥哥小姐姐的时候，想改变既定的认知，难度不小。想在保持当前定位的同时，加上一个社交属性，好像有些部分是相互有冲突的。</p><p>看到新闻在灰度测试，陌生人视频聊天，增强社交属性，看来是太不活跃，并没有灰度上。不知道具体是怎么样的过程，有没有足够多的对话题的引导，这种带点“阅后即焚”性质的尝试，会不会一不小心跨过监管允许的限制，lol  拭目以待</p><h2 id="3-2-others"><a href="#3-2-others" class="headerlink" title="3.2 others"></a>3.2 others</h2><ul><li>用户集中于一二线城市<ul><li>如何向三四线城市扩张？<ul><li>囧妈 很酷</li><li>大量的广告，代言<ul><li>这种打法在一二线城市很好用，三四线城市呢，联想趣头条 – 我们要最实在的！请给我钱，lol</li></ul></li><li>内容上的倾斜<ul><li>如何生产更多的小镇青年感兴趣的内容？  </li></ul></li></ul></li></ul></li><li>视频创作的门槛与参与热情<ul><li>刺激计划</li><li>培训平台 <ul><li>2019年11月26日上线创作者学院 </li></ul></li></ul></li><li>内容同质化，低俗化<ul><li>当在娱乐化做到很极致的时候(请看抖音app的极快的迭代频率，以及层出不穷的新道具，新玩法)，需要做更加深度的内容么？ </li><li>当知识付费成为新风口，巫师财经，半佛仙人成功出圈以后，有机会将内容浓缩到1-5min的视频当中，来点先导知识，然后再成功引流到长视频网站上？ </li></ul></li><li>弱社交平台<ul><li>社交是保证一个平台用户粘性的护城河，当抖音选择了沉浸式的无限下滑的交互方式的时候，一定程度上，我们可以说是舍弃了社交的 （对比快手的下滑留评，左滑回退的操作）。</li><li>弱社交也可以从留评数据当中可以看出，尽管抖音的日活月活遥遥领先，但留评，点赞是快手占据优势的，互动率要高出很多</li><li>做不做社交？<ul><li>一直无限想做，先出自己的专属app，没做起来，现在直接放到抖音这个国民app里做了</li></ul></li><li>为什么想做？<ul><li>社交，粘性，带货，看看快手的带货数据，贼酷炫</li><li>社交 - 附近的人 - 一张美丽的类似美团的外卖带动基于地理位置的其他业务的美妙构想</li></ul></li><li>concern<ul><li>社交注定是需要带点“平均人” 的理念的，这不仅仅需要接口，路径，交互方式的改变，更是内容分发逻辑，视频创作方式上的改变。那问题来了，社交有多重要，重要到改变整个平台的现有定位，重要到可能会降低一些格调，少一些fancy，多点生活气息么？ </li></ul></li></ul></li><li>算法 信息茧房<ul><li>用户喜欢的信息和信息广度的tradeoff，算法的单个方向上的相对极致优化，会缩减用户能够接受到的信息范围的</li><li>依旧是平台算法优化的问题了，到底给用户留出多少自己的空间呢？ </li></ul></li><li>政策的限制/要求 - 娱乐属性，社会属性，深入的思考性的东西很少<ul><li>嗯，是这样的~  </li></ul></li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="http://www.woshipm.com/evaluating/994454.html" target="_blank" rel="noopener">http://www.woshipm.com/evaluating/994454.html</a> </li><li><a href="https://tools.lancely.tech/apple/app-version/cn/1142110895" target="_blank" rel="noopener">https://tools.lancely.tech/apple/app-version/cn/1142110895</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Overview&quot;&gt;&lt;a href=&quot;#1-Overview&quot; class=&quot;headerlink&quot; title=&quot;1. Overview&quot;&gt;&lt;/a&gt;1. Overview&lt;/h1&gt;&lt;h2 id=&quot;1-1-外部环境背景&quot;&gt;&lt;a href=&quot;#1-1-外部环境背
      
    
    </summary>
    
    
      <category term="Notes" scheme="https://www.llchen60.com/categories/Notes/"/>
    
    
      <category term="thought" scheme="https://www.llchen60.com/tags/thought/"/>
    
      <category term="抖音" scheme="https://www.llchen60.com/tags/%E6%8A%96%E9%9F%B3/"/>
    
  </entry>
  
  <entry>
    <title>构建React的想法 - from sebmarkbage</title>
    <link href="https://www.llchen60.com/%E6%9E%84%E5%BB%BAReact%E7%9A%84%E6%83%B3%E6%B3%95-from-sebmarkbage/"/>
    <id>https://www.llchen60.com/%E6%9E%84%E5%BB%BAReact%E7%9A%84%E6%83%B3%E6%B3%95-from-sebmarkbage/</id>
    <published>2020-04-09T03:25:08.000Z</published>
    <updated>2020-04-09T03:31:08.065Z</updated>
    
    <content type="html"><![CDATA[<p>从github翻到的论述，是React设计者试图说明其构建React的整个逻辑。</p><h1 id="1-转换-Transformation"><a href="#1-转换-Transformation" class="headerlink" title="1. 转换 - Transformation"></a>1. 转换 - Transformation</h1><p>React的核心假定是UI层实际上是对数据的展现形式的一种转换。同样的输入会给出同样的输出结果，只是表现形式可能会有所区别。</p><pre><code>function NameBox(name) {  return { fontWeight: &#39;bold&#39;, labelContent: name };}&#39;Sebastian Markbåge&#39; -&gt;{ fontWeight: &#39;bold&#39;, labelContent: &#39;Sebastian Markbåge&#39; };</code></pre><h1 id="2-抽象-Abstraction"><a href="#2-抽象-Abstraction" class="headerlink" title="2. 抽象 - Abstraction"></a>2. 抽象 - Abstraction</h1><p>我们无法将一个复杂的UI放到一个方法当中的。将UI抽象到各个可以复用的组件当中就变得尤为重要。抽象成可复用的组件，并且隐藏实现的细节，是我们想要做的。</p><pre><code>function FancyUserBox(user) {  return {    borderStyle: &#39;1px solid blue&#39;,    childContent: [      &#39;Name: &#39;,      NameBox(user.firstName + &#39; &#39; + user.lastName)    ]  };}{ firstName: &#39;Sebastian&#39;, lastName: &#39;Markbåge&#39; } -&gt;{  borderStyle: &#39;1px solid blue&#39;,  childContent: [    &#39;Name: &#39;,    { fontWeight: &#39;bold&#39;, labelContent: &#39;Sebastian Markbåge&#39; }  ]};</code></pre><h1 id="3-组合-Composition"><a href="#3-组合-Composition" class="headerlink" title="3. 组合 - Composition"></a>3. 组合 - Composition</h1><p>为了实现真正可以复用的特性，仅仅使用细分的子功能，并且每次给他们构建容器是不太够的。我们需要能够建立中间层的抽象，即将几个子功能组件组合起来，形成另一层次的组件。这里的组合就是指将多个抽象融合成一个抽象的能力。</p><pre><code>function FancyBox(children) {  return {    borderStyle: &#39;1px solid blue&#39;,    children: children  };}function UserBox(user) {  return FancyBox([    &#39;Name: &#39;,    NameBox(user.firstName + &#39; &#39; + user.lastName)  ]);}</code></pre><h1 id="4-状态-State"><a href="#4-状态-State" class="headerlink" title="4. 状态 - State"></a>4. 状态 - State</h1><p>UI不仅仅是服务器以及商业逻辑的复制，实际上是有很多状态，是服务于特定的运行过程的。比如你在一个文本框输入内容，那么我们需要一些方式能够记录下这个文本框当前的状态，并且用这个状态去和后端进或者其他的方法进行交互。</p><p>我们希望我们的数据是immutable的</p><pre><code>function FancyNameBox(user, likes, onClick) {  return FancyBox([    &#39;Name: &#39;, NameBox(user.firstName + &#39; &#39; + user.lastName),    &#39;Likes: &#39;, LikeBox(likes),    LikeButton(onClick)  ]);}// Implementation Detailsvar likes = 0;function addOneMoreLike() {  likes++;  rerender();}// InitFancyNameBox(  { firstName: &#39;Sebastian&#39;, lastName: &#39;Markbåge&#39; },  likes,  addOneMoreLike);</code></pre><h1 id="5-记忆方法"><a href="#5-记忆方法" class="headerlink" title="5. 记忆方法"></a>5. 记忆方法</h1><p>如果我们知道这是个纯方法，并且还会重复的call它，那么我们可以设计一个记忆版本的方法，这样我们就不用在有相同的数据(输入)的时候还要重复执行了</p><pre><code>function memoize(fn) {  var cachedArg;  var cachedResult;  return function(arg) {    if (cachedArg === arg) {      return cachedResult;    }    cachedArg = arg;    cachedResult = fn(arg);    return cachedResult;  };}var MemoizedNameBox = memoize(NameBox);function NameAndAgeBox(user, currentTime) {  return FancyBox([    &#39;Name: &#39;,    MemoizedNameBox(user.firstName + &#39; &#39; + user.lastName),    &#39;Age in milliseconds: &#39;,    currentTime - user.dateOfBirth  ]);}// 我们同样可以不仅仅记一个值，也可以记一个mapfunction memoize(fn) {  return function(arg, memoizationCache) {    if (memoizationCache.arg === arg) {      return memoizationCache.result;    }    const result = fn(arg);    memoizationCache.arg = arg;    memoizationCache.result = result;    return result;  };}function FancyBoxWithState(  children,  stateMap,  updateState,  memoizationCache) {  return FancyBox(    children.map(child =&gt; child.continuation(      stateMap.get(child.key),      updateState,      memoizationCache.get(child.key)    ))  );}const MemoizedFancyNameBox = memoize(FancyNameBox);</code></pre><h1 id="6-列表"><a href="#6-列表" class="headerlink" title="6. 列表"></a>6. 列表</h1><p>大部分的UI都是一些形式的列表，然后为在列表中的每个元素产出不同的一系列的值。这就自然的产生了一个有层级的结构。</p><p>我们可以通过使用Map方法来管理每个列表当中的元素的状态。</p><pre><code>function UserList(users, likesPerUser, updateUserLikes) {  return users.map(user =&gt; FancyNameBox(    user,    likesPerUser.get(user.id),    () =&gt; updateUserLikes(user.id, likesPerUser.get(user.id) + 1)  ));}var likesPerUser = new Map();function updateUserLikes(id, likeCount) {  likesPerUser.set(id, likeCount);  rerender();}UserList(data.users, likesPerUser, updateUserLikes);</code></pre><h1 id="7-持续性"><a href="#7-持续性" class="headerlink" title="7. 持续性"></a>7. 持续性</h1><p>一些时候，我们在运行我们的核心商业逻辑的时候会大量的操作数据，这部分关于数据的操作会显得有些冗余，我们可以将其移出核心逻辑的代码块，比如使用bind，来绑定方法，在其他地方写具体的代码逻辑。</p><pre><code>function FancyUserList(users) {  return FancyBox(    UserList.bind(null, users)  );}const box = FancyUserList(data.users);const resolvedChildren = box.children(likesPerUser, updateUserLikes);const resolvedBox = {  ...box,  children: resolvedChildren};</code></pre><h1 id="8-状态Map"><a href="#8-状态Map" class="headerlink" title="8. 状态Map"></a>8. 状态Map</h1><p>我们可以用组合来将几个子组件放在一起来使用，同样的，对于他们需要的一些输入数据，我们可以通过state，来传到下层的方法处，供他们使用。</p><pre><code>function FancyBoxWithState(  children,  stateMap,  updateState) {  return FancyBox(    children.map(child =&gt; child.continuation(      stateMap.get(child.key),      updateState    ))  );}function UserList(users) {  return users.map(user =&gt; {    continuation: FancyNameBox.bind(null, user),    key: user.id  });}function FancyUserList(users) {  return FancyBoxWithState.bind(null,    UserList(users)  );}const continuation = FancyUserList(data.users);continuation(likesPerUser, updateUserLikes);</code></pre><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://github.com/reactjs/react-basic" target="_blank" rel="noopener">https://github.com/reactjs/react-basic</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从github翻到的论述，是React设计者试图说明其构建React的整个逻辑。&lt;/p&gt;
&lt;h1 id=&quot;1-转换-Transformation&quot;&gt;&lt;a href=&quot;#1-转换-Transformation&quot; class=&quot;headerlink&quot; title=&quot;1. 转换 
      
    
    </summary>
    
    
      <category term="FrontEnd" scheme="https://www.llchen60.com/categories/FrontEnd/"/>
    
    
      <category term="React" scheme="https://www.llchen60.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>如何知道用户是否在使用Adblocker</title>
    <link href="https://www.llchen60.com/%E5%A6%82%E4%BD%95%E7%9F%A5%E9%81%93%E7%94%A8%E6%88%B7%E6%98%AF%E5%90%A6%E5%9C%A8%E4%BD%BF%E7%94%A8Adblocker/"/>
    <id>https://www.llchen60.com/%E5%A6%82%E4%BD%95%E7%9F%A5%E9%81%93%E7%94%A8%E6%88%B7%E6%98%AF%E5%90%A6%E5%9C%A8%E4%BD%BF%E7%94%A8Adblocker/</id>
    <published>2020-04-07T18:58:04.000Z</published>
    <updated>2020-04-07T19:00:33.044Z</updated>
    
    <content type="html"><![CDATA[<p>广告监测和屏蔽是很好的功能，而Ad-blocker基本是市面上做屏蔽广告插件的翘楚了。根据GlobalWebIndex在2019年五月做的统计，现在有47% 的用户正在使用广告屏蔽的软件。</p><p>作为网站管理者，你可以做一个pop up 的信息框，希望用户能够停止对于广告的屏蔽，或者你可以直接不允许用户来访问页面，知道去除了广告屏蔽之后。</p><p>那么如何知道用户是否在使用AbBlocker呢，这里需要了解下adblocker的运行机制，广告屏蔽的运行依赖于过滤规则(filter rules)， adblock会将你正在访问的URL和过滤列表相比较，如果匹配，那么这个请求就会被屏蔽掉。</p><p>但是还有部分的广告是不会发起一个HTTP请求，相对应的，他们会使用<code>data:image/png</code>这种方式来加载广告，对于这种广告，AdBlock 在每个页面都会插入一个样式表，然后这个样式表包括选择器，来display:none 通过这种方式来隐藏页面上的广告</p><p>而这些屏蔽列表来自于一些过去的积累，譬如：</p><ul><li><a href="https://easylist.to/" target="_blank" rel="noopener">Easylist</a></li><li><a href="https://help.getadblock.com/support/solutions/articles/6000092027-why-am-i-suddenly-seeing-taboola-outbrain-and-google-ads-" target="_blank" rel="noopener">accesptable list</a></li></ul><p>除此以外，adblocker还会检测前端调用的js文件，如果还有ad关键词，也会直接屏蔽，所以我们可以直接使用命名，来做一个简单的判断。</p><pre><code>// 创建名为ads.js的文件isAdBlockActive = false;// 创建script.jsvar AdBlocker = (function () {    function showModal() {        $(&#39;#modal_ad_blocker&#39;).modal(); // show a message to the user when ads are blocked    }    setInterval(function () {        // Get the first AdSense ad unit on the page        var ad = document.querySelector(&quot;ins.adsbygoogle&quot;);        // If the ads.js or the Google ads are not loaded, show modal and track the event        if (typeof isAdBlockActive === &#39;undefined&#39;            || (ad &amp;&amp; ad.innerHTML.replace(/\s/g, &quot;&quot;).length === 0)) {            showModal();            if (typeof ga !== &#39;undefined&#39;) {                // Log an event in Universal Analytics                // but without affecting overall bounce rate                ga(&#39;send&#39;, &#39;event&#39;, &#39;Adblock&#39;, &#39;Yes&#39;, {&#39;nonInteraction&#39;: 1});            } else if (typeof _gaq !== &#39;undefined&#39;) {                // Log a non-interactive event in old Google Analytics                _gaq.push([&#39;_trackEvent&#39;, &#39;Adblock&#39;, &#39;Yes&#39;, undefined, undefined, true]);            }        }    }, 5000); // check every 5 seconds})();</code></pre><p>通过检测我们在ads.js当中定义的isAdBlockActive 是否能够被检测到(undefined or have some value)。我们就可以看出是否有adBlocker正在运行，然后根据检测结果我们可以给用户提醒，或者直接阻止访问。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://blog.rampatra.com/how-to-know-whether-a-user-is-using-an-adblocker" target="_blank" rel="noopener">https://blog.rampatra.com/how-to-know-whether-a-user-is-using-an-adblocker</a> </li><li><a href="https://help.getadblock.com/support/solutions/articles/6000087914-how-does-adblock-work-" target="_blank" rel="noopener">https://help.getadblock.com/support/solutions/articles/6000087914-how-does-adblock-work-</a> </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;广告监测和屏蔽是很好的功能，而Ad-blocker基本是市面上做屏蔽广告插件的翘楚了。根据GlobalWebIndex在2019年五月做的统计，现在有47% 的用户正在使用广告屏蔽的软件。&lt;/p&gt;
&lt;p&gt;作为网站管理者，你可以做一个pop up 的信息框，希望用户能够停止对
      
    
    </summary>
    
    
      <category term="Web" scheme="https://www.llchen60.com/categories/Web/"/>
    
    
      <category term="Tricks" scheme="https://www.llchen60.com/tags/Tricks/"/>
    
  </entry>
  
  <entry>
    <title>Log4j2 Tutorial </title>
    <link href="https://www.llchen60.com/Log4j2-Tutorial/"/>
    <id>https://www.llchen60.com/Log4j2-Tutorial/</id>
    <published>2020-04-02T05:27:56.000Z</published>
    <updated>2020-04-02T05:32:48.736Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Log4j2-overview"><a href="#1-Log4j2-overview" class="headerlink" title="1. Log4j2 overview"></a>1. Log4j2 overview</h1><h2 id="1-1-Why-log"><a href="#1-1-Why-log" class="headerlink" title="1.1 Why log?"></a>1.1 Why log?</h2><p>Logging is an important component of the development cycle. </p><ul><li>provides precise context about a run of the application </li><li>once inserted into code, the generation of logging output requires no human intervention </li><li>moreover, log output can be saved in persistent medium to be studied at a later time </li></ul><h2 id="1-2-Why-Log4j2"><a href="#1-2-Why-Log4j2" class="headerlink" title="1.2 Why Log4j2?"></a>1.2 Why Log4j2?</h2><ul><li>Designed to be usable as an audit logging framework , will not lose events while reconfiguring </li><li>Contains asynchrounous loggers, which is 10 times faster than log4j 1.x and logback </li><li>Garbage free for stand alone applications </li><li>Use a plugin system that makes it easy to extend the framework by adding new appenders, filters, layouts, lookups, and pattern converters</li><li>Support for custom log levels </li></ul><h2 id="1-3-Log4j-Architecture"><a href="#1-3-Log4j-Architecture" class="headerlink" title="1.3 Log4j Architecture"></a>1.3 Log4j Architecture</h2><p><img src="https://i.loli.net/2020/04/02/AsXomqJciUyPVKh.jpg" alt="Log4jClasses.jpg"> </p><p>Applications using the Log4j 2 API will request <strong>a Logger with a specific name from the LogManager</strong>. The LogManager will <strong>locate the appropriate LoggerContext</strong> and then obtain the Logger from it. If the Logger must be created it will <strong>be associated with the LoggerConfig</strong> that contains either a) the same name as the Logger, b) the name of a parent package, or c) the root LoggerConfig. LoggerConfig objects are created from Logger declarations in the configuration. The LoggerConfig is associated with the Appenders that actually deliver the LogEvents.</p><ul><li>Filter <ul><li>apply in different time point <ul><li>before control is passed to any loggerConfig</li><li>after control is passed to a LoggerConfig but before calling any Appenders</li><li>after control is passed to a LoggerConfig but before calling a specific Appender</li><li>on each Appender</li></ul></li></ul></li><li>Appender <ul><li>selectively enable or disable logging requests</li><li>allow logging requests to print to multiple destinations </li></ul></li><li>Layout <ul><li>Used to customize the output format </li><li>Associate a layout with an appender </li></ul></li></ul><h1 id="2-Migration-from-Log4j-to-Log4j2"><a href="#2-Migration-from-Log4j-to-Log4j2" class="headerlink" title="2. Migration from Log4j to Log4j2"></a>2. Migration from Log4j to Log4j2</h1><p>We usually use log4j/ log4j2 with Slf4j, Slf4j is kind of like a connecter, you could use slf4j as logging system, and slf4j could help you connect to logging framework you want to use: like logback, log4j2, commons-logging, etc. </p><p><a href="https://logging.apache.org/log4j/2.x/manual/migration.html" target="_blank" rel="noopener">https://logging.apache.org/log4j/2.x/manual/migration.html</a> </p><p>Look at sample 1 in above link for how to set up basic configuration </p><p>For some tips: </p><ul><li>The main package in version 1 is org.apache.log4j, in version 2 it is org.apache.logging.log4j</li><li>Calls to org.apache.log4j.Logger.getLogger() must be modified to org.apache.logging.log4j.LogManager.getLogger().</li><li>Calls to org.apache.log4j.Logger.getRootLogger() or org.apache.log4j.LogManager.getRootLogger() must be replaced with org.apache.logging.log4j.LogManager.getRootLogger().</li><li>Calls to org.apache.log4j.Logger.getLogger that accept a LoggerFactory must remove the org.apache.log4j.spi.LoggerFactory and use one of Log4j 2’s other extension mechanisms.</li><li>Replace calls to org.apache.log4j.Logger.getEffectiveLevel() with org.apache.logging.log4j.Logger.getLevel().</li><li>Remove calls to org.apache.log4j.LogManager.shutdown(), they are not needed in version 2 because the Log4j Core now automatically adds a JVM shutdown hook on start up to perform any Core clean ups.<ul><li>Starting in Log4j 2.1, you can specify a custom ShutdownCallbackRegistry to override the default JVM shutdown hook strategy.</li><li>Starting in Log4j 2.6, you can now use org.apache.logging.log4j.LogManager.shutdown() to initiate shutdown manually.</li></ul></li><li>Calls to org.apache.log4j.Logger.setLevel() or similar methods are not supported in the API. Applications should remove these. Equivalent functionality is provided in the Log4j 2 implementation classes, see org.apache.logging.log4j.core.config.Configurator.setLevel(), but may leave the application susceptible to changes in Log4j 2 internals.</li><li>Where appropriate, applications should convert to use parameterized messages instead of String concatenation.</li><li>org.apache.log4j.MDC and org.apache.log4j.NDC have been replaced by the Thread Context.</li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://logging.apache.org/log4j/2.x/manual/migration.html" target="_blank" rel="noopener">https://logging.apache.org/log4j/2.x/manual/migration.html</a> </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Log4j2-overview&quot;&gt;&lt;a href=&quot;#1-Log4j2-overview&quot; class=&quot;headerlink&quot; title=&quot;1. Log4j2 overview&quot;&gt;&lt;/a&gt;1. Log4j2 overview&lt;/h1&gt;&lt;h2 id=&quot;1-1
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="log" scheme="https://www.llchen60.com/tags/log/"/>
    
  </entry>
  
  <entry>
    <title>Amazon RDS Onboard - MySQL </title>
    <link href="https://www.llchen60.com/Amazon-RDS-Onboard-MySQL/"/>
    <id>https://www.llchen60.com/Amazon-RDS-Onboard-MySQL/</id>
    <published>2020-03-29T03:39:50.000Z</published>
    <updated>2020-04-05T22:47:32.274Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a>1. Overview</h1><p>Amazon Relational Databazse Service </p><ul><li>provide cost efficient, resizable capacity for relational database and manage common database administration tasks </li><li>CPU, memory, storage, IOPS can be scaled independently </li><li>help you manage backups, software patching, automatic failure detection, and recovery </li><li>Automated backups </li><li>Can get high availability with a primary instance and synchronous secondary instance that you can fail over to when problems occur.</li><li>Integrate with IAM and VPC settings</li></ul><h2 id="1-1-How-does-amazon-help-you-do-the-setup"><a href="#1-1-How-does-amazon-help-you-do-the-setup" class="headerlink" title="1.1 How does amazon help you do the setup?"></a>1.1 How does amazon help you do the setup?</h2><p>Overall, you control your database by using DB instance, you could select different kind of host with different configuration, AWS will help you to deploy it in your selected region, and it will be automatically deployed to different AZ, to increase availability. Let’s go through it in detail. </p><h3 id="1-1-1-DB-Instances"><a href="#1-1-1-DB-Instances" class="headerlink" title="1.1.1 DB Instances"></a>1.1.1 DB Instances</h3><ul><li><p>An isolated database env in the AWS Cloud </p></li><li><p>One instance can contain multiple user-created databases </p></li><li><p>Each DB instance runs one DB engine, for DB engine, we mean MySQL, MariaDB, PostgreSQL, etc. </p></li><li><p>You could change your selected computation and memory capacity by using <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.DBInstanceClass.html" target="_blank" rel="noopener">DB instance class</a>.</p></li><li><p>You could choose to use multiple availability zones, AZ is engineered to be isolated from failures in other AZs, by launching instances in separate AZs, you can protect your applications from the failure of a single location</p><h3 id="1-1-2-Basic-setup"><a href="#1-1-2-Basic-setup" class="headerlink" title="1.1.2 Basic setup"></a>1.1.2 Basic setup</h3></li><li><p>AWS account </p></li><li><p>IAM user </p></li></ul><h1 id="2-MySQL-on-RDS"><a href="#2-MySQL-on-RDS" class="headerlink" title="2. MySQL on RDS"></a>2. MySQL on RDS</h1><h2 id="2-1-Manage-security-for-DB-instance"><a href="#2-1-Manage-security-for-DB-instance" class="headerlink" title="2.1 Manage security for DB instance"></a>2.1 Manage security for DB instance</h2><h3 id="2-1-1-Security-Overview"><a href="#2-1-1-Security-Overview" class="headerlink" title="2.1.1 Security Overview"></a>2.1.1 Security Overview</h3><ul><li>Run DB instance in a vertual private cloud based on the Amazon VPC service </li><li>Use AWS Identity and Access Management policies to assign permissions that determine who is allowed to manage Amazon RDS resrouces </li><li>Use security groups to control what IP addresses or Amazon EC2 instances can connect to your databases on a DB instance</li><li>Use SSL or TLS connections with DB instances <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.SSL.html" target="_blank" rel="noopener">Instructions</a></li><li>Use Amazon RDS encryption to secure DB instances and snapshots at rest. It used AES-256 encryption algorithm to encrypt data on the server that hosts DB instance</li></ul><h3 id="2-1-2-Manage-access-with-Policies-resource-level"><a href="#2-1-2-Manage-access-with-Policies-resource-level" class="headerlink" title="2.1.2 Manage access with Policies - resource level"></a>2.1.2 Manage access with Policies - resource level</h3><ul><li>A poloicy is an object that associated with an identity or resource, defines their permissions. </li><li>An IAM administrator could use policies to specify who has access to AWS resources, and what actions they can perform on the resources </li></ul><h3 id="2-1-3-Access-control-in-DB-instance-level-security-group"><a href="#2-1-3-Access-control-in-DB-instance-level-security-group" class="headerlink" title="2.1.3 Access control in DB instance level - security group"></a>2.1.3 Access control in DB instance level - security group</h3><ul><li>Security groups control the access that traffic has in and out of a DB instance <ul><li>VPC security groups </li><li>DB security groups</li><li>EC2-classic security groups </li></ul></li><li>VPC security group<ul><li>enable a specific source to access a DB instance in a VPC in the security group </li><li>source could be: <ul><li>a range of addresses </li><li>another VPC security group </li></ul></li></ul></li><li>DB security group <ul><li>Used with DB instances that are not in a VPC and on the EC2 classic platform  </li><li>DB security group rules apply to inbound traffic only </li><li>You don’t need to specify port number or protocol when adding rules </li></ul></li></ul><h2 id="2-2-Connect-to-DB-instance"><a href="#2-2-Connect-to-DB-instance" class="headerlink" title="2.2 Connect to DB instance"></a>2.2 Connect to DB instance</h2><ul><li>Create DB instance as prerequisite </li><li>Use MySQL client application or utility to connect to the instance</li><li>Specify DNS address from the DB instance endpoint as the host parameter, specify the port number from DB instance endpoint as the port parameter </li><li>For endpoint, we could find in AWS console, on the “connectivity &amp; security” tab </li><li>To  connect from MySQL client, using command shown as below<ul><li><code>mysql -h mysql–instance1.123456789012.us-east-1.rds.amazonaws.com -P 3306 -u mymasteruser -p</code></li></ul></li><li>Amazon RDS creates an SSL certificate for your DB instance when the instance is created     + you could do it with native password or with IAM authentication <ul><li><code>mysql -h mysql–instance1.123456789012.us-east-1.rds.amazonaws.com --ssl-ca=rds-ca-2015-root.pem -p</code> </li></ul></li><li>we could also connect from MySQL workbench <ul><li>See instructions on <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_ConnectToInstance.html" target="_blank" rel="noopener">Connnecting from MySQL Workbench</a> </li></ul></li></ul><h2 id="2-3-Configure-high-availability-for-a-production-DB-instance"><a href="#2-3-Configure-high-availability-for-a-production-DB-instance" class="headerlink" title="2.3 Configure high availability for a production DB instance"></a>2.3 Configure high availability for a production DB instance</h2><p>Amazon help you do this with Multi-AZ deployments. SQL server DB instances use SQL server Database Mirroring or Always On Availability Groups. </p><p>In a Multi-AZ deployment, Amazon RDS automatically provisions and maintains a synchronous standby replica in a different Availability Zone. The primary DB instance is synchronously replicated across Availability Zones to a standby replica to provide data redundancy, eliminate I/O freezes, and minimize latency spikes during system backups. Running a DB instance with high availability can enhance availability during planned system maintenance, and help protect your databases against DB instance failure and Availability Zone disruption.</p><p>The high availability feature is not scaling solution for read-only scenarios, you cannot use a standby replica to serve read traffic. </p><p>NOTICE – DB instances using Multi-AZ deployments can have increased write and commit latency compared to a Single-AZ depolyment, due to the synchrounous data replication that occurs. </p><p>In the event of a planned or unplanned outage of your DB instance, Amazon RDS automatically switches to a standby replica in another Availability Zone if you have enabled Multi-AZ. The time it takes for the failover to complete depends on the database activity and other conditions at the time the primary DB instance became unavailable. Failover times are typically 60–120 seconds. However, large transactions or a lengthy recovery process can increase failover time. When the failover is complete, it can take additional time for the RDS console to reflect the new Availability Zone.</p><h2 id="2-4-Configure-a-DB-instance-in-VPC"><a href="#2-4-Configure-a-DB-instance-in-VPC" class="headerlink" title="2.4 Configure a DB instance in VPC"></a>2.4 Configure a DB instance in VPC</h2><ul><li>VPC is a virtual network that is logically isolated from other virtual networks in the AWS cloud. Amazon VPC lets you launch AWS resources into a VPC. </li><li>VPC must have at least 2 subnets. And those subnets must be in two different AZs </li><li>If you want DB instance in the VPC to be publicly accessible, you must enable the VPC attributes DNS hostnames and DNS resolution </li></ul><h2 id="2-5-Configure-MySQL-database-parameters-and-features"><a href="#2-5-Configure-MySQL-database-parameters-and-features" class="headerlink" title="2.5 Configure MySQL database parameters and features"></a>2.5 Configure MySQL database parameters and features</h2><ul><li>Manage DB engine configuration by associating DB instances with parameter groups. A DB parameter group act as a container for engine configuration values that are applied to one or more DB instances </li><li>For MySQL, AWS has memcached support </li></ul><h2 id="2-6-Modify-a-DB-instance-running-the-MySQL-database-engine"><a href="#2-6-Modify-a-DB-instance-running-the-MySQL-database-engine" class="headerlink" title="2.6 Modify a DB instance running the MySQL database engine"></a>2.6 Modify a DB instance running the MySQL database engine</h2><ul><li>We could change the settings of a DB instance to add additional storage or changing the DB instance class </li><li>Notice: some cahnges will result in an outage because Amazon RDS must reboot DB instance for the change to take effect <ul><li>We could either modify through AWS console</li><li>Or through AWS CLI</li><li>Or through RDS API </li></ul></li><li>we could do settings as follow:<ul><li>Allocate storage </li><li>Auto minor version upgrade </li><li>Backup retention period <ul><li>number of days that automatic backups are retained </li></ul></li><li>Backup window </li><li>Certificate Authority </li><li>Database port </li><li>DB engine version </li><li>DB instance class </li><li>DB parameter group </li><li>Delete protection <ul><li>prevent your DB from being deleted  </li></ul></li><li>Enhanced Monitoring </li><li>IAM DB authentication </li><li>Kerberos authentication </li><li>License Model </li><li>Log Exports <ul><li>We could publish Database logs to Amazon Cloudwatch logs </li></ul></li><li>Maintenance window </li><li>Multi-AZ deployment </li><li>Performance Insight </li><li>Processor features </li><li>Provisioned IOPS </li><li>Storage auto scaling </li><li>Subnet group </li></ul></li></ul><h2 id="2-7-Configure-database-backup-and-restore"><a href="#2-7-Configure-database-backup-and-restore" class="headerlink" title="2.7 Configure database backup and restore"></a>2.7 Configure database backup and restore</h2><ul><li>Amazon RDS creates and saves automated backups of your DB instance</li><li>RDS creates a storage volume snapshot of DB instance, backing up entire DB instance </li><li>The first snapshot of a DB instance contains the data for the full DB instance. Subsequent snapshots of the same DB instance are incremental, which means that only the data that has changed after your most recent snapshot is saved.</li><li><a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_CommonTasks.BackupRestore.html" target="_blank" rel="noopener">Guide for backup and restore an Amazon RDS DB instance</a></li></ul><h2 id="2-8-Monitor-a-MySQL-DB-instance"><a href="#2-8-Monitor-a-MySQL-DB-instance" class="headerlink" title="2.8 Monitor a MySQL DB instance"></a>2.8 Monitor a MySQL DB instance</h2><h3 id="2-8-1-Overview"><a href="#2-8-1-Overview" class="headerlink" title="2.8.1 Overview"></a>2.8.1 Overview</h3><ul><li><p>We should store historical monitoring data, the stored data will gove a baseline to compare against with current performance data</p></li><li><p>With Amazon RDS, you could monitor network throughput, I/O for read and write, metadata operations, client connections</p></li><li><p>Some adviced metrics </p><ul><li>High CPU or RAM consumption </li><li>Disk space consumption </li><li>Network traffic </li><li>Database connections </li><li>IOPS metrics </li></ul></li><li><p>Monitoring Tools </p><ul><li>Amazon RDS Events <ul><li>subscribe to events thus could be notified when changes occur with a DB instance </li></ul></li><li>Database log files</li><li>Amazon RDS Enhanced Monitoring<ul><li>Look at the metrics in real time for the operating system</li></ul></li><li>Amazon CloudWatch Metrics </li><li>Amazon CloudWatch Alarms</li><li>Amazon CloudWatch Logs </li><li>In RDS console, you could see: <ul><li>the number of connections to a DB instance </li><li>the amount of read and write operations to a DB instance </li><li>the amount of storage that a DB instance is currently utilizing </li><li>the amount of memory and CPU being utilized for a DB instance </li><li>the amount of network traffic to and from a DB instance </li></ul></li></ul></li><li><p>Amazon RDS Metrics </p><ul><li>CPUCreditUsage <ul><li>The number of CPU credits spent by the instance for CPU utilization. One CPU credit equals one vCPU running at 100 percent utilization for one minute or an equivalent combination of vCPUs, utilization, and time.</li></ul></li><li>DatabaseConnections</li><li>DiskQueueDepth <ul><li>the number of outstanding IOs waiting to access the disk</li></ul></li><li>FailedSQLServerAgentJobsCount <ul><li>the numebr of failed SQL server agent jobs during the last minute </li></ul></li><li>ReadIOPS <ul><li>the average number of disk read I/O operations per second</li></ul></li><li>ReadLatency <ul><li>the average amount to time taken per disk I/O operation  </li></ul></li></ul></li></ul><h3 id="2-8-2-Enhanced-Monitoring"><a href="#2-8-2-Enhanced-Monitoring" class="headerlink" title="2.8.2 Enhanced Monitoring"></a>2.8.2 Enhanced Monitoring</h3><p>Real time metrics for the operating system</p><p>CloudWatch gathers metrics about CPU utilization from the hypervisor for a DB instance, and Enhanced Monitoring gathers its metrics from an agent on the instance. As a result, you might find differences between the measurements, because the hypervisor layer performs a small amount of work. The differences can be greater if your DB instances use smaller instance classes, because then there are likely more virtual machines (VMs) that are managed by the hypervisor layer on a single physical instance. Enhanced Monitoring metrics are useful when you want to see how different processes or threads on a DB instance use the CPU</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://docs.aws.amazon.com/AmazonRDS" target="_blank" rel="noopener">https://docs.aws.amazon.com/AmazonRDS</a> </li><li><a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_MySQL.html" target="_blank" rel="noopener">https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_MySQL.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Overview&quot;&gt;&lt;a href=&quot;#1-Overview&quot; class=&quot;headerlink&quot; title=&quot;1. Overview&quot;&gt;&lt;/a&gt;1. Overview&lt;/h1&gt;&lt;p&gt;Amazon Relational Databazse Service 
      
    
    </summary>
    
    
      <category term="Cloud" scheme="https://www.llchen60.com/categories/Cloud/"/>
    
    
      <category term="AWS" scheme="https://www.llchen60.com/tags/AWS/"/>
    
      <category term="RDS" scheme="https://www.llchen60.com/tags/RDS/"/>
    
      <category term="MySQL" scheme="https://www.llchen60.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Spring @Transactional</title>
    <link href="https://www.llchen60.com/Spring-Transactional/"/>
    <id>https://www.llchen60.com/Spring-Transactional/</id>
    <published>2020-03-25T02:37:03.000Z</published>
    <updated>2020-03-25T02:40:00.334Z</updated>
    
    <content type="html"><![CDATA[<p>Spring的Transactional注解用来做事务管理</p><h1 id="1-使用方法"><a href="#1-使用方法" class="headerlink" title="1. 使用方法"></a>1. 使用方法</h1><p>首先我们需要在xml当中配置事务信息，定义transactionManager的bean，当然也可以使用注解来实现对于bean的定义，具体如下：</p><pre><code>&lt;tx:annotation-driven /&gt;&lt;bean id=&quot;transactionManager&quot;class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;&lt;/bean&gt;@EnableTransactionManagement</code></pre><p>而后，在具体的使用的时候，我们只需要将@Transactional注解添加到合适的方法当中，并且设置合适的属性信息</p><ul><li>name<ul><li>指定事务管理器</li></ul></li><li>propagation<ul><li>事务的传播行为，默认为REQUIRED</li></ul></li><li>isolation <ul><li>事务的隔离度，默认为DEFAULT</li></ul></li><li>timeout<ul><li>事务的超时时间，默认为-1，如果超过该时间限制但事务没有完成，就自动回滚</li></ul></li><li>read-only<ul><li>指定事务是否为只读事务，默认值为false</li><li>当要忽略那些不需要事务的方法的时候，可以设置read-only为true</li></ul></li><li>rollback-for<ul><li>指定能够触发事务回滚的异常类型，如果有多个异常类型需要指定，可以通过逗号来做分隔</li></ul></li><li>no-rollback-for<ul><li>对于在这里定义的exception，不回滚 </li></ul></li></ul><h1 id="2-Spring-注解方式的事务实现机制"><a href="#2-Spring-注解方式的事务实现机制" class="headerlink" title="2. Spring 注解方式的事务实现机制"></a>2. Spring 注解方式的事务实现机制</h1><p>在调用@Transactional的目标方法之后，Spring Framework会通过AOP代理，在代码运行时生成一个代理对象，根据注解的属性配置信息，决定该声明@Transactional的目标方法是否由拦截器 - TransactionInterceptor来拦截.</p><p>如果确定要被拦截，那么就会在目标方法开始执行之前创建并加入事务，并执行目标方法的逻辑，最后根据执行情况是否出现异常，利用抽象事务管理器提交或者回滚事务。</p><p><img src="https://i.loli.net/2020/03/25/cM5yEjbPAIogk1X.jpg" alt="Spring事务实现机制.jpg"></p><h1 id="3-Isolation-Level"><a href="#3-Isolation-Level" class="headerlink" title="3. Isolation Level"></a>3. Isolation Level</h1><p>Isolation是有不同的配置的，它主要是为了避免事务的一些副作用：</p><ul><li>脏读：读到同时进行的事务还没有提交上去的数据</li><li>不可重复的读：重复读的时候会读到不同的数据，因为有同时进行的事务对同一条数据进行了更新</li><li>幽灵读取：在做query的时候，再度执行拿到不同的行，因为有同时进行的事务在做更新</li></ul><p>针对不同级别的事务，Spring有如下的设置</p><ul><li>DEFAULT</li><li>READ_UNCOMMITTED<ul><li>最低的隔离水平 </li><li>允许大部分的同时的访问</li><li>有上述所有的弊端</li></ul></li><li>READ_COMMMITED<ul><li>阻止脏读 </li></ul></li><li>REPEATABLE_READ<ul><li>阻止脏读</li><li>阻止不可重复读取</li></ul></li><li>SERAILIZABLE<ul><li>最高程度的隔离</li><li>基本是单序列的执行</li></ul></li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/annotation/Transactional.html" target="_blank" rel="noopener">https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/annotation/Transactional.html</a></li><li><a href="https://dzone.com/articles/how-does-spring-transactional" target="_blank" rel="noopener">https://dzone.com/articles/how-does-spring-transactional</a></li><li><a href="https://www.ibm.com/developerworks/cn/java/j-master-spring-transactional-use/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-master-spring-transactional-use/index.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Spring的Transactional注解用来做事务管理&lt;/p&gt;
&lt;h1 id=&quot;1-使用方法&quot;&gt;&lt;a href=&quot;#1-使用方法&quot; class=&quot;headerlink&quot; title=&quot;1. 使用方法&quot;&gt;&lt;/a&gt;1. 使用方法&lt;/h1&gt;&lt;p&gt;首先我们需要在xml当中配置事
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
      <category term="Spring" scheme="https://www.llchen60.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>团队能力构建手册-新人Ramp Up</title>
    <link href="https://www.llchen60.com/%E5%9B%A2%E9%98%9F%E8%83%BD%E5%8A%9B%E6%9E%84%E5%BB%BA%E6%89%8B%E5%86%8C-%E6%96%B0%E4%BA%BARamp-Up/"/>
    <id>https://www.llchen60.com/%E5%9B%A2%E9%98%9F%E8%83%BD%E5%8A%9B%E6%9E%84%E5%BB%BA%E6%89%8B%E5%86%8C-%E6%96%B0%E4%BA%BARamp-Up/</id>
    <published>2020-03-24T03:37:58.000Z</published>
    <updated>2020-03-24T03:39:22.183Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博客引述了ThoughtWorks的<a href="https://insights.thoughtworks.cn/capacity-building-and-quality-assurance/" target="_blank" rel="noopener">capacity-building-and-quality-assurance</a>，里面讲得如何构建团队，如何让新人快速适应的方法指南非常实用。分享/ 思考/ 归纳如下。</p><p>自己所在的团队最近也经历了快速的增长，在带新人的过程当中，确实感觉到想一茬抓一茬是客观存在且经常性发生的事情，lol。需要一个更加清晰细致的上手指南，并把一些需要的前提条件先给到，然后给新人留下在正确的方向上足够的探索空间，这样大概才能加速他们的成长把。</p><p>我们当然需要每个个体的无上才能，但更需要一个好的平台，让他们能够专注的将自己的才能用在那个地方。而平台，意味着脚手架，意味着规则，意味着指南。</p><h1 id="1-常规新人成长方式-Mentor-Onboarding-Buddy"><a href="#1-常规新人成长方式-Mentor-Onboarding-Buddy" class="headerlink" title="1. 常规新人成长方式 Mentor/ Onboarding Buddy"></a>1. 常规新人成长方式 Mentor/ Onboarding Buddy</h1><p>为新人指派一名有经验的师傅，作为他的onboarding伙伴，平时可以做结对编程，在日常工作当中交换知识，学习并成长。新人onboarding的速度，取决于师傅的技能。</p><p>这么做当然有好处，一定比新人自己探索onboard要快的多，但是正如上面所说的那样，这种方式很依赖于师傅的能力，还有新人的沟通交流，搜集知识的能力。效果会因为每个成员的性格习惯能力等，有很大的不同。</p><h1 id="2-制定规则化的成长流程"><a href="#2-制定规则化的成长流程" class="headerlink" title="2. 制定规则化的成长流程"></a>2. 制定规则化的成长流程</h1><h2 id="2-1-CraftSkill-Map"><a href="#2-1-CraftSkill-Map" class="headerlink" title="2.1 CraftSkill Map"></a>2.1 CraftSkill Map</h2><p>能力地图是希望能够梳理完整的技术图谱，对技术人员需要掌握的能力进行可视化</p><p>新成员在加入项目的时候一般会有很多问题：</p><ul><li>这个项目是做什么的？ </li><li>这个项目是在解决什么样的问题？</li><li>这个项目使用了什么技术栈？</li><li>新成员应该从哪里开始？</li></ul><p>新人onboard，rampup需要的知识是可以分成可以自己学习的知识(通过各种文档，wiki, stackoverflow, etc.)以及需要老人的帮助的知识(需要上手实操的内容，比如设计原则，DRY,SOLID, LOD等等具体如何使用的问题)。</p><p>我们需要新人自己去探索，获取一些必要的前提性知识，也需要有人帮助，帮他迅速适应新的环境。</p><p>能力地图就是希望能够对所需要的知识，做一个清晰的梳理，形成一个脉络，能够使新人onboard的过程更有的放矢一些。</p><p><img src="https://i.loli.net/2020/03/24/JayeLmisObEpdTS.png" alt="craftskill map E.G.png"></p><h2 id="2-2-指定Onboarding流程"><a href="#2-2-指定Onboarding流程" class="headerlink" title="2.2 指定Onboarding流程"></a>2.2 指定Onboarding流程</h2><p>这里主要是要给一个比较详细的计划，告知新人每周要做的事情，更多的是时间上，任务上的安排。</p><p>根据任务，可以侧重学习前端，后端，或者QA方面的领域知识和技能，然后<strong>做一个meeting，将自己学到的完整的和组里的同事分享下，然后可以一起查漏补缺，完善新人的知识体系</strong>。</p><p>值得注意的是Onboarding的流程当中需要有里程碑和执行时间，由资深员工协助制定，然后就可以领取任务，保质保量的独立完成。</p><p>Onboard流程当中，关于自己看的知识，有很多方式可以来做，比如wiki，视频，甚至是音频，起到的作用就是更高速度的学习。这种相对来说比较被动，主动性的学习可以通过Unit test，将知识点转化成Unit test，然后通过单元测试迅速熟悉知识点。</p><h2 id="2-3-新成员状态看板"><a href="#2-3-新成员状态看板" class="headerlink" title="2.3 新成员状态看板"></a>2.3 新成员状态看板</h2><p>每周由mentor负责跟踪观察新人状态，会议追踪，确定新人是否能在一个月的ramp up以后自己独立负责一部分的任务。</p><h2 id="2-4-Case-by-case-针对性培训"><a href="#2-4-Case-by-case-针对性培训" class="headerlink" title="2.4 Case by case 针对性培训"></a>2.4 Case by case 针对性培训</h2><p>根据个人情况来探究如何做提高，是否可以提前交付项目，诸如此类。</p><p><a href="https://insights.thoughtworks.cn/capacity-building-and-quality-assurance/" target="_blank" rel="noopener">https://insights.thoughtworks.cn/capacity-building-and-quality-assurance/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这篇博客引述了ThoughtWorks的&lt;a href=&quot;https://insights.thoughtworks.cn/capacity-building-and-quality-assurance/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ca
      
    
    </summary>
    
    
      <category term="Notes" scheme="https://www.llchen60.com/categories/Notes/"/>
    
    
      <category term="Mentor" scheme="https://www.llchen60.com/tags/Mentor/"/>
    
  </entry>
  
  <entry>
    <title>迪米特法则 (LOD) — 高内聚，低耦合</title>
    <link href="https://www.llchen60.com/%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99-LOD-%E2%80%94-%E9%AB%98%E5%86%85%E8%81%9A%EF%BC%8C%E4%BD%8E%E8%80%A6%E5%90%88/"/>
    <id>https://www.llchen60.com/%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99-LOD-%E2%80%94-%E9%AB%98%E5%86%85%E8%81%9A%EF%BC%8C%E4%BD%8E%E8%80%A6%E5%90%88/</id>
    <published>2020-03-23T03:30:09.000Z</published>
    <updated>2020-03-23T03:30:50.426Z</updated>
    
    <content type="html"><![CDATA[<p>高内聚 低耦合是比较通用的设计思想，可以用来指导不同的粒度的代码的设计和开发的工作，比如系统，模块，类，甚至是函数。也可以去使用到不同的开发场景当中，比如微服务，框架，组件，类库等等。</p><p>在这个原则当中，高内聚指的是类本身的设计，低耦合指的是类和类之间的依赖关系的设计。</p><p>迪米特法则，可以称之为The least knowledge principle.<br>Each unit should have only limited knowledge about other units: only units “closely” related to the current unit. Or: Each unit should only talk to its friends; Don’t talk to strangers.</p><h1 id="1-什么是高内聚？"><a href="#1-什么是高内聚？" class="headerlink" title="1. 什么是高内聚？"></a>1. 什么是高内聚？</h1><p>指的是相近的功能应该放到同一个类当中，不相近的功能不要放在同一类。代码集中相对来说就会更加容易维护了。</p><h1 id="2-什么是低耦合？"><a href="#2-什么是低耦合？" class="headerlink" title="2. 什么是低耦合？"></a>2. 什么是低耦合？</h1><p>类和类之间的依赖关系简单清晰，即尽管两个类之间有依赖关系。一个类的代码的改动不会或者很少导致依赖类的代码的改动。</p><h1 id="3-内聚和耦合的关系"><a href="#3-内聚和耦合的关系" class="headerlink" title="3. 内聚和耦合的关系"></a>3. 内聚和耦合的关系</h1><p><img src="https://i.loli.net/2020/03/23/yZVTqaQSgvbtE4l.png" alt="内聚耦合关系.png"></p><p>如图所示，左侧就是很好的高内聚低耦合的范例，我们将类最小化，即每个类只做一件事情，这样子其他依赖就会少很多。在修改或增加功能的时候，就不会对其他的类造成很大的影响。</p><h1 id="4-实战"><a href="#4-实战" class="headerlink" title="4. 实战"></a>4. 实战</h1><pre><code>public class NetworkTransporter {    // 存在问题，NetworkTransporter作为一个底层类，不应该依赖于HtmlRequest类；与之相反的，因为其实他需要的是string address，以及byte的数组，那我们应该直接提供这些primitive type的数据    public Byte[] send(HtmlRequest htmlRequest) {      //...    }}public class HtmlDownloader {  private NetworkTransporter transporter;//通过构造函数或IOC注入  public Html downloadHtml(String url) {  // 根据上面NetworkTransporter我们希望做的改动，这里传入的不应该是HtmlRequest类的实例了    Byte[] rawHtml = transporter.send(new HtmlRequest(url));    return new Html(rawHtml);  }}public class Document {  private Html html;  private String url;  public Document(String url) {    this.url = url;    // downloader.downloadHtml逻辑复杂，不应该放在构造函数当中，也会很不好测试    // 构造函数中使用new来做实例，违反了基于接口而非实现编程的原则    HtmlDownloader downloader = new HtmlDownloader();    this.html = downloader.downloadHtml(url);  }  //...}</code></pre><p>修改以后的代码： </p><pre><code>public class NetworkTransporter {    // 省略属性和其他方法...    public Byte[] send(String address, Byte[] data) {      //...    }}public class HtmlDownloader {  private NetworkTransporter transporter;//通过构造函数或IOC注入  // HtmlDownloader这里也要有相应的修改  public Html downloadHtml(String url) {    HtmlRequest htmlRequest = new HtmlRequest(url);    Byte[] rawHtml = transporter.send(      htmlRequest.getAddress(), htmlRequest.getContent().getBytes());    return new Html(rawHtml);  }}public class Document {  private Html html;  private String url;  public Document(String url, Html html) {    this.html = html;    this.url = url;  }  //...}// 通过一个工厂方法来创建Documentpublic class DocumentFactory {  private HtmlDownloader downloader;  public DocumentFactory(HtmlDownloader downloader) {    this.downloader = downloader;  }  public Document createDocument(String url) {    Html html = downloader.downloadHtml(url);    return new Document(url, html);  }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;高内聚 低耦合是比较通用的设计思想，可以用来指导不同的粒度的代码的设计和开发的工作，比如系统，模块，类，甚至是函数。也可以去使用到不同的开发场景当中，比如微服务，框架，组件，类库等等。&lt;/p&gt;
&lt;p&gt;在这个原则当中，高内聚指的是类本身的设计，低耦合指的是类和类之间的依赖关系
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="高内聚" scheme="https://www.llchen60.com/tags/%E9%AB%98%E5%86%85%E8%81%9A/"/>
    
      <category term="低耦合" scheme="https://www.llchen60.com/tags/%E4%BD%8E%E8%80%A6%E5%90%88/"/>
    
      <category term="迪米特" scheme="https://www.llchen60.com/tags/%E8%BF%AA%E7%B1%B3%E7%89%B9/"/>
    
  </entry>
  
  <entry>
    <title>DRY 原则</title>
    <link href="https://www.llchen60.com/DRY-%E5%8E%9F%E5%88%99/"/>
    <id>https://www.llchen60.com/DRY-%E5%8E%9F%E5%88%99/</id>
    <published>2020-03-22T03:01:51.000Z</published>
    <updated>2020-03-22T03:02:11.787Z</updated>
    
    <content type="html"><![CDATA[<p>Don’t repeat yourself </p><h1 id="1-实现逻辑的重复"><a href="#1-实现逻辑的重复" class="headerlink" title="1. 实现逻辑的重复"></a>1. 实现逻辑的重复</h1><pre><code>public class UserAuthenticator {  public void authenticate(String username, String password) {    if (!isValidUsername(username)) {      // ...throw InvalidUsernameException...    }    if (!isValidPassword(password)) {      // ...throw InvalidPasswordException...    }    //...省略其他代码...  }  private boolean isValidUsername(String username) {    // check not null, not empty    if (StringUtils.isBlank(username)) {      return false;    }    // check length: 4~64    int length = username.length();    if (length &lt; 4 || length &gt; 64) {      return false;    }    // contains only lowcase characters    if (!StringUtils.isAllLowerCase(username)) {      return false;    }    // contains only a~z,0~9,dot    for (int i = 0; i &lt; length; ++i) {      char c = username.charAt(i);      if (!(c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;z&#39;) || (c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;) || c == &#39;.&#39;) {        return false;      }    }    return true;  }  private boolean isValidPassword(String password) {    // check not null, not empty    if (StringUtils.isBlank(password)) {      return false;    }    // check length: 4~64    int length = password.length();    if (length &lt; 4 || length &gt; 64) {      return false;    }    // contains only lowcase characters    if (!StringUtils.isAllLowerCase(password)) {      return false;    }    // contains only a~z,0~9,dot    for (int i = 0; i &lt; length; ++i) {      char c = password.charAt(i);      if (!(c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;z&#39;) || (c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;) || c == &#39;.&#39;) {        return false;      }    }    return true;  }}</code></pre><p>这里想强调的是不一定完全一样的代码就意味着他们是需要合并的，比如上述的代码当中，isValidPassword还有isValidUsername有着基本上相同的逻辑结构，但是他们本身代表的是不同的意思的，虽然一样的逻辑，但是我们无法保证在接下来的一段时间以内，他们还能这样子一致下去。</p><p>所以合并为isValidUserOrPassword是不可以的，逻辑上讲不通，但是我们可以将上面在这个函数内部调用的方法进行分割的方式，来复用一些代码。</p><p>其实有一些使用组合的味道在里面了。</p><h1 id="2-功能语义的重复"><a href="#2-功能语义的重复" class="headerlink" title="2. 功能语义的重复"></a>2. 功能语义的重复</h1><p>对于功能语义重复的理解，是指一个代码包里在多个地方为了实现同样的功能，设定了不同的方法体。这大部分情况下都是因为沟通等方面的问题，不管里面使用的方法有什么不同，如果他们都是为了达成一样的，那么我们认为其实违反了DRY原则的，是需要清除多余的方法体的。</p><h1 id="3-代码执行重复"><a href="#3-代码执行重复" class="headerlink" title="3. 代码执行重复"></a>3. 代码执行重复</h1><p>看代码的内部逻辑，减少多次重复调用的代码。</p><p>注意IO操作，因为IO非常费时…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Don’t repeat yourself &lt;/p&gt;
&lt;h1 id=&quot;1-实现逻辑的重复&quot;&gt;&lt;a href=&quot;#1-实现逻辑的重复&quot; class=&quot;headerlink&quot; title=&quot;1. 实现逻辑的重复&quot;&gt;&lt;/a&gt;1. 实现逻辑的重复&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;pu
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
  </entry>
  
  <entry>
    <title>KISS and YAGNI原则</title>
    <link href="https://www.llchen60.com/KISS-and-YAGNI%E5%8E%9F%E5%88%99/"/>
    <id>https://www.llchen60.com/KISS-and-YAGNI%E5%8E%9F%E5%88%99/</id>
    <published>2020-03-21T03:24:37.000Z</published>
    <updated>2020-03-21T03:25:05.413Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-KISS"><a href="#1-KISS" class="headerlink" title="1. KISS"></a>1. KISS</h1><p>Keep it simple and stupid. </p><p>这个原则相对比较范范，其实着重在说的还是从代码的可读性和可维护性两个角度来衡量代码的质量。</p><pre><code>// 第一种实现方式: 使用正则表达式public boolean isValidIpAddressV1(String ipAddress) {  if (StringUtils.isBlank(ipAddress)) return false;  String regex = &quot;^(1\\d{2}|2[0-4]\\d|25[0-5]|[1-9]\\d|[1-9])\\.&quot;          + &quot;(1\\d{2}|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)\\.&quot;          + &quot;(1\\d{2}|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)\\.&quot;          + &quot;(1\\d{2}|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)$&quot;;  return ipAddress.matches(regex);}// 第二种实现方式: 使用现成的工具类public boolean isValidIpAddressV2(String ipAddress) {  if (StringUtils.isBlank(ipAddress)) return false;  String[] ipUnits = StringUtils.split(ipAddress, &#39;.&#39;);  if (ipUnits.length != 4) {    return false;  }  for (int i = 0; i &lt; 4; ++i) {    int ipUnitIntValue;    try {      ipUnitIntValue = Integer.parseInt(ipUnits[i]);    } catch (NumberFormatException e) {      return false;    }    if (ipUnitIntValue &lt; 0 || ipUnitIntValue &gt; 255) {      return false;    }    if (i == 0 &amp;&amp; ipUnitIntValue == 0) {      return false;    }  }  return true;}// 第三种实现方式: 不使用任何工具类public boolean isValidIpAddressV3(String ipAddress) {  char[] ipChars = ipAddress.toCharArray();  int length = ipChars.length;  int ipUnitIntValue = -1;  boolean isFirstUnit = true;  int unitsCount = 0;  for (int i = 0; i &lt; length; ++i) {    char c = ipChars[i];    if (c == &#39;.&#39;) {      if (ipUnitIntValue &lt; 0 || ipUnitIntValue &gt; 255) return false;      if (isFirstUnit &amp;&amp; ipUnitIntValue == 0) return false;      if (isFirstUnit) isFirstUnit = false;      ipUnitIntValue = -1;      unitsCount++;      continue;    }    if (c &lt; &#39;0&#39; || c &gt; &#39;9&#39;) {      return false;    }    if (ipUnitIntValue == -1) ipUnitIntValue = 0;    ipUnitIntValue = ipUnitIntValue * 10 + (c - &#39;0&#39;);  }  if (ipUnitIntValue &lt; 0 || ipUnitIntValue &gt; 255) return false;  if (unitsCount != 3) return false;  return true;}</code></pre><p>相对来说，第二种实现方式会更好一些，因为细节被封装在工具类当中，可读性相对强很多；方法一直接使用正则表达式，可读性会差很多；第三种自己来处理底层的逻辑，虽然执行起来相对会快一些，但是很容易出错。</p><h1 id="2-YAGNI"><a href="#2-YAGNI" class="headerlink" title="2. YAGNI"></a>2. YAGNI</h1><p>You ain’t gonna need it. </p><p>你不会需要它。深有感触，很多时候我们想写很优雅的代码，会疯狂向后考虑，比如对于不常用的功能，有的时候哪怕就一个方法，也想搞个接口供后面的扩展来使用。过度设计，反而增加了代码的阅读成本和维护成本。</p><p>我们不应当去设计当前用不到的功能，也不应该编写现在用不到的代码。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-KISS&quot;&gt;&lt;a href=&quot;#1-KISS&quot; class=&quot;headerlink&quot; title=&quot;1. KISS&quot;&gt;&lt;/a&gt;1. KISS&lt;/h1&gt;&lt;p&gt;Keep it simple and stupid. &lt;/p&gt;
&lt;p&gt;这个原则相对比较范范，其实着重在说
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
  </entry>
  
</feed>
