<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Leilei&#39;s Blog | 磊磊的博客</title>
  
  <subtitle>Because it&#39;s there</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.llchen60.com/"/>
  <updated>2020-02-09T06:11:17.904Z</updated>
  <id>https://www.llchen60.com/</id>
  
  <author>
    <name>Leilei Chen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>System.gc() and Runtime.gc()</title>
    <link href="https://www.llchen60.com/System-gc-and-Runtime-gc/"/>
    <id>https://www.llchen60.com/System-gc-and-Runtime-gc/</id>
    <published>2020-02-09T06:10:53.000Z</published>
    <updated>2020-02-09T06:11:17.904Z</updated>
    
    <content type="html"><![CDATA[<p>首先在Java中垃圾回收算法是首先遍历所有在堆中的非垃圾的对象，然后推断出那些一段时间内没有被访问的对象一定是垃圾了。call gc()方法不是强制垃圾回收发生的，相反的，它只是在建议JVM现在是不错的做垃圾回收的时间。</p><p>system.gc()是用来运行垃圾收集器的。call这个方法就意味着Java虚拟机正在努力去回收没有被使用的对象，使得他们现在占用的内存可以进行快速地再利用。整个垃圾回收在Java中是自动进行的。</p><p>system.gc()是个静态方法，但是手动调用它很有可能会让整个系统运行更慢的，一般为了加快整体的运行，会使用<code>-XX:+DisableExplicitGC</code>这条指令，这样子JVM就不会在你手动唤醒gc的时候直接call这个方法了。</p><p>runtime.gc()和system.gc()并没有什么区别，实质上system.gc()内部就call了runtime.gc()。 唯一的不同在于System.gc()是类的方法然而runtime.gc()是实例方法。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="http://net-informations.com/java/cjava/gc.htm" target="_blank" rel="noopener">http://net-informations.com/java/cjava/gc.htm</a> </li><li><a href="https://docs.oracle.com/javase/7/docs/api/java/lang/System.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/7/docs/api/java/lang/System.html</a> </li><li><a href="https://www.geeksforgeeks.org/garbage-collection-java/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/garbage-collection-java/</a> </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先在Java中垃圾回收算法是首先遍历所有在堆中的非垃圾的对象，然后推断出那些一段时间内没有被访问的对象一定是垃圾了。call gc()方法不是强制垃圾回收发生的，相反的，它只是在建议JVM现在是不错的做垃圾回收的时间。&lt;/p&gt;
&lt;p&gt;system.gc()是用来运行垃圾收
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Ruby Totorial</title>
    <link href="https://www.llchen60.com/Ruby-Totorial/"/>
    <id>https://www.llchen60.com/Ruby-Totorial/</id>
    <published>2020-02-09T05:22:07.000Z</published>
    <updated>2020-02-09T05:22:33.775Z</updated>
    
    <content type="html"><![CDATA[<p>Met circumstances where need Ruby knowledge to resolve problems, thus need to do a quick touch on Ruby, at least know how to read ruby code. </p><p>Leran by doing, or we say, learn by satisfying current needs. </p><h1 id="1-Basics"><a href="#1-Basics" class="headerlink" title="1. Basics"></a>1. Basics</h1><ul><li>features <ul><li>object-oriented </li><li>server side scripting language </li><li>can be used to write common gateway interface(CGI) scripts</li></ul></li></ul><h2 id="1-1-Syntax-of-Ruby"><a href="#1-1-Syntax-of-Ruby" class="headerlink" title="1.1 Syntax of Ruby"></a>1.1 Syntax of Ruby</h2><ul><li>whitespace <ul><li>ignored in ruby code, except when they appear in strings. </li></ul></li><li>end of line<ul><li>you could use <ul><li>semicolons </li><li>newline characters as the ending of a statement </li></ul></li></ul></li><li>Ruby Identifiers<ul><li>case sensitive </li></ul></li><li>comments<ul><li><code>#</code></li><li><code>=begin</code> at beginning, <code>=end</code> at the end</li></ul></li></ul><pre><code>// Declares code to be called before the program run BEGIN {    code}// Declares code to be called at the end of the program END {    code}</code></pre><ul><li>classes and objects <ul><li>features<ul><li>data encapsulation </li><li>data abstraction </li><li>polymorphism</li><li>inheritance </li></ul></li></ul></li></ul><pre><code>// Class exampleClass Vehicle {   Number no_of_wheels   Number horsepower   Characters type_of_tank   Number Capacity   Function speeding {   }   Function driving {   }   Function halting {   }}</code></pre><h2 id="1-2-Class-and-Objects"><a href="#1-2-Class-and-Objects" class="headerlink" title="1.2 Class and Objects"></a>1.2 Class and Objects</h2><ul><li>Define a class in Ruby </li></ul><pre><code>// A class always starts with keyword class, followed by the name of the class. // Terminate a class by using the keyword end. class Customerend</code></pre><ul><li>Variables in a Ruby Class <ul><li>local variables <ul><li>defined in a method</li><li>begin with a lowercase letter or _. </li></ul></li><li>instance variables <ul><li>available across methods for any particular instance or object </li><li>instance variables change from object to object </li><li><code>@</code></li></ul></li><li>class variables <ul><li>available across different objects </li><li>belongs to the class and is a characteristic of a class </li><li><code>@@</code></li></ul></li><li>global variables <ul><li>Class variables are not available across classes, while global variables are.  </li><li><code>$</code></li></ul></li></ul></li></ul><pre><code>// Determine the number of objects that are being ccreated class Customer   @@no_of_customers = 0end</code></pre><ul><li>creating objects with <code>new</code> method<ul><li><code>object1 = Customer.new</code></li><li>object1 is object name</li><li>Customer is class</li><li>To instantiate a new object, you need to use class name followed by dot and new(keyword)</li></ul></li><li>custom method to create ruby objects (similar to constructor concept in Java)<ul><li>pass parameters to method new </li><li>when you plan to declare new method with parameters, you need to declare the method <strong>initialize</strong> at the time of the class creation </li></ul></li></ul><pre><code>class Customer   @@no_of_customers = 0   def initialize(id, name, addr)      @cust_id = id      @cust_name = name      @cust_addr = addr   endend// To create objects cust1 = Customer.new(&quot;1&quot;, &quot;John&quot;, &quot;Wisdom Apartments, Ludhiya&quot;)</code></pre><ul><li>member functions in class <ul><li>each method in a class starts with the keyword <code>def</code> followed by the method name </li></ul></li></ul><pre><code>class Sample    def function        statement 1        statement 2    endend// A full example #!/usr/bin/rubyclass Sample   def hello      puts &quot;Hello Ruby!&quot;   endend# Now using above class to create objectsobject = Sample. newobject.hello</code></pre><h2 id="1-3-Variables"><a href="#1-3-Variables" class="headerlink" title="1.3 Variables"></a>1.3 Variables</h2><ul><li>Global Variables <ul><li>begin with $ </li><li>uninitialized global variables have the value <code>nil</code> </li></ul></li></ul><pre><code>#!/usr/bin/ruby$global_variable = 10class Class1   def print_global      # In ruby, you can use HashTag to access any variables value       puts &quot;Global variable in Class1 is #$global_variable&quot;   endendclass Class2   def print_global      puts &quot;Global variable in Class2 is #$global_variable&quot;   endendclass1obj = Class1.newclass1obj.print_globalclass2obj = Class2.newclass2obj.print_global</code></pre><ul><li>Instance Variables <ul><li>begin with <code>@</code></li></ul></li></ul><pre><code>#!/usr/bin/rubyclass Customer   def initialize(id, name, addr)      @cust_id = id      @cust_name = name      @cust_addr = addr   end   def display_details()      puts &quot;Customer id #@cust_id&quot;      puts &quot;Customer name #@cust_name&quot;      puts &quot;Customer address #@cust_addr&quot;   endend# Create Objectscust1 = Customer.new(&quot;1&quot;, &quot;John&quot;, &quot;Wisdom Apartments, Ludhiya&quot;)cust2 = Customer.new(&quot;2&quot;, &quot;Poul&quot;, &quot;New Empire road, Khandala&quot;)# Call Methodscust1.display_details()cust2.display_details()</code></pre><ul><li>Class Variables <ul><li>begin with @@</li><li>must be initialized before they can be used in method definitions </li></ul></li></ul><pre><code>#!/usr/bin/rubyclass Customer   @@no_of_customers = 0   def initialize(id, name, addr)      @cust_id = id      @cust_name = name      @cust_addr = addr   end   def display_details()      puts &quot;Customer id #@cust_id&quot;      puts &quot;Customer name #@cust_name&quot;      puts &quot;Customer address #@cust_addr&quot;   end   def total_no_of_customers()      @@no_of_customers += 1      puts &quot;Total number of customers: #@@no_of_customers&quot;   endend# Create Objectscust1 = Customer.new(&quot;1&quot;, &quot;John&quot;, &quot;Wisdom Apartments, Ludhiya&quot;)cust2 = Customer.new(&quot;2&quot;, &quot;Poul&quot;, &quot;New Empire road, Khandala&quot;)# Call Methodscust1.total_no_of_customers()cust2.total_no_of_customers()</code></pre><ul><li><p>Local variables </p><ul><li>begin with a lowercase letter or <code>_</code></li><li>scope<ul><li>class</li><li>module</li><li>def</li><li>do to the corresponding end</li><li>block’s opening brace to its close brace </li></ul></li></ul></li><li><p>Constants</p><ul><li>Begin with an <strong>uppercase</strong> letter  </li><li>defined within a class or module </li></ul></li><li><p>Pseudo-variables </p><ul><li><p>self </p></li><li><p>true</p></li><li><p>false</p></li><li><p>nil </p><ul><li>Value representing undefined </li></ul></li><li><p><code>_FILE_</code></p><ul><li>the name of the current source file </li></ul></li><li><p><code>_LINE_</code></p><ul><li>the current line number in the source file <h2 id="1-4-Arrays"><a href="#1-4-Arrays" class="headerlink" title="1.4 Arrays"></a>1.4 Arrays</h2>Array are created by placing a comma-separated series of object references between the square brackets.</li></ul><p>#!/usr/bin/ruby</p><p>ary = [  “fred”, 10, 3.14, “This is a string”, “last element”, ]<br>ary.each do |i|<br> puts i<br>end</p></li></ul></li></ul><h2 id="1-5-Hashes"><a href="#1-5-Hashes" class="headerlink" title="1.5 Hashes"></a>1.5 Hashes</h2><p>Hash is created by placing a list of key/value pairs between braces, with either a comma or the sequence =&gt; between the key and the value. A trailing comma is ignored.</p><pre><code>#!/usr/bin/rubyhsh = colors = { &quot;red&quot; =&gt; 0xf00, &quot;green&quot; =&gt; 0x0f0, &quot;blue&quot; =&gt; 0x00f }hsh.each do |key, value|   print key, &quot; is &quot;, value, &quot;\n&quot;end</code></pre><h2 id="1-6-Ranges"><a href="#1-6-Ranges" class="headerlink" title="1.6 Ranges"></a>1.6 Ranges</h2><p>A Range represents an interval which is a set of values with a start and an end. Ranges may be constructed using the s..e and s…e literals, or with Range.new.</p><pre><code>#!/usr/bin/ruby(10..15).each do |n|    print n, &#39; &#39; end</code></pre><h2 id="1-7-Operators"><a href="#1-7-Operators" class="headerlink" title="1.7 Operators"></a>1.7 Operators</h2><ul><li><code>&lt;=&gt;</code><ul><li>ruturn 0 if first operand equals second</li><li>1 if first greater than second</li><li>-1 if first less than second </li></ul></li><li><code>.eql?</code><ul><li>true if the receiver and argument have both the same type and equal values</li></ul></li><li><code>equal?</code><ul><li>true if the receiver and argument have the same object id </li></ul></li><li><code>..</code><ul><li>1..10 creates a range from 1 to 10 inclusive</li></ul></li><li><code>...</code><ul><li>1…10 creates a range from 1 to 9  </li></ul></li><li>defined? operators<ul><li>takes the form of a method call to determine whether or not the passed expression is defined</li><li>returns a description string of the expression, or nil if the expression isn’t defined </li></ul></li><li>dot operators<ul><li></li></ul></li><li>double colon <code>::</code> operators<ul><li>You call a module method by preceding its name with the module’s name and a period, and you reference a constant using the module name and two colons. </li><li><code>::</code> us a unary operator that allows constants, instance methods and class methods defined within a class or module to be accessed from anywhere outside the class or module </li><li>*<em>Classes and methods are considered to be constants too *</em></li></ul></li></ul><h2 id="1-8-Conditions"><a href="#1-8-Conditions" class="headerlink" title="1.8 Conditions"></a>1.8 Conditions</h2><pre><code>// if else condition checkif condition    code..elsif condition2    codeelse     codeend// case #!/usr/bin/ruby$age =  5case $agewhen 0 .. 2   puts &quot;baby&quot;when 3 .. 6   puts &quot;little child&quot;when 7 .. 12   puts &quot;child&quot;when 13 .. 18   puts &quot;youth&quot;else   puts &quot;adult&quot;end</code></pre><h2 id="1-9-Loops"><a href="#1-9-Loops" class="headerlink" title="1.9 Loops"></a>1.9 Loops</h2><pre><code>while condition do     codeend</code></pre><p>Executes code while conditional is true </p><pre><code>$i = 0$num = 5begin     puts(&quot;123&quot;)    $i += 1end while $i &lt; $num // for loopfor i in 0..5    puts &quot;Value of local variable is #{i}&quot;end// subtitute way of for loop(expression).each do |variable|     codeend// E.G (0..5).each do |i|    puts &quot;Value of local variable is #{i}&quot;end </code></pre><ul><li><code>next</code><ul><li>jump to the next iteration of the most internal loop </li></ul></li><li><code>redo</code><ul><li>restarts this iteration of the most internal loop, without checking loop condition  </li></ul></li><li><code>retry</code></li><li><code>break</code><ul><li>terminate the most internal loop  </li></ul></li></ul><h2 id="1-10-Methods"><a href="#1-10-Methods" class="headerlink" title="1.10 Methods"></a>1.10 Methods</h2><ul><li><p>used to bundle one or more repeatable statements into a single unit </p></li><li><p>method name should begin with a lowercase lettter </p></li><li><p>method should be defined before calling them </p></li><li><p>call the method by direcly type in the method name <code>method_name</code></p></li><li><p>with parameters <code>method_name 25, 30</code></p></li><li><p>Ruby will return the value of lat statement by default </p></li><li><p>or use the return statement </p></li><li><p>method defined in the class definition are marked as <strong>public</strong> by default </p></li><li><p>a block is always invoked from a function with the same name as that of the block </p><p>  def method_name (var1, var2)</p><pre><code>  expr</code></pre><p>  end </p></li><li><p>variable number of parameters </p><ul><li><code>def sample (*test)</code>   </li></ul></li></ul><h2 id="1-11-Blocks"><a href="#1-11-Blocks" class="headerlink" title="1.11 Blocks"></a>1.11 Blocks</h2><ul><li>definition <ul><li>consists of chunks of code</li><li>assign a name to a block </li><li>code in the block is always enclosed within braces <code>{}</code> or <code>()</code></li><li>a block is always invoked from a function with the same name as that of the block</li><li>invoke a block by using the <code>yield</code> statement </li></ul></li><li>if the last argument of a method is preceded by &amp;, then you can pass a block to this method and this block will be assigned to the last parameter. </li></ul><pre><code>#!/usr/bin/rubydef test(&amp;block)   block.callendtest { puts &quot;Hello World!&quot;}</code></pre><h2 id="1-12-Modules-and-Mixins"><a href="#1-12-Modules-and-Mixins" class="headerlink" title="1.12 Modules and Mixins"></a>1.12 Modules and Mixins</h2><ul><li>Module<ul><li>way of grouping together methods, classes, and constants </li><li>provides namespace and prevent name clashes<ul><li>a sandbox  </li></ul></li><li>implement mixin facility </li></ul></li></ul><pre><code>// syntaxmodule Identifier    statement1    statement2end</code></pre><ul><li>call a module method by precedint its name with the module’s name and a period </li><li>reference a constant using the module name and two colons </li></ul><pre><code>#!/usr/bin/ruby# Module defined in trig.rb filemodule Trig   PI = 3.141592654   def Trig.sin(x)   # ..   end   def Trig.cos(x)   # ..   endend</code></pre><ul><li><p><code>require</code></p><ul><li>similar to import, include</li><li>if a third program wants to use any defined module, it can simply load the module files using the Ruby<code>require</code> statement </li></ul></li><li><p>mixin </p><ul><li>multiple inheratance </li></ul></li></ul><pre><code>module A   def a1   end   def a2   endendmodule B   def b1   end   def b2   endendclass Sampleinclude Ainclude B   def s1   endendsamp = Sample.newsamp.a1samp.a2samp.b1samp.b2samp.s1</code></pre><p>In this way, samp could call method defined in Module A and Module B</p><h2 id="1-13-Strings"><a href="#1-13-Strings" class="headerlink" title="1.13 Strings"></a>1.13 Strings</h2><ul><li>holds and manipulates an arbitrary sequence of one or more bytes</li></ul><h2 id="1-14-Array"><a href="#1-14-Array" class="headerlink" title="1.14 Array"></a>1.14 Array</h2><ul><li>ordered, integer indexed collections of any object</li><li>each element in an array is associated with and referred to by an index </li><li>creating arrays<ul><li><code>Array.new</code> </li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Met circumstances where need Ruby knowledge to resolve problems, thus need to do a quick touch on Ruby, at least know how to read ruby co
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Ruby" scheme="https://www.llchen60.com/tags/Ruby/"/>
    
  </entry>
  
  <entry>
    <title>PATH and LD_LIBRARY_PATH</title>
    <link href="https://www.llchen60.com/PATH-and-LD-LIBRARY-PATH/"/>
    <id>https://www.llchen60.com/PATH-and-LD-LIBRARY-PATH/</id>
    <published>2020-02-09T05:19:09.000Z</published>
    <updated>2020-02-09T05:20:52.375Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-What-is-LD-LIBRARY-PATH"><a href="#1-What-is-LD-LIBRARY-PATH" class="headerlink" title="1. What is LD_LIBRARY_PATH?"></a>1. What is LD_LIBRARY_PATH?</h1><p>LD_LIBRARY_PATH is a variable in linux to provide a list of additional directories in which to search for dynamically linkable libraries. </p><p>Consulted at time of execution , not consulted at link time </p><h1 id="2-PATH"><a href="#2-PATH" class="headerlink" title="2. PATH"></a>2. PATH</h1><p>PATH environment variable specifies the search paths for commands</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-What-is-LD-LIBRARY-PATH&quot;&gt;&lt;a href=&quot;#1-What-is-LD-LIBRARY-PATH&quot; class=&quot;headerlink&quot; title=&quot;1. What is LD_LIBRARY_PATH?&quot;&gt;&lt;/a&gt;1. What i
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.llchen60.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.llchen60.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Lombok</title>
    <link href="https://www.llchen60.com/Lombok/"/>
    <id>https://www.llchen60.com/Lombok/</id>
    <published>2020-02-09T05:17:23.000Z</published>
    <updated>2020-02-09T05:17:47.769Z</updated>
    
    <content type="html"><![CDATA[<p>Merely want to list all annotations here, and do some analysis. Lombok is a great tool to relieve java programmer from writing duplicate code. </p><h1 id="1-EqualsAndHashCode"><a href="#1-EqualsAndHashCode" class="headerlink" title="1. @EqualsAndHashCode"></a>1. @EqualsAndHashCode</h1><p>Generates hashCode and equals implementations from the fields of your object. </p><h2 id="1-1-What’s-hashCode-equals-use-for"><a href="#1-1-What’s-hashCode-equals-use-for" class="headerlink" title="1.1 What’s hashCode/ equals use for?"></a>1.1 What’s hashCode/ equals use for?</h2><p>Equals compare pass-in objects’ attributes, to see if they are the same. It compares all the field values to make judgement. </p><p>== compares whether two object references point to the same object</p><p>Use hashcode() method to optimize performance when comparing objects. <strong><em>Execute hashcode() returns a unique ID for each object in your program, which makes the task of comparing the whole state of the object much easier.</em></strong> </p><p>First run hashcode() method to judge if two objects are same, then run equals() method. </p><p>See <a href="https://www.javaworld.com/article/3305792/learn-java/java-challengers-4-comparing-java-objects-with-equals-and-hashcode.html" target="_blank" rel="noopener">Comparing Java objects with <code>equals()</code> and <code>hashcode()</code></a></p><h2 id="1-2-Implementation"><a href="#1-2-Implementation" class="headerlink" title="1.2 Implementation"></a>1.2 Implementation</h2><ol><li>By default, it uses all non-static and non-transient fields</li><li>Do modification by set <code>@EqualsAndHashCode.Include</code> or <code>@EqualsAndHashCode.Exclude</code></li></ol><h3 id="1-3-1-Apply-to-a-class-that-extends-another"><a href="#1-3-1-Apply-to-a-class-that-extends-another" class="headerlink" title="1.3.1 Apply to a class that extends another"></a>1.3.1 Apply to a class that extends another</h3><p>Normally, auto-generating an equals and hashCode method for such classes is a bad idea, as the superclass also defines fields, which also need equals/hashCode code but this code will not be generated. By setting callSuper to true, you can include the equals and hashCode methods of your superclass in the generated methods. For hashCode, the result of super.hashCode() is included in the hash algorithm, and forequals, the generated method will return false if the super implementation thinks it is not equal to the passed in object.  You can safely call your superclass equals if it, too, has a lombok-generated equals method.</p><p><code>callSuper</code>, set it to ture when you don’t extend anything is a compile time error. </p><pre><code> import lombok.EqualsAndHashCode;@EqualsAndHashCodepublic class EqualsAndHashCodeExample {  private transient int transientVar = 10;  private String name;  private double score;  @EqualsAndHashCode.Exclude private Shape shape = new Square(5, 10);  private String[] tags;  @EqualsAndHashCode.Exclude private int id;  public String getName() {    return this.name;  }  @EqualsAndHashCode(callSuper=true)  public static class Square extends Shape {    private final int width, height;    public Square(int width, int height) {      this.width = width;      this.height = height;    }  }}</code></pre><h1 id="2-NonNull"><a href="#2-NonNull" class="headerlink" title="2. @NonNull"></a>2. @NonNull</h1><p>Use this annotation on the parameter of a mothod or constructor to have lombok generate a null-check statement. </p><p>And a @NonNull on a primitive parameter results in a warning. </p><pre><code> import lombok.NonNull;public class NonNullExample extends Something {  private String name;  public NonNullExample(@NonNull Person person) {    super(&quot;Hello&quot;);    this.name = person.getName();  }}</code></pre><h1 id="3-Cleanup"><a href="#3-Cleanup" class="headerlink" title="3. @Cleanup"></a>3. @Cleanup</h1><p>It’s an antomatic resource management: call your close() methods safely with no hassle!</p><p>You can use @Cleanup to <strong><em>ensure a given resource is automatically cleaned up before the code execution path exits your current scope</em></strong>. </p><p>For example, you can use it like： </p><pre><code>@Cleanup InputStream in = new FileInputStream(&quot;some/file&quot;);</code></pre><p>As a result, at the end of the scope you are in, <code>in.close()</code> is called. The call is guaranteed to run by way of a try/ finally construct. </p><p>If the type of object you’d like to cleanup does not have a close method, you can specify the name of this method like:</p><pre><code>@Cleanup(&quot;dispose&quot;) org.eclipse.swt.widgets.CoolBar bar = new CoolBar(parent, 0); </code></pre><p>Notice: there should be no variables in the cleanup method. </p><pre><code> import lombok.Cleanup;import java.io.*;public class CleanupExample {  public static void main(String[] args) throws IOException {    @Cleanup InputStream in = new FileInputStream(args[0]);    @Cleanup OutputStream out = new FileOutputStream(args[1]);    byte[] b = new byte[10000];    while (true) {      int r = in.read(b);      if (r == -1) break;      out.write(b, 0, r);    }  }}</code></pre><h1 id="4-Getter-Setter"><a href="#4-Getter-Setter" class="headerlink" title="4. @Getter/ @Setter"></a>4. @Getter/ @Setter</h1><p>Annotate any field with Getter and Setter to let lombok generate the default getter/ setter automatically. </p><p>The generated getter/setter method will be public unless you explicitly specify an AccessLevel, as shown in the example below. Legal access levels are PUBLIC, PROTECTED, PACKAGE, and PRIVATE.</p><p>Also we can put the annotation on a class, in this way, it’s as if you annotate all the non-static fields in the class with annotation. </p><pre><code> import lombok.AccessLevel;import lombok.Getter;import lombok.Setter;public class GetterSetterExample {  /**   * Age of the person. Water is wet.   *    * @param age New value for this person&#39;s age. Sky is blue.   * @return The current value of this person&#39;s age. Circles are round.   */  @Getter @Setter private int age = 10;  /**   * Name of the person.   * -- SETTER --   * Changes the name of this person.   *    * @param name The new value.   */  @Setter(AccessLevel.PROTECTED) private String name;  @Override public String toString() {    return String.format(&quot;%s (age: %d)&quot;, name, age);  }}</code></pre><h1 id="5-ToString"><a href="#5-ToString" class="headerlink" title="5. @ToString"></a>5. @ToString</h1><p>No need to start a debugger to see your fields, lombok can generate a toString for you. </p><p>Any <strong><em>class</em></strong> can be annotated with @ToString to let lombok generate an implementation of the toString() method. </p><p>We can set: </p><ul><li><p>includeFieldNames </p><ul><li>Add some clarity to the output </li></ul></li><li><p>@ToString.Exclude </p></li><li><p>@ToString(onlyExplicitlyIncluded = true)</p><ul><li>specify exactly which fields you wish to be used  </li><li>then marking each field you want to include with <code>@ToString.Include</code></li></ul></li><li><p>Can also include non static methods that take no argument  -&gt; use <code>@ToString.Include</code></p><p>  import lombok.ToString;</p><p>  @ToString<br>  public class ToStringExample {</p><pre><code>private static final int STATIC_VAR = 10;private String name;private Shape shape = new Square(5, 10);private String[] tags;@ToString.Exclude private int id;public String getName() {  return this.name;}@ToString(callSuper=true, includeFieldNames=true)public static class Square extends Shape {  private final int width, height;  public Square(int width, int height) {    this.width = width;    this.height = height;  }}</code></pre><p>  }</p></li></ul><h1 id="6-NoArgsConstructor-RequiredArgsConstructor-AllArgsConstructor"><a href="#6-NoArgsConstructor-RequiredArgsConstructor-AllArgsConstructor" class="headerlink" title="6. @NoArgsConstructor, @RequiredArgsConstructor, @AllArgsConstructor"></a>6. @NoArgsConstructor, @RequiredArgsConstructor, @AllArgsConstructor</h1><p>Constructors: </p><ul><li>Generates constructors that take no arguments</li><li>Generates constructors that take one argument per final/ non-null field </li><li>Generates constructors that take one argument for every field</li></ul><h2 id="6-1-NoArgsConstructor"><a href="#6-1-NoArgsConstructor" class="headerlink" title="6.1 @NoArgsConstructor"></a>6.1 @NoArgsConstructor</h2><p>@NoArgsConstructor will generate a constructor with no parameters. </p><p>If it’s not possible(because of final fields), a compiler error will result, unless we use <code>@NoArgsConstructor(force = true)</code>. Then all final fields are initialized with 0/ false/ null </p><h2 id="6-2-RequiredArgsConstructor"><a href="#6-2-RequiredArgsConstructor" class="headerlink" title="6.2 @RequiredArgsConstructor"></a>6.2 @RequiredArgsConstructor</h2><p>@RequiredArgsConstructor  generates a constructor with 1 parameter for each field that requires special handling.  All <strong>non-initialized final fields</strong> get a parameter, as well as any fields that are marked as <strong>@NonNull</strong> that aren’t initialized where they are declared. For those fields marked with @NonNull, an explicit null check is also generated. The constructor will throw a NullPointerException if any of the parameters intended for the fields marked with @NonNull contain null. The order of the parameters match the order in which the fields appear in your class.</p><h2 id="6-3-AllArgsConstructor"><a href="#6-3-AllArgsConstructor" class="headerlink" title="6.3 @AllArgsConstructor"></a>6.3 @AllArgsConstructor</h2><p>@AllArgsConstructor generates a constructor with 1 parameter for each field in your class. Fields marked with @NonNull result in null checks on those parameters.</p><h1 id="7-Data"><a href="#7-Data" class="headerlink" title="7. @Data"></a>7. @Data</h1><p>All togerther: a shortcut for: </p><ul><li>@ToString,</li><li>@EqualsAndHashCode</li><li>@Getter on all fields</li><li>@Setter on all non-final fields</li><li>@RequiredArgsConstructor </li></ul><p>@Data generates all the boilerplate that is normally associated with simple POJOs (Plain Old Java Objects) and beans: getters for all fields, setters for all non-final fields, and appropriate toString, equals and hashCode implementations that involve the fields of the class, and a constructor that initializes all final fields, as well as all non-final fields with no initializer that have been marked with @NonNull, in order to ensure the field is never null.</p><p>All generated getters and setters will be public</p><p>All fields marked as transient will not be considered for hashCode and equals. All static fields will be skipped entirely. </p><pre><code> import lombok.AccessLevel;import lombok.Setter;import lombok.Data;import lombok.ToString;@Data public class DataExample {  private final String name;  @Setter(AccessLevel.PACKAGE) private int age;  private double score;  private String[] tags;  @ToString(includeFieldNames=true)  @Data(staticConstructor=&quot;of&quot;)  public static class Exercise&lt;T&gt; {    private final String name;    private final T value;  }}</code></pre><h1 id="8-Value"><a href="#8-Value" class="headerlink" title="8. @Value"></a>8. @Value</h1><p>@Value is the immutable variant of @Data. All fields are made private and final by default. setters are not generated at all. </p><p>The class itself is also made final by default, becuase immutability is not something that can be forced onto a sunclass.</p><p>Actually, @Value equals to <code>final @ToString @EqualsAndHashCode @AllArgsConstructor @FieldDefaults(makeFinal = true, level = AccessLevel.PRIVATE) @Getter</code></p><pre><code> import lombok.AccessLevel;import lombok.experimental.NonFinal;import lombok.experimental.Value;import lombok.experimental.Wither;import lombok.ToString;@Value public class ValueExample {  String name;  @Wither(AccessLevel.PACKAGE) @NonFinal int age;  double score;  protected String[] tags;  @ToString(includeFieldNames=true)  @Value(staticConstructor=&quot;of&quot;)  public static class Exercise&lt;T&gt; {    String name;    T value;  }}</code></pre><h1 id="9-Builder"><a href="#9-Builder" class="headerlink" title="9. @Builder"></a>9. @Builder</h1><p>The @Builder annotation produces complex builder APIs for your classes.</p><p>@Builder lets you automatically produce the code required to have your class be instantiable with code such as:<br>Person.builder().name(“Adam Savage”).city(“San Francisco”).job(“Mythbusters”).job(“Unchained Reaction”).build();</p><h1 id="10-Getter-lazy-true"><a href="#10-Getter-lazy-true" class="headerlink" title="10. @Getter(lazy = true)"></a>10. @Getter(lazy = true)</h1><p>You can let lombok generate a getter which will calculate a value once, the first time this getter is called, and cache it from then on. This can be useful if calculating the value takes a lot of CPU, or the value takes a lot of memory. To use this feature, create a private final variable, initialize it with the expression that’s expensive to run, and annotate your field with @Getter(lazy=true)</p><pre><code> import lombok.Getter;public class GetterLazyExample {  @Getter(lazy=true) private final double[] cached = expensive();  private double[] expensive() {    double[] result = new double[1000000];    for (int i = 0; i &lt; result.length; i++) {      result[i] = Math.asin(i);    }    return result;  }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Merely want to list all annotations here, and do some analysis. Lombok is a great tool to relieve java programmer from writing duplicate 
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
      <category term="Annotation" scheme="https://www.llchen60.com/tags/Annotation/"/>
    
      <category term="Lombok" scheme="https://www.llchen60.com/tags/Lombok/"/>
    
  </entry>
  
  <entry>
    <title>JSP Tutorial</title>
    <link href="https://www.llchen60.com/JSP-Tutorial/"/>
    <id>https://www.llchen60.com/JSP-Tutorial/</id>
    <published>2020-02-09T05:16:31.000Z</published>
    <updated>2020-02-09T05:16:49.160Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h1><h2 id="1-1-Intro"><a href="#1-1-Intro" class="headerlink" title="1.1 Intro"></a>1.1 Intro</h2><ul><li>JavaServer Pages <ul><li>develop webpages that support dynamic content </li><li>collect input from users through webpage forms</li><li>present records from a database or another source </li><li>creates webpage dynamically </li></ul></li></ul><h2 id="1-2-Architecture"><a href="#1-2-Architecture" class="headerlink" title="1.2 Architecture"></a>1.2 Architecture</h2><ul><li><p>JSP engine</p><ul><li>a container to process JSP pages  </li><li>responsible for intercepting requests for JSP pages </li></ul></li><li><p>JSP processing </p><ul><li>browser sends an HTTP request to the web server </li><li>web server recognizes that the HTTP request is for a JSP page and forwards it to a JSP engine. <ul><li>Finish by using the URL or JSP page which ends with .jsp instead of .html </li></ul></li><li>JSP engine loads the JSP page from disk and converts it into a servlet content. </li><li>JSP engine compiles the servlet into an executable class and forwards the original request to a servlet engine</li><li>A part of the web server called the servlet engine loads the Servlet class and executes it. During execution, the servlet produces an output in HTML format. The output is furthur passed on to the web server by the servlet engine inside an HTTP response.</li><li>The web server forwards the HTTP response to your browser in terms of static HTML content !!! Return static html directly </li><li>the web browser handles the dynamically generated HTML page inside the HTTP response exactly as if it were a static page </li></ul></li></ul><h2 id="1-3-Lifecycle"><a href="#1-3-Lifecycle" class="headerlink" title="1.3 Lifecycle"></a>1.3 Lifecycle</h2><p>A JSP life cycle is defined as the process from its creation till the destruction, Similar to a servlet life cycle with an additional step which is required to compile a JSP into servlet.</p><ul><li>compilation<ul><li>when a browser asks for a JSP, the JSP engine first checks to see whether it needs to compile the page </li><li>If the page has never been compiled, or if the JSP has been modified since it was last compiled, the JSP engine compiles the page</li><li>compile involves:<ul><li>parsing the JSP</li><li>turning the JSP into a servlet </li><li>compile the servlet </li></ul></li></ul></li><li>initialization<ul><li>invokes the jspInit() method before servicing any requests  </li></ul></li><li>execution<ul><li>represents all interactions with requests until the JSP is destroyed </li><li>Whenever a browser requests a JSP and the page has been loaded and initialized, the JSP engine invokes the _jspService() method in the JSP</li><li><code>void _jspService(HttpServletRequest request, HttpServletResponse response) {// Service handling code...}</code></li></ul></li><li>cleanup <ul><li>represents when a JSP is being removed from use by a container </li><li>The jspDestroy() method is the JSP equivalent of the destroy method for servlets. </li></ul></li></ul><h1 id="2-Syntax-Operations"><a href="#2-Syntax-Operations" class="headerlink" title="2. Syntax/ Operations"></a>2. Syntax/ Operations</h1><h2 id="2-1-Elements-of-JSP"><a href="#2-1-Elements-of-JSP" class="headerlink" title="2.1 Elements of JSP"></a>2.1 Elements of JSP</h2><h3 id="2-1-1-Scriptlet"><a href="#2-1-1-Scriptlet" class="headerlink" title="2.1.1 Scriptlet"></a>2.1.1 Scriptlet</h3><p>A scriptlet can contain any number of JAVA language statements, variable or method declarations, or expressions that are valid in the page scripting language. </p><p><code>&lt;%code fragment%&gt;</code></p><p>XML equivalent as follows: </p><pre><code>&lt;jsp:scriptlet&gt;   code fragment&lt;/jsp:scriptlet&gt;</code></pre><p>Any text, HTML tags, or JSP elements you write must be outside the scriptlet. </p><h3 id="2-1-2-JSP-Declarations"><a href="#2-1-2-JSP-Declarations" class="headerlink" title="2.1.2 JSP Declarations"></a>2.1.2 JSP Declarations</h3><p>A declaration declares one or more variables or methods that you can use in Java code later in the JSP file. You must declare the variable or method before you use it in the JSP file.</p><pre><code>&lt;%! declaration; [ declaration; ]+ ... %&gt;</code></pre><p>We can also write the XML equivalent of the above syntax as follows: </p><pre><code>&lt;jsp:declaration&gt;   code fragment&lt;/jsp:declaration&gt;</code></pre><h3 id="2-1-3-JSP-Expression"><a href="#2-1-3-JSP-Expression" class="headerlink" title="2.1.3 JSP Expression"></a>2.1.3 JSP Expression</h3><ul><li>Contains a scripting language expression that is evaluated, converted to a String, and inserted where the expression appears in the JSP file. </li><li>The expression element can contain any expression that is valid according to the Java Language Specification but you cannot use a semicolon to end an expression.</li></ul><pre><code>&lt;%= expression %&gt;&lt;jsp:expression&gt;    expression&lt;/jsp:expression&gt;</code></pre><h3 id="2-1-4-JSP-Comments"><a href="#2-1-4-JSP-Comments" class="headerlink" title="2.1.4 JSP Comments"></a>2.1.4 JSP Comments</h3><p>JSP comments marks text or statements that the JSP container should ignore. A JSP comment is useful when you want to hide or comment out. </p><p>&lt;%– This is JSP comment –%&gt;</p><h3 id="2-1-5-JSP-Directives"><a href="#2-1-5-JSP-Directives" class="headerlink" title="2.1.5 JSP Directives"></a>2.1.5 JSP Directives</h3><ul><li>A JSP directive affects the overall structure of the servlet class. </li></ul><pre><code>&lt;%@ directive attribute=&quot;value&quot; %&gt;</code></pre><ul><li><code>&lt;%@ page. attribute=.. %&gt;</code><ul><li>Defines page dependent attributes<ul><li>scripting language</li><li>error page</li><li>buffering requirements </li></ul></li><li>instructions to the current page </li><li>attributes list <ul><li>buffer </li><li>autoFlush </li><li>contentType</li><li>errorPage</li><li>isErrorPage</li><li>extends</li><li>import</li><li>info </li><li>isThreadSafe</li><li>language</li><li>session </li><li>isELignored </li><li>isScriptingEnabled</li></ul></li></ul></li><li><code>&lt;%@ include ... %&gt;</code><ul><li>include a file during the translation phase  </li><li>tells the container to merge the content of other external files with the current JSP during the translation phase.</li></ul></li><li><code>&lt;%@ taglib ... %&gt;</code><ul><li>declares a tag library, containing custom actions, used in the page  </li></ul></li></ul><h3 id="2-1-6-JSP-Actions"><a href="#2-1-6-JSP-Actions" class="headerlink" title="2.1.6 JSP Actions"></a>2.1.6 JSP Actions</h3><p>JSP actions use contructs in XML syntax to control the behavior of the servlet engine</p><p>You can dynamically insert a file, reuse javaBeans components, forward the user to another page, or generate HTML for the java plugin </p><pre><code>&lt;jsp:action_name  attribute=&quot;value&gt;</code></pre><ul><li>jsp:include </li><li>jsp:useBean </li><li>jsp:setProperty</li><li>jsp:forward <ul><li>forward the requester to a new page </li></ul></li><li>jsp:plugin<ul><li>generates browser-specific code that makes an OBJECT or EMBED tag for the java plugin</li></ul></li><li>jsp:element <ul><li>defines XML elements dynamically </li></ul></li><li>jsp:attribute <ul><li>defines dynamically defined XML element’s attribute</li></ul></li><li>jsp:body<ul><li>Defines dynamically-defined XML element’s body.</li></ul></li><li>jsp:text <ul><li>write template text in JSP pages and documents </li></ul></li></ul><h2 id="2-2-JSP-Implicit-Objects"><a href="#2-2-JSP-Implicit-Objects" class="headerlink" title="2.2 JSP Implicit Objects"></a>2.2 JSP Implicit Objects</h2><p>JSP supports some automatically defined variables</p><ul><li>request <ul><li>HttpServletRequest object </li></ul></li><li>response <ul><li>HttpServletResponse object </li></ul></li><li>out <ul><li>send output  to the client </li></ul></li><li>session <ul><li>HttpSession object associated with the request </li></ul></li><li>application <ul><li>The servletContext object associated with the application context </li></ul></li><li>config <ul><li>servletConfig object associated with the page </li></ul></li><li>pageContext<ul><li>This encapsulates use of server-specific features like higher performance JspWriters.</li></ul></li><li>page<ul><li>This is simply a synonym for this, and is used to call the methods defined by the translated servlet class.</li></ul></li><li>exception <ul><li>The Exception object allows the exception data to be accessed by designated JSP. </li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Introduction&quot;&gt;&lt;a href=&quot;#1-Introduction&quot; class=&quot;headerlink&quot; title=&quot;1. Introduction&quot;&gt;&lt;/a&gt;1. Introduction&lt;/h1&gt;&lt;h2 id=&quot;1-1-Intro&quot;&gt;&lt;a h
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
      <category term="JSP" scheme="https://www.llchen60.com/tags/JSP/"/>
    
  </entry>
  
  <entry>
    <title>JMX - Tutorials</title>
    <link href="https://www.llchen60.com/JMX-Tutorials/"/>
    <id>https://www.llchen60.com/JMX-Tutorials/</id>
    <published>2020-02-09T05:15:44.000Z</published>
    <updated>2020-02-09T05:16:07.815Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h1><ul><li>JMX - Java Management extensions<ul><li>export standard metrics and custom metrics using MBeans to a monitoring system </li><li>understand how your application is performing <ul><li>memory </li><li>cpu</li><li>threads </li><li>API calls in a REST endpoint</li></ul></li></ul></li></ul><h1 id="2-Why-need-this"><a href="#2-Why-need-this" class="headerlink" title="2. Why need this?"></a>2. Why need this?</h1><ul><li>Large scale java applications <ul><li>gather performance information <ul><li>number of users connected </li></ul></li></ul></li><li>could provide a monitoring interface </li><li>any class that exports data to JMX is called a Managed Bean(MBean). These MBeans publish their metrics to a MBean Server provided by the Java platform. </li></ul><h1 id="3-Components"><a href="#3-Components" class="headerlink" title="3. Components"></a>3. Components</h1><h2 id="3-1-MBean"><a href="#3-1-MBean" class="headerlink" title="3.1 MBean"></a>3.1 MBean</h2><ul><li>Objects with methods that return information and export the information via the MBeanServer</li><li>Mainly have 4 types <ul><li>Standard MBean <ul><li>create an interface with getter  </li></ul></li><li>Dynamic MBean <ul><li>implements getters and setters to retrieve or modify the metric that can be auto discovered by implementing the javax.management.DynamicMBean interface </li></ul></li><li>Model MBean<ul><li>Generic, dynamic in runtime to instrument the resources  </li></ul></li><li>Open MBean<ul><li>Using a predefined set of java classes</li></ul></li></ul></li></ul><h1 id="4-Example"><a href="#4-Example" class="headerlink" title="4. Example"></a>4. Example</h1><pre><code>// Create an interface that the MBeanServer will retrieve information public interface SystemStatusMBean {   Integer getNumberOfSecondsRunning();   String getProgramName();   Long getNumberOfUnixSecondsRunning();   Boolean getSwitchStatus();}</code></pre><p>Actual Implementation </p><pre><code>    public class SystemStatus implements SystemStatusMBean {   private Integer numberOfSecondsRunning;   private String programName;   private Long numberOfUnixSecondsRunning;   private Boolean switchStatus;   private Thread backgroundThread;   public SystemStatus(String programName) {       // First we initialize all the metrics       this.backgroundThread = new Thread();       this.programName = programName;       this.numberOfSecondsRunning = 0;       this.numberOfUnixSecondsRunning = System.currentTimeMillis() / 1000L;       this.switchStatus = false;       // We will use a background thread to update the metrics       this.backgroundThread = new Thread(() -&gt; {           try {               while (true) {                   // Every second we update the metrics                   numberOfSecondsRunning += 1;                   numberOfUnixSecondsRunning += 1;                   switchStatus = !switchStatus;                   Thread.sleep(1000L);               }           } catch (Exception e) {               e.printStackTrace();           }       });       this.backgroundThread.setName(&quot;backgroundThread&quot;);       this.backgroundThread.start();   }</code></pre><h1 id="5-Operations-and-attributes"><a href="#5-Operations-and-attributes" class="headerlink" title="5. Operations and attributes"></a>5. Operations and attributes</h1><p>Class properties exported through MBeans are called attributes, and methods exported through MBeans are called operations.</p><ul><li>TotalCompilationTime <ul><li>Total time spent doing in JIT compilation  </li></ul></li><li>Garbage Collector - CollectionCount <ul><li>Number of garbage collection events fired since the JVM launch</li></ul></li><li>Garbage Collector - CollectionTime </li><li>FreePyhsicalMemorySize </li><li>CommitedVirtualMemorySize<ul><li>The amount of memory that is guaranteed to be available for use by JVM  </li></ul></li><li>ProcessCpuTime <ul><li>Time CPU has spent running the process  </li></ul></li><li>PeakThreadCount <ul><li>maximum number of threads being executed at the same time since the JVM was started or the peak was reset  </li></ul></li><li>ThreadCount <ul><li>the number of threads running at the current moment </li></ul></li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://sysdig.com/blog/jmx-monitoring-custom-metrics/" target="_blank" rel="noopener">https://sysdig.com/blog/jmx-monitoring-custom-metrics/</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Introduction&quot;&gt;&lt;a href=&quot;#1-Introduction&quot; class=&quot;headerlink&quot; title=&quot;1. Introduction&quot;&gt;&lt;/a&gt;1. Introduction&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;JMX - Java Man
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
      <category term="JMX" scheme="https://www.llchen60.com/tags/JMX/"/>
    
  </entry>
  
  <entry>
    <title>Java是如何工作的</title>
    <link href="https://www.llchen60.com/Java%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/"/>
    <id>https://www.llchen60.com/Java%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/</id>
    <published>2020-02-09T05:14:12.000Z</published>
    <updated>2020-02-09T05:14:29.247Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-编程语言是如何工作的"><a href="#1-编程语言是如何工作的" class="headerlink" title="1. 编程语言是如何工作的"></a>1. 编程语言是如何工作的</h1><p>我们可以把编程语言按照与底层实现的接近程度来划分层次，更加高层次的编程语言会让我们写起来更像自然语言一些，比如Java, C++。而低层次的语言，更贴近机器语言，即在描述底层是如何实现的。</p><p>对于大部分编程语言来说，工作的整个过程是从编译 - 链接 - 执行。就是从源代码开始，编译器会运行源代码，将其转化为贴近机器语言的状态，我们将其称为<code>Object</code> 文件。一系列的<code>Object</code>文件可以被链接起来，并创建一个可执行文件。操作系统可以加载这个可执行文件到内存中，并运行程序。</p><p>还有一部分语言是解释性的，比如Lisp, Schema。他会针对每一个高层次的语句来做低层次的翻译，然后顺序执行他们。这个过程相当于我遇到一个语句，翻译成计算机能看懂的语言以后，再看下一句…</p><h1 id="2-Java是如何工作的"><a href="#2-Java是如何工作的" class="headerlink" title="2. Java是如何工作的"></a>2. Java是如何工作的</h1><p>Java是个平台独立的语言，那他是怎么做到的呢？</p><p>首先我们要理解一下什么叫做平台独立？</p><blockquote><p>对于很多编程语言来说，编译器会生成可以在特定计算机上执行的代码。比如你在windows机器上编译一段c++代码，那么生成的可执行文件可以在任何其他的windows电脑上运行，但无法在Mac或者Linux机器上运行。</p></blockquote><p>对于早期的语言来说，设计者需要针对每一个平台专门设计一个编译器。而作为一个程序员，如果你想自己的代码在多个平台上都可以工作，你也需要针对性的做很多修改。</p><p>Java重新组织了编译-链接-执行这个循环，它将和平台相关的代码给抽象出来，和其他代码分开。这样子，编译的时候不会生成一个Object文件，反之，会生成字节码文件，这个字节码文件是平台独立的，即它可以在任何平台运行。那么刚才说的和平台相关的代码放到哪里了呢？为了执行字节码，我们需要唤醒java解释器。每个平台都会有自己的解释器，来解决和平台相关的问题。</p><p>对于其他语言来说，执行的过程是 编译，链接然后执行。对于Java来说，更应该说是编译然后链接，执行。</p><h1 id="3-Compile-vs-Runtime"><a href="#3-Compile-vs-Runtime" class="headerlink" title="3. Compile vs Runtime"></a>3. Compile vs Runtime</h1><p>整个代码的lifecycle,程序员先写源码，通过源码定义了程序是比如和工作的。这些源码必须要编译成机器码(java里面等效为字节码)，然后变成可执行文件。这个编译的过程称之为compile time.</p><p>一个编译过的文件是可以打开并且运行的，当一个应用正在运行的时候，我们就叫他处在runtime当中。</p><p>compile error一般是在编译的过程中由编译器报的错，告诉我们哪一行出了什么问题。运行时候的错误就叫做runtime error，这往往是一些逻辑错误，系统崩溃，流量过大等原因造成的。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="http://www.cs.cmu.edu/~jcarroll/15-100-s05/supps/basics/history.html" target="_blank" rel="noopener">CMU Class Notes</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-编程语言是如何工作的&quot;&gt;&lt;a href=&quot;#1-编程语言是如何工作的&quot; class=&quot;headerlink&quot; title=&quot;1. 编程语言是如何工作的&quot;&gt;&lt;/a&gt;1. 编程语言是如何工作的&lt;/h1&gt;&lt;p&gt;我们可以把编程语言按照与底层实现的接近程度来划分层次，更
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java Unit Test - Junit5</title>
    <link href="https://www.llchen60.com/Java-Unit-Test-Junit5/"/>
    <id>https://www.llchen60.com/Java-Unit-Test-Junit5/</id>
    <published>2020-02-09T05:12:58.000Z</published>
    <updated>2020-02-09T05:13:43.504Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Writing-Tests"><a href="#1-Writing-Tests" class="headerlink" title="1. Writing Tests"></a>1. Writing Tests</h1><p>JUnit5 = Junit Platform + Junit Jupiter + Junit Vintage </p><p>First test cases: </p><pre><code>import static org.junit.jupiter.api.Assertions.assertEquals;import example.util.Calculator;import org.junit.jupiter.api.Test;class MyFirstJUnitJupiterTests {    private final Calculator calculator = new Calculator();    @Test    void addition() {        assertEquals(2, calculator.add(1, 1));    }}</code></pre><h2 id="1-1-Annotations"><a href="#1-1-Annotations" class="headerlink" title="1.1 Annotations"></a>1.1 Annotations</h2><ul><li>@Test <ul><li>Denotes that a method is a test method. This annotation does not declare any attributes</li></ul></li><li>@ParameterizedTest <ul><li>Denote a method is a parameterized test </li><li>Make it possible to run a test multiple times with different arguments </li><li>Must declare at least one source that will provide the arguments for each invocation and then consume the arguments in teh test method </li></ul></li><li>@RepeatedTest <ul><li>denotes a method is a test template for a repeated test </li><li>Provides ability to repeat a test a specific number of times by annotating a method with <code>@RepeatedTest</code> and specify the total number of repetitions desired. </li></ul></li><li>@TestFactory <ul><li>denotes a method is a test factory for dynamic tests</li><li>dynamic test generated at runtime by a factory method that is annotated with @TestFactory </li><li>a factory for test case </li></ul></li><li>@TestTemplate<ul><li>denotes that a method is a template for test cases designed to be invoked multiple times depending on the number of invocation contexts returned by the registered providers. </li></ul></li><li>@TestMethodOrder <ul><li>Configure the test method execution order </li></ul></li><li>@TestInstance<ul><li>Used to configure the test instance lifecycle for the annotated test class.  </li></ul></li><li>@DisplayName<ul><li>Declares a custom display name for the test class or test method.</li></ul></li><li>@BeforeEach<ul><li>Denotes that the annotated method should be executed before each @Test, @RepeatedTest, @ParameterizedTest, or @TestFactory method in the current class; analogous to JUnit 4’s @Before. </li></ul></li><li>@AfterEach <ul><li>Denotes that the annotated method should be executed after each @Test, @RepeatedTest, @ParameterizedTest, or @TestFactory method in the current class; analogous to JUnit 4’s @After</li></ul></li><li>@BeforeAll <ul><li>Denotes that the annotated method should be executed before all @Test, @RepeatedTest, @ParameterizedTest, and @TestFactory methods in the current class; analogous to JUnit 4’s @BeforeClass. Such methods are inherited (unless they are hidden or overridden) and must be static (unless the “per-class” test instance lifecycle is used).</li></ul></li><li>@AfterAll <ul><li>Denotes that the annotated method should be executed after all @Test, @RepeatedTest, @ParameterizedTest, and @TestFactory methods in the current class; analogous to JUnit 4’s @AfterClass. Such methods are inherited (unless they are hidden or overridden) and must be static</li></ul></li><li>@Nested <ul><li>Denotes that the annotated class is a non-static nested test class. @BeforeAll and @AfterAll methods cannot be used directly in a @Nested test class unless the “per-class” test instance lifecycle is used.</li></ul></li><li>@Tag<ul><li>Used to declare tags for filtering tests, either at the class or method level; analogous to test groups in TestNG or Categories in JUnit 4. Such annotations are inherited at the class level but not at the method level.</li></ul></li><li>@Disabled <ul><li>Used to disable a test class or test method; analogous to JUnit 4’s @Ignore. Such annotations are not inherited.</li></ul></li><li>@ExtendWith<ul><li>Used to register extensions declaratively </li></ul></li><li>@RegisterExtension<ul><li>Used to register extensions programmatically via fields.</li></ul></li><li>@TempDir<ul><li>Used to supply a temporary directory via field injection or parameter injection in a lifecycle method or test method </li></ul></li></ul><h2 id="1-2-Test-classes-and-methods"><a href="#1-2-Test-classes-and-methods" class="headerlink" title="1.2 Test classes and methods"></a>1.2 Test classes and methods</h2><ul><li>Test classes must not be abstract and mush have a single constructor</li><li>Test method: any instance method that is directly annotated or meta-annotated with @Test, @RepeatedTest, @ParameterizedTest, @TestFactory, or @TestTemplate</li><li>Lifecycle Method: any method that is directly annotated or meta-annotated with @BeforeAll, @AfterAll, @BeforeEach, or @AfterEach</li></ul><p>A standard unit test class: </p><pre><code>import static org.junit.jupiter.api.Assertions.fail;import static org.junit.jupiter.api.Assumptions.assumeTrue;import org.junit.jupiter.api.AfterAll;import org.junit.jupiter.api.AfterEach;import org.junit.jupiter.api.BeforeAll;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Disabled;import org.junit.jupiter.api.Test;class StandardTests {    @BeforeAll    static void initAll() {    }    @BeforeEach    void init() {    }    @Test    void succeedingTest() {    }    @Test    void failingTest() {        fail(&quot;a failing test&quot;);    }    @Test    @Disabled(&quot;for demonstration purposes&quot;)    void skippedTest() {        // not executed    }    @Test    void abortedTest() {        assumeTrue(&quot;abc&quot;.contains(&quot;Z&quot;));        fail(&quot;test should have been aborted&quot;);    }    @AfterEach    void tearDown() {    }    @AfterAll    static void tearDownAll() {    }}</code></pre><h2 id="1-3-Assertions"><a href="#1-3-Assertions" class="headerlink" title="1.3 Assertions"></a>1.3 Assertions</h2><p>All assertions are static methods in org.junit.jupiter.api.Assertions class.</p><p>See <a href="https://junit.org/junit5/docs/current/api/org/junit/jupiter/api/Assertions.html" target="_blank" rel="noopener">API doc</a> for detail: </p><ul><li>assertAll()</li><li>assertArrayEquals()</li><li>assertArrauEqualsString()</li><li>assertEquals()</li><li>assertNotEquals()</li><li>assertTimeout()</li><li>assertTimeoutPreemptively()</li><li>assertTure()</li><li>fail()</li></ul><pre><code>@Test    void dependentAssertions() {        // Within a code block, if an assertion fails the        // subsequent code in the same block will be skipped.        assertAll(&quot;properties&quot;,            () -&gt; {                String firstName = person.getFirstName();                assertNotNull(firstName);                // Executed only if the previous assertion is valid.                assertAll(&quot;first name&quot;,                    () -&gt; assertTrue(firstName.startsWith(&quot;J&quot;)),                    () -&gt; assertTrue(firstName.endsWith(&quot;e&quot;))                );            },            () -&gt; {                // Grouped assertion, so processed independently                // of results of first name assertions.                String lastName = person.getLastName();                assertNotNull(lastName);                // Executed only if the previous assertion is valid.                assertAll(&quot;last name&quot;,                    () -&gt; assertTrue(lastName.startsWith(&quot;D&quot;)),                    () -&gt; assertTrue(lastName.endsWith(&quot;e&quot;))                );            }        );    }</code></pre><h2 id="1-4-Assumptions"><a href="#1-4-Assumptions" class="headerlink" title="1.4 Assumptions"></a>1.4 Assumptions</h2><p>Assumptions is a collection of utility methods that support conditional test execution based on assumptions.In direct contrast to failed assertions, failed assumptions do not result in a test failure; rather, a failed assumption results in a <strong>test being aborted</strong>.</p><ul><li><p>assumeFalse()</p></li><li><p>assumeTrue()</p></li><li><p>assumingThat(boolean assumption, Executable executable)</p><p>   @Test</p><pre><code>  void testOnlyOnDeveloperWorkstation() {      assumeTrue(&quot;DEV&quot;.equals(System.getenv(&quot;ENV&quot;)),          () -&gt; &quot;Aborting test: not on developer workstation&quot;);      // remainder of test  }  @Test  void testInAllEnvironments() {      assumingThat(&quot;CI&quot;.equals(System.getenv(&quot;ENV&quot;)),          () -&gt; {              // perform these assertions only on the CI server              assertEquals(2, calculator.divide(4, 2));          });      // perform these assertions in all environments      assertEquals(42, calculator.multiply(6, 7));  }</code></pre></li></ul><h2 id="1-5-Test-Instance-Lifecycle"><a href="#1-5-Test-Instance-Lifecycle" class="headerlink" title="1.5 Test Instance Lifecycle"></a>1.5 Test Instance Lifecycle</h2><p>In order to allow individual test methods to be executed in isolation and to avoid unexpected side effects due to mutable test instance state, <strong>JUnit creates a new instance of each test class before executing each test method</strong></p><p>You can annotate your test class with <code>@TestInstance(Lifecycle.PER_CLASS)</code> if you <strong>prefer to execute all test methods on the same test instance</strong>. And if your test mothods rely on state stored in instance variables, may need to reset the state in @BeforeEach or @AfterEach methods. </p><p>The “per-class” mode has some additional benefits over the default “per-method” mode. Specifically, with the “per-class” mode it becomes possible to declare @BeforeAll and @AfterAll on non-static methods as well as on interface default methods. The “per-class” mode therefore also makes it possible to use @BeforeAll and @AfterAll methods in @Nested test classes.</p><pre><code>@TestInstance(Lifecycle.PER_CLASS)interface TestLifecycleLogger {    static final Logger logger = Logger.getLogger(TestLifecycleLogger.class.getName());    @BeforeAll    default void beforeAllTests() {        logger.info(&quot;Before all tests&quot;);    }    @AfterAll    default void afterAllTests() {        logger.info(&quot;After all tests&quot;);    }    @BeforeEach    default void beforeEachTest(TestInfo testInfo) {        logger.info(() -&gt; String.format(&quot;About to execute [%s]&quot;,            testInfo.getDisplayName()));    }    @AfterEach    default void afterEachTest(TestInfo testInfo) {        logger.info(() -&gt; String.format(&quot;Finished executing [%s]&quot;,            testInfo.getDisplayName()));    }}</code></pre><h2 id="1-6-Repeated-Test"><a href="#1-6-Repeated-Test" class="headerlink" title="1.6 Repeated Test"></a>1.6 Repeated Test</h2><pre><code>import static org.junit.jupiter.api.Assertions.assertEquals;import java.util.logging.Logger;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.DisplayName;import org.junit.jupiter.api.RepeatedTest;import org.junit.jupiter.api.RepetitionInfo;import org.junit.jupiter.api.TestInfo;class RepeatedTestsDemo {    private Logger logger = // ...    @BeforeEach    void beforeEach(TestInfo testInfo, RepetitionInfo repetitionInfo) {        int currentRepetition = repetitionInfo.getCurrentRepetition();        int totalRepetitions = repetitionInfo.getTotalRepetitions();        String methodName = testInfo.getTestMethod().get().getName();        logger.info(String.format(&quot;About to execute repetition %d of %d for %s&quot;, //            currentRepetition, totalRepetitions, methodName));    }    @RepeatedTest(10)    void repeatedTest() {        // ...    }    @RepeatedTest(5)    void repeatedTestWithRepetitionInfo(RepetitionInfo repetitionInfo) {        assertEquals(5, repetitionInfo.getTotalRepetitions());    }    @RepeatedTest(value = 1, name = &quot;{displayName} {currentRepetition}/{totalRepetitions}&quot;)    @DisplayName(&quot;Repeat!&quot;)    void customDisplayName(TestInfo testInfo) {        assertEquals(&quot;Repeat! 1/1&quot;, testInfo.getDisplayName());    }    @RepeatedTest(value = 1, name = RepeatedTest.LONG_DISPLAY_NAME)    @DisplayName(&quot;Details...&quot;)    void customDisplayNameWithLongPattern(TestInfo testInfo) {        assertEquals(&quot;Details... :: repetition 1 of 1&quot;, testInfo.getDisplayName());    }    @RepeatedTest(value = 5, name = &quot;Wiederholung {currentRepetition} von {totalRepetitions}&quot;)    void repeatedTestInGerman() {        // ...    }}</code></pre><h2 id="1-7-Parameterized-Tests"><a href="#1-7-Parameterized-Tests" class="headerlink" title="1.7 Parameterized Tests"></a>1.7 Parameterized Tests</h2><p>With parameterized, we could run a test multiple times with different arguments. And we must declare at least one source that will provide the arguments for each invocation and then consume the arguments in the test method. </p><pre><code>@ParameterizedTest@ValueSource(strings = { &quot;racecar&quot;, &quot;radar&quot;, &quot;able was I ere I saw elba&quot; })void palindromes(String candidate) {    assertTrue(StringUtils.isPalindrome(candidate));}</code></pre><h3 id="1-7-1-Annotations-used-in-parameterized-tests"><a href="#1-7-1-Annotations-used-in-parameterized-tests" class="headerlink" title="1.7.1 Annotations used in parameterized tests"></a>1.7.1 Annotations used in parameterized tests</h3><ul><li>@ValueSource<ul><li>specify a single array of literal values </li></ul></li><li>@NullSource<ul><li>provides a single null argument to the annotated @ParameterizedTest method.</li></ul></li><li>@EmptySource<ul><li>provides a single empty argument to the annotated @ParameterizedTest method for parameters of the following types: java.lang.String, java.util.List, java.util.Set, java.util.Map, primitive arrays (e.g., int[], char[][], etc.), object arrays (e.g.,String[], Integer[][], etc.).</li></ul></li><li>@NullAndEmptySource: <ul><li>a composed annotation that combines the functionality of @NullSource and @EmptySource.</li></ul></li></ul><pre><code>@ParameterizedTest@NullAndEmptySource@ValueSource(strings = { &quot; &quot;, &quot;   &quot;, &quot;\t&quot;, &quot;\n&quot; })void nullEmptyAndBlankStrings(String text) {    assertTrue(text == null || text.trim().isEmpty());}</code></pre><ul><li>@EnumSource<ul><li>provides a convenient way to use Enum constants. </li><li>also provides an optional names parameter that lets you specify which constants shall be used </li></ul></li></ul><pre><code>@ParameterizedTest@EnumSource(value = TimeUnit.class, names = { &quot;DAYS&quot;, &quot;HOURS&quot; })void testWithEnumSourceInclude(TimeUnit timeUnit) {    assertTrue(EnumSet.of(TimeUnit.DAYS, TimeUnit.HOURS).contains(timeUnit));}@ParameterizedTest@EnumSource(value = TimeUnit.class, mode = EXCLUDE, names = { &quot;DAYS&quot;, &quot;HOURS&quot; })void testWithEnumSourceExclude(TimeUnit timeUnit) {    assertFalse(EnumSet.of(TimeUnit.DAYS, TimeUnit.HOURS).contains(timeUnit));    assertTrue(timeUnit.name().length() &gt; 5);}</code></pre><ul><li>@MethodSource<ul><li>Allow you to refer to one or more factory methods of the test class or external classes </li><li>Each factory method must generate a stream of arguments</li></ul></li></ul><pre><code>@ParameterizedTest@MethodSource(&quot;stringProvider&quot;)void testWithExplicitLocalMethodSource(String argument) {    assertNotNull(argument);}static Stream&lt;String&gt; stringProvider() {    return Stream.of(&quot;apple&quot;, &quot;banana&quot;);}</code></pre><ul><li>@CsvSource </li><li>@CsvFileSource</li><li>@ArgumentsSource <ul><li>can be used to specify a custom resuable ArgumentsProvider </li><li>An implementation of ArgumentsProvider mush be declared as either a top-level class or as a static nested class. </li></ul></li></ul><pre><code>@ParameterizedTest@ArgumentsSource(MyArgumentsProvider.class)void testWithArgumentsSource(String argument) {    assertNotNull(argument);}public class MyArgumentsProvider implements ArgumentsProvider {    @Override    public Stream&lt;? extends Arguments&gt; provideArguments(ExtensionContext context) {        return Stream.of(&quot;apple&quot;, &quot;banana&quot;).map(Arguments::of);    }}</code></pre><h3 id="1-7-2-Lifecycle-and-Interoperability"><a href="#1-7-2-Lifecycle-and-Interoperability" class="headerlink" title="1.7.2 Lifecycle and Interoperability"></a>1.7.2 Lifecycle and Interoperability</h3><p>Each invocation of a parameterized test has the same lifecycle </p><h2 id="1-8-Test-Templates"><a href="#1-8-Test-Templates" class="headerlink" title="1.8 Test Templates"></a>1.8 Test Templates</h2><p>A @TestTemplate method is not a regular test case but rather a template for test cases. It is designed to be invoked multiple times depending on the number of invocation contexts returned by the registerd providers. </p><p>Thus, it must be used in conjunction with a registered TestTemplateInvocationContextProvider extension. Each invocation of a test template method behaves like the execution of a regular @Test method with full support for the same lifecycle callbacks and extensions.</p><h2 id="1-9-Dynamic-Tests"><a href="#1-9-Dynamic-Tests" class="headerlink" title="1.9 Dynamic Tests"></a>1.9 Dynamic Tests</h2><p> @Test describe methods that implement test cases. These test cases are static in the sense that they are fully specified at compile time, and their behavior cannot be changed by anything happening at runtime.</p><p> This new kind of test is a dynamic test which is generated at runtime by a factory method that is annotated with @TestFactory</p><p> In contrast to @Test methods, a @TestFactory method is not itself a test case but rather a factory for test cases. Thus, a dynamic test is the product of a factory. Technically speaking, a @TestFactory method must return a single DynamicNode or a Stream, Collection, Iterable, Iterator, or array of DynamicNode instances. Instantiable subclasses of DynamicNode are DynamicContainer and </p><p> DynamicContainer instances are composed of <strong>a display name</strong> and <strong>a list of dynamic child nodes</strong>, enabling the creation of arbitrarily nested hierarchies of dynamic nodes. DynamicTest instances will be executed lazily, enabling dynamic and even non-deterministic generation of test cases.</p><h3 id="1-9-1-Dynamic-test-lifecycle"><a href="#1-9-1-Dynamic-test-lifecycle" class="headerlink" title="1.9.1 Dynamic test lifecycle"></a>1.9.1 Dynamic test lifecycle</h3><p>The execution lifecycle of a dynamic test is quite different than it is for a standard @Test case. Specifically, there are <strong>no lifecycle callbacks for individual dynamic tests</strong>. This means that @BeforeEach and @AfterEach methods and their corresponding extension callbacks are** executed for the @TestFactory method** but not for each dynamic test. In other words, if you access fields from the test instance within a lambda expression for a dynamic test, those fields will not be reset by callback methods or extensions between the execution of individual dynamic tests generated by the same @TestFactory method.</p><h2 id="1-10-Parallel-Execution"><a href="#1-10-Parallel-Execution" class="headerlink" title="1.10 Parallel Execution"></a>1.10 Parallel Execution</h2><h3 id="1-10-1-Mode"><a href="#1-10-1-Mode" class="headerlink" title="1.10.1 Mode"></a>1.10.1 Mode</h3><p>Offers two mode: </p><ul><li>SAME_THREAD<ul><li>Force execution in the same thread used by the parent. For example, when used on a test method, the test method will be executed in the same thread as any @BeforeAll or @AfterAll methods of the containing test class. </li></ul></li><li>CONCURRENT<ul><li>Execute concurrently unless a resource lock forces execution in the same thread.</li></ul></li></ul><p>Alternatively, you can use the @Execution annotation to change the execution mode for the annotated element and its subelements (if any) which allows you to activate parallel execution for individual test classes, one by one.</p><h3 id="1-10-2-Synchronization"><a href="#1-10-2-Synchronization" class="headerlink" title="1.10.2 Synchronization"></a>1.10.2 Synchronization</h3><p>The @ResourceLock annotation allows you to declare that a test class or method uses a specific shared resource that requires synchronized access to ensure reliable test execution. </p><pre><code>@Execution(CONCURRENT)class SharedResourcesDemo {    private Properties backup;    @BeforeEach    void backup() {        backup = new Properties();        backup.putAll(System.getProperties());    }    @AfterEach    void restore() {        System.setProperties(backup);    }    @Test    @ResourceLock(value = SYSTEM_PROPERTIES, mode = READ)    void customPropertyIsNotSetByDefault() {        assertNull(System.getProperty(&quot;my.prop&quot;));    }    @Test    @ResourceLock(value = SYSTEM_PROPERTIES, mode = READ_WRITE)    void canSetCustomPropertyToApple() {        System.setProperty(&quot;my.prop&quot;, &quot;apple&quot;);        assertEquals(&quot;apple&quot;, System.getProperty(&quot;my.prop&quot;));    }    @Test    @ResourceLock(value = SYSTEM_PROPERTIES, mode = READ_WRITE)    void canSetCustomPropertyToBanana() {        System.setProperty(&quot;my.prop&quot;, &quot;banana&quot;);        assertEquals(&quot;banana&quot;, System.getProperty(&quot;my.prop&quot;));    }}</code></pre><h1 id="2-Extension-Model"><a href="#2-Extension-Model" class="headerlink" title="2. Extension Model"></a>2. Extension Model</h1><p>In contrast to Runner, TestRule and MethodRule extension points in JUnit4, the JUnit Jupiter extension model consists of a single, coherent concept – Extension API. </p><h2 id="2-1-Registering-Extensions"><a href="#2-1-Registering-Extensions" class="headerlink" title="2.1 Registering Extensions"></a>2.1 Registering Extensions</h2><p>Extensions can be registered declaraticely via @ExtendWith, programmatically via @RegisterExtension, or automatically via Java’s ServiceLoader mechanism. </p><h3 id="2-1-1-Declarative-Extension-Registration"><a href="#2-1-1-Declarative-Extension-Registration" class="headerlink" title="2.1.1 Declarative Extension Registration"></a>2.1.1 Declarative Extension Registration</h3><pre><code>@ExtendWith(RandomParametersExtension.class)@Testvoid test(@Random int i) {    // ...}</code></pre><p>Notice: we could annotate it in class level to register an extension for all tests in this specific class. </p><p>We can also register multiple extensions: </p><pre><code>@ExtendWith({ DatabaseExtension.class, WebServerExtension.class })class MyFirstTests {    // ...}</code></pre><h3 id="2-1-2-Programmatic-Extension-Registration"><a href="#2-1-2-Programmatic-Extension-Registration" class="headerlink" title="2.1.2 Programmatic Extension Registration"></a>2.1.2 Programmatic Extension Registration</h3><p>Register extensions programmatically by annotating fields in test classes with @RegisterExtension </p><p>When an extension is registered declaratively via @ExtendWith, it can typically only be configured via annotations. In contrast, when an extension is registered via @RegisterExtension, it can be <strong>configured programmatically</strong> - for example, in order to pass arguments to the extension’s constructor, a static factory method, or a builder API.</p><p>If a @RegisterExtension field is static, the extension will be registered after extensions that are registered at the class level via @ExtendWith. Such static extensions are not limited in which extension APIs they can implement. Extensions registered via static fields may therefore implement class-level and instance-level extension APIs such as BeforeAllCallback, AfterAllCallback, and TestInstancePostProcessor as well as method-level extension APIs such as BeforeEachCallback, etc.</p><pre><code>class WebServerDemo {    @RegisterExtension    static WebServerExtension server = WebServerExtension.builder()        .enableSecurity(false)        .build();    @Test    void getProductList() {        WebClient webClient = new WebClient();        String serverUrl = server.getServerUrl();        // Use WebClient to connect to web server using serverUrl and verify response        assertEquals(200, webClient.get(serverUrl + &quot;/products&quot;).getResponseStatus());    }}</code></pre><ul><li><p>For a non-static field with @RegisterExtension, it will be registered after the test class has been instantiated </p></li><li><p>By default, an instance extension will be registered after extensions that are registered at the method level via @ExtendWith </p></li><li><p>If the class is configured with @TestInstance(Lifecycle.PER_CLASS) semantics, an instance extension will be registered at the method level via @ExtendWith.</p><p>  class DocumentationDemo {</p><pre><code>  static Path lookUpDocsDir() {      // return path to docs dir  }  // The configured DocumentationExtension will be automatically registered as an extension at the method level.  @RegisterExtension  DocumentationExtension docs = DocumentationExtension.forPath(lookUpDocsDir());  @Test  void generateDocumentation() {      // use this.docs ...  }</code></pre><p>  }</p></li></ul><h3 id="2-1-3-Automatic-Extension-Registration"><a href="#2-1-3-Automatic-Extension-Registration" class="headerlink" title="2.1.3 Automatic Extension Registration"></a>2.1.3 Automatic Extension Registration</h3><p>JUnit Jupiter also supports global extension registration via Java’s java.util.ServiceLoader mechanism, allowing third-party extensions to be *<em>auto-detected and automatically registered *</em>based on what is available in the classpath.</p><h2 id="2-2-Conditional-Test-Execution"><a href="#2-2-Conditional-Test-Execution" class="headerlink" title="2.2 Conditional Test Execution"></a>2.2 Conditional Test Execution</h2><p>Used to define conditional test execution. </p><p>An ExecutionCondition is evaluated for each container (e.g., a test class) to determine if all the tests it contains should be executed based on the supplied ExtensionContext</p><h2 id="2-3-Execution-Order-of-User-Code-and-Extensions"><a href="#2-3-Execution-Order-of-User-Code-and-Extensions" class="headerlink" title="2.3 Execution Order of User Code and Extensions"></a>2.3 Execution Order of User Code and Extensions</h2><p>When executing a test class that contains one or more test methods, a number of extension callbacks are called in addition to the user-supplied test and lifecycle methods.</p><p><img src="https://i.loli.net/2020/02/09/9OkZPCtrFL8RfYM.png" alt="fig1.png"></p><p>JUnit Jupiter always guarantees wrapping behavior for multiple registered extensions that implement lifecycle callbacks such as BeforeAllCallback, AfterAllCallback, BeforeEachCallback, AfterEachCallback, BeforeTestExecutionCallback, and AfterTestExecutionCallback.</p><p>That means that, given two extensions Extension1 and Extension2 with Extension1 registered before Extension2, <strong>any “before” callbacks implemented by Extension1 are guaranteed to execute before any “before” callbacks implemented by Extension2</strong>.</p><pre><code>import static example.callbacks.Logger.afterAllMethod;import static example.callbacks.Logger.afterEachMethod;import static example.callbacks.Logger.beforeAllMethod;import static example.callbacks.Logger.beforeEachMethod;import org.junit.jupiter.api.AfterAll;import org.junit.jupiter.api.AfterEach;import org.junit.jupiter.api.BeforeAll;import org.junit.jupiter.api.BeforeEach;/** * Abstract base class for tests that use the database. */abstract class AbstractDatabaseTests {    @BeforeAll    static void createDatabase() {        beforeAllMethod(AbstractDatabaseTests.class.getSimpleName() + &quot;.createDatabase()&quot;);    }    @BeforeEach    void connectToDatabase() {        beforeEachMethod(AbstractDatabaseTests.class.getSimpleName() + &quot;.connectToDatabase()&quot;);    }    @AfterEach    void disconnectFromDatabase() {        afterEachMethod(AbstractDatabaseTests.class.getSimpleName() + &quot;.disconnectFromDatabase()&quot;);    }    @AfterAll    static void destroyDatabase() {        afterAllMethod(AbstractDatabaseTests.class.getSimpleName() + &quot;.destroyDatabase()&quot;);    }}</code></pre><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://junit.org/junit5/docs/current/user-guide/" target="_blank" rel="noopener">https://junit.org/junit5/docs/current/user-guide/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Writing-Tests&quot;&gt;&lt;a href=&quot;#1-Writing-Tests&quot; class=&quot;headerlink&quot; title=&quot;1. Writing Tests&quot;&gt;&lt;/a&gt;1. Writing Tests&lt;/h1&gt;&lt;p&gt;JUnit5 = Junit P
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
      <category term="Unit Test" scheme="https://www.llchen60.com/tags/Unit-Test/"/>
    
  </entry>
  
  <entry>
    <title>Java日志管理 - slf4j + log4j - 探究Distribute system 的threadContext复用的问题</title>
    <link href="https://www.llchen60.com/Java%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-slf4j-log4j-%E6%8E%A2%E7%A9%B6Distribute-system-%E7%9A%84threadContext%E5%A4%8D%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://www.llchen60.com/Java%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-slf4j-log4j-%E6%8E%A2%E7%A9%B6Distribute-system-%E7%9A%84threadContext%E5%A4%8D%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2020-02-07T03:48:00.000Z</published>
    <updated>2020-02-07T03:48:21.842Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-常用日志系统介绍"><a href="#1-常用日志系统介绍" class="headerlink" title="1. 常用日志系统介绍"></a>1. 常用日志系统介绍</h1><ul><li>日志门面<ul><li>jcl - jakarta common logging  <ul><li>日志接口，支持运行时动态加载日志组件的实现 </li></ul></li><li>slf4j<ul><li>日志接口</li><li>在log层和代码层之间起到门面作用，对于用户来说只要使用SLF4J的接口，就可以隐藏日志的具体实现，其提供的核心API是一些接口和一个LoggerFactory的工厂类，用户只需要按照其提供的日志接口进行使用，最终日志的格式，记录级别，输出方式等都可以通过具体日志系统的配置来实现</li></ul></li></ul></li><li>日志框架<ul><li>jul - java.util.logging </li><li>log4j</li><li>log4j2</li><li>logback<ul><li>slf4j的实现 </li><li>是log4j的升级版</li></ul></li></ul></li></ul><h1 id="2-日志级别"><a href="#2-日志级别" class="headerlink" title="2. 日志级别"></a>2. 日志级别</h1><ul><li>severe</li><li>warning </li><li>info</li><li>config</li><li>fine </li><li>finer </li></ul><h1 id="3-常见使用方式"><a href="#3-常见使用方式" class="headerlink" title="3. 常见使用方式"></a>3. 常见使用方式</h1><p>一般工程上会选择一个日志门面，加日志框架，常用的门面基本上还是SLF4J比较多，框架的选择很多，主要是需要注意工程上分布式系统的多线程方面的支持。</p><h1 id="4-Log4j2-ThreadContext复用的问题"><a href="#4-Log4j2-ThreadContext复用的问题" class="headerlink" title="4. Log4j2 ThreadContext复用的问题"></a>4. Log4j2 ThreadContext复用的问题</h1><p>ThreadContext出现的背景主要是因为现代系统基本上都需要都是和多个client打交道，在一个典型的多线程的应用系统当中，不同的线程就需要和不同的client打交道.为了能够分辨出同一个client发出的不同log请求，我们就需要给每个请求一个id，来做标记。</p><p>Log4j2使用Thread Context Map和Thread Context Stack来进行标记。常用Map，因为键值对更容易进行添加和处理</p><p>使用Stack: </p><pre><code>ThreadContext.push(UUID.randomUUID().toString()); // Add the fishtag;logger.debug(&quot;Message 1&quot;);...logger.debug(&quot;Message 2&quot;);..ThreadContext.pop();</code></pre><p>使用Map: </p><pre><code>ThreadContext.put(&quot;id&quot;, UUID.randomUUID().toString()); // Add the fishtag;ThreadContext.put(&quot;ipAddress&quot;, request.getRemoteAddr());ThreadContext.put(&quot;loginId&quot;, session.getAttribute(&quot;loginId&quot;));ThreadContext.put(&quot;hostName&quot;, request.getServerName());.logger.debug(&quot;Message 1&quot;);..logger.debug(&quot;Message 2&quot;);..ThreadContext.clear();</code></pre><p>问题来了，如果我们使用Executor.execute(new CachedThreadPool())的话，因为线程的复用，（所有使用完的线程会归还到线程池当中），那么ThreadContext里面的东西必须要进行手动清除，才能防止原先记录的这个线程的东西被复用掉。比如一般会记录的[Client][API]此类信息。</p><p>这个时候需要使用getContext()和cloneStack()来使得子线程获得父线程的信息。</p><pre><code>ThreadContext.clearAll();ThreadContext.putAll(preSavedThreadContextMap);ThreadContext.setStack(preSavedThreadContextStack);</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-常用日志系统介绍&quot;&gt;&lt;a href=&quot;#1-常用日志系统介绍&quot; class=&quot;headerlink&quot; title=&quot;1. 常用日志系统介绍&quot;&gt;&lt;/a&gt;1. 常用日志系统介绍&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;日志门面&lt;ul&gt;
&lt;li&gt;jcl - jakarta com
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
      <category term="Log" scheme="https://www.llchen60.com/tags/Log/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识</title>
    <link href="https://www.llchen60.com/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://www.llchen60.com/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2020-02-06T03:05:08.000Z</published>
    <updated>2020-02-06T03:05:28.755Z</updated>
    
    <content type="html"><![CDATA[<p>给自己搭个脚手架，建个基础知识的小字典，查遗用(持续更新)：</p><h1 id="1-Java平台"><a href="#1-Java平台" class="headerlink" title="1.Java平台"></a>1.Java平台</h1><h2 id="1-1-Java解释执行？"><a href="#1-1-Java解释执行？" class="headerlink" title="1.1 Java解释执行？"></a>1.1 Java解释执行？</h2><p>Java源代码，通过javac编译成字节码，运行时通过JVM内嵌的解释器将字节码转换为机器码。但是大部分JVM都提供了JIT(just in time),即动态编译器，它能够在运行时将热点代码编成机器码，这种情况下热点代码就属于编译执行。</p><h2 id="1-2-Java类加载机制"><a href="#1-2-Java类加载机制" class="headerlink" title="1.2 Java类加载机制"></a>1.2 Java类加载机制</h2><p>类加载大致过程：加载-验证-链接-初始化</p><h2 id="1-3-Java反射机制"><a href="#1-3-Java反射机制" class="headerlink" title="1.3 Java反射机制"></a>1.3 Java反射机制</h2><h2 id="1-4-面向对象编程SOLID原则"><a href="#1-4-面向对象编程SOLID原则" class="headerlink" title="1.4 面向对象编程SOLID原则"></a>1.4 面向对象编程SOLID原则</h2><ol><li>Single Responsibility </li><li>Open for extension, close for modification </li><li>Liskov Substitution </li><li>Interface Segragation </li><li>Dependency Injection </li></ol><p>E.G</p><pre><code>public class VIPCenter {  void serviceVIP(T extend User user&gt;) {     if (user instanceof SlumDogVIP) {        // 穷 X VIP，活动抢的那种        // do somthing      } else if(user instanceof RealVIP) {        // do somthing      }      // ...  }</code></pre><p>增加其扩展性：</p><pre><code>public class VIPCenter {   private Map&lt;User.TYPE, ServiceProvider&gt; providers;   void serviceVIP(T extend User user） {      providers.get(user.getType()).service(user);   } } interface ServiceProvider{   void service(T extend User user) ; } class SlumDogVIPServiceProvider implements ServiceProvider{   void service(T extend User user){     // do somthing   } } class RealVIPServiceProvider implements ServiceProvider{   void service(T extend User user) {     // do something   } } </code></pre><p>在另一篇博文里，有对SOLID的详细描述，详情见<a href="https://www.llchen60.com/2018/11/12/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/">面向对象设计原则</a></p><h2 id="1-5-类加载过程"><a href="#1-5-类加载过程" class="headerlink" title="1.5 类加载过程"></a>1.5 类加载过程</h2><p>load-link-initialize</p><ul><li>load </li></ul><p>首先是加载阶段（Loading），它是 Java 将字节码数据从不同的数据源读取到 JVM 中，并映射为 JVM 认可的数据结构（Class 对象），这里的数据源可能是各种各样的形态，如 jar 文件、class 文件，甚至是网络数据源等；如果输入数据不是 ClassFile 的结构，则会抛出 ClassFormatError。</p><ul><li>link </li></ul><p>第二阶段是链接（Linking），这是核心的步骤，简单说是把原始的类定义信息平滑地转化入 JVM 运行的过程中。这里可进一步细分为三个步骤：</p><ol><li>验证， JVM需要验证字节信息是符合Java虚拟机规范的，否则会被认为是Verify Error</li><li>准备 创建类或接口中的静态变量，并初始化静态变量的初始值，侧重点在分配所需要的内存空间，不会去执行更进一步的JVM指令</li><li>解析。将常量池中的符号引用替换为直接引用。</li></ol><p>再来谈谈双亲委派模型，简单说就是当类加载器（Class-Loader）试图加载某个类型的时候，除非父加载器找不到相应类型，否则尽量将这个任务代理给当前加载器的父加载器去做。使用委派模型的目的是避免重复加载 Java 类型。</p><h1 id="2-Java语言特性"><a href="#2-Java语言特性" class="headerlink" title="2. Java语言特性"></a>2. Java语言特性</h1><h2 id="2-1-泛型"><a href="#2-1-泛型" class="headerlink" title="2.1 泛型"></a>2.1 泛型</h2><h2 id="2-2-Lambda"><a href="#2-2-Lambda" class="headerlink" title="2.2 Lambda"></a>2.2 Lambda</h2><h2 id="2-3-Exception-Error"><a href="#2-3-Exception-Error" class="headerlink" title="2.3 Exception/ Error"></a>2.3 Exception/ Error</h2><h3 id="2-3-1-定义"><a href="#2-3-1-定义" class="headerlink" title="2.3.1 定义"></a>2.3.1 定义</h3><blockquote><p>Exception: 程序正常运行中可以预料到的意外情况，可能并且应该被捕获，进行相应处理</p></blockquote><blockquote><p>Error: 在正常情况下，不应该出现的情况。绝大部分的Error都会导致程序比如JVM自身处于非正常的、不可恢复的状态</p></blockquote><p>Throwable分类图！！！！！</p><p>异常之所以很强大，在调试方面，在于其回答了以下三个问题：</p><ol><li>什么出了错？    异常类型</li><li>在哪出了错？    异常堆栈跟踪位置</li><li>为什么出错？    异常信息</li></ol><h3 id="2-3-2-Tips"><a href="#2-3-2-Tips" class="headerlink" title="2.3.2 Tips"></a>2.3.2 Tips</h3><ol><li>不捕获通用异常，写自己的Exception，方便Debug</li><li>不要生吞异常，不知道怎么处理了可以继续向外层抛出</li><li>提早抛出，延迟捕获！ </li><li>把异常处理的责任往调用链的上游传递的方法就是在方法的throws子句声明异常。<a href="https://www.zhihu.com/question/28254987" target="_blank" rel="noopener">(如何优雅的处理异常？)</a></li></ol><h3 id="2-3-3-性能角度分析"><a href="#2-3-3-性能角度分析" class="headerlink" title="2.3.3 性能角度分析"></a>2.3.3 性能角度分析</h3><ol><li>try-catch代码段会产生额外的性能开销，往往会影响JVM对代码进行优化，因此应该仅捕获有必要的代码，尽量不要使用一个大的try包住整段代码</li><li>Java每实例化一个Exception，都会对<strong>当时的栈进行快照</strong>，这是个比较重的操作。</li></ol><h2 id="2-4-引用"><a href="#2-4-引用" class="headerlink" title="2.4 引用"></a>2.4 引用</h2><p>Java中除了原始数据类型的变量其他所有都是引用类型，指向不同的对象。理解引用，以理解Java对象的生命周期和JVM内部的相关机制。</p><p>不同的引用类型，主要体现在对象的不同的可达性状态和对垃圾收集的影响。</p><h3 id="2-4-1-强引用"><a href="#2-4-1-强引用" class="headerlink" title="2.4.1 强引用"></a>2.4.1 强引用</h3><p>Strong Reference, 即普通对象引用。只要还有强引用指向一个对象，那么垃圾收集器就不会碰。</p><h3 id="2-4-2-弱引用"><a href="#2-4-2-弱引用" class="headerlink" title="2.4.2 弱引用"></a>2.4.2 弱引用</h3><p>不能使对象豁免垃圾收集，提供一种访问在弱引用装天下对象的途径</p><p>使用weak reference类来实现的</p><h3 id="2-4-3-软引用"><a href="#2-4-3-软引用" class="headerlink" title="2.4.3 软引用"></a>2.4.3 软引用</h3><p>Soft Reference. 相对强引用弱化一些的引用，可以让对象豁免一些垃圾收集，只有当JVM认为内存不足时，才会去试图回收软引用指向的对象。</p><p>使用soft reference类实现的</p><h3 id="2-4-4-幻象引用"><a href="#2-4-4-幻象引用" class="headerlink" title="2.4.4 幻象引用"></a>2.4.4 幻象引用</h3><p>虚引用，提供一种确保对象被finalize以后，做某些事情的机制。</p><p>通过PhantomReference类来实现的</p><h2 id="2-5-String-vs-StringBuffer-vs-StringBuilder"><a href="#2-5-String-vs-StringBuffer-vs-StringBuilder" class="headerlink" title="2.5 String vs. StringBuffer vs. StringBuilder"></a>2.5 String vs. StringBuffer vs. StringBuilder</h2><ul><li><p>字符串缓存，放在对重，后来放在metaSpace当中，可以通过JVM调参来修改大小</p><p>  -XX:+PrintStringTableStatistics<br>  -XX:StringTableSize=N</p></li><li><p>String 压缩</p></li></ul><p>从使用Char到使用Byte + 标志编码位。紧凑字符串带来了很大优势，更小的内存占用，更快的操作速度。</p><h3 id="2-5-1-String"><a href="#2-5-1-String" class="headerlink" title="2.5.1 String"></a>2.5.1 String</h3><p>Immutable类，声明为final class,所有属性也都是final的。</p><p>java引入了字符创常量池，创建一个字符串，首先看常量池里面有没有值相同的字符串，如果有直接到池里拿对应的对象引用，如果没有就创建新的，并放到池里去。</p><pre><code>String str1 = &quot;123&quot;;// 放入常量池String str2 = new String(&quot;123&quot;); // 不放入常量池</code></pre><h3 id="2-5-2-StringBuffer"><a href="#2-5-2-StringBuffer" class="headerlink" title="2.5.2 StringBuffer"></a>2.5.2 StringBuffer</h3><p>为了解决String拼接产生太多中间对象的问题，本质上是一个线程安全的可修改字符序列。保证了线程安全，但是也带来了额外的性能开销。</p><p>线程安全是通过在各种修改数据的方法上加<code>synchronized</code>关键字来实现的。</p><p>底层使用char/ byte数组，继承了AbstractStringBuilder</p><h3 id="2-5-3-StringBuilder"><a href="#2-5-3-StringBuilder" class="headerlink" title="2.5.3 StringBuilder"></a>2.5.3 StringBuilder</h3><p>与StringBuffer类似，去掉了线程安全的部分，有效减少了开销</p><p>底层使用char/ byte数组，继承了AbstractStringBuilder。</p><h2 id="2-6-Abstract-and-Interface"><a href="#2-6-Abstract-and-Interface" class="headerlink" title="2.6 Abstract and Interface"></a>2.6 Abstract and Interface</h2><h3 id="2-6-1-接口"><a href="#2-6-1-接口" class="headerlink" title="2.6.1 接口"></a>2.6.1 接口</h3><p>接口是对行为的抽象，是抽象方法的集合，利用接口可以达到API定义和实现分离的目的。接口不能实例化，不能包含任何非常量成员，任何field都是隐含着public static final的意义的。同时，没有非静态方法的实现。要么是静态方法，要么是抽象方法。</p><p>接口可以多继承！类只可以单继承</p><h3 id="2-6-2-抽象类"><a href="#2-6-2-抽象类" class="headerlink" title="2.6.2 抽象类"></a>2.6.2 抽象类</h3><p>不能实例化的类，用abstract关键字来修饰，其目的主要是代码重用。抽象类大多用于抽取相关Java类的公用方法实现或者是共同成员变量，然后通过继承达到代码复用的目的。Java标准库中，比如Collection框架，很多通用部分就抽象成了抽象类来使用。</p><h1 id="3-Java基础类库"><a href="#3-Java基础类库" class="headerlink" title="3. Java基础类库"></a>3. Java基础类库</h1><h2 id="3-1-集合"><a href="#3-1-集合" class="headerlink" title="3.1 集合"></a>3.1 集合</h2><h3 id="3-1-1-Vector-vs-ArrayList-vs-LinkedList"><a href="#3-1-1-Vector-vs-ArrayList-vs-LinkedList" class="headerlink" title="3.1.1 Vector vs. ArrayList vs.LinkedList"></a>3.1.1 Vector vs. ArrayList vs.LinkedList</h3><p>三者都是集合框架中的List，根据位置有定位，添加或者删除的操作。Vector是Java早期提供的线程安全的动态数组。ArrayList动态数组，不是线程安全的，ArrayList扩容时会增加50%。LinkedList双向链表，不是线程安全的。</p><p>Vector, arrayList作为动态数组，非常适合随机访问的场合，插入删除元素性能会比较差，因为要移动后续的所有元素。LinkedList进行节点插入，删除会很高效，但是随机访问性能很差。</p><h3 id="3-1-2-Hashtable-vs-HashMap-vs-TreeMap"><a href="#3-1-2-Hashtable-vs-HashMap-vs-TreeMap" class="headerlink" title="3.1.2 Hashtable vs. HashMap vs. TreeMap"></a>3.1.2 Hashtable vs. HashMap vs. TreeMap</h3><p>Hashtable是同步的，性能开销大</p><p>HashMap 非同步的，性能开销小，put，get操作能达到常数时间的性能</p><p>TreeMap是基于红黑树的一种提供顺序访问的Map，和Hashmap不同，它的get\put\remove之类的操作都是O(log(n))的时间复杂度。</p><h2 id="3-2-IO-NIO"><a href="#3-2-IO-NIO" class="headerlink" title="3.2 IO/NIO"></a>3.2 IO/NIO</h2><h3 id="3-2-1-IO"><a href="#3-2-1-IO" class="headerlink" title="3.2.1 IO"></a>3.2.1 IO</h3><p>java.io包，基于流模型实现，提供了我们最熟知的一些IO功能，比如File抽象、输入输出流等。交互方式是同步、阻塞的方式。也就是说，在读取输入流或者写入输出流时，在读写动作之前，线程会一直阻塞在那里，他们之间的调用是可靠的线性顺序。</p><h3 id="3-2-2-NIO"><a href="#3-2-2-NIO" class="headerlink" title="3.2.2 NIO"></a>3.2.2 NIO</h3><p>NIO框架，提供Channel, selector, Buffer等新的抽象，可以构建<strong>多路复用，同步非阻塞IO程序</strong>，同时提供了更接近操作系统底层的高性能数据操作方式。</p><ul><li>Channel </li><li>Buffer</li><li>Selector </li></ul><h2 id="3-3-网络"><a href="#3-3-网络" class="headerlink" title="3.3 网络"></a>3.3 网络</h2><h2 id="3-4-并发"><a href="#3-4-并发" class="headerlink" title="3.4 并发"></a>3.4 并发</h2><h3 id="3-4-1-synchronized"><a href="#3-4-1-synchronized" class="headerlink" title="3.4.1 synchronized"></a>3.4.1 synchronized</h3><ul><li>概念</li></ul><p>是java内部的同步机制，也称为intrinsic locking, 提供了互斥的语义和可见性，当一个线程已经获取当前锁时，其他试图获取的线程只能等待或者阻塞在那里了。</p><p>在 Java 5 以前，synchronized 是仅有的同步手段，在代码中， synchronized 可以用来修饰方法，也可以使用在特定的代码块儿上，本质上** synchronized 方法等同于把方法全部语句用 synchronized 块包起来**。</p><ul><li>底层实现</li></ul><p>synchronized代码块是由一对<code>monitorenter/ moniterexit</code>指令来实现的，Monitor对象是同步的基本实现单元。</p><p>在 Java 6 之前，Monitor 的实现完全是依靠操作系统内部的互斥锁，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作。现代的（Oracle）JDK 中，JVM 对此进行了大刀阔斧地改进，提供了三种不同的 Monitor 实现，也就是常说的三种不同的锁：偏斜锁（Biased Locking）、轻量级锁和重量级锁，大大改进了其性能。</p><p>所谓锁的升级、降级，就是 JVM 优化 synchronized 运行的机制，当 JVM 检测到不同的竞争状况时，会自动切换到适合的锁实现，这种切换就是锁的升级、降级。</p><p>没有竞争的时候，默认使用偏斜锁。JVM会利用CAS操作，在对象头上的Mark Word部分设置线程ID，以表示这个对象偏向于当前线程，所以并不涉及真正的互斥锁。如果有另外的线程试图锁定某个已经被偏斜过的对象，JVM就需要撤销偏斜锁，并切换到轻量锁的实现。</p><h3 id="3-4-2-ReeantrantLock"><a href="#3-4-2-ReeantrantLock" class="headerlink" title="3.4.2 ReeantrantLock"></a>3.4.2 ReeantrantLock</h3><ul><li>ReentrantLock 再入锁</li></ul><p>再入锁通过代码直接调用lock()方法来获取，是表示当一个线程试图获取一个它已经获取的锁时，这个获取动作就自动成功。这是多锁获取粒度上的一个区分，锁的持有是以线程为单位而不是基于调用次数了，java锁实现强调再入性是为了和pthread的行为进行区分。</p><p>再入锁可以设置公平性：</p><pre><code>ReentrantLock fairLock = new ReetrantLock(true);</code></pre><p>这里所谓的公平性是指在竞争场景中，当公平性为真时，会倾向于将锁赋予等待时间最久的线程。公平性是减少线程“饥饿”（个别线程长期等待锁，但始终无法获取）情况发生的一个办法。</p><p>使用synchronized我们无法进行公平性的选择，其永远是不公平的，这也是主流操作系统线程调度的选择。通用场景中，公平性未必有想象中的那么重要，Java 默认的调度策略很少会导致 “饥饿”发生。与此同时，若要保证公平性则会引入额外开销，自然会导致一定的吞吐量下降。</p><h3 id="3-4-3-死锁"><a href="#3-4-3-死锁" class="headerlink" title="3.4.3 死锁"></a>3.4.3 死锁</h3><h2 id="3-5-安全"><a href="#3-5-安全" class="headerlink" title="3.5 安全"></a>3.5 安全</h2><h1 id="4-JVM基础概念和机制"><a href="#4-JVM基础概念和机制" class="headerlink" title="4. JVM基础概念和机制"></a>4. JVM基础概念和机制</h1><h2 id="4-1-类加载机制"><a href="#4-1-类加载机制" class="headerlink" title="4.1 类加载机制"></a>4.1 类加载机制</h2><h2 id="4-2-常见的垃圾收集器"><a href="#4-2-常见的垃圾收集器" class="headerlink" title="4.2 常见的垃圾收集器"></a>4.2 常见的垃圾收集器</h2><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://www.zhihu.com/question/28254987" target="_blank" rel="noopener">如何优雅的处理异常？</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给自己搭个脚手架，建个基础知识的小字典，查遗用(持续更新)：&lt;/p&gt;
&lt;h1 id=&quot;1-Java平台&quot;&gt;&lt;a href=&quot;#1-Java平台&quot; class=&quot;headerlink&quot; title=&quot;1.Java平台&quot;&gt;&lt;/a&gt;1.Java平台&lt;/h1&gt;&lt;h2 id=&quot;1-1
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Javadoc tutorial</title>
    <link href="https://www.llchen60.com/Javadoc-tutorial/"/>
    <id>https://www.llchen60.com/Javadoc-tutorial/</id>
    <published>2020-02-06T03:04:12.000Z</published>
    <updated>2020-02-06T03:04:33.985Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-What-is-javadoc"><a href="#1-What-is-javadoc" class="headerlink" title="1. What is javadoc"></a>1. What is javadoc</h1><p>A tool comes with JDK and used for generating Java code documentation in <strong>HTML format from Java source code</strong>, which requires documentation in a predefined format </p><h1 id="2-Javadoc-tags"><a href="#2-Javadoc-tags" class="headerlink" title="2. Javadoc tags"></a>2. Javadoc tags</h1><ul><li>@author</li><li>{@code}<ul><li>Displays text in code font without interpreting the text as HTML markup or nested javadoc tags.</li></ul></li><li>{@docRoot}<ul><li>Represents the relative path to the generated document’s root directory from any generated page.</li></ul></li><li>@deprecated</li><li>@exception<ul><li>Adds a Throws subheading to the generated documentation, with the classname and description text.</li></ul></li><li>{@inheritDoc}<ul><li>Inherits a comment from the nearest inheritable class or implementable interface.</li></ul></li><li>{@link}<ul><li>Inserts an in-line link with the visible text label that points to the documentation for the specified package, class, or member name of a referenced class. </li></ul></li><li>@param</li><li>@return</li><li>@see</li><li>@serial</li><li>@serialData <ul><li>Documents the data written by the writeObject( ) or writeExternal( ) methods.</li></ul></li><li>@serialField<ul><li>Documents an ObjectStreamField component.</li></ul></li><li>@since <ul><li>Adds a since heading with the specified since text to the generated documentation</li></ul></li><li>@throws </li><li>{@value}<ul><li>When {@value} is used in the doc comment of a static field, it displays the value of that constant. </li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-What-is-javadoc&quot;&gt;&lt;a href=&quot;#1-What-is-javadoc&quot; class=&quot;headerlink&quot; title=&quot;1. What is javadoc&quot;&gt;&lt;/a&gt;1. What is javadoc&lt;/h1&gt;&lt;p&gt;A tool c
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java 继承与组合</title>
    <link href="https://www.llchen60.com/Java-%E7%BB%A7%E6%89%BF%E4%B8%8E%E7%BB%84%E5%90%88/"/>
    <id>https://www.llchen60.com/Java-%E7%BB%A7%E6%89%BF%E4%B8%8E%E7%BB%84%E5%90%88/</id>
    <published>2020-02-06T03:03:28.000Z</published>
    <updated>2020-02-06T03:03:53.281Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-什么是组合？"><a href="#1-什么是组合？" class="headerlink" title="1. 什么是组合？"></a>1. 什么是组合？</h1><p>组合将类定义为各个部分的集合</p><pre><code>public class MerchantListHelper {    // TODO     void addToDDB (ListEntry entry) {    }    void removeFromDDB(DDBRecord record) {    }    List&lt;ListEntry&gt; getFromDDB() {    }}public class MerchantBlacklistBizLogic {    private MerchantListHelper merchantListHelper;    merchantListHelper.addToDDB(blabla..);    merchantListHelper.removeFromDDB(blabla..)}</code></pre><h1 id="2-什么是继承？"><a href="#2-什么是继承？" class="headerlink" title="2. 什么是继承？"></a>2. 什么是继承？</h1><p>将父类和子类通过集成关系紧密联系在一起 （紧耦合）。但与之相对的是继承会允许再利用类的方法以及其他的属性，会很便捷。</p><p>使用super()方法来直接访问父类的方法，构造器，属性等。</p><pre><code>public Abstract class MerchantListHelper {    // TODO     abstract void addToDDB (ListEntry entry);    abstract void removeFromDDB(DDBRecord record);    abstract List&lt;ListEntry&gt; getFromDDB();}public class MerchantBlacklistBizLogic {    private MerchantListHelper merchantListHelper;    @Override    void addToDDB(ListEntry entry) {        // TODO    }    @Override    void removeFromDDB(DDBRecord record) {        // TODO    }    ...}</code></pre><h1 id="3-Use-cases"><a href="#3-Use-cases" class="headerlink" title="3. Use cases"></a>3. Use cases</h1><p>组合和继承都可以将子对象放到新的类当中，组合一般是当你想要在这个新类当中使用一个已经存在的类的特征的时候。这意味着，通过这种方式你可以嵌入一个对象，并将其放在新的类当中。 继承表示的是一种is-a的关系，组合表达的含有某种功能。</p><p>如何判断是否需要继承或者组合 -&gt; 看是否需要从你的新类到基本类进行向上转型。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="http://thedeanbear.com/2012/09/24/composition_vs_inheritance/" target="_blank" rel="noopener">http://thedeanbear.com/2012/09/24/composition_vs_inheritance/</a></li><li>Java Challengers #7: Debugging Java inheritance </li><li>javaworld.com/article/3409071/java-challenger-7-debugging-java-inheritance.html</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-什么是组合？&quot;&gt;&lt;a href=&quot;#1-什么是组合？&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是组合？&quot;&gt;&lt;/a&gt;1. 什么是组合？&lt;/h1&gt;&lt;p&gt;组合将类定义为各个部分的集合&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class M
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
      <category term="Composition" scheme="https://www.llchen60.com/tags/Composition/"/>
    
  </entry>
  
  <entry>
    <title>Java 反射机制</title>
    <link href="https://www.llchen60.com/Java-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
    <id>https://www.llchen60.com/Java-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</id>
    <published>2020-02-06T03:02:35.000Z</published>
    <updated>2020-02-06T03:02:58.113Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h1><p>Java反射机制是在运行时用来判定或者修改方法，类，接口的行为的API。</p><ul><li><p>反射可以告诉我们类和对象之间的信息，以及我们可以用类的哪些方法来使用这个对象</p></li><li><p>通过反射，我们就可以在运行的时候赋予类一个新的对象</p></li></ul><h1 id="2-使用范例"><a href="#2-使用范例" class="headerlink" title="2. 使用范例"></a>2. 使用范例</h1><p>反射可以用来获取关于类，构造器和方法的信息：</p><ul><li><p>class: getClass()方法可以用来获取对象属于的类的名字</p></li><li><p>Constructors: getConstructor()可以用来获取对象属于的类的public的构造器</p></li><li><p>getMethods() 可以用来获取对象属于的类的public的方法</p><p>  // A simple Java program to demonstrate the use of reflection<br>  import java.lang.reflect.Method;<br>  import java.lang.reflect.Field;<br>  import java.lang.reflect.Constructor; </p><p>  // class whose object is to be created<br>  class Test<br>  { </p><pre><code>  // creating a private field   private String s;   // creating a public constructor   public Test() { s = &quot;GeeksforGeeks&quot;; }   // Creating a public method with no arguments   public void method1() {       System.out.println(&quot;The string is &quot; + s);   }   // Creating a public method with int as argument   public void method2(int n) {       System.out.println(&quot;The number is &quot; + n);   }   // creating a private method   private void method3() {       System.out.println(&quot;Private method invoked&quot;);   } </code></pre><p>  } </p><p>  class Demo<br>  { </p><pre><code>  public static void main(String args[]) throws Exception   {       // Creating object whose property is to be checked       Test obj = new Test();           // 构建类的对象      // getclass method       Class cls = obj.getClass();       System.out.println(&quot;The name of class is &quot; +                           cls.getName());       // Getting the constructor of the class through the       // object of the class       Constructor constructor = cls.getConstructor();       System.out.println(&quot;The name of constructor is &quot; +                           constructor.getName());       System.out.println(&quot;The public methods of class are : &quot;);       // Getting methods of the class through the object       // of the class by using getMethods       Method[] methods = cls.getMethods();       // Printing method names       for (Method method:methods)           System.out.println(method.getName());       // creates object of desired method by providing the       // method name and parameter class as arguments to       // the getDeclaredMethod        // 这里是通过方法的名字和输入变量来获取对应的方法      Method methodcall1 = cls.getDeclaredMethod(&quot;method2&quot;,                                               int.class);       // invokes the method at runtime       // 这里是在运行时执行这个方法       methodcall1.invoke(obj, 19);       // creates object of the desired field by providing       // the name of field as argument to the       // getDeclaredField method       // 运行时获取对应的private的变量      Field field = cls.getDeclaredField(&quot;s&quot;);       // allows the object to access the field irrespective       // of the access specifier used with the field       // 将这个变量设成可以获取的      field.setAccessible(true);       // takes object and the new value to be assigned       // to the field as arguments       field.set(obj, &quot;JAVA&quot;);       // Creates object of desired method by providing the       // method name as argument to the getDeclaredMethod       Method methodcall2 = cls.getDeclaredMethod(&quot;method1&quot;);       // invokes the method at runtime       methodcall2.invoke(obj);       // Creates object of the desired method by providing       // the name of method as argument to the       // getDeclaredMethod method       Method methodcall3 = cls.getDeclaredMethod(&quot;method3&quot;);       // allows the object to access the method irrespective       // of the access specifier used with the method       methodcall3.setAccessible(true);       // invokes the method at runtime       methodcall3.invoke(obj);   } </code></pre><p>  } </p></li></ul><h1 id="3-详细分析"><a href="#3-详细分析" class="headerlink" title="3. 详细分析"></a>3. 详细分析</h1><p>反射一言以蔽之，即在运行时拿到class，并创建类对应的对象的方式。这种好处是更具灵活性，劣势是会慢很多，代码会相对难理解些。</p><p>从代码本身的角度来讲，是指一部分代码有能力去观察/检查另一部分代码。用已知的部分合理推断出未知的部分，这未知的部分其实是指还不知道的信息。</p><p>一般来说在Java里我们都是和注解一起来使用反射的，</p><h1 id="4-优劣势"><a href="#4-优劣势" class="headerlink" title="4. 优劣势"></a>4. 优劣势</h1><ul><li>好处<ul><li>反射是什么呢？当我们的程序在运行时，需要动态的加载一些类这些类可能之前用不到所以不用加载到jvm，而是在运行时根据需要才加载，这样的好处对于服务器来说不言而喻，举个例子我们的项目底层有时是用mysql，有时用oracle，<strong>需要动态地根据实际情况加载驱动类，这个时候反射就有用了</strong>，假设 <code>com.java.dbtest.myqlConnection</code>，<code>com.java.dbtest.oracleConnection</code>这两个类我们要用，这时候我们的程序就写得比较动态化，通过<code>Class tc = Class.forName(&quot;com.java.dbtest.TestConnection&quot;);</code>通过类的全类名让jvm在服务器中找到并加载这个类，而如果是oracle则传入的参数就变成另一个了。这时候就可以看到反射的好处了，这个动态性就体现出java的特性了！</li><li>更具拓展性，可以在运行时获取信息</li><li>获取一些private的域的值方便debug</li></ul></li><li>劣势<ul><li>更慢，有延时</li><li>会暴露一些接口</li><li>反射会要求运行的许可，当在secure manager下来运行可能不被允许</li></ul></li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://stackoverflow.com/questions/37628/what-is-reflection-and-why-is-it-useful" target="_blank" rel="noopener">https://stackoverflow.com/questions/37628/what-is-reflection-and-why-is-it-useful</a></li><li><a href="https://docs.oracle.com/javase/tutorial/reflect/index.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/tutorial/reflect/index.html</a></li><li><a href="https://docs.oracle.com/javase/tutorial/reflect/class/index.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/tutorial/reflect/class/index.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-介绍&quot;&gt;&lt;a href=&quot;#1-介绍&quot; class=&quot;headerlink&quot; title=&quot;1. 介绍&quot;&gt;&lt;/a&gt;1. 介绍&lt;/h1&gt;&lt;p&gt;Java反射机制是在运行时用来判定或者修改方法，类，接口的行为的API。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;反射可以告诉我
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
      <category term="Reflection" scheme="https://www.llchen60.com/tags/Reflection/"/>
    
  </entry>
  
  <entry>
    <title>java - serialization</title>
    <link href="https://www.llchen60.com/java-serialization/"/>
    <id>https://www.llchen60.com/java-serialization/</id>
    <published>2020-02-06T03:01:26.000Z</published>
    <updated>2020-02-06T03:01:43.795Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a>1. Overview</h1><p>An object is eligible for serialization if and only if its class implements the <strong>java.io.Serializable</strong> interface. Serializable is a marker interface (contains no methods) that tell the Java Virtual Machine (JVM) that the objects of this class is ready for being written to and read from a persistent storage or over the network.</p><h1 id="2-Why-we-need-serialization"><a href="#2-Why-we-need-serialization" class="headerlink" title="2. Why we need serialization?"></a>2. Why we need serialization?</h1><p>It’s used when the need arises to send data/ object over network or stored in files.</p><p>The thing is network and hard disk are hardware component that understand bits and bytes but not Java Objects. </p><p>Serialization is the translation of your Java object’s values/states to bytes to send it over network or save it.</p><p>Also used to store into database. </p><h1 id="3-Implementation"><a href="#3-Implementation" class="headerlink" title="3. Implementation"></a>3. Implementation</h1><p>Ways for serialize/ deserialize  – xml JSON </p><p>Serialization process is instance independent. </p><ul><li>ObjectInputStream <ul><li>extends java.io.InputStream </li></ul></li></ul><pre><code>public final Object readObject() throws IOException, ClassNotFoundException;</code></pre><ul><li>ObjectOutputStream <ul><li>extends java.io.OutputStream</li></ul></li></ul><pre><code>public final void writeObject(Object o) throws IOException;</code></pre><h2 id="3-1-Example"><a href="#3-1-Example" class="headerlink" title="3.1 Example"></a>3.1 Example</h2><pre><code>public class Person implements Serializable {    private static final long serialVersionUID = 1L;    static String country = &quot;ITALY&quot;;    private int age;    private String name;    transient int height;    // getters and setters}@Testpublic void whenSerializingAndDeserializing_ThenObjectIsTheSame() ()   throws IOException, ClassNotFoundException {     Person person = new Person();    person.setAge(20);    person.setName(&quot;Joe&quot;);    FileOutputStream fileOutputStream      = new FileOutputStream(&quot;yourfile.txt&quot;);    ObjectOutputStream objectOutputStream       = new ObjectOutputStream(fileOutputStream);    objectOutputStream.writeObject(person);    objectOutputStream.flush();    objectOutputStream.close();    FileInputStream fileInputStream      = new FileInputStream(&quot;yourfile.txt&quot;);    ObjectInputStream objectInputStream      = new ObjectInputStream(fileInputStream);    Person p2 = (Person) objectInputStream.readObject();    objectInputStream.close();     assertTrue(p2.getAge() == p.getAge());    assertTrue(p2.getName().equals(p.getName()));}</code></pre><h1 id="4-Caveats"><a href="#4-Caveats" class="headerlink" title="4. Caveats"></a>4. Caveats</h1><ol><li>When a class implements the java.io.Serializable interface, all <strong>its sub-classes are serializable as well</strong>.</li><li>when an object has a reference to another object, these objects must implement the Serializable interface separately, or else a NotSerializableException will be thrown</li><li>JVM associates a version number with each serializable class. </li></ol><p>Reference</p><ol><li><a href="https://www.codejava.net/java-se/file-io/why-do-we-need-serialization-in-java" target="_blank" rel="noopener">https://www.codejava.net/java-se/file-io/why-do-we-need-serialization-in-java</a></li><li><a href="https://www.baeldung.com/java-serialization" target="_blank" rel="noopener">https://www.baeldung.com/java-serialization</a></li><li><a href="https://www.geeksforgeeks.org/serialization-in-java/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/serialization-in-java/</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Overview&quot;&gt;&lt;a href=&quot;#1-Overview&quot; class=&quot;headerlink&quot; title=&quot;1. Overview&quot;&gt;&lt;/a&gt;1. Overview&lt;/h1&gt;&lt;p&gt;An object is eligible for serializat
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java Pattern Regex表达式</title>
    <link href="https://www.llchen60.com/Java-Pattern-Regex%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://www.llchen60.com/Java-Pattern-Regex%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2020-02-06T03:00:32.000Z</published>
    <updated>2020-02-06T03:00:54.343Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-为什么要使用Pattern？"><a href="#1-为什么要使用Pattern？" class="headerlink" title="1. 为什么要使用Pattern？"></a>1. 为什么要使用Pattern？</h1><p>一般来说如果我们要对String做某个范式下的替换时，我们需要使用</p><pre><code>stringEG.replaceAll(&quot;(?i)@gmail\\.com$&quot;, &quot;&quot;);</code></pre><p>上面这行代码是将stringEG最后的@gmail.com给替换掉，通过这种方式来获得用户名。</p><p>这种Replace操作我们会经常使用，但是上述有一个问题，即每次运行都要执行一遍Regex操作，这样很费时间，每次都要进行编译，Pattern可以帮助我们解决这个问题。</p><p>通过设置static的变量，我们可以将Compile完的结果存起来，然后在需要的时候直接使用这个结果即可。</p><p>使用方法如下所示:</p><pre><code>private static final Pattern USER_NAME_PATTERN = Pattern.compile(&quot;(?i)@gmail\\.com$);final String username =  USER_NAME_PATTERN.matcher(stringEG.replace(&quot;&quot;));</code></pre><h1 id="2-如何使用Pattern？"><a href="#2-如何使用Pattern？" class="headerlink" title="2. 如何使用Pattern？"></a>2. 如何使用Pattern？</h1><p>使用Java Pattern，重点在于对于正则表达式的使用，可以看一下文章 - <a href="https://llchen60.com/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" target="_blank" rel="noopener">正则表达式</a>, 里面有对正则的详细介绍。</p><p>Pattern对象是一个已经编译过的正则表达式的表达，Pattern类没有public的构造器，想要创建一个Pattern，我们需要首先调用其静态的compile()方法，通过这个方法会得到一个Pattern对象。</p><p>Matcher 对象用来解释正则表达式然后根据表达式来找符合规则的相关表达，同样没有public的构造器，通过调用matcher() 方法来作比较</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-为什么要使用Pattern？&quot;&gt;&lt;a href=&quot;#1-为什么要使用Pattern？&quot; class=&quot;headerlink&quot; title=&quot;1. 为什么要使用Pattern？&quot;&gt;&lt;/a&gt;1. 为什么要使用Pattern？&lt;/h1&gt;&lt;p&gt;一般来说如果我们要对St
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
      <category term="Regex" scheme="https://www.llchen60.com/tags/Regex/"/>
    
  </entry>
  
  <entry>
    <title>Java map() 与 flatMap()的比较</title>
    <link href="https://www.llchen60.com/Java-map-%E4%B8%8E-flatMap-%E7%9A%84%E6%AF%94%E8%BE%83/"/>
    <id>https://www.llchen60.com/Java-map-%E4%B8%8E-flatMap-%E7%9A%84%E6%AF%94%E8%BE%83/</id>
    <published>2020-02-06T02:59:48.000Z</published>
    <updated>2020-02-06T03:00:06.496Z</updated>
    
    <content type="html"><![CDATA[<p><code>map()</code>和<code>flatMap()</code>方法都来自于functional languages. 在Java8当中，我们可以在Optional, Stream还有CompletableFuture当中找到他们。</p><p>Stream代表一些列的对象，而Optional代表一个存在或者空的值。<code>map()</code>和<code>flatmap()</code>都是聚合方法，尽管其有着相同的返回类型，但是实际上他们有很多的不同。下面我们通过例子来逐一展现。</p><h1 id="1-在Optionals当中"><a href="#1-在Optionals当中" class="headerlink" title="1. 在Optionals当中"></a>1. 在Optionals当中</h1><pre><code>// map()Optional&lt;String&gt; s = Optional.of(&quot;Test&quot;);assertEquals(Optional.of(&quot;TEST&quot;), s.map(String::toUpperCase));// 如果情况更为复杂，变成Optional&lt;Optional&lt;String&gt;&gt;assertEquals(Optional.of(Optional.of(&quot;STRING&quot;)),     Optional.of(&quot;string&quot;).map(s -&gt; Optional.of(&quot;STRING&quot;)));// 同样的代码用flatmap来表示assertEquals(Optional.of(&quot;STRING&quot;), Optional.of(&quot;string&quot;).flatMap(s -&gt; Optional.of(&quot;STRING&quot;)));</code></pre><h1 id="2-在Streams当中"><a href="#2-在Streams当中" class="headerlink" title="2. 在Streams当中"></a>2. 在Streams当中</h1><p>map方法只能做一层的序列化，但是flatmap可以做多层的，来解决Stream&lt;Stream<R>&gt;的这种结构的问题。</p><pre><code>// 对于这种多层架构的, map()方法就显得力有未逮了List&lt;List&lt;String&gt;&gt; list = Arrays.asList(  Arrays.asList(&quot;a&quot;),  Arrays.asList(&quot;b&quot;));System.out.println(list);// flatmap可以很好的解决System.out.println(list.stream().flatMap(Collection::stream).collect(Collectors.toList()));</code></pre><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://www.baeldung.com/java-difference-map-and-flatmap" target="_blank" rel="noopener">https://www.baeldung.com/java-difference-map-and-flatmap</a></li><li><a href="https://www.mkyong.com/java8/java-8-flatmap-example/" target="_blank" rel="noopener">https://www.mkyong.com/java8/java-8-flatmap-example/</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;map()&lt;/code&gt;和&lt;code&gt;flatMap()&lt;/code&gt;方法都来自于functional languages. 在Java8当中，我们可以在Optional, Stream还有CompletableFuture当中找到他们。&lt;/p&gt;
&lt;p&gt;Stre
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
      <category term="Map" scheme="https://www.llchen60.com/tags/Map/"/>
    
  </entry>
  
  <entry>
    <title>Java - ExecutorService</title>
    <link href="https://www.llchen60.com/Java-ExecutorService/"/>
    <id>https://www.llchen60.com/Java-ExecutorService/</id>
    <published>2020-02-06T02:58:50.000Z</published>
    <updated>2020-02-06T02:59:23.181Z</updated>
    
    <content type="html"><![CDATA[<p>ExecutorService is a framework provided by the JDK which simplifies the execution of tasks in <strong><em>asynchronous</em></strong> mode. ExecutorService automatically provides a pool of threads and API for assigning tasks to it. </p><h1 id="1-Instantiation"><a href="#1-Instantiation" class="headerlink" title="1. Instantiation"></a>1. Instantiation</h1><h2 id="1-1-Factory-methods-of-Executors-class"><a href="#1-1-Factory-methods-of-Executors-class" class="headerlink" title="1.1 Factory methods of Executors class"></a>1.1 Factory methods of Executors class</h2><p>Use its factory methods of the Executors class to create ExecutorService. </p><pre><code>ExecutorService executor = Executors.newFixedThreadPool(10);</code></pre><h2 id="1-2-Directly-create"><a href="#1-2-Directly-create" class="headerlink" title="1.2 Directly create"></a>1.2 Directly create</h2><pre><code>ExecutorService executorService =   new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS,     new LinkedBlockingQueue&lt;Runnable&gt;());</code></pre><h1 id="2-Assigning-Tasks"><a href="#2-Assigning-Tasks" class="headerlink" title="2. Assigning Tasks"></a>2. Assigning Tasks</h1><p>ExecutorService can execute Runnable and Callable tasks. </p><pre><code>Runnable runnableTask = () -&gt; {    try {        TimeUnit.MILLISECONDS.sleep(300);    } catch (InterruptedException e) {        e.printStackTrace();    }};Callable&lt;String&gt; callableTask = () -&gt; {    TimeUnit.MILLISECONDS.sleep(300);    return &quot;Task&#39;s execution&quot;;};List&lt;Callable&lt;String&gt;&gt; callableTasks = new ArrayList&lt;&gt;();callableTasks.add(callableTask);callableTasks.add(callableTask);callableTasks.add(callableTask);</code></pre><h2 id="2-1-execute"><a href="#2-1-execute" class="headerlink" title="2.1 execute()"></a>2.1 execute()</h2><p>The execute() method is void, and it doesn’t give any possibility to get the result of task’s execution or to check the task’s status (is it running or executed).</p><pre><code>executerService.execute(runnableTask);</code></pre><h2 id="2-2-submit"><a href="#2-2-submit" class="headerlink" title="2.2 submit()"></a>2.2 submit()</h2><p>submit() submits a Callable or a Runnable task to an ExecutorService and returns a result of type Future.</p><pre><code>Future&lt;String&gt; future = executorService.submit(callableTask);</code></pre><h2 id="2-3-invokeAny"><a href="#2-3-invokeAny" class="headerlink" title="2.3 invokeAny()"></a>2.3 invokeAny()</h2><p>invokeAny() assigns a collection of tasks to an ExecutorService, causing each to be executed, and returns the result of a successful execution of one task (if there was a successful execution).</p><pre><code>String result = executorService.invokeAny(callableTasks);</code></pre><h2 id="2-4-invokeAll"><a href="#2-4-invokeAll" class="headerlink" title="2.4 invokeAll()"></a>2.4 invokeAll()</h2><p>invokeAll() assigns a collection of tasks to an ExecutorService, causing each to be executed, and returns the result of all task executions in the form of a list of objects of type Future.</p><pre><code>List&lt;Future&lt;String&gt;&gt; futures = executorService.invokeAll(callableTasks);</code></pre><h1 id="3-Shutdown"><a href="#3-Shutdown" class="headerlink" title="3. Shutdown"></a>3. Shutdown</h1><p>In general, the ExecutorService will not be automatically destroyed when there is not task to process. It will stay alive and wait for new work to do.</p><p>In some cases this is very helpful; for example, if an app needs to process tasks which appear on an irregular basis or the quantity of these tasks is not known at compile time.</p><p>On the other hand, an app could reach its end, but it will not be stopped because a waiting ExecutorService will cause the JVM to keep running.</p><h2 id="3-1-shutdown"><a href="#3-1-shutdown" class="headerlink" title="3.1 shutdown()"></a>3.1 shutdown()</h2><p>The shutdown() method doesn’t cause an immediate destruction of the ExecutorService. It will make the ExecutorService stop accepting new tasks and shut down after all running threads finish their current work.</p><pre><code>executorService.shutdown();</code></pre><h2 id="3-2-shutdownNow"><a href="#3-2-shutdownNow" class="headerlink" title="3.2 shutdownNow()"></a>3.2 shutdownNow()</h2><p>The shutdownNow() method tries to destroy the ExecutorService immediately, but it doesn’t guarantee that all the running threads will be stopped at the same time. This method returns a list of tasks which are waiting to be processed. It is up to the developer to decide what to do with these tasks.</p><pre><code>List&lt;Runnable&gt; notExecutedTasks = executorService.shutDownNow();</code></pre><h2 id="3-3-best-behavior"><a href="#3-3-best-behavior" class="headerlink" title="3.3 best behavior"></a>3.3 best behavior</h2><pre><code>executorService.shutdown();try {    if (!executorService.awaitTermination(800, TimeUnit.MILLISECONDS)) {        executorService.shutdownNow();    } } catch (InterruptedException e) {    executorService.shutdownNow();}</code></pre><h1 id="4-Future-interface"><a href="#4-Future-interface" class="headerlink" title="4. Future interface"></a>4. Future interface</h1><p>Future interface provides a <code>get()</code> which returns an actual result of the Callable task’s execution or null in the case of Runnable task. Calling the get() method while the task is still running will cause execution to block until the task is properly executed and the result is available.</p><pre><code>Future&lt;String&gt; future = executorService.submit(callableTask);String result = null;try {    result = future.get();} catch (InterruptedException | ExecutionException e) {    e.printStackTrace();}</code></pre><p>With very long blocking caused by the get() method, an application’s performance can degrade. If the resulting data is not crucial, it is possible to avoid such a problem by using timeouts:</p><pre><code>String result = future.get(200, TimeUnit.MILLISECONDS);</code></pre><p>some other methods provided:</p><pre><code>cancel()isCancelled()isDone() </code></pre><h1 id="5-How-to-sync-the-value-across-different-threads"><a href="#5-How-to-sync-the-value-across-different-threads" class="headerlink" title="5. How to sync the value across different threads?"></a>5. How to sync the value across different threads?</h1><p>Suppose we have i++ in several threads, and they all perform such operations. To make the i computed properly, we need to make it atomic. </p><p>Use <code>AtomicInteger</code> or <code>synchronized</code> to get the final correct result. </p><p>Notice, <code>volatile</code> cannot make sure the final result is correct. It mainly makes sure the visibility of newest value, but there is possibility that we mound and switch to other thread before the new value being recorded. </p><p>AtomicInteger class uses CAS(Compare and swap) low level CPU operations. They allow you to modify a particular variable only if the present value is equal to something else (and is returned successfully).</p><h1 id="6-Executor-execute-and-ExecutorService-submit-differences"><a href="#6-Executor-execute-and-ExecutorService-submit-differences" class="headerlink" title="6. Executor.execute() and ExecutorService.submit() differences"></a>6. Executor.execute() and ExecutorService.submit() differences</h1><ol><li>execute(Runnable) does not return anything; while submit(Callable<T>) returns a Future object which allows a way to programatically cancel the running thread and get the return result. </li><li>submit() can accept both Runnable and Callable task but execute() can only accept the Runnable task</li><li>submit() return a Future object while execute() has no return</li><li>get() is a blocking call, which will take some time</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ExecutorService is a framework provided by the JDK which simplifies the execution of tasks in &lt;strong&gt;&lt;em&gt;asynchronous&lt;/em&gt;&lt;/strong&gt; mode
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
      <category term="Executor Service" scheme="https://www.llchen60.com/tags/Executor-Service/"/>
    
  </entry>
  
  <entry>
    <title>Java - callback</title>
    <link href="https://www.llchen60.com/Java-callback/"/>
    <id>https://www.llchen60.com/Java-callback/</id>
    <published>2020-02-06T02:57:58.000Z</published>
    <updated>2020-02-06T02:58:23.254Z</updated>
    
    <content type="html"><![CDATA[<p>In C/ C++, callback refers to the mechanism of calling a function from another function. Memory address of a function is represented as function pointer here. SO the callback is achieved by passing the pointer of func1() to func2().</p><p>However, in java, there is no function pointer existing. And we use a callback object or a callback interface, and the interface is passed that refers to the location of a function. </p><p>Below is an example to compute tax by state tax and fedaral tax. Suppose federal tax keeps same while state tax vary by state. We can build interface and implements interface to realize it.<br>    // Java program to demonstrate callback mechanism<br>    // using interface is Java </p><pre><code>// Create interface import java.util.Scanner; interface STax {     double stateTax(); } // Implementation class of Punjab state tax class Punjab implements STax {     public double stateTax()     {         return 3000.0;     } } // Implementation class of Himachal Pardesh state tax class HP implements STax {     public double stateTax()     {         return 1000.0;     } } class TAX {     public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException     {         Scanner sc = new Scanner(System.in);         System.out.println(&quot;Enter the state name&quot;);         String state = sc.next(); // name of the state         // The state name is then stored in an object c         Class c = Class.forName(state);         // Create the new object of the class whose name is in c         // Stax interface reference is now referencing that new object         STax ref = (STax)c.newInstance();         /*Call the method to calculate total tax         and pass interface reference - this is callback .         Here, ref may refer to stateTax() of Punjab or HP classes         depending on the class for which the object is created         in the previous step         */        calculateTax(ref);     }     static void calculateTax(STax t)     {         // calculate central tax         double ct = 2000.0;         // calculate state tax         double st = t.stateTax();         double totaltax = st + ct;         // display total tax         System.out.println(&quot;Total tax =&quot; + totaltax);     } } </code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;In C/ C++, callback refers to the mechanism of calling a function from another function. Memory address of a function is represented as f
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Callback" scheme="https://www.llchen60.com/tags/Callback/"/>
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java Annotations 注解详解</title>
    <link href="https://www.llchen60.com/Java-Annotations-%E6%B3%A8%E8%A7%A3%E8%AF%A6%E8%A7%A3/"/>
    <id>https://www.llchen60.com/Java-Annotations-%E6%B3%A8%E8%A7%A3%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-02-06T02:57:11.000Z</published>
    <updated>2020-02-06T02:57:33.469Z</updated>
    
    <content type="html"><![CDATA[<p>Java annotation很有用，这篇博客会带着大家去理解Annotation的语法以及用法，希望能有所裨益。</p><h1 id="1-Annotation架构"><a href="#1-Annotation架构" class="headerlink" title="1. Annotation架构"></a>1. Annotation架构</h1><h2 id="1-0-Annotation的介绍"><a href="#1-0-Annotation的介绍" class="headerlink" title="1.0 Annotation的介绍"></a>1.0 Annotation的介绍</h2><p>用一句话来解释Annotation的话，我想可以称其为Metadata(元数据) - 即数据的数据。</p><p>举个例子，比如这里我使用了@Override：</p><pre><code>@Overridepublic String toString() {return &quot;This is String Representation of current object.&quot;;}</code></pre><p>通过注解的方式，我告诉编译器我重写了这个toString()的方法。但其实就算我没有加这个注解，代码仍然是可以有效运行的，那么用注解的好处有哪些呢？为什么我们需要使用注解呢？？？ </p><p>上述的注解告诉编译器我重写了父类里面的一个方法，然后编译器会去父类检查看这个方法是否存在，如果不存在的话，那就会扔出一个编译错误。通过这种方式我们可以减少错误的发生，并且提高整个代码的可读性，给我们带来一些便利。</p><p>其实就像上面说的那样，注解是一种携带元数据的方式，我们实际上在注解之前是用XML来做元数据的存储的。二者各有自己的适用场景。对于XML来说，如果你写的应用有大量的常数，参量，用XML会更好，因为我们可以将这些常量和代码完全解耦，这样在改变常量值的时候会方便很多。如果你想对外暴露一些方法来做服务，那注解会是更好的选择。因为这种情形下元数据最好和方法紧密相连，让开发者意识到这个方法的一些特征。</p><p>另外注解提供了一个标准的在代码中定义元数据的方式，在注解之前工程师常会自己定义，比如注释，接口，等等。注解将这个过程做了标准化。</p><h2 id="1-1-Annotation-组成部分"><a href="#1-1-Annotation-组成部分" class="headerlink" title="1.1 Annotation 组成部分"></a>1.1 Annotation 组成部分</h2><p><img src="fig1.jpg" alt="fig1.jpg"></p><ul><li>Annotation<ul><li>1 RetentionPolicy 每一个注解对象都会有唯一的RetentionPolicy属性</li><li>1 - n ElementType  每个注解对象都可以有若干个ElementType属性</li><li>Annotation有多个实现类，包括<ul><li>Deprecated </li><li>Documented</li><li>Inherited </li><li>Override </li><li>Retention </li><li>Target </li></ul></li></ul></li></ul><p>第一个很重要的观念，就是<strong><em>注解只是元数据，它不包括任何真正的代码逻辑</em></strong>。</p><p>第二个很重要的观念，建立在第一个的基础之上，即如果注解不包括代码逻辑，那么就一定有针对注解的消费者，来读取注解提供的信息，并且执行对应的代码逻辑。</p><p>比如以@override为例，这里JVM就是这个注解的消费者，并且在字节码的水平利用注解信息。</p><h3 id="1-1-1-Annotation-java"><a href="#1-1-1-Annotation-java" class="headerlink" title="1.1.1 Annotation.java"></a>1.1.1 Annotation.java</h3><pre><code>package java.lang.annotation;public interface Annotation {    boolean equals(Object obj);    int hashCode();    String toString();    Class&lt;? extends Annotation&gt; annotationType();}</code></pre><p>一个接口</p><h3 id="1-1-2-ElementType-java"><a href="#1-1-2-ElementType-java" class="headerlink" title="1.1.2 ElementType.java"></a>1.1.2 ElementType.java</h3><pre><code>package java.lang.annotation;public enum ElementType {    TYPE,               /* 类、接口（包括注释类型）或枚举声明  */    FIELD,              /* 字段声明（包括枚举常量）  */    METHOD,             /* 方法声明  */    PARAMETER,          /* 参数声明  */    CONSTRUCTOR,        /* 构造方法声明  */    LOCAL_VARIABLE,     /* 局部变量声明  */    ANNOTATION_TYPE,    /* 注释类型声明  */    PACKAGE             /* 包声明  */}</code></pre><p>枚举类型，用来指定Annotation的类型。就是这个注解对象是用来修饰什么的，是方法，是变量，还是其他的各种…</p><h3 id="1-1-3-RetentionPolicy-java"><a href="#1-1-3-RetentionPolicy-java" class="headerlink" title="1.1.3 RetentionPolicy.java"></a>1.1.3 RetentionPolicy.java</h3><pre><code>package java.lang.annotation;public enum RetentionPolicy {    SOURCE,            /* Annotation信息仅存在于编译器处理期间，编译器处理完之后就没有该Annotation信息了  */    CLASS,             /* 编译器将Annotation存储于类对应的.class文件中。默认行为  */    RUNTIME            /* 编译器将Annotation存储于class文件中，并且可由JVM读入 */}</code></pre><p>RetentionPolicy是Enum枚举类型，每个都有其对应的行为。</p><p><strong>RetentionPolicy.SOURCE</strong> – Discard during the compile. These annotations don’t make any sense after the compile has completed, so they aren’t written to the bytecode. Examples @Override, @SuppressWarnings</p><p><strong>RetentionPolicy.CLASS</strong> – Discard during class load. Useful when doing bytecode-level post-processing. Somewhat surprisingly, this is the default.</p><p><strong>RetentionPolicy.RUNTIME</strong> – Do not discard. The annotation should be available for reflection at runtime. This is what we generally use for our custom annotations.</p><h2 id="1-2-通用定义"><a href="#1-2-通用定义" class="headerlink" title="1.2 通用定义"></a>1.2 通用定义</h2><pre><code>@Documented@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface MyAnnotation1 {}</code></pre><h3 id="1-2-1-interface"><a href="#1-2-1-interface" class="headerlink" title="1.2.1 @interface"></a>1.2.1 @interface</h3><p>意味着实现了java.lang.annotation.Annotation接口，即该注解就是一个Annotation。Annotation接口的实现细节都由编译器来完成的，通过@interface定义注解吼，该注解不能继承其他的注解或接口。</p><h3 id="1-2-2-Documented"><a href="#1-2-2-Documented" class="headerlink" title="1.2.2 @Documented"></a>1.2.2 @Documented</h3><p>类和方法的Annotation在缺省情况下是不出现在javadoc中的。如果使用@Documented修饰该Annotation，则表示它可以出现在javadoc中。</p><h3 id="1-2-3-Target-ElementType-TYPE"><a href="#1-2-3-Target-ElementType-TYPE" class="headerlink" title="1.2.3 @Target(ElementType.TYPE)"></a>1.2.3 @Target(ElementType.TYPE)</h3><p>ElementType是Annotation的类型属性，而@Target的作用，就是来指定类型属性的</p><p>有@Target，则该Annotation只能用于其所指定的地方；若没有，则该Annotation可以用于任何地方</p><h3 id="1-2-4-Retention-RetentionPolicy-RUNTIME"><a href="#1-2-4-Retention-RetentionPolicy-RUNTIME" class="headerlink" title="1.2.4 @Retention(RetentionPolicy.RUNTIME)"></a>1.2.4 @Retention(RetentionPolicy.RUNTIME)</h3><p>RetentionPolicy是Annotation的策略属性，</p><h2 id="1-3-常用Annotation"><a href="#1-3-常用Annotation" class="headerlink" title="1.3 常用Annotation"></a>1.3 常用Annotation</h2><h3 id="1-3-1-Deprecated"><a href="#1-3-1-Deprecated" class="headerlink" title="1.3.1 @Deprecated"></a>1.3.1 @Deprecated</h3><pre><code>@Documented@Retention(RetentionPolicy.RUNTIME)public @interface Deprecated {}</code></pre><ol><li>@interface – 它的用来修饰Deprecated，意味着Deprecated实现了java.lang.annotation.Annotation接口；即Deprecated就是一个注解。</li><li>@Documented – 它的作用是说明该注解能出现在javadoc中。</li><li>@Retention(RetentionPolicy.RUNTIME) – 它的作用是指定Deprecated的策略是RetentionPolicy.RUNTIME。这就意味着，编译器会将Deprecated的信息保留在.class文件中，并且能被虚拟机读取。</li><li>@Deprecated 所标注内容，不再被建议使用。<h3 id="1-3-2-Override"><a href="#1-3-2-Override" class="headerlink" title="1.3.2 @Override"></a>1.3.2 @Override</h3></li></ol><h3 id="1-3-3-Documented"><a href="#1-3-3-Documented" class="headerlink" title="1.3.3 @Documented"></a>1.3.3 @Documented</h3><h3 id="1-3-4-Inherited"><a href="#1-3-4-Inherited" class="headerlink" title="1.3.4 @Inherited"></a>1.3.4 @Inherited</h3><p>用来标注Annotation类型，所标注的Annotation具有继承性</p><pre><code>@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Inherited {}</code></pre><ol><li>@interface – 它的用来修饰Inherited，意味着Inherited实现了java.lang.annotation.Annotation接口；即Inherited就是一个注解。</li><li>@Documented – 它的作用是说明该注解能出现在javadoc中。</li><li>@Retention(RetentionPolicy.RUNTIME) – 它的作用是指定Inherited的策略是RetentionPolicy.RUNTIME。这就意味着，编译器会将Inherited的信息保留在.class文件中，并且能被虚拟机读取。</li><li>@Target(ElementType.ANNOTATION_TYPE) – 它的作用是指定Inherited的类型是ANNOTATION_TYPE。这就意味着，@Inherited只能被用来标注“Annotation类型”。</li></ol><h3 id="1-3-5-Retention"><a href="#1-3-5-Retention" class="headerlink" title="1.3.5 @Retention"></a>1.3.5 @Retention</h3><p>用来标注Annotation类型，用来指定RetentionPolicy属性</p><h3 id="1-3-6-Target"><a href="#1-3-6-Target" class="headerlink" title="1.3.6 @Target"></a>1.3.6 @Target</h3><p>@Target只能被用来标注“Annotation类型”，而且它被用来指定Annotation的ElementType属性。</p><h3 id="1-3-7-SuppressWarnings"><a href="#1-3-7-SuppressWarnings" class="headerlink" title="1.3.7 @SuppressWarnings"></a>1.3.7 @SuppressWarnings</h3><p>@SuppressWarnings 所标注内容产生的警告，编译器会对这些警告保持静默。</p><pre><code>@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})@Retention(RetentionPolicy.SOURCE)public @interface SuppressWarnings {    String[] value();}</code></pre><ol><li>@interface – 它的用来修饰SuppressWarnings，意味着SuppressWarnings实现了java.lang.annotation.Annotation接口；即SuppressWarnings就是一个注解。</li><li>@Retention(RetentionPolicy.SOURCE) – 它的作用是指定SuppressWarnings的策略是RetentionPolicy.SOURCE。这就意味着，SuppressWarnings信息仅存在于编译器处理期间，编译器处理完之后SuppressWarnings就没有作用了。</li><li>@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE}) – 它的作用是指定SuppressWarnings的类型同时包括TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE。</li></ol><ul><li>TYPE意味着，它能标注“类、接口（包括注释类型）或枚举声明”。</li><li>FIELD意味着，它能标注“字段声明”。</li><li>METHOD意味着，它能标注“方法”。</li><li>PARAMETER意味着，它能标注“参数”。</li><li>CONSTRUCTOR意味着，它能标注“构造方法”。</li><li>LOCAL_VARIABLE意味着，它能标注“局部变量”。</li></ul><ol start="4"><li>String[] value(); 意味着，SuppressWarnings能指定参数</li><li>SuppressWarnings 的作用是，让编译器对“它所标注的内容”的某些警告保持静默。例如，”@SuppressWarnings(value={“deprecation”, “unchecked”})” 表示对“它所标注的内容”中的 “SuppressWarnings不再建议使用警告”和“未检查的转换时的警告”保持沉默。<h1 id="2-创建自己的Annotation"><a href="#2-创建自己的Annotation" class="headerlink" title="2. 创建自己的Annotation"></a>2. 创建自己的Annotation</h1></li></ol><p>注解只支持基本类型，String，还有Enum。所有的注解的属性都被定义为方法，default的值也会在方法里提供。</p><pre><code>@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)@interface Todo {public enum Priority {LOW, MEDIUM, HIGH}public enum Status {STARTED, NOT_STARTED}String author() default &quot;Yash&quot;;Priority priority() default Priority.LOW;Status status() default Status.NOT_STARTED;}</code></pre><p>这里我们创建了一个新的注解，@Todo</p><pre><code>@Todo(priority = Todo.Priority.MEDIUM, author = &quot;Yashwant&quot;, status = Todo.Status.STARTED)public void incompleteMethod1() {    //一些业务逻辑}</code></pre><p>值得注意的一点，如果注解只有一个属性，那么它应该被命名为value,在使用它的时候不用使用具体的变量名了。</p><pre><code>@interface Author{String value();}@Author(&quot;Yashwant&quot;)public void someMethod() {}</code></pre><p>定义好注解以后，我们需要写注解的消费者，使用反射。</p><pre><code>Class businessLogicClass = BusinessLogic.class;for(Method method : businessLogicClass.getMethods()) {    Todo todoAnnotation = (Todo)method.getAnnotation(Todo.class);    if(todoAnnotation != null) {    System.out.println(&quot; Method Name : &quot; + method.getName());    System.out.println(&quot; Author : &quot; + todoAnnotation.author());    System.out.println(&quot; Priority : &quot; + todoAnnotation.priority());    System.out.println(&quot; Status : &quot; + todoAnnotation.status());    }}</code></pre><h1 id="3-Reference"><a href="#3-Reference" class="headerlink" title="3. Reference"></a>3. Reference</h1><ol><li><a href="https://www.cnblogs.com/skywang12345/p/3344137.html" target="_blank" rel="noopener">https://www.cnblogs.com/skywang12345/p/3344137.html</a> </li><li><a href="https://dzone.com/articles/how-annotations-work-java" target="_blank" rel="noopener">https://dzone.com/articles/how-annotations-work-java</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java annotation很有用，这篇博客会带着大家去理解Annotation的语法以及用法，希望能有所裨益。&lt;/p&gt;
&lt;h1 id=&quot;1-Annotation架构&quot;&gt;&lt;a href=&quot;#1-Annotation架构&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
      <category term="Annotations" scheme="https://www.llchen60.com/tags/Annotations/"/>
    
  </entry>
  
  <entry>
    <title>Jackson  java-json parser</title>
    <link href="https://www.llchen60.com/Jackson-java-json-parser/"/>
    <id>https://www.llchen60.com/Jackson-java-json-parser/</id>
    <published>2020-02-06T02:55:49.000Z</published>
    <updated>2020-02-06T02:56:25.555Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Intro"><a href="#1-Intro" class="headerlink" title="1. Intro"></a>1. Intro</h1><ul><li>JSON <ul><li>JavaScript Object Notation </li><li>Data exchange format between browsers and web servers </li></ul></li><li>Jackson <ul><li>2 main parsers <ul><li>ObjectMapper <ul><li>parse JSON into custom Java objects, or into a jackson specific tree structure </li></ul></li><li>JsonParser <ul><li>JSON pull parser, parsing JSON one token at a time </li></ul></li></ul></li><li>2 main JSON generator<ul><li>ObjectMapper </li><li>JsonGenerator<ul><li>generate JSON one token at a time </li></ul></li></ul></li><li>3 main packages <ul><li>Jackson Core</li><li>Jackson Annotations</li><li>Jackson Databind </li></ul></li></ul></li></ul><h1 id="2-Parsers-JSON-to-Java-Object"><a href="#2-Parsers-JSON-to-Java-Object" class="headerlink" title="2. Parsers - JSON to Java Object"></a>2. Parsers - JSON to Java Object</h1><pre><code>ObjectMapper objectMapper = new ObjectMapper();String lakers = &quot;{ \&quot;SuperStar\&quot;:\&quot;Kobe Bryant\&quot;}&quot;;try {    Lakers lakers = objectMapper.readValue(lakers, Lakers.class);} catch (IOException e) {    log.error(e);}@Datapublic class Lakers {    private String superStar;}</code></pre><h2 id="2-1-How-Jackson-ObjectMapper-matches-JSON-fields-to-Java-Fields"><a href="#2-1-How-Jackson-ObjectMapper-matches-JSON-fields-to-Java-Fields" class="headerlink" title="2.1 How Jackson ObjectMapper matches JSON fields to Java Fields?"></a>2.1 How Jackson ObjectMapper matches JSON fields to Java Fields?</h2><p>By default, Jackson maps the fields of a JSON object to fields in a Java object by matching the names of the JSON field to the getter and setter methods in the Java object.<br>Jackson removes the “get” and “set” part of the names of the getter and setter methods, and converts the first character of the remaining name to lowercase.</p><p>If you want to customize the parsing process, you may want to use a custom serializer and deserializer, or use Jackson Annotations </p><h2 id="2-2-Fail-on-Null-for-primitive-types"><a href="#2-2-Fail-on-Null-for-primitive-types" class="headerlink" title="2.2 Fail on Null for primitive types"></a>2.2 Fail on Null for primitive types</h2><p>We could configure the Jackson ObjectMapper to fail if a JSON string contains a field with its value set to null. </p><pre><code>ObjectMapper objectMapper = new ObjectMapper();objectMapper.configure(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES, true);</code></pre><h2 id="2-3-Jackson-JsonParser"><a href="#2-3-Jackson-JsonParser" class="headerlink" title="2.3 Jackson JsonParser"></a>2.3 Jackson JsonParser</h2><ul><li><p>lower level than the ObjectMapper </p><ul><li>faster than the ObjectMapper</li></ul></li><li><p>Create a JsonParser </p><ul><li><code>JsonFactory factory = new JsonFactory();</code></li><li><code>JsonParser parser = factory.createParser(carJson);</code></li></ul></li><li><p>Parsing Json with JsonParser</p><ul><li>break the JSON up into a sequence of tokens which you can iterate one by one </li></ul></li></ul><pre><code>String carJson =        &quot;{ \&quot;brand\&quot; : \&quot;Mercedes\&quot;, \&quot;doors\&quot; : 5 }&quot;;JsonFactory factory = new JsonFactory();JsonParser  parser  = factory.createParser(carJson);while(!parser.isClosed()){    JsonToken jsonToken = parser.nextToken();    System.out.println(&quot;jsonToken = &quot; + jsonToken);}</code></pre><h1 id="3-Generators-Java-Object-to-JSON"><a href="#3-Generators-Java-Object-to-JSON" class="headerlink" title="3. Generators - Java Object to JSON"></a>3. Generators - Java Object to JSON</h1><ul><li>ObjectMapper<ul><li>writeValue()</li><li>writeValueAsString()</li><li>writeValueAsBytes()</li></ul></li></ul><h2 id="3-1-Jackson-JsonGenerator"><a href="#3-1-Jackson-JsonGenerator" class="headerlink" title="3.1 Jackson JsonGenerator"></a>3.1 Jackson JsonGenerator</h2><ul><li>used to generate JSON from java objects </li></ul><pre><code>JsonFactory factory = new JsonFactory();JsonGenerator generator = factory.createGenerator(    new File(&quot;blabla&quot;), JsonEncoding.UTF8);</code></pre><h1 id="4-Jackson-JSON-Tree-Model"><a href="#4-Jackson-JSON-Tree-Model" class="headerlink" title="4. Jackson JSON Tree Model"></a>4. Jackson JSON Tree Model</h1><ul><li>A built-in tree model: used to represent a JSON object </li><li>Represented by the JsonNode class <ul><li>use the ObjectMapper to parse JSON into a JsonNode tree model</li></ul></li><li>JsonNode class lets you navigate the JSOn as a Java object in a quite flexible and dynamic way </li></ul><pre><code>String carJson =        &quot;{ \&quot;brand\&quot; : \&quot;Mercedes\&quot;, \&quot;doors\&quot; : 5 }&quot;;ObjectMapper objectMapper = new ObjectMapper();try {    JsonNode jsonNode = objectMapper.readValue(carJson, JsonNode.class);} catch (IOException e) {    e.printStackTrace();}// ways on how to access JSON fields, arrays and nested objects String carJson =    &quot;{ \&quot;brand\&quot; : \&quot;Mercedes\&quot;, \&quot;doors\&quot; : 5,&quot; +    &quot;  \&quot;owners\&quot; : [\&quot;John\&quot;, \&quot;Jack\&quot;, \&quot;Jill\&quot;],&quot; +    &quot;  \&quot;nestedObject\&quot; : { \&quot;field\&quot; : \&quot;value\&quot; } }&quot;;ObjectMapper objectMapper = new ObjectMapper();try {    JsonNode jsonNode = objectMapper.readValue(carJson, JsonNode.class);    // we could always use get() to get the node     JsonNode brandNode = jsonNode.get(&quot;brand&quot;);    String brand = brandNode.asText();    System.out.println(&quot;brand = &quot; + brand);    JsonNode doorsNode = jsonNode.get(&quot;doors&quot;);    int doors = doorsNode.asInt();    System.out.println(&quot;doors = &quot; + doors);    JsonNode array = jsonNode.get(&quot;owners&quot;);    JsonNode jsonNode = array.get(0);    String john = jsonNode.asText();    System.out.println(&quot;john  = &quot; + john);    JsonNode child = jsonNode.get(&quot;nestedObject&quot;);    JsonNode childField = child.get(&quot;field&quot;);    String field = childField.asText();    System.out.println(&quot;field = &quot; + field);} catch (IOException e) {    e.printStackTrace();}</code></pre><h2 id="4-1-Read-JsonNode-from-JSON"><a href="#4-1-Read-JsonNode-from-JSON" class="headerlink" title="4.1 Read JsonNode from JSON"></a>4.1 Read JsonNode from JSON</h2><pre><code>String jsonStr = blablabla;ObjectMapper objectMapper = new ObjectMapper();JsonNode jsonNode = objectMapper.readTree(json);</code></pre><h2 id="4-2-Write-JsonNode-to-JSON"><a href="#4-2-Write-JsonNode-to-JSON" class="headerlink" title="4.2 Write JsonNode to JSON"></a>4.2 Write JsonNode to JSON</h2><pre><code>ObjectMapper objectMapper = new ObjectMapper();JsonNode jsonNode = readJsonIntoJsonNode();String json = objectMapper.writeValueAsString(jsonNode);</code></pre><h1 id="5-JsonAnnotation"><a href="#5-JsonAnnotation" class="headerlink" title="5. JsonAnnotation"></a>5. JsonAnnotation</h1><ul><li>@JsonIgnore</li><li>@JsonIgnoreProperties<ul><li>specify a list of properties of a class to ignore </li></ul></li><li>@JsonIgnoreType</li><li>@JsonAutoDetect </li><li>@JsonSetter </li><li>@JsonCreator</li><li>@JsonProperty </li><li>@JsonInclude<ul><li>tells Jackson only to include properties under certain circumstances</li></ul></li><li>@JsonGetter <ul><li>tell Jackson that a certain field value should be obtained from calling a getter method instead of via direct field access </li></ul></li><li>@JsonPropertyOrder<ul><li>specify in what order the fields of your java object should be serialized into JSON</li></ul></li><li>@JsonValue<ul><li>tells jackson that it should not attempt to serialize the obejct itself, but rather call a method on the object which serialize the object to a JSON string </li></ul></li><li>@JsonSerialize <ul><li>specify a custom serializer for a field in a Java object  </li></ul></li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="http://tutorials.jenkov.com/java-json/jackson-objectmapper.html" target="_blank" rel="noopener">http://tutorials.jenkov.com/java-json/jackson-objectmapper.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Intro&quot;&gt;&lt;a href=&quot;#1-Intro&quot; class=&quot;headerlink&quot; title=&quot;1. Intro&quot;&gt;&lt;/a&gt;1. Intro&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;JSON &lt;ul&gt;
&lt;li&gt;JavaScript Object Notation &lt;
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
      <category term="Jackson" scheme="https://www.llchen60.com/tags/Jackson/"/>
    
      <category term="Serialization" scheme="https://www.llchen60.com/tags/Serialization/"/>
    
  </entry>
  
</feed>
