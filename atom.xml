<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Leilei&#39;s Blog | 磊磊的博客</title>
  
  <subtitle>Because it&#39;s there</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.llchen60.com/"/>
  <updated>2020-06-17T18:46:53.268Z</updated>
  <id>https://www.llchen60.com/</id>
  
  <author>
    <name>Leilei Chen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>设计模式-创建型-原型模式</title>
    <link href="https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-06-17T18:46:18.000Z</published>
    <updated>2020-06-17T18:46:53.268Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-什么是原型模式"><a href="#1-什么是原型模式" class="headerlink" title="1. 什么是原型模式"></a>1. 什么是原型模式</h1><p>如果说对象的创建成本比较大，并且同一个类的不同对象之间的差别不大（大部分字段都相同），在这种情况下，我们可以利用对已有对象(原型)进行复制/拷贝的方式来创建新对象，来达到节省创建时间的目的。</p><ul><li>如何理解对象的创建成本比较大<ul><li>比如对象当中的数据需要经过复杂的计算才能得到（排序，哈希）</li><li>需要IO读取</li></ul></li></ul><p>在这种情况下，我们就可以利用原型模式，从其他已有对象当中直接拷贝，而不是在每次创建对象的时候，重复执行这个非常耗时的操作。</p><h1 id="2-如何使用原型模式"><a href="#2-如何使用原型模式" class="headerlink" title="2.如何使用原型模式"></a>2.如何使用原型模式</h1><h2 id="2-1-实际场景案例"><a href="#2-1-实际场景案例" class="headerlink" title="2.1 实际场景案例"></a>2.1 实际场景案例</h2><ul><li><p>数据库 存储10万条搜索关键词信息</p><ul><li><p>包含关键词，关键词被搜索次数，信息最近被更新的时间</p></li><li><p>系统A启动的时候会加载这份数据到内存当中，用于处理某些其他的业务需求</p></li><li><p>构建散列表索引 – hashmap</p><ul><li>key为搜索关键词</li><li>value为关键词的详细信息</li></ul></li><li><p>系统B分析搜索日志，每隔10分钟就批量更新数据库中的数据，并且标记为新的数据版本</p></li><li><p>系统A需要定期根据数据库的数据更新内存中的索引和数据</p></li></ul></li></ul><h2 id="2-2-根据需求的迭代"><a href="#2-2-根据需求的迭代" class="headerlink" title="2.2 根据需求的迭代"></a>2.2 根据需求的迭代</h2><ul><li>在系统A中记录更新时间，在数据库中拿出更新时间大于系统A当中的搜索关键词，然后针对差集中的每个关键词进行处理</li><li>如果在散列表中了，更新相应的搜索次数，更新时间等</li><li>如果不在，插入散列表当中</li></ul><pre><code>public class Demo {  private ConcurrentHashMap&lt;String, SearchWord&gt; currentKeywords = new ConcurrentHashMap&lt;&gt;();  private long lastUpdateTime = -1;  public void refresh() {    // 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到currentKeywords中    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);    long maxNewUpdatedTime = lastUpdateTime;    for (SearchWord searchWord : toBeUpdatedSearchWords) {      if (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) {        maxNewUpdatedTime = searchWord.getLastUpdateTime();      }      if (currentKeywords.containsKey(searchWord.getKeyword())) {        currentKeywords.replace(searchWord.getKeyword(), searchWord);      } else {        currentKeywords.put(searchWord.getKeyword(), searchWord);      }    }    lastUpdateTime = maxNewUpdatedTime;  }  private List&lt;SearchWord&gt; getSearchWords(long lastUpdateTime) {    // TODO: 从数据库中取出更新时间&gt;lastUpdateTime的数据    return null;  }}</code></pre><ul><li>如果需要任何时刻系统A中的所有数据都必须是同一个版本的</li><li>更新内存数据的时候，系统A不能处于不可用的状态，不能停机更新数据<ul><li>针对需求，我们需要出了正在使用的服务版本之外，创建另外一个版本的数据。当新的版本数据建好之后，再一次性地将服务版本进行切换</li><li>可以保证数据一直可用，并且避免中间状态的存在</li></ul></li></ul><pre><code>public class Demo {  private HashMap&lt;String, SearchWord&gt; currentKeywords=new HashMap&lt;&gt;();  public void refresh() {    HashMap&lt;String, SearchWord&gt; newKeywords = new LinkedHashMap&lt;&gt;();    // 从数据库中取出所有的数据，放入到newKeywords中    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords();    for (SearchWord searchWord : toBeUpdatedSearchWords) {      newKeywords.put(searchWord.getKeyword(), searchWord);    }    currentKeywords = newKeywords;  }  private List&lt;SearchWord&gt; getSearchWords() {    // TODO: 从数据库中取出所有的数据    return null;  }}</code></pre><ul><li>新数据结构的构建成本非常高，需要IO读出数据库，计算哈希值，构建newKeywords</li><li>我们可以拷贝当前的版本到新的待处理的散列表当中，然后从数据库当中拿出新增或者有更新的关键词，来做更新</li></ul><pre><code>public class Demo {  private HashMap&lt;String, SearchWord&gt; currentKeywords=new HashMap&lt;&gt;();  private long lastUpdateTime = -1;  public void refresh() {    // 原型模式就这么简单，拷贝已有对象的数据，更新少量差值    HashMap&lt;String, SearchWord&gt; newKeywords = (HashMap&lt;String, SearchWord&gt;) currentKeywords.clone();    // 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);    long maxNewUpdatedTime = lastUpdateTime;    for (SearchWord searchWord : toBeUpdatedSearchWords) {      if (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) {        maxNewUpdatedTime = searchWord.getLastUpdateTime();      }      if (newKeywords.containsKey(searchWord.getKeyword())) {        SearchWord oldSearchWord = newKeywords.get(searchWord.getKeyword());        oldSearchWord.setCount(searchWord.getCount());        oldSearchWord.setLastUpdateTime(searchWord.getLastUpdateTime());      } else {        newKeywords.put(searchWord.getKeyword(), searchWord);      }    }    lastUpdateTime = maxNewUpdatedTime;    currentKeywords = newKeywords;  }  private List&lt;SearchWord&gt; getSearchWords(long lastUpdateTime) {    // TODO: 从数据库中取出更新时间&gt;lastUpdateTime的数据    return null;  }}</code></pre><ul><li>上述代码做的是浅拷贝，因为在散列表当中，key存的是搜索关键词，而value实际上存储的是对象的内存地址</li><li>当我们做浅拷贝的时候，我们实际上是把内存地址给拷贝了过来；这样的话当我们做修改的话，实际上两个版本的数据都做了变动，并没有将其彻底的分割开</li><li>我们实际需要的是深拷贝，即不仅仅复制索引，并且复制数据本身<ul><li>递归拷贝对象，对象的引用对象以及引用对象的引用对象</li><li>先将对象序列化，再反序列化成新对象</li></ul></li></ul><pre><code>// 实现递归深拷贝public class Demo {  private HashMap&lt;String, SearchWord&gt; currentKeywords=new HashMap&lt;&gt;();  private long lastUpdateTime = -1;  public void refresh() {    // Deep copy    HashMap&lt;String, SearchWord&gt; newKeywords = new HashMap&lt;&gt;();    for (HashMap.Entry&lt;String, SearchWord&gt; e : currentKeywords.entrySet()) {      SearchWord searchWord = e.getValue();      SearchWord newSearchWord = new SearchWord(              searchWord.getKeyword(), searchWord.getCount(), searchWord.getLastUpdateTime());      newKeywords.put(e.getKey(), newSearchWord);    }    // 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);    long maxNewUpdatedTime = lastUpdateTime;    for (SearchWord searchWord : toBeUpdatedSearchWords) {      if (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) {        maxNewUpdatedTime = searchWord.getLastUpdateTime();      }      if (newKeywords.containsKey(searchWord.getKeyword())) {        SearchWord oldSearchWord = newKeywords.get(searchWord.getKeyword());        oldSearchWord.setCount(searchWord.getCount());        oldSearchWord.setLastUpdateTime(searchWord.getLastUpdateTime());      } else {        newKeywords.put(searchWord.getKeyword(), searchWord);      }    }    lastUpdateTime = maxNewUpdatedTime;    currentKeywords = newKeywords;  }  private List&lt;SearchWord&gt; getSearchWords(long lastUpdateTime) {    // TODO: 从数据库中取出更新时间&gt;lastUpdateTime的数据    return null;  }}// 实现递归深拷贝public Object deepCopy(Object object) {  ByteArrayOutputStream bo = new ByteArrayOutputStream();  ObjectOutputStream oo = new ObjectOutputStream(bo);  oo.writeObject(object);  ByteArrayInputStream bi = new ByteArrayInputStream(bo.toByteArray());  ObjectInputStream oi = new ObjectInputStream(bi);  return oi.readObject();}</code></pre><ul><li>最快的方式，是可以先用浅拷贝来创建，对于需要更新的对象，再用深拷贝的方式创建一份新的对象，来做替换</li></ul><pre><code>public class Demo {  private HashMap&lt;String, SearchWord&gt; currentKeywords=new HashMap&lt;&gt;();  private long lastUpdateTime = -1;  public void refresh() {    // Shallow copy    HashMap&lt;String, SearchWord&gt; newKeywords = (HashMap&lt;String, SearchWord&gt;) currentKeywords.clone();    // 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);    long maxNewUpdatedTime = lastUpdateTime;    for (SearchWord searchWord : toBeUpdatedSearchWords) {      if (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) {        maxNewUpdatedTime = searchWord.getLastUpdateTime();      }      if (newKeywords.containsKey(searchWord.getKeyword())) {        newKeywords.remove(searchWord.getKeyword());      }      newKeywords.put(searchWord.getKeyword(), searchWord);    }    lastUpdateTime = maxNewUpdatedTime;    currentKeywords = newKeywords;  }  private List&lt;SearchWord&gt; getSearchWords(long lastUpdateTime) {    // TODO: 从数据库中取出更新时间&gt;lastUpdateTime的数据    return null;  }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-什么是原型模式&quot;&gt;&lt;a href=&quot;#1-什么是原型模式&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是原型模式&quot;&gt;&lt;/a&gt;1. 什么是原型模式&lt;/h1&gt;&lt;p&gt;如果说对象的创建成本比较大，并且同一个类的不同对象之间的差别不大（大部分字段都相
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="原型模式" scheme="https://www.llchen60.com/tags/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-创建型-建造者模式</title>
    <link href="https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-06-16T04:17:36.000Z</published>
    <updated>2020-06-16T04:18:58.833Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-为什么需要建造者模式"><a href="#1-为什么需要建造者模式" class="headerlink" title="1. 为什么需要建造者模式"></a>1. 为什么需要建造者模式</h1><p>一个关于如何使用建造者模式的问题是：当我们能够使用构造函数或者使用set方法就能够创建对象的时候，我们为什么会需要建造者模式来创建呢？ </p><p>一个例子，假设我们要定义一个类，其大部分的属性都是可以选择的，那么我们可以使用构造函数来做如下的声明： </p><pre><code>public class ResourcePoolConfig {  private static final int DEFAULT_MAX_TOTAL = 8;  private static final int DEFAULT_MAX_IDLE = 8;  private static final int DEFAULT_MIN_IDLE = 0;  private String name;  private int maxTotal = DEFAULT_MAX_TOTAL;  private int maxIdle = DEFAULT_MAX_IDLE;  private int minIdle = DEFAULT_MIN_IDLE;  public ResourcePoolConfig(String name, Integer maxTotal, Integer maxIdle, Integer minIdle) {    if (StringUtils.isBlank(name)) {      throw new IllegalArgumentException(&quot;name should not be empty.&quot;);    }    this.name = name;    if (maxTotal != null) {      if (maxTotal &lt;= 0) {        throw new IllegalArgumentException(&quot;maxTotal should be positive.&quot;);      }      this.maxTotal = maxTotal;    }    if (maxIdle != null) {      if (maxIdle &lt; 0) {        throw new IllegalArgumentException(&quot;maxIdle should not be negative.&quot;);      }      this.maxIdle = maxIdle;    }    if (minIdle != null) {      if (minIdle &lt; 0) {        throw new IllegalArgumentException(&quot;minIdle should not be negative.&quot;);      }      this.minIdle = minIdle;    }  }  //...省略getter方法...}</code></pre><p>在这个例子当中，除了name以外的所有选项都是可选的，因此会看到在构造函数当中，我们做了很多的null check。这样做当参数很多的时候，是很难看懂的。我们可以将其改良为一系列的set()函数，构造函数只实例化NonNull的参数，对于Nullable的参数，我们可以用set方法来实现声明。如下所示： </p><pre><code>public class ResourcePoolConfig {  private static final int DEFAULT_MAX_TOTAL = 8;  private static final int DEFAULT_MAX_IDLE = 8;  private static final int DEFAULT_MIN_IDLE = 0;  private String name;  private int maxTotal = DEFAULT_MAX_TOTAL;  private int maxIdle = DEFAULT_MAX_IDLE;  private int minIdle = DEFAULT_MIN_IDLE;  public ResourcePoolConfig(String name) {    if (StringUtils.isBlank(name)) {      throw new IllegalArgumentException(&quot;name should not be empty.&quot;);    }    this.name = name;  }  public void setMaxTotal(int maxTotal) {    if (maxTotal &lt;= 0) {      throw new IllegalArgumentException(&quot;maxTotal should be positive.&quot;);    }    this.maxTotal = maxTotal;  }  public void setMaxIdle(int maxIdle) {    if (maxIdle &lt; 0) {      throw new IllegalArgumentException(&quot;maxIdle should not be negative.&quot;);    }    this.maxIdle = maxIdle;  }  public void setMinIdle(int minIdle) {    if (minIdle &lt; 0) {      throw new IllegalArgumentException(&quot;minIdle should not be negative.&quot;);    }    this.minIdle = minIdle;  }  //...省略getter方法...}</code></pre><p>上述的set方法还是有一些缺陷的，即：</p><ul><li>首先如果必填的配置项有很多，且都需要放置到构造函数当中，那构造函数就会出现参数列表很长的问题了。</li><li>假设配置项之间有一定的依赖关系，我们需要将配置项之间的依赖关系和校验逻辑找地方放</li><li>如果我们希望类对象是不可变对象，即对象在创建好之后就不能再修改内部的属性值，那么我们就不能再ResourcePoolConfig类当中暴露set()方法</li></ul><p>Builder模式可以很好的解决上述我们的需求，我们可以将校验逻辑放在调用build()方法之前，也可以将构造函数私有化，这样就只能通过建造者来创建ResourcePoolConfig类对象</p><h1 id="2-如何使用建造者模式构建对象"><a href="#2-如何使用建造者模式构建对象" class="headerlink" title="2. 如何使用建造者模式构建对象"></a>2. 如何使用建造者模式构建对象</h1><pre><code>public class ResourcePoolConfig {  private String name;  private int maxTotal;  private int maxIdle;  private int minIdle;  private ResourcePoolConfig(Builder builder) {    this.name = builder.name;    this.maxTotal = builder.maxTotal;    this.maxIdle = builder.maxIdle;    this.minIdle = builder.minIdle;  }  //...省略getter方法...  //我们将Builder类设计成了ResourcePoolConfig的内部类。  //我们也可以将Builder类设计成独立的非内部类ResourcePoolConfigBuilder。  public static class Builder {    private static final int DEFAULT_MAX_TOTAL = 8;    private static final int DEFAULT_MAX_IDLE = 8;    private static final int DEFAULT_MIN_IDLE = 0;    private String name;    private int maxTotal = DEFAULT_MAX_TOTAL;    private int maxIdle = DEFAULT_MAX_IDLE;    private int minIdle = DEFAULT_MIN_IDLE;    public ResourcePoolConfig build() {      // 校验逻辑放到这里来做，包括必填项校验、依赖关系校验、约束条件校验等      if (StringUtils.isBlank(name)) {        throw new IllegalArgumentException(&quot;...&quot;);      }      if (maxIdle &gt; maxTotal) {        throw new IllegalArgumentException(&quot;...&quot;);      }      if (minIdle &gt; maxTotal || minIdle &gt; maxIdle) {        throw new IllegalArgumentException(&quot;...&quot;);      }      return new ResourcePoolConfig(this);    }    public Builder setName(String name) {      if (StringUtils.isBlank(name)) {        throw new IllegalArgumentException(&quot;...&quot;);      }      this.name = name;      return this;    }    public Builder setMaxTotal(int maxTotal) {      if (maxTotal &lt;= 0) {        throw new IllegalArgumentException(&quot;...&quot;);      }      this.maxTotal = maxTotal;      return this;    }    public Builder setMaxIdle(int maxIdle) {      if (maxIdle &lt; 0) {        throw new IllegalArgumentException(&quot;...&quot;);      }      this.maxIdle = maxIdle;      return this;    }    public Builder setMinIdle(int minIdle) {      if (minIdle &lt; 0) {        throw new IllegalArgumentException(&quot;...&quot;);      }      this.minIdle = minIdle;      return this;    }  }}// 这段代码会抛出IllegalArgumentException，因为minIdle&gt;maxIdleResourcePoolConfig config = new ResourcePoolConfig.Builder()        .setName(&quot;dbconnectionpool&quot;)        .setMaxTotal(16)        .setMaxIdle(10)        .setMinIdle(12)        .build();</code></pre><h1 id="3-何时使用"><a href="#3-何时使用" class="headerlink" title="3. 何时使用"></a>3. 何时使用</h1><p>建造者模式用来创建一种类型的复杂对象，通过设置不同的可选参数，定制化地创建不同的对象。建造者模式和工厂模式的区别可以用一个例子来说明，顾客走进一家餐馆点餐，我们利用工厂模式，根据用户不同的选择，来制作不同的食物，比如披萨、汉堡、沙拉。对于披萨来说，用户又有各种配料可以定制，比如奶酪、西红柿、起司，我们通过建造者模式根据用户选择的不同配料来制作披萨。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-为什么需要建造者模式&quot;&gt;&lt;a href=&quot;#1-为什么需要建造者模式&quot; class=&quot;headerlink&quot; title=&quot;1. 为什么需要建造者模式&quot;&gt;&lt;/a&gt;1. 为什么需要建造者模式&lt;/h1&gt;&lt;p&gt;一个关于如何使用建造者模式的问题是：当我们能够使用构造函
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="建造者模式" scheme="https://www.llchen60.com/tags/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-创建型-工厂模式</title>
    <link href="https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-06-14T20:58:25.000Z</published>
    <updated>2020-06-16T04:18:00.563Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-简单工厂-Simple-Factory"><a href="#1-简单工厂-Simple-Factory" class="headerlink" title="1. 简单工厂 Simple Factory"></a>1. 简单工厂 Simple Factory</h1><p>假设要做一个parser类，根据后缀来实例化Parser</p><pre><code>public class RuleConfigSource {  public RuleConfig load(String ruleConfigFilePath) {    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);    IRuleConfigParser parser = RuleConfigParserFactory.createParser(ruleConfigFileExtension);    if (parser == null) {      throw new InvalidRuleConfigException(              &quot;Rule config file format is not supported: &quot; + ruleConfigFilePath);    }    String configText = &quot;&quot;;    //从ruleConfigFilePath文件中读取配置文本到configText中    RuleConfig ruleConfig = parser.parse(configText);    return ruleConfig;  }  private String getFileExtension(String filePath) {    //...解析文件名获取扩展名，比如rule.json，返回json    return &quot;json&quot;;  }}public class RuleConfigParserFactory {  public static IRuleConfigParser createParser(String configFormat) {    IRuleConfigParser parser = null;    if (&quot;json&quot;.equalsIgnoreCase(configFormat)) {      parser = new JsonRuleConfigParser();    } else if (&quot;xml&quot;.equalsIgnoreCase(configFormat)) {      parser = new XmlRuleConfigParser();    } else if (&quot;yaml&quot;.equalsIgnoreCase(configFormat)) {      parser = new YamlRuleConfigParser();    } else if (&quot;properties&quot;.equalsIgnoreCase(configFormat)) {      parser = new PropertiesRuleConfigParser();    }    return parser;  }}</code></pre><p>上述代码是创建了工厂类，并且在工厂类当中制定了静态方法，根据输入参数的不同来分别实例化不同的parser。一般来说工厂当中创建对象的方法都是create开头，或者说明对于instance的操作，常见的方法名比如：</p><ul><li>createXXX()</li><li>getInstance()</li><li>createInstance()</li><li>newInstance() </li></ul><p>同样，如果要声明的类时很可能可以复用的，那么我们就可以在调用前就创建好，来节省对象创建的时间</p><pre><code>public class RuleConfigParserFactory {  private static final Map&lt;String, RuleConfigParser&gt; cachedParsers = new HashMap&lt;&gt;();  static {    cachedParsers.put(&quot;json&quot;, new JsonRuleConfigParser());    cachedParsers.put(&quot;xml&quot;, new XmlRuleConfigParser());    cachedParsers.put(&quot;yaml&quot;, new YamlRuleConfigParser());    cachedParsers.put(&quot;properties&quot;, new PropertiesRuleConfigParser());  }  public static IRuleConfigParser createParser(String configFormat) {    if (configFormat == null || configFormat.isEmpty()) {      return null;//返回null还是IllegalArgumentException全凭你自己说了算    }    IRuleConfigParser parser = cachedParsers.get(configFormat.toLowerCase());    return parser;  }}</code></pre><h1 id="2-工厂方法"><a href="#2-工厂方法" class="headerlink" title="2. 工厂方法"></a>2. 工厂方法</h1><p>利用多态将if分支逻辑给去掉： </p><pre><code>public interface IRuleConfigParserFactory {  IRuleConfigParser createParser();}public class JsonRuleConfigParserFactory implements IRuleConfigParserFactory {  @Override  public IRuleConfigParser createParser() {    return new JsonRuleConfigParser();  }}public class XmlRuleConfigParserFactory implements IRuleConfigParserFactory {  @Override  public IRuleConfigParser createParser() {    return new XmlRuleConfigParser();  }}public class YamlRuleConfigParserFactory implements IRuleConfigParserFactory {  @Override  public IRuleConfigParser createParser() {    return new YamlRuleConfigParser();  }}public class PropertiesRuleConfigParserFactory implements IRuleConfigParserFactory {  @Override  public IRuleConfigParser createParser() {    return new PropertiesRuleConfigParser();  }}// 关于如何选取需要import的factory，使用hashmap，相当于为工厂类创建了一个简单的工厂；一种委托给别人进行生产的模式思路public class RuleConfigSource {  public RuleConfig load(String ruleConfigFilePath) {    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);    IRuleConfigParserFactory parserFactory = RuleConfigParserFactoryMap.getParserFactory(ruleConfigFileExtension);    if (parserFactory == null) {      throw new InvalidRuleConfigException(&quot;Rule config file format is not supported: &quot; + ruleConfigFilePath);    }    IRuleConfigParser parser = parserFactory.createParser();    String configText = &quot;&quot;;    //从ruleConfigFilePath文件中读取配置文本到configText中    RuleConfig ruleConfig = parser.parse(configText);    return ruleConfig;  }  private String getFileExtension(String filePath) {    //...解析文件名获取扩展名，比如rule.json，返回json    return &quot;json&quot;;  }}//因为工厂类只包含方法，不包含成员变量，完全可以复用，//不需要每次都创建新的工厂类对象，所以，简单工厂模式的第二种实现思路更加合适。public class RuleConfigParserFactoryMap { //工厂的工厂  private static final Map&lt;String, IRuleConfigParserFactory&gt; cachedFactories = new HashMap&lt;&gt;();  static {    cachedFactories.put(&quot;json&quot;, new JsonRuleConfigParserFactory());    cachedFactories.put(&quot;xml&quot;, new XmlRuleConfigParserFactory());    cachedFactories.put(&quot;yaml&quot;, new YamlRuleConfigParserFactory());    cachedFactories.put(&quot;properties&quot;, new PropertiesRuleConfigParserFactory());  }  public static IRuleConfigParserFactory getParserFactory(String type) {    if (type == null || type.isEmpty()) {      return null;    }    IRuleConfigParserFactory parserFactory = cachedFactories.get(type.toLowerCase());    return parserFactory;  }}</code></pre><h1 id="3-Dependency-Injection-框架"><a href="#3-Dependency-Injection-框架" class="headerlink" title="3. Dependency Injection 框架"></a>3. Dependency Injection 框架</h1><p>依赖注入框架想要解决的是在基于Inversion of control的理念下，我们应该如何做，如何简化整个创建对象的过程。</p><p>DI容器底层最基本的设计思路是基于工厂模式来进行的，DI容器就相当于一个大的工厂类，复杂在程序启动的时候，根据配置（需要创建哪些类对象，每个类对象的创建需要依赖哪些其他类的对象）事先创建好对象。当应用程序需要使用某个类对象的时候，直接从容器当中获取即可。</p><p>DI容器的核心功能主要有：</p><ul><li>配置解析</li><li>对象创建</li><li>对象生命周期管理</li></ul><h2 id="3-1-配置解析"><a href="#3-1-配置解析" class="headerlink" title="3.1 配置解析"></a>3.1 配置解析</h2><p>应用需要告知DI容器需要创建哪些对象，需要将由DI容器来创建的类对象和创建类对象的必要信息，放到配置文件当中。容器读取配置文件，根据配置文件提供的信息来创建对象。像在spring当中，就是依靠xml文件或者注解，来告诉spring 用何种方式来创建对象。</p><h2 id="3-2-对象创建"><a href="#3-2-对象创建" class="headerlink" title="3.2 对象创建"></a>3.2 对象创建</h2><p>Spring当中将所有类对象的创建都放到了一个工厂类当中实现</p><h2 id="3-3-对象生命周期管理"><a href="#3-3-对象生命周期管理" class="headerlink" title="3.3 对象生命周期管理"></a>3.3 对象生命周期管理</h2><ul><li><p>通过配置scope属性，决定是每次都返回一个新创建的对象还是每次都返回一个事先创建好的对象 – 单例对象</p></li><li><p>配置是否懒加载；lazy-init</p><ul><li>真正被使用的时候被创建</li><li>在应用启动的时候就事先创建好</li></ul></li><li><p>配置对象的init-method, destroy-method </p><ul><li>DI容器在创建好对象之后，会主动调用init-method属性指定的方法来初始化对象</li><li>在对象被最终销毁之前，DI容器会主动调用destroy-method属性指定的方法来做一些清理工作</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-简单工厂-Simple-Factory&quot;&gt;&lt;a href=&quot;#1-简单工厂-Simple-Factory&quot; class=&quot;headerlink&quot; title=&quot;1. 简单工厂 Simple Factory&quot;&gt;&lt;/a&gt;1. 简单工厂 Simple Factory
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="工厂模式" scheme="https://www.llchen60.com/tags/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>思维模型的搜集/整理</title>
    <link href="https://www.llchen60.com/%E6%80%9D%E7%BB%B4%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%90%9C%E9%9B%86-%E6%95%B4%E7%90%86/"/>
    <id>https://www.llchen60.com/%E6%80%9D%E7%BB%B4%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%90%9C%E9%9B%86-%E6%95%B4%E7%90%86/</id>
    <published>2020-06-12T05:46:32.000Z</published>
    <updated>2020-06-16T04:35:44.663Z</updated>
    
    <content type="html"><![CDATA[<p>看到了Adam Amran的<a href="https://untools.co/，感觉是有一些元知识是衍生的根本，希望能够用这篇blog作为总结分享的集散地，把自己看到的认为在某些方面有实际效用的思维模型分享给大家。" target="_blank" rel="noopener">https://untools.co/，感觉是有一些元知识是衍生的根本，希望能够用这篇blog作为总结分享的集散地，把自己看到的认为在某些方面有实际效用的思维模型分享给大家。</a></p><h1 id="1-问题树-Issue-Tree"><a href="#1-问题树-Issue-Tree" class="headerlink" title="1. 问题树 - Issue Tree"></a>1. 问题树 - <a href="https://untools.co/issue-trees" target="_blank" rel="noopener">Issue Tree</a></h1><h2 id="1-1-是什么"><a href="#1-1-是什么" class="headerlink" title="1.1 是什么"></a>1.1 是什么</h2><ul><li>一个问题地图</li><li>旨在给你需要解决的问题一个清晰而系统的思考方式</li><li>帮助你对问题进行拆分，其实很符合divide and conquer 即分治的思想</li></ul><p>对自己而言，确实有在做，在思考。值得注意且需要加强的一点是MECE原则 – mutually exclusive, collectively exhaustive。 对提高思维的完备性很有作用</p><h2 id="1-2-怎么做"><a href="#1-2-怎么做" class="headerlink" title="1.2 怎么做"></a>1.2 怎么做</h2><ul><li><p>问题树应该能够覆盖所有的问题，需要非常细致</p></li><li><p>一些需要遵循的原则</p><ul><li><p><strong>MECE - mutually exclusive, collectively exhaustive</strong> </p><ul><li><strong>需要做到相互之间没有交集，并集即为全集</strong></li></ul></li><li><p>不要过度纠结于太小的细节，需要先做大类目的划分，来定义问题</p></li><li><p>二八法则，专注于起于数据的有价值的问题</p></li></ul></li></ul><h1 id="2-Second-order-thinking"><a href="#2-Second-order-thinking" class="headerlink" title="2. Second-order thinking"></a>2. <a href="https://untools.co/second-order-thinking" target="_blank" rel="noopener">Second-order thinking</a></h1><h2 id="2-1-Overview"><a href="#2-1-Overview" class="headerlink" title="2.1 Overview"></a>2.1 Overview</h2><p>有的时候我们下的决定看起来直观上会给我们带来好处，但是长远看来是对我们不利的。我们通常的思考链条是 需求 - 设定方案 - 评估方案 - 执行。其实大到公司的项目，小到晚上吃什么，我们的脑海里都会先给出需求，饿了，需要吃饭。到设定方案，在家吃vs出去吃，然后是吃什么，然后做出决定，并且按照决定来执行。</p><p>这种思考方式希望你做的是在要做出决定的时候，在想了决定的直接影响之后。再多问自己一个问题，即 – 然后呢？ 这个决定后续还会带来什么结果呢？ </p><p><strong>从事情发展的阶段来看，思考二度的发展；也可以从时间维度，去思考做出的决定在接下来几天，几个月，甚至相对更长的时间里可能对你带来的影响。</strong></p><h1 id="3-第一性原理"><a href="#3-第一性原理" class="headerlink" title="3. 第一性原理"></a>3. 第一性原理</h1><p>在每一种系统的探索当中，存在第一性原理，这是一个最基本的命题或假设，不能被忽略或删除，也不能被违反。</p><p>首先是归纳法与演绎法的对比，我们生活中最经常使用的是归纳法，即根据经验，现象到结果的链条来总结事情是如何发生的；而演绎法是基于一些元知识，做出自己的推论。</p><p>第一性原理 – First Principle，说的就是不能被省略，不能被删除，不能违反的最基本的命题或假设。是演绎法的一种，即从根本原理上，剔除干扰因素和常识性知识的思考方法。目的是希望能够将人从错综复杂的现实问题中换一个视角，将复杂的事情努力转化为简单的结构，来从源头上理解。</p><p>“我们运用第一性原理，而不是比较思维去思考问题是非常重要的。我们在生活中总是倾向于比较，对别人已经做过或者正在做的事情我们也都去做，这样发展的结果只能产生细小的迭代发展。</p><p>第一性原理的思想方式是用物理学的角度看待世界，也就是说一层层拨开事物表象，看到里面的本质，再从本质一层层往上走。”</p><h2 id="3-1-如何使用第一性原理"><a href="#3-1-如何使用第一性原理" class="headerlink" title="3.1 如何使用第一性原理"></a>3.1 如何使用第一性原理</h2><ul><li><p>苏格拉底式的提问</p><ul><li>问题源头，源起，具体表现形式？</li><li>这个情况总是发生么？什么因素会导致问题出现？</li><li>假设的证据在哪里？是否可靠？</li><li>替代观点和角度</li><li>影响和后果</li><li>对问题本身的质疑</li></ul></li><li><p>实践过程</p><ul><li>溯源</li><li>拆解</li><li>重构</li><li>迭代</li></ul></li><li><p>比较思维 vs 第一性原理</p><ul><li>看资讯</li><li>自己总结分析想法</li></ul></li></ul><h1 id="4-抽象梯子"><a href="#4-抽象梯子" class="headerlink" title="4. 抽象梯子"></a>4. 抽象梯子</h1><p>通过在不同的抽象层的移动来更好的构建你的问题。我们可以向上移动，从更大的视角看问题，看到树木背后的森林；也可以向下移动，来演化出一个更加精细的解决方案。</p><h2 id="4-1-如何使用"><a href="#4-1-如何使用" class="headerlink" title="4.1 如何使用"></a>4.1 如何使用</h2><ul><li>从一个普通的问题开始</li><li>通过问为什么来获得更大更远的视角</li><li>通过问如何做来逐步获得一个更具体的解决方案</li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://untools.co/issue-trees" target="_blank" rel="noopener">https://untools.co/issue-trees</a></li><li><a href="https://medium.com/@idtimw/%E6%80%9D%E7%BB%B4%E6%A8%A1%E5%9E%8B03-first-principles-%E7%AC%AC%E4%B8%80%E6%80%A7%E5%8E%9F%E7%90%86-7571fc664faf" target="_blank" rel="noopener">https://medium.com/@idtimw/%E6%80%9D%E7%BB%B4%E6%A8%A1%E5%9E%8B03-first-principles-%E7%AC%AC%E4%B8%80%E6%80%A7%E5%8E%9F%E7%90%86-7571fc664faf</a></li><li><a href="http://fund.jrj.com.cn/2018/06/04151524634381.shtml" target="_blank" rel="noopener">http://fund.jrj.com.cn/2018/06/04151524634381.shtml</a></li><li><a href="https://36kr.com/p/5068808" target="_blank" rel="noopener">https://36kr.com/p/5068808</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;看到了Adam Amran的&lt;a href=&quot;https://untools.co/，感觉是有一些元知识是衍生的根本，希望能够用这篇blog作为总结分享的集散地，把自己看到的认为在某些方面有实际效用的思维模型分享给大家。&quot; target=&quot;_blank&quot; rel=&quot;noop
      
    
    </summary>
    
    
      <category term="Notes" scheme="https://www.llchen60.com/categories/Notes/"/>
    
    
      <category term="思维模型" scheme="https://www.llchen60.com/tags/%E6%80%9D%E7%BB%B4%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-创建型-单例模式</title>
    <link href="https://www.llchen60.com/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.llchen60.com/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-06-11T22:00:48.000Z</published>
    <updated>2020-06-13T05:00:36.811Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-为什么需要单例模式"><a href="#1-为什么需要单例模式" class="headerlink" title="1. 为什么需要单例模式"></a>1. 为什么需要单例模式</h1><p>windows系统的任务管理器，只能有一个,唯一性的原因：</p><ol><li>如果能弹出多个窗口，且这些窗口的内容完全一致，全都是重复对象，那势必会浪费资源，尤其是任务管理器会需要进入内核态调取各种状态信息，会对性能造成一定的影响。</li><li>而且多个窗口之间需要保持一致性，绝对的同步，相互之间的同步也是资源的浪费。</li></ol><p>现实中的例子，就是为了节约系统资源，有时需要确保系统中某个类只有唯一一个实例，当这个实例创建成功以后，我们无法再创建一个同类型的其他对象，所有的操作都只能基于这个唯一的实例。</p><h2 id="1-1-处理资源的访问冲突"><a href="#1-1-处理资源的访问冲突" class="headerlink" title="1.1 处理资源的访问冲突"></a>1.1 处理资源的访问冲突</h2><p>下述代码自定义了一个往文件当中打印日志的logger类： </p><pre><code>public class Logger {  private FileWriter writer;  public Logger() {    File file = new File(&quot;/Users/leilei/log.txt&quot;);    writer = new FileWriter(file, true); //true表示追加写入  }  public void log(String message) {    writer.write(mesasge);  }}// Logger类的应用示例：public class UserController {  private Logger logger = new Logger();  public void login(String username, String password) {    // ...省略业务逻辑代码...    logger.log(username + &quot; logined!&quot;);  }}public class OrderController {  private Logger logger = new Logger();  public void create(OrderVo order) {    // ...省略业务逻辑代码...    logger.log(&quot;Created an order: &quot; + order.toString());  }}</code></pre><p>这段代码的问题在于每个类在实现的过程中都创建了一个新的Logger对象，如果我们同时创建了两个controller，然后执行的话，会同时写入同一个文件当中，这会有可能导致日志信息互相覆盖的情况。</p><p>想要解决这个问题，我们需要加上类级别的锁，让所有的对象都能够共享一把锁：</p><pre><code>public class Logger {  private FileWriter writer;  public Logger() {    File file = new File(&quot;/Users/wangzheng/log.txt&quot;);    writer = new FileWriter(file, true); //true表示追加写入  }  public void log(String message) {    synchronized(Logger.class) { // 类级别的锁      writer.write(mesasge);    }  }}</code></pre><p>我们也可以使用单例模式，使得程序当中只允许创建一个Logger对象，所有的线程共享这一个Logger对象，共享一个FileWriter对象（本身有对象级别的线程安全的保障）</p><pre><code>public class Logger {  private FileWriter writer;  private static final Logger instance = new Logger();  private Logger() {    File file = new File(&quot;/Users/leilei/log.txt&quot;);    writer = new FileWriter(file, true); //true表示追加写入  }  public static Logger getInstance() {    return instance;  }  public void log(String message) {    writer.write(mesasge);  }}// Logger类的应用示例：public class UserController {  public void login(String username, String password) {    // ...省略业务逻辑代码...    Logger.getInstance().log(username + &quot; logined!&quot;);  }}public class OrderController {    public void create(OrderVo order) {    // ...省略业务逻辑代码...    Logger.getInstance().log(&quot;Created a order: &quot; + order.toString());  }}</code></pre><h2 id="1-2-表示全局唯一类"><a href="#1-2-表示全局唯一类" class="headerlink" title="1.2 表示全局唯一类"></a>1.2 表示全局唯一类</h2><p>对于只应该在系统当中保存一份的数据，比较适合设计为单例类。</p><pre><code>import java.util.concurrent.atomic.AtomicLong;public class IdGenerator {  // AtomicLong是一个Java并发库中提供的一个原子变量类型,  // 它将一些线程不安全需要加锁的复合操作封装为了线程安全的原子操作，  // 比如下面会用到的incrementAndGet().  private AtomicLong id = new AtomicLong(0);  private static final IdGenerator instance = new IdGenerator();  private IdGenerator() {}  public static IdGenerator getInstance() {    return instance;  }  public long getId() {     return id.incrementAndGet();  }}// IdGenerator使用举例long id = IdGenerator.getInstance().getId();</code></pre><h1 id="2-单例模式概述"><a href="#2-单例模式概述" class="headerlink" title="2. 单例模式概述"></a>2. 单例模式概述</h1><ul><li><p>单例的定义</p><ul><li>一个类只允许创建唯一一个对象，那这个类就是一个单例类</li></ul></li><li><p>对象的唯一性指</p><ul><li>进程内只允许创建一个对象</li><li>进程之间是不唯一的</li></ul></li></ul><h2 id="2-1-模拟任务管理类"><a href="#2-1-模拟任务管理类" class="headerlink" title="2.1 模拟任务管理类"></a>2.1 模拟任务管理类</h2><pre><code>class TaskManager{     public TaskManager() {...} //初始化窗口     public void displayProcesses()  {……} //显示进程     public void  displayServices() {……} //显示服务}</code></pre><p>对其进行重构，为了使其是单一实例的，那我们需要禁止类的外部直接使用new来创建对象  —–&gt;  将其构造函数的可见性变为private</p><pre><code>public TaskManager() {...}</code></pre><p>在类内部创建对象，保存这个唯一实例</p><pre><code>private static TaskManager tm = null;public static TaskManager getInstance() {    if (tm == null) {        tm = new TaskManager();    }    return tm;}</code></pre><p><code>getInstance()</code>定义成一个静态方法，这样可以直接通过类名来使用</p><h2 id="2-2-定义"><a href="#2-2-定义" class="headerlink" title="2.2 定义"></a>2.2 定义</h2><blockquote><p>单例模式(Singleton Pattern)：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式是一种对象创建型模式。</p></blockquote><ol><li>只有一个实例</li><li>必须自行创建这个实例</li><li>必须自行向整个系统提供这个实例</li></ol><p><img src="https://i.loli.net/2020/02/03/vKPVAeCrImYXq1U.gif" alt="s1.gif"></p><h2 id="2-3-负载均衡器的设计与实现"><a href="#2-3-负载均衡器的设计与实现" class="headerlink" title="2.3 负载均衡器的设计与实现"></a>2.3 负载均衡器的设计与实现</h2><p> Sunny软件公司承接了一个服务器负载均衡(Load Balance)软件的开发工作，该软件运行在一台负载均衡服务器上，可以将并发访问和数据流量分发到服务器集群中的多台设备上进行并发处理，提高系统的整体处理能力，缩短响应时间。由于集群中的服务器需要动态删减，且客户端请求需要统一分发，因此需要确保负载均衡器的唯一性，只能有一个负载均衡器来负责服务器的管理和请求的分发，否则将会带来服务器状态的不一致以及请求分配冲突等问题。如何确保负载均衡器的唯一性是该软件成功的关键。</p><p>使用单例模式来设计该负载均衡器： </p><p><img src="https://i.loli.net/2020/02/03/4vJzXqlRCITLUge.gif" alt="s2.gif"></p><pre><code>import java.util.*;//负载均衡器LoadBalancer：单例类，真实环境下该类将非常复杂，包括大量初始化的工作和业务方法，考虑到代码的可读性和易理解性，只列出部分与模式相关的核心代码class LoadBalancer {    //私有静态成员变量，存储唯一实例    private static LoadBalancer instance = null;    //服务器集合    private List serverList = null;    //私有构造函数    private LoadBalancer() {        serverList = new ArrayList();    }    //公有静态成员方法，返回唯一实例    public static LoadBalancer getLoadBalancer() {        if (instance == null) {            instance = new LoadBalancer();        }        return instance;    }    //增加服务器    public void addServer(String server) {        serverList.add(server);    }    //删除服务器    public void removeServer(String server) {        serverList.remove(server);    }    //使用Random类随机获取服务器    public String getServer() {        Random random = new Random();        int i = random.nextInt(serverList.size());        return (String)serverList.get(i);    }}</code></pre><h1 id="3-饿汉式单例模式和懒汉式单例模式"><a href="#3-饿汉式单例模式和懒汉式单例模式" class="headerlink" title="3. 饿汉式单例模式和懒汉式单例模式"></a>3. 饿汉式单例模式和懒汉式单例模式</h1><h2 id="3-1-饿汉式单例模式"><a href="#3-1-饿汉式单例模式" class="headerlink" title="3.1 饿汉式单例模式"></a>3.1 饿汉式单例模式</h2><p><img src="https://i.loli.net/2020/02/03/UAk8topvxWQTwfd.gif" alt="s3.gif"></p><pre><code>class EagerSingleton {     private static final EagerSingleton instance = new EagerSingleton();     private EagerSingleton() { }     public static EagerSingleton getInstance() {        return instance;     }   }</code></pre><p>在类加载的时候，静态变量instance就会被初始化，此时类的私有构造函数会被调用，然后单例类的唯一实例会在这个时候被创建出来。</p><p>恶汉模式的好处是没有延迟加载，这样子是在需要用到它的时候才来执行这个耗时长的初始化过程，可以避免在程序运行的时候才初始化导致的新跟那个问题。</p><h2 id="3-2-懒汉式单例模式"><a href="#3-2-懒汉式单例模式" class="headerlink" title="3.2 懒汉式单例模式"></a>3.2 懒汉式单例模式</h2><p><img src="https://i.loli.net/2020/02/03/bDLQtESdzF8Ugmq.gif" alt="s4.gif"></p><p>在第一个调用getInstance()方法的时候进行实例化。又叫做延迟加载技术——在需要的时候再加载实例，为了避免多个线程同时调用getInstance()方法，我们需要使用<strong><em>synchronized关键字</em></strong>：</p><pre><code>class LazySingleton {     private static LazySingleton instance = null;     private LazySingleton() { }     synchronized public static LazySingleton getInstance() {         if (instance == null) {            instance = new LazySingleton();         }        return instance;     }}</code></pre><p>getInstance()方法带锁，并发度很低，如果频繁调用，需要频繁开关锁的话，效率是很低的。</p><h2 id="3-3-兼顾效率和安全性的方式-饱汉-饿汉"><a href="#3-3-兼顾效率和安全性的方式-饱汉-饿汉" class="headerlink" title="3.3 兼顾效率和安全性的方式(饱汉+饿汉)"></a>3.3 兼顾效率和安全性的方式(饱汉+饿汉)</h2><pre><code>class LazySingleton {     private static LazySingleton instance；     private LazySingleton() { }     public static LazySingleton getInstance() {         if (instance == null) {            synchronized(LazySingleton.class) {                instance = new LazySingleton();             }        }        return instance;     }}</code></pre><h2 id="3-4-使用静态内部类"><a href="#3-4-使用静态内部类" class="headerlink" title="3.4 使用静态内部类"></a>3.4 使用静态内部类</h2><p>利用Java的静态内部类，因为静态内部类只有在被调用的时候，才会被加载。而静态内部类的唯一性，线程安全型都由JVM来保证。</p><p>public class LazySingleton {<br>    private static class LazySingletonHolder{<br>        private static final LazySingleton instance = new LazySingleton();<br>    }</p><pre><code>public static LazySingleton getInstance() {    return LazySingletonHolder.instance;}</code></pre><p>}</p><h1 id="4-单例的问题"><a href="#4-单例的问题" class="headerlink" title="4. 单例的问题"></a>4. 单例的问题</h1><ul><li>违背了基于接口而非实现的设计原则，如果我们想要更改的话，是需要到每个类的位置去做更改的</li><li>单例会隐藏类之间的依赖关系<ul><li>一般来说我们通过构造函数，参数传递来声明类之间的依赖关系</li><li>单例不需要显示创建，不需要依赖参数传递，在函数中直接调用</li><li>对代码的扩展性不友好<h1 id="5-优缺点分析"><a href="#5-优缺点分析" class="headerlink" title="5. 优缺点分析"></a>5. 优缺点分析</h1></li></ul></li></ul><h2 id="5-1-优点"><a href="#5-1-优点" class="headerlink" title="5.1 优点"></a>5.1 优点</h2><ol><li>提供了对唯一实例的访问控制</li><li>因为内存中只存在一个对象，因此可以节约系统资源。尤其是对于一些需要频繁创建和销毁的对象，单例模式可以很大程度上提高系统性能</li></ol><h2 id="5-2-缺点"><a href="#5-2-缺点" class="headerlink" title="5.2 缺点"></a>5.2 缺点</h2><ol><li>扩展困难</li><li>职责相对比较重。因为单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身的功能融合到一起。</li><li>一些语言的垃圾自动回收技术，如果实例化的对象在一段时间内没有被使用，系统会认为它是垃圾，会自动销毁并回收资源。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-为什么需要单例模式&quot;&gt;&lt;a href=&quot;#1-为什么需要单例模式&quot; class=&quot;headerlink&quot; title=&quot;1. 为什么需要单例模式&quot;&gt;&lt;/a&gt;1. 为什么需要单例模式&lt;/h1&gt;&lt;p&gt;windows系统的任务管理器，只能有一个,唯一性的原因：&lt;/p
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="Design Pattern" scheme="https://www.llchen60.com/tags/Design-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>设计原则，编程规范的总结</title>
    <link href="https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%EF%BC%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83%E7%9A%84%E6%80%BB%E7%BB%93/"/>
    <id>https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%EF%BC%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83%E7%9A%84%E6%80%BB%E7%BB%93/</id>
    <published>2020-06-07T18:12:00.000Z</published>
    <updated>2020-06-11T04:21:56.586Z</updated>
    
    <content type="html"><![CDATA[<p>本文作为一个对于整理过的设计原则和思想的总结，包括：</p><ul><li>面向对象<ul><li>封装、继承、抽象、多态</li><li>面向对象编程 vs 面向过程编程</li><li>面向对象分析、设计、编程</li><li>接口 vs 抽象类</li><li>基于接口而非实现编程</li><li>多用组合少用继承</li><li>贫血模式 vs 充血模式 </li></ul></li><li>设计原则<ul><li>单一职责原则</li><li>开闭原则</li><li>里氏替换原则</li><li>接口隔离原则</li><li>依赖倒置原则</li><li>DRY</li><li>KISS</li><li>YAGNI</li><li>LOD</li></ul></li><li>规范与重构<ul><li>目的，对象，时机，方法</li><li>单元测试和代码的可测试性</li><li>大重构</li><li>小重构</li></ul></li></ul><h1 id="1-代码质量的评判标准"><a href="#1-代码质量的评判标准" class="headerlink" title="1. 代码质量的评判标准"></a>1. 代码质量的评判标准</h1><ul><li>常用评价标准<ul><li>最常用<ul><li>可维护性</li><li>可读性</li><li>可扩展性</li></ul></li><li>其他<ul><li>灵活性</li><li>简洁性</li><li>可复用性</li><li>可测试性</li></ul></li></ul></li><li>如何写出高质量代码？<ul><li>设计思想</li><li>设计原则</li><li>设计模式</li><li>编码规范</li><li>重构技巧</li></ul></li></ul><h1 id="2-面向对象"><a href="#2-面向对象" class="headerlink" title="2. 面向对象"></a>2. 面向对象</h1><ul><li><p>特性</p><ul><li>封装<ul><li>隐藏信息，数据访问保护</li></ul></li><li>继承<ul><li>is a</li></ul></li><li>多态<ul><li>子类可以替代父类的模式</li><li>在实际代码运行当中，通过调用子类的方法来实现</li></ul></li><li>抽象<ul><li>隐藏类的具体实现方法</li><li>使得修改实现不需要改变定义</li></ul></li></ul></li><li><p>面向对象设计 – 如何设计出具体的类</p><ul><li>划分职责</li><li>定义类及其属性和方法</li><li>定义类和类之间的交互关系</li><li>将类组装起来并提供执行入口</li></ul></li><li><p>接口 vs 抽象类</p><ul><li><p>接口</p><ul><li>对方法的抽象</li><li>是一种has a的关系</li><li>表示具有某一组行为特性</li><li>为了解决解耦问题，隔离接口和具体实现，提高代码扩展性</li></ul></li><li><p>抽象类</p><ul><li>对成员变量和方法的抽象</li><li>是一种is a的关系</li><li>为了解决代码复用的问题</li></ul></li></ul></li><li><p>贫血模型 vs 充血模型</p><ul><li>MVC  贫血模型</li><li>充血模型的设计<ul><li>与贫血模型的区别在于Service层</li><li>在基于充血模型的开发模式下，将service类中的业务逻辑移动到一个充血的domain领域模型当中</li><li>让Service类的实现依赖这个domain类</li></ul></li></ul></li></ul><h1 id="3-设计原则"><a href="#3-设计原则" class="headerlink" title="3. 设计原则"></a>3. 设计原则</h1><ul><li><p>单一职责原则</p><ul><li>一个类只负责一个职责或者功能</li></ul></li><li><p>开闭原则</p><ul><li>对扩展开放，对修改关闭<ul><li>添加一个新的功能，应该是通过在已有的代码基础上扩展代码(新增模块，类，方法，属性)，而非修改已有的代码的方式来完成的</li><li>指的是以最小的修改代码的代价来完成新功能的开发</li></ul></li></ul></li><li><p>里氏替代原则</p><ul><li>子类对象能够替代程序当中父类对象出现的任何地方，并且保证原来程序的逻辑行为不变及正确性不被破坏。</li><li>理解 Design by contract 按照协议来设计</li><li>父类定义函数的约定/协议</li><li>子类可以改变函数的内部实现逻辑，但不能改变函数的原有约定<ul><li>约定包括<ul><li>函数声明要实现的功能</li><li>对输入 输出 异常的约定</li><li>注释中罗列的特殊说明</li></ul></li></ul></li></ul></li><li><p>接口隔离原则</p><ul><li>客户端不应该强迫依赖它不需要的接口<ul><li>将接口理解为一组接口集合<ul><li>如果部分接口只被部分调用者使用，应该将这部分接口隔离起来，单独给他们使用</li></ul></li><li>理解为单个API接口或函数<ul><li>部分调用者只需要函数的部分功能，那我们就应该将函数拆分为粒度更细的多个函数，让调用者只依赖它需要的那个细粒度的函数</li></ul></li><li>理解为OOP中的接口<ul><li>接口的设计需要尽量单一，不要让接口的实现类和调用者，依赖不需要的接口函数</li></ul></li></ul></li></ul></li><li><p>YAGNI - you ain’t gonna need it </p></li><li><p>LOD - 高内聚，低耦合</p></li><li><p>迪米特法则</p><ul><li>不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口</li></ul></li></ul><h1 id="4-相关的文章"><a href="#4-相关的文章" class="headerlink" title="4. 相关的文章"></a>4. 相关的文章</h1><ol><li><a href="https://llchen60.com/%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0-general/" target="_blank" rel="noopener">架构学习-general</a></li><li><a href="https://llchen60.com/%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0-%E5%8E%9F%E5%88%99/" target="_blank" rel="noopener">架构学习-原则</a></li><li><a href="https://llchen60.com/%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0-%E5%8F%AF%E6%89%A9%E5%B1%95%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">架构学习-可扩展架构模式</a></li><li><a href="https://llchen60.com/%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0-%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%9D%A5%E6%BA%90/" target="_blank" rel="noopener">架构学习-复杂度来源</a></li><li><a href="https://llchen60.com/%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0-%E5%AE%9E%E6%88%98/" target="_blank" rel="noopener">架构学习 - 实战</a></li><li><a href="https://llchen60.com/%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3%E6%A8%A1%E6%9D%BF/" target="_blank" rel="noopener">架构学习 - 架构设计文档模板</a></li><li><a href="https://llchen60.com/%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%B5%81%E7%A8%8B/" target="_blank" rel="noopener">架构学习-架构设计流程</a></li><li><a href="https://llchen60.com/%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0-%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">架构学习-高可用架构模式</a></li><li><a href="https://llchen60.com/%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">架构学习-高性能架构模式</a></li><li><a href="https://llchen60.com/%E5%9F%BA%E4%BA%8E%E5%85%85%E8%A1%80%E6%A8%A1%E5%9E%8B%E7%9A%84DDD%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B/" target="_blank" rel="noopener">基于充血模型的DDD开发模型</a></li><li><a href="https://llchen60.com/SOLID-%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99/" target="_blank" rel="noopener">SOLID-单一职责原则</a></li><li><a href="https://llchen60.com/SOLID-%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/" target="_blank" rel="noopener">SOLID - 开闭原则</a></li><li><a href="https://llchen60.com/SOLID-%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99/" target="_blank" rel="noopener">SOLID - 里氏替换原则</a></li><li><a href="https://llchen60.com/SOLID-%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99/" target="_blank" rel="noopener">SOLID - 接口隔离原则</a></li><li><a href="https://llchen60.com/SOLID-%E4%BE%9D%E8%B5%96%E5%8F%8D%E8%BD%AC%E5%8E%9F%E5%88%99/" target="_blank" rel="noopener">SOLID - 依赖反转原则</a></li><li><a href="https://llchen60.com/KISS-and-YAGNI%E5%8E%9F%E5%88%99/" target="_blank" rel="noopener">KISS and YAGNI原则</a></li><li><a href="https://llchen60.com/DRY-%E5%8E%9F%E5%88%99/" target="_blank" rel="noopener">DRY 原则</a></li><li><a href="https://llchen60.com/%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99-LOD-%E2%80%94-%E9%AB%98%E5%86%85%E8%81%9A%EF%BC%8C%E4%BD%8E%E8%80%A6%E5%90%88/" target="_blank" rel="noopener">迪米特法则 (LOD) — 高内聚，低耦合</a></li><li><a href="https://llchen60.com/%E5%BA%94%E7%94%A8%E8%AE%BE%E8%AE%A1-Practice/" target="_blank" rel="noopener">应用设计 Practice</a></li><li><a href="https://llchen60.com/%E5%85%B3%E4%BA%8E%E6%8F%90%E9%AB%98%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E7%9A%84Tips/" target="_blank" rel="noopener">提高代码质量的Tips</a></li></ol><h1 id="5-实战：ID生成器"><a href="#5-实战：ID生成器" class="headerlink" title="5. 实战：ID生成器"></a>5. 实战：ID生成器</h1><p>使用ID来做服务内部的请求追踪，因为在日志文件当中，不同请求的日志是会交织到一起的。我们需要使用ID来标识哪些日志属于同一个请求。</p><p>因此我们需要做的事情就是给每个请求分配一个唯一的ID，并且保存在请求的上下文当中。Java当中可以将ID存储在ThreadLocal当中，或者使用Slf4j的MDC(Mapped Diagnostic Contexts)来实现。每次打印日志的时候，我们就可以从请求上下文当中取出请求ID，跟日志一块输出。</p><h2 id="5-1-原始的生成ID的代码"><a href="#5-1-原始的生成ID的代码" class="headerlink" title="5.1 原始的生成ID的代码"></a>5.1 原始的生成ID的代码</h2><pre><code>public class IdGenerator {  private static final Logger logger = LoggerFactory.getLogger(IdGenerator.class);  public static String generate() {    String id = &quot;&quot;;    try {      String hostName = InetAddress.getLocalHost().getHostName();      String[] tokens = hostName.split(&quot;\\.&quot;);      if (tokens.length &gt; 0) {        hostName = tokens[tokens.length - 1];      }      char[] randomChars = new char[8];      int count = 0;      Random random = new Random();      while (count &lt; 8) {        int randomAscii = random.nextInt(122);        if (randomAscii &gt;= 48 &amp;&amp; randomAscii &lt;= 57) {          randomChars[count] = (char)(&#39;0&#39; + (randomAscii - 48));          count++;        } else if (randomAscii &gt;= 65 &amp;&amp; randomAscii &lt;= 90) {          randomChars[count] = (char)(&#39;A&#39; + (randomAscii - 65));          count++;        } else if (randomAscii &gt;= 97 &amp;&amp; randomAscii &lt;= 122) {          randomChars[count] = (char)(&#39;a&#39; + (randomAscii - 97));          count++;        }      }      id = String.format(&quot;%s-%d-%s&quot;, hostName,              System.currentTimeMillis(), new String(randomChars));    } catch (UnknownHostException e) {      logger.warn(&quot;Failed to get the host name.&quot;, e);    }    return id;  }}</code></pre><ul><li>上述代码存在的问题<ul><li>static 方法可测试性太低</li><li>generate函数的代码实现依赖运行环境，时间函数以及随机函数，本身的可测试性也不强</li><li>随机字符串生成代码难以看懂</li><li>有太多的魔法数，需要告诉读代码的人这些都是什么意思才可以的</li></ul></li></ul><h2 id="5-2-完善后的代码"><a href="#5-2-完善后的代码" class="headerlink" title="5.2 完善后的代码"></a>5.2 完善后的代码</h2><pre><code>public interface IdGenerator {  String generate();}public interface LogTraceIdGenerator extends IdGenerator {}public class RandomIdGenerator implements IdGenerator {  private static final Logger logger = LoggerFactory.getLogger(RandomIdGenerator.class);  @Override  public String generate() {    String substrOfHostName = getLastfieldOfHostName();    long currentTimeMillis = System.currentTimeMillis();    String randomString = generateRandomAlphameric(8);    String id = String.format(&quot;%s-%d-%s&quot;,            substrOfHostName, currentTimeMillis, randomString);    return id;  }  private String getLastfieldOfHostName() {    String substrOfHostName = null;    try {      String hostName = InetAddress.getLocalHost().getHostName();      String[] tokens = hostName.split(&quot;\\.&quot;);      substrOfHostName = tokens[tokens.length - 1];      return substrOfHostName;    } catch (UnknownHostException e) {      logger.warn(&quot;Failed to get the host name.&quot;, e);    }    return substrOfHostName;  }  private String generateRandomAlphameric(int length) {    char[] randomChars = new char[length];    int count = 0;    Random random = new Random();    while (count &lt; length) {      int maxAscii = &#39;z&#39;;      int randomAscii = random.nextInt(maxAscii);      boolean isDigit= randomAscii &gt;= &#39;0&#39; &amp;&amp; randomAscii &lt;= &#39;9&#39;;      boolean isUppercase= randomAscii &gt;= &#39;A&#39; &amp;&amp; randomAscii &lt;= &#39;Z&#39;;      boolean isLowercase= randomAscii &gt;= &#39;a&#39; &amp;&amp; randomAscii &lt;= &#39;z&#39;;      if (isDigit|| isUppercase || isLowercase) {        randomChars[count] = (char) (randomAscii);        ++count;      }    }    return new String(randomChars);  }}//代码使用举例LogTraceIdGenerator logTraceIdGenerator = new RandomIdGenerator();</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文作为一个对于整理过的设计原则和思想的总结，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;面向对象&lt;ul&gt;
&lt;li&gt;封装、继承、抽象、多态&lt;/li&gt;
&lt;li&gt;面向对象编程 vs 面向过程编程&lt;/li&gt;
&lt;li&gt;面向对象分析、设计、编程&lt;/li&gt;
&lt;li&gt;接口 vs 抽象类&lt;/li&gt;

      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="设计原则" scheme="https://www.llchen60.com/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
      <category term="编程规范" scheme="https://www.llchen60.com/tags/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>价格心理学</title>
    <link href="https://www.llchen60.com/%E4%BB%B7%E6%A0%BC%E5%BF%83%E7%90%86%E5%AD%A6/"/>
    <id>https://www.llchen60.com/%E4%BB%B7%E6%A0%BC%E5%BF%83%E7%90%86%E5%AD%A6/</id>
    <published>2020-05-31T01:08:14.000Z</published>
    <updated>2020-06-05T03:37:44.103Z</updated>
    
    <content type="html"><![CDATA[<p>一些定价，看价的技巧。无论你是销售者还是购买者，应该都能从中得到一些对你更有利的定价策略。</p><h1 id="1-使自己的价格看起来更低"><a href="#1-使自己的价格看起来更低" class="headerlink" title="1. 使自己的价格看起来更低"></a>1. 使自己的价格看起来更低</h1><p>我们可以通过一些方式来影响在人们印象当中的产品的价格。当人们将你的产品价格和参考产品比较的时候，你可以用某些方式施加影响，来使得他们拿更低的价格来进行比较。</p><p>这样做有效的原因是我们的大脑是很懒的，我们在大脑中不会记一个物品的数字上的价格，很有可能是记录相对的高或者低</p><h4 id="1-对最左侧的数字减1"><a href="#1-对最左侧的数字减1" class="headerlink" title="1. 对最左侧的数字减1"></a>1. 对最左侧的数字减1</h4><p>通过比较转化率，我们会发现减少一分钱，即例如从$1 到$0.99，转化率就提高了1个百分点。</p><p><img src="https://i.loli.net/2020/05/31/Xr2xVAUkP7SsKM5.jpg" alt="conversion rate in Gumroad.jpg"></p><p>很多人都知道.99的魔力，但是转化率更大的转变出现在当最左侧的数字发生了改变的时候。大脑意识是有锚定效应的，即我们会认为$2.99是属于2的范畴，而$3是属于3的范畴，他们之间相差很大。同理出现在199和200之间，诸如此类。</p><h4 id="2-选择更少音节的价格"><a href="#2-选择更少音节的价格" class="headerlink" title="2. 选择更少音节的价格"></a><strong>2. 选择更少音节的价格</strong></h4><p>价格的整个读音（音节数量）也会影响最终对于价格的认知[3]。当我们需要处理更多音节的刺激的时候，我们会需要更多的意识来处理这种刺激，这同样适用于数字，当我们需要花更多的时间处理这个数字的时候，我们潜意识会认为这个数字非常大。</p><p>当包含更少的读音的时候，人们会认为价格比实际上低。</p><p>这不仅仅发生在读出价格的时候，研究表明哪怕我们看到的是写出来的价格，我们的大脑也会潜意识当中将其编码成听觉版本。[4]</p><h4 id="3-用更小的字号来展示价格"><a href="#3-用更小的字号来展示价格" class="headerlink" title="3. 用更小的字号来展示价格"></a><strong>3. 用更小的字号来展示价格</strong></h4><p>我们的大脑对于大小是有概念上的认知的。视觉大小与数字大小的交汇是很模糊的，即我们潜意识可能会认为视觉上用更小的字体也意味着数字本身是更小的。</p><p>同样，对于折扣来说，我们就应该使用尽可能大的字体来展示了。</p><p><img src="https://i.loli.net/2020/05/31/kMWAyd1LVaNsPEF.png" alt="pricing-tactic-3"></p><h4 id="4-移除价格当中的逗号"><a href="#4-移除价格当中的逗号" class="headerlink" title="4. 移除价格当中的逗号"></a><strong>4. 移除价格当中的逗号</strong></h4><p>移除逗号可以使得你的价格看起来更低！[5]</p><p>首先是视觉上，逗号使得整个数字显得更大；<br>其次是如果不加逗号，比如对于1499这个数字，会读成fourteen niety-nine; 但是如果加了逗号，那么就会读成one thousand four hundred and ninty nine. 音节从5个升到了10个。</p><h4 id="5-选择维度更小的词"><a href="#5-选择维度更小的词" class="headerlink" title="5. 选择维度更小的词"></a><strong>5. 选择维度更小的词</strong></h4><p>对于在显示的价格旁边的词，选择要谨慎。有些词是可以左右人们的设想的。举个例子, low friction vs high performance. 通过测试发现在参与者认为两个词语都同等重要的前提下，更多的人选择了带有Low Friction的。如果可以，在价格旁边选择维度更小的一些词。</p><h4 id="6-将物流和订单处理的费用分开"><a href="#6-将物流和订单处理的费用分开" class="headerlink" title="6. 将物流和订单处理的费用分开"></a><strong>6. 将物流和订单处理的费用分开</strong></h4><p>当你要在线销售产品的时候，往往需要支付物流和订单处理的费用。当将价格都分割开的时候，使得人们能够锚定在基础价格上，而不是整个价格。[6]</p><h4 id="7-提供首付金相关的选择"><a href="#7-提供首付金相关的选择" class="headerlink" title="7. 提供首付金相关的选择"></a><strong>7. 提供首付金相关的选择</strong></h4><p>一下子付1000刀和分10个月每次付100刀给人的感觉是完全不一样的。如果可能，我们通过使用月付可以很大程度上提升人们购买的欲望。他们会认为这个价格很低。</p><h4 id="8-提及每天的等值价格"><a href="#8-提及每天的等值价格" class="headerlink" title="8. 提及每天的等值价格"></a><strong>8. 提及每天的等值价格</strong></h4><p>假设我们在做一个月付的东西，30刀每月，这会显得很多。如果说每天一美元，给人感觉就会少一些了。</p><h4 id="9-关于大额的数字，要精准"><a href="#9-关于大额的数字，要精准" class="headerlink" title="9. 关于大额的数字，要精准"></a><strong>9. 关于大额的数字，要精准</strong></h4><p>比如购房的时候，$359,289和$359,000给人的感觉会很不一样，前者触发的是人们对于低价产品的认知；即足够精准，而后者会被默认为是价格很高的产品。除此以外，一个很精确的数字也会让人感觉谈价的余地相对有限；对方在很认真仔细的准备。 </p><h4 id="10-小额的价格放到左侧"><a href="#10-小额的价格放到左侧" class="headerlink" title="10. 小额的价格放到左侧"></a><strong>10. 小额的价格放到左侧</strong></h4><p>当我们设计一个布局的时候，价格应该往左侧放。这是因为在英文当中，我们将上和高质联系到了一起，低和不好的东西联系起来。譬如：</p><ul><li>go up to heaven </li><li>down to hell </li><li>thumbs up </li><li>thumbs down </li><li>get high</li><li>come down</li><li>etc.</li></ul><p>研究也证实了当好词在屏幕上方，坏词在屏幕下方的时候，我们能更快的识别出他们来。类似的概念也出现在数字上，根据研究[7]发现人们会将数字置于自己想象的一条水平方向的线上，从左到右数字依次增大。</p><p>因此小价格放到左侧，对于大家概念中的大价格，放到右侧。</p><h4 id="11-让用户看到价格的乘积-例子"><a href="#11-让用户看到价格的乘积-例子" class="headerlink" title="11. 让用户看到价格的乘积(例子)"></a><strong>11. 让用户看到价格的乘积(例子)</strong></h4><p><img src="https://i.loli.net/2020/06/03/OgXICK9tdBZHEyp.png" alt="price-multiples.png"></p><p>前两个是给了你无限添加topping的选择，从经济上来说是更好的选择，但是经过试验发现人们普遍更加喜欢后面的两个。</p><p>这是因为后面是可以计算的，即pizza的多少和toppings的数量的乘积等于价格。这种优势看起来有点荒唐，但是心理学能够给予解释。我们从小开始就在被训练一下基本的数学连接，比如熟知的九九乘法表，然后这种连接会终身影响我们，使得我们能够对其迅速反应。</p><p>也正因为这种连接，使得我们能够更加快速的处理几个不同部分的信息，并且通过数字连接建立起内容上的连接。</p><h4 id="12-正确使用取整操作"><a href="#12-正确使用取整操作" class="headerlink" title="12. 正确使用取整操作"></a><strong>12. 正确使用取整操作</strong></h4><p>取整的数字会相对容易处理很多，譬如100 vs 98.65。根据研究发现，当用户能够更快的处理分析价格的时候，他们会感觉这个价格感觉上更对。</p><p>与之相对的，消费者会需要更多的精神来处理非取整的价格，因此这种非取整的价格更适合理性消费的场景。</p><p>而对于基于情感进行的消费，使用整数价格会更容易促进销量的提升。</p><p>同样，不要使用像100，5000这样的数字，会很容易让消费者感觉这个价格虚高。</p><p>基于情感，使用整数；基于理性，可以使用带小数的价格。</p><h4 id="13-根据名字和生日调整价格"><a href="#13-根据名字和生日调整价格" class="headerlink" title="13. 根据名字和生日调整价格"></a><strong>13. 根据名字和生日调整价格</strong></h4><p>尽管略显古怪，但是确实很多研究都支持这个结论，即用户更喜欢有他们的名字同样字母的价格，亦或者是包含他们的生日的价格。[8]</p><p>心理学上的理论支持为implicit egotism – 以自我为中心的倾向。我们潜意识里会更加倾向于那些和我们相关的/ 构筑我们自我的事物。</p><h4 id="14-在最优时间展示价格"><a href="#14-在最优时间展示价格" class="headerlink" title="14. 在最优时间展示价格"></a><strong>14. 在最优时间展示价格</strong></h4><p>我们应该首先展示什么？ 你的产品或者价格？ </p><p>我们首先看到的是产品或者价格很大程度上决定了我们决定是否要去买这件产品的标准[9].</p><p>当产品被首先展示出来的时候，用户会根据产品质量，自己的喜爱程度来决定是否要购买</p><p>当价格首先被展示出来的时候，用户会根据这个产品是否值这个价格来决定是否要买。</p><p>当销售奢侈品的时候，就应该先展示产品，再阐明价格；而对于日常使用的产品来说，用户更倾向于先看到价格，再决定是否购买这件产品。</p><h4 id="15-向男士展示红颜色标注的价格"><a href="#15-向男士展示红颜色标注的价格" class="headerlink" title="15. 向男士展示红颜色标注的价格"></a>15. 向男士展示红颜色标注的价格</h4><p>研究[10]表明当价格标签颜色为红色的时候，男士更有可能买这件产品。</p><p>红色价格会成为关注的中心，很有可能变为做出评估的唯一信息。而且常常将红色价格和省钱联系起来。</p><h1 id="2-最大化参考价格"><a href="#2-最大化参考价格" class="headerlink" title="2. 最大化参考价格"></a>2. 最大化参考价格</h1><h4 id="16-使用一个高且精准的价格开始谈价-（从商家角度来看）"><a href="#16-使用一个高且精准的价格开始谈价-（从商家角度来看）" class="headerlink" title="16. 使用一个高且精准的价格开始谈价 （从商家角度来看）"></a>16. 使用一个高且精准的价格开始谈价 （从商家角度来看）</h4><p>基于锚定效应，使用一个更高的价格，往往能够使得最后商定的价格更高。我们不仅仅应该使用一个更高的价格，更应该使用一个更加精确的价格。</p><blockquote><p>If adjustment is viewed as movement along a subjective representational scale, then the resolution of this scale might also influence the amount of adjustment. X units of adjustment along a fine-resolution scale will cover less objective distance than the same number of units of adjustment along a coarse-resolution scale.</p></blockquote><h4 id="17-使用户看到更高的其他价格"><a href="#17-使用户看到更高的其他价格" class="headerlink" title="17. 使用户看到更高的其他价格"></a>17. 使用户看到更高的其他价格</h4><p>同样是通过锚定效应完成操作的，即 使人们能够看到更高的价格，那会潜意识当中也提高对你的产品的估价。</p><h4 id="18-使用户看到更高的数字"><a href="#18-使用户看到更高的数字" class="headerlink" title="18. 使用户看到更高的数字"></a>18. 使用户看到更高的数字</h4><p>依旧是潜意识，在展示价格之前，先使用户看到一些很大的数字，这已经足够来影响用户接下来对于数字相对大小的认知了。</p><p><img src="https://i.loli.net/2020/06/03/qKZ352bCYk9zPVE.png" alt="pricing-tactic-18.png"></p><h4 id="19-提高过去产品的售价"><a href="#19-提高过去产品的售价" class="headerlink" title="19. 提高过去产品的售价"></a>19. 提高过去产品的售价</h4><p>如果你正在推出一个更新版本的产品，针对行业，是可以尝试提高前一代的产品的售价的。新产品的参考价格会依托于上一代的产品，如果我们降价了的话，那新一代产品锚定的是上一代产品，会让用户有这一代产品相对比较贵的感觉。</p><h4 id="20-价格排序应该从高到低"><a href="#20-价格排序应该从高到低" class="headerlink" title="20. 价格排序应该从高到低"></a>20. 价格排序应该从高到低</h4><p>通过降序的排列，我们可以使得用户更有可能去买相对比较贵的选择。</p><p>首先，先看到的价格会成为我们的参考价格，如果初始价格比较高，用户就会生成一个相对比较高的参考价格。这样子的话，当我们降序排列，看到的新的产品往往感觉都会相对更有性价比好一些，就更容易达成交易，且平均值也会相对大一些。</p><p>还有一个原因是人们对于失去的厌恶，价格从低到高排列，失去的是价格的优势感觉，直觉反应是应该选低价的来减少损失。价格从高到低，感觉失去的是品质，直觉应该是选高品质的物品，哪怕价格高一些。中间当然有权衡。</p><h4 id="21-将价格放在大数量的右面-11"><a href="#21-将价格放在大数量的右面-11" class="headerlink" title="21. 将价格放在大数量的右面[11]"></a>21. 将价格放在大数量的右面[11]</h4><ul><li><p>前提条件</p><ul><li><p>单价计算应该是相对比较困难的</p><ul><li>当困难的时候，会更依赖于直觉去进行判断<ul><li>价格开始，注意力集中在花费</li><li>数量开始，注意力集中在潜在的好处</li></ul></li></ul></li><li><p>物品数量最好大于价格的数字</p><ul><li>锚定于数量，忽略价格</li><li>从而认为这是个很值得买的东西</li></ul></li></ul></li></ul><h1 id="3-强调参考价格之间的不同-鸿沟"><a href="#3-强调参考价格之间的不同-鸿沟" class="headerlink" title="3. 强调参考价格之间的不同/鸿沟"></a>3. 强调参考价格之间的不同/鸿沟</h1><h4 id="22-加入视觉上的售价对比"><a href="#22-加入视觉上的售价对比" class="headerlink" title="22. 加入视觉上的售价对比"></a>22. 加入视觉上的售价对比</h4><p>如果你将自己的价格和更高的其他产品价格对比，那么人们就更可能去买你的产品，因为有了对比以后会相对少一些自行去比价的动力了。</p><p>一些小技巧：</p><ul><li>如果视觉上使用不同大小，或者颜色，我们会给消费者一种很流程的体验，消费者会有将颜色的不同和价格上不同程度做通感的趋向。[12]</li><li>出了颜色和大小，视觉上的距离也会对消费者产生的对价格高低的概念产生影响，距离远会认为数字差的会更大[13]</li></ul><h4 id="23-提供一个“诱饵”的购买选择"><a href="#23-提供一个“诱饵”的购买选择" class="headerlink" title="23. 提供一个“诱饵”的购买选择"></a>23. 提供一个“诱饵”的购买选择</h4><p>举个例子：</p><ul><li>提供三个购买选择<ul><li>web only $59</li><li>print only $125 </li><li>web and print $125 </li></ul></li></ul><p>很多人肯定和我一样，刚开始看到的时候会认为第二个选择是错误的，用同等价格，可以购买网页版和纸质版，那么谁会只选择纸质版呢？ 当时经过试验发现就是这个print only的看似无用的选择，产生了锚定效应，即用户对于如何界定关于web 和 print only自己应该付多少钱的认知，通过放置print only的选择，最终选取web and print的人要多很多，整体GMS也有了很大提高。 </p><p><img src="https://i.loli.net/2020/06/05/C964yTjH2awuzqP.png" alt="psychological-pricing-table-3.png"></p><p><img src="https://i.loli.net/2020/06/05/KqY14GgLlTMkbWy.png" alt="psychological-pricing-table-4.png"></p><h1 id="4-减少付款的“心疼感”"><a href="#4-减少付款的“心疼感”" class="headerlink" title="4. 减少付款的“心疼感”"></a>4. 减少付款的“心疼感”</h1><h4 id="24-移除货币符号"><a href="#24-移除货币符号" class="headerlink" title="24. 移除货币符号"></a>24. 移除货币符号</h4><p>付款的心疼感是很容易被触发的，事实上货币符号本身就很容易触发这种情绪，让人们想花的更少。[14]</p><p>同样，需要取舍，即你放在这里的数字如果没有货币符号，是否会变得难以认清，难以明白这串数字代表价格，是需要做trade-off的。</p><h4 id="25-在用户使用前令他们付费"><a href="#25-在用户使用前令他们付费" class="headerlink" title="25. 在用户使用前令他们付费"></a>25. 在用户使用前令他们付费</h4><p>预付对链条中的所有角色都有例。对于生产方，首先可以减少资金的压力；对于消费者，预付往往会使得他们对产品更加满意，因为当先付款的时候，他们会更加专注于购买了物品以后他们获得的好处，而不是花了钱的痛感当中。如果他们已经使用了你的产品再付费，往往会更不情愿付款的。[15]</p><p>这对于那种收月度会员费的模式很有意义，如果是这种模式，那就应该在月初还没开始使用的时候先收费。当然经验也告诉我们确确实实现在大部分的商家都是这么做的。</p><p>同时不要在月底来推送你这个月总共花了多少钱之类的账单明细，这只会降低消费者的购买欲望。</p><h4 id="26-对非工具类的产品给多件折扣"><a href="#26-对非工具类的产品给多件折扣" class="headerlink" title="26. 对非工具类的产品给多件折扣"></a>26. 对非工具类的产品给多件折扣</h4><p>为了减少付费时候的痛感，可以考虑成套销售。成套来购买的时候，用户就很难给单件产品一个很清晰的定价了。而添加的产品最好是非工具类的，即使用的时候会给人带来一些愉悦的感觉的物品。在做描述的时候，也要注意着重去描述一些好玩的场景，者都会给用户带来愉悦的刺激，提高最终的付费比率。</p><h4 id="27-不要将价格昂贵和便宜的物品一起成套销售"><a href="#27-不要将价格昂贵和便宜的物品一起成套销售" class="headerlink" title="27. 不要将价格昂贵和便宜的物品一起成套销售"></a>27. 不要将价格昂贵和便宜的物品一起成套销售</h4><p>这样建议的原因是便宜的物品会改变消费者对于昂贵产品的认知，会认为其更贵，更不值钱。 </p><h4 id="28-将关注点转移到时间相关的方面"><a href="#28-将关注点转移到时间相关的方面" class="headerlink" title="28. 将关注点转移到时间相关的方面"></a>28. 将关注点转移到时间相关的方面</h4><p>当描述我们的产品的时候，尽量避免用金钱作为参考的描述。相反，使用时间概念来描述。</p><p>譬如，Mogilner，Aaker[16]做过的一个关于柠檬饮品的试验，他们做了三个强调不同属性的广告：</p><ul><li>Time: Spend a little time and enjoy C &amp; D’s lemonade</li><li>Money: Spend a little money and enjoy C &amp; D’s lemonade</li><li>Neutral: Enjoy C &amp; D’s lemonade</li></ul><p>实验结果发现时间相关的广告玩虐其他两个，相较而言，人们愿意付双倍的价格来购买柠檬汁。</p><h4 id="29-建立付费中转商"><a href="#29-建立付费中转商" class="headerlink" title="29. 建立付费中转商"></a>29. 建立付费中转商</h4><p>赌场使用代币而不是现金，礼品卡将钱提前存进去，这样做的好处实际上就是将我们把钱拿出口袋的动作发生的时间前移，和我们享用的时间分割开。这样就能够扭曲付费时候的立场，使得不会觉得那么的痛苦。</p><p>这样做行之有效的原因是因为人都是懒的，会不愿意去算各种方式的转化率的问题.</p><h4 id="30-避免直接联系到金钱的语言"><a href="#30-避免直接联系到金钱的语言" class="headerlink" title="30. 避免直接联系到金钱的语言"></a>30. 避免直接联系到金钱的语言</h4><p>the money in your account vs your credits </p><p>通过尽量避免将app内的点数和实际金钱挂钩，就会使得用户失去对于钱的某些概念。</p><p>同时，可以的话不要做1比1 的转化，太容易做这个计算了。可以搞比如说存100送10块之类的，这样的转化就会在1 - 1.1之间，对于用户来说，计算的难度上来，这样计算的人就会少很多了。</p><h4 id="31-强调你的产品的固定成本"><a href="#31-强调你的产品的固定成本" class="headerlink" title="31. 强调你的产品的固定成本"></a>31. 强调你的产品的固定成本</h4><p>消费者会在看到产品以后做出一个价格高低的判断，但是他们也同样在意价格的合理程度。即便你的价格是低的，用户仍然可能认为这个价格不合理；同样，对于相对高的价格，用户也有可能认为非常合适。这取决于以下几个因素：</p><ul><li>你如何定价的？<ul><li>基于成本的定价</li><li>基于供求的定价</li></ul></li></ul><p>用户会认为基于成本的定价更加公平，这也是你可以通过强调产品本身的成本从而给出价格很合适的认知的原因。强调你的产品的原材料非常好，或者其他很费钱的方面，这些信息会使得用户对你的产品价格有个更真切的认知。</p><h4 id="32-对于相似的产品，价格需要有一点不同"><a href="#32-对于相似的产品，价格需要有一点不同" class="headerlink" title="32. 对于相似的产品，价格需要有一点不同"></a>32. 对于相似的产品，价格需要有一点不同</h4><p>你也许经历过选择困难症，往往是选择越多，人们就越难以做出选择。一旦人们做出一个选择，他们就会失去其他选择可能带来的利益。因为对于失去的厌恶，他们就会推迟自己的决定，尤其是当更多的选择在的时候。</p><p>同样有研究者做过这样的实验，实验者询问两组参与者是否想要买一盒口香糖，每组都有以下两种选择</p><ul><li>组1： 同样价格</li><li>组2： 稍稍不同的价格 (62美分 vs 64美分)</li></ul><p><img src="https://i.loli.net/2020/06/05/2RWLMOteuDTbxpC.png" alt="price-differences.png"></p><p>实验结果发现当价格稍稍有些不同的时候，人们更有可能去买一盒口香糖。</p><p>当两个产品有同样的价格的时候，人们无法立刻区分二者的不同，那么他们只能自己主动去寻找特征上的不同。因为主动寻找，所以产品的不同会看着更加明显。</p><p>然而，当你给价格加上一点点不同的时候，你减少了搜索不同的需求。消费者可以很直接的通过价格来区分不同的产品。因为用户对于产品的不同关注的更少，两个产品直观上就会看起来更加雷斯了。这种相似性是的人们更可能去选择一个产品。</p><p><img src="https://i.loli.net/2020/06/05/6JD8M4dX2Rlfor5.png" alt="pricing-tactic-32.png"></p><h4 id="33-使用更加频繁小额的提价"><a href="#33-使用更加频繁小额的提价" class="headerlink" title="33. 使用更加频繁小额的提价"></a>33. 使用更加频繁小额的提价</h4><p>最简单的控制对于价格相对高低的概念的方法是根于刚刚能注意到的不同。比如你的价格是11.99，那么加到12.99算比较合理的，加到19.99就会很夸张了</p><h4 id="34-减小某特征-vs-提价"><a href="#34-减小某特征-vs-提价" class="headerlink" title="34. 减小某特征 vs 提价"></a>34. 减小某特征 vs 提价</h4><p>除了提价，另外可以选择的是在分量上，某个特征上的一定程度的减少。同样要遵循着小额多次的宗旨，一点点来。 </p><h1 id="5-适量使用折扣"><a href="#5-适量使用折扣" class="headerlink" title="5. 适量使用折扣"></a>5. 适量使用折扣</h1><p>如果没有合理使用，折扣是有可能伤害你的事业的。也有人小极端，认为我们永远不应该使用折扣 [17]. 值得注意的是，如果我们的折扣十分频繁，或者折扣力度太大，是会使得消费者对于产品，品牌的认知改变的。消费者可能会等待下一个折扣期才会购买产品了。</p><p>同样，折扣也会降低你的产品的参考价格，使得人们未来更少买（因为觉得你的当前价格高）</p><h4 id="35-遵循100原则"><a href="#35-遵循100原则" class="headerlink" title="35. 遵循100原则"></a>35. 遵循100原则</h4><p>当你的价格低于100的时候，使用百分比折扣，反之直接使用数字；目的是使得折扣的程度看起来更大。</p><h4 id="36-给折扣一个原因"><a href="#36-给折扣一个原因" class="headerlink" title="36. 给折扣一个原因"></a>36. 给折扣一个原因</h4><p>为了最大化折扣的有效性，我们需要解释为什么提供这样的折扣。</p><p>比如every day low pricing store 指向的是供应商给的折扣，当你提供折扣的理由的时候，你在说明他的临时性。因此人们不太会将你的折扣价和他内在隐含的实际价值做出强关联。</p><p><img src="https://i.loli.net/2020/06/05/3TSGCNQscynW6gi.png" alt="pricing-tactic-36.png"></p><h4 id="37-提供更好计算的折扣"><a href="#37-提供更好计算的折扣" class="headerlink" title="37. 提供更好计算的折扣"></a>37. 提供更好计算的折扣</h4><p>提供更好计算的折扣可以显得折扣更大的</p><h4 id="38-在月末打折"><a href="#38-在月末打折" class="headerlink" title="38. 在月末打折"></a>38. 在月末打折</h4><p>当我们总钱数少的时候，我们会更不愿意付钱出去。到了月末，很多人的钱包都会空下来，就算购买，也很可能只能买折扣的东西了。</p><h4 id="39-将你的促销价放在原价的右侧"><a href="#39-将你的促销价放在原价的右侧" class="headerlink" title="39. 将你的促销价放在原价的右侧"></a>39. 将你的促销价放在原价的右侧</h4><p>研究[18]表明当促销价放在原价的右边的时候，消费者会觉得折扣更大一些。</p><h4 id="40-只给低价商品折扣"><a href="#40-只给低价商品折扣" class="headerlink" title="40. 只给低价商品折扣"></a>40. 只给低价商品折扣</h4><p>折扣有可能有害的，尤其是当你结束一个折扣的时候，人们可能会选择竞品，或者等待下一个折扣期。</p><p>那么这种副作用会在什么时候因为什么而生效呢？ 答案在于你的品牌的定位，是高质量的还是低质量的产品，高质量商品就应该集中注意力于质量</p><h4 id="41-逐渐减小折扣的百分比"><a href="#41-逐渐减小折扣的百分比" class="headerlink" title="41. 逐渐减小折扣的百分比"></a>41. 逐渐减小折扣的百分比</h4><p>这种方式能够吸引流量，也能够保证自己的利润不受到太大的损害。</p><h4 id="42-折扣完价格的右侧数字需要小一些"><a href="#42-折扣完价格的右侧数字需要小一些" class="headerlink" title="42. 折扣完价格的右侧数字需要小一些"></a>42. 折扣完价格的右侧数字需要小一些</h4><p>当右侧的数字小，会显得整个折扣相对比较大。</p><p><img src="https://i.loli.net/2020/06/05/qU7mokILNzFGJ5M.png" alt="right-digit-effect-2.png"></p><p><img src="https://i.loli.net/2020/06/05/KNczCvMyIa2hOrf.png" alt="pricing-tactic-42.png"></p><p><img src="https://i.loli.net/2020/06/05/pfBYcn2QTrbtyJ7.png" alt="psychological-pricing-table5.png"></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://www.nickkolenda.com/psychological-pricing-strategies/" target="_blank" rel="noopener">https://www.nickkolenda.com/psychological-pricing-strategies/</a> </li><li><a href="https://blog.gumroad.com/post/64417917582/a-penny-saved-psychological-pricing" target="_blank" rel="noopener">https://blog.gumroad.com/post/64417917582/a-penny-saved-psychological-pricing</a></li><li><a href="https://www.sciencedirect.com/science/article/abs/pii/S1057740811001082" target="_blank" rel="noopener">https://www.sciencedirect.com/science/article/abs/pii/S1057740811001082</a></li><li><a href="https://www.sciencedirect.com/science/article/abs/pii/001002779290049N" target="_blank" rel="noopener">https://www.sciencedirect.com/science/article/abs/pii/001002779290049N</a></li><li><a href="https://www.sciencedirect.com/science/article/abs/pii/S1057740811001082" target="_blank" rel="noopener">https://www.sciencedirect.com/science/article/abs/pii/S1057740811001082</a></li><li><a href="https://www8.gsb.columbia.edu/sites/decisionsciences/files/files/Divide_and_Prosper.pdf" target="_blank" rel="noopener">https://www8.gsb.columbia.edu/sites/decisionsciences/files/files/Divide_and_Prosper.pdf</a></li><li><a href="http://www.dc.uba.ar/materias/incc/practicas/p1/Dehaene-ParitySNARCeffect-JEPGeneral1993.pdf" target="_blank" rel="noopener">www.dc.uba.ar/materias/incc/practicas/p1/Dehaene-ParitySNARCeffect-JEPGeneral1993.pdf</a></li><li><a href="https://journals.ama.org/doi/abs/10.1509/jm.13.0059" target="_blank" rel="noopener">https://journals.ama.org/doi/abs/10.1509/jm.13.0059</a></li><li><a href="https://journals.ama.org/doi/abs/10.1509/jmr.13.0488" target="_blank" rel="noopener">https://journals.ama.org/doi/abs/10.1509/jmr.13.0488</a></li><li><a href="http://www.dhruvgrewal.com/wp-content/uploads/2014/09/2013-JR-Color.pdf" target="_blank" rel="noopener">http://www.dhruvgrewal.com/wp-content/uploads/2014/09/2013-JR-Color.pdf</a></li><li><a href="https://vtechworks.lib.vt.edu/bitstream/handle/10919/49138/661893.pdf?sequence=1&amp;isAllowed=y" target="_blank" rel="noopener">https://vtechworks.lib.vt.edu/bitstream/handle/10919/49138/661893.pdf?sequence=1&amp;isAllowed=y</a></li><li><a href="https://production.wordpress.uconn.edu/businessmarketing/wp-content/uploads/sites/724/2014/08/size-does-matter.pdf" target="_blank" rel="noopener">https://production.wordpress.uconn.edu/businessmarketing/wp-content/uploads/sites/724/2014/08/size-does-matter.pdf</a></li><li><a href="https://www.sciencedirect.com/science/article/abs/pii/S1057740809000266" target="_blank" rel="noopener">https://www.sciencedirect.com/science/article/abs/pii/S1057740809000266</a></li><li><a href="https://www.sciencedirect.com/science/article/abs/pii/S1057740809000266" target="_blank" rel="noopener">https://www.sciencedirect.com/science/article/abs/pii/S1057740809000266</a></li><li><a href="https://www.andrew.cmu.edu/user/gl20/GeorgeLoewenstein/Papers_files/pdf/redblack.pdf" target="_blank" rel="noopener">https://www.andrew.cmu.edu/user/gl20/GeorgeLoewenstein/Papers_files/pdf/redblack.pdf</a></li><li><a href="https://www.jstor.org/stable/10.1086/597161?seq=1" target="_blank" rel="noopener">https://www.jstor.org/stable/10.1086/597161?seq=1</a></li><li><a href="https://socialtriggers.com/why-you-should-never-discount/" target="_blank" rel="noopener">https://socialtriggers.com/why-you-should-never-discount/</a></li><li><a href="https://journals.ama.org/doi/pdf/10.1509/jm.12.0052" target="_blank" rel="noopener">https://journals.ama.org/doi/pdf/10.1509/jm.12.0052</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一些定价，看价的技巧。无论你是销售者还是购买者，应该都能从中得到一些对你更有利的定价策略。&lt;/p&gt;
&lt;h1 id=&quot;1-使自己的价格看起来更低&quot;&gt;&lt;a href=&quot;#1-使自己的价格看起来更低&quot; class=&quot;headerlink&quot; title=&quot;1. 使自己的价格看起来更
      
    
    </summary>
    
    
      <category term="Notes" scheme="https://www.llchen60.com/categories/Notes/"/>
    
    
      <category term="心理学" scheme="https://www.llchen60.com/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>提高代码质量的Tips</title>
    <link href="https://www.llchen60.com/%E5%85%B3%E4%BA%8E%E6%8F%90%E9%AB%98%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E7%9A%84Tips/"/>
    <id>https://www.llchen60.com/%E5%85%B3%E4%BA%8E%E6%8F%90%E9%AB%98%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E7%9A%84Tips/</id>
    <published>2020-05-25T05:34:48.000Z</published>
    <updated>2020-05-29T00:49:33.202Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-如何重构"><a href="#1-如何重构" class="headerlink" title="1. 如何重构"></a>1. 如何重构</h1><h2 id="1-1-为什么要重构代码？"><a href="#1-1-为什么要重构代码？" class="headerlink" title="1.1 为什么要重构代码？"></a>1.1 为什么要重构代码？</h2><p>重构是一种对软件内部结构的改善，目的是在不改变软件的可见行为的情况下，使其更易理解，修改成本更低。</p><p>即 重构是指保持功能不变的前提下，利用设计思想、原则、模式和编程规范等理论来优化代码，修改设计上的不足，提高代码的质量。</p><p>如果没有维护，物体势必会往熵增加的方向去演变的。如果不做代码的维护，代码总归会往越来越混乱的方向演进，当混乱到一定程度，量变引起质变，项目的维护成本已经高过了重新开发一套新代码的成本，再去重构就会变得十分困难了。</p><h2 id="1-2-重构的对象"><a href="#1-2-重构的对象" class="headerlink" title="1.2 重构的对象"></a>1.2 重构的对象</h2><ul><li>大型重构<ul><li>对顶层代码设计的重构<ul><li>包括 <ul><li>系统</li><li>模块</li><li>代码结构</li><li>类与类之间的关系</li></ul></li><li>重构的手段<ul><li>分层</li><li>模块化</li><li>解耦</li><li>抽象可复用的组件</li></ul></li></ul></li></ul></li></ul><ul><li>小型重构<ul><li>对于代码细节的重构</li><li>针对类，函数，变量等代码级别的重构</li></ul></li></ul><h2 id="1-3-什么时候重构？"><a href="#1-3-什么时候重构？" class="headerlink" title="1.3 什么时候重构？"></a>1.3 什么时候重构？</h2><p>持续重构的概念，即没事情的时候，看看项目中有哪些写得不够好，可以优化的代码，主动去重构一下。或者在修改添加某个功能代码的时候，也可以顺手把不符合编码规范，不好的设计重构一下。</p><h2 id="1-4-如何解耦代码？"><a href="#1-4-如何解耦代码？" class="headerlink" title="1.4 如何解耦代码？"></a>1.4 如何解耦代码？</h2><ul><li><p>解耦的目的</p><ul><li>高内聚</li><li>松耦合</li></ul></li><li><p>为什么需要解耦</p><ul><li>控制代码的复杂性</li><li>使得我们可以聚焦在某一模块或类当中，不需要了解太多其他模块或类的代码</li><li>使得代码改动相对集中，引入bug的风险就减少了很多</li></ul></li><li><p>如何判断是否需要解耦</p><ul><li>在做修改的时候是否需要跨很多个包来进行改动</li><li>需要通过解耦的方式让依赖关系变得清晰，简单一些</li></ul></li><li><p>如何进行解耦</p><ul><li><p>封装与抽象</p><ul><li>有效隐藏实现的复杂</li><li>隔离实现的易变性</li><li>给依赖的模块提供稳定易用的抽象接口</li></ul></li><li><p>引入中间层</p><ul><li>引入中间层能够简化模块或类之间的依赖关系</li><li>即我们可以让开发和重构同步进行</li><li>例如需要进行接口的修改<ul><li>先引入一个中间层，包裹老的接口，提供新的接口定义</li><li>新开发的代码依赖中间层提供的新接口</li><li>将依赖老街口的代码改为调用新接口</li><li>确保所有的代码都调用新接口之后，删掉老接口</li></ul></li></ul></li><li><p>模块化</p><ul><li>对于一个大型复杂系统来说，没有人能够掌控所有细节</li><li>通过划分成不同的独立模块，让不同的人负责不同的模块</li><li>这样即便在不了解全部细节的情况下，管理者也能够协调各个模块，让整个系统有效运转起来</li><li>将每个模块都当做一个独立的library来进行开发，只提供封装了内部实现细节的接口给其他模块使用，以此来减少不同模块之间的耦合度</li></ul></li><li><p>遵循设计思想和原则</p><ul><li>单一职责原则</li><li>基于接口而非实现编程</li><li>依赖注入</li><li>多用组合少用继承</li><li>迪米特法则<ul><li>不应该有直接依赖关系的类</li></ul></li></ul></li></ul></li></ul><h1 id="2-代码的可测试性"><a href="#2-代码的可测试性" class="headerlink" title="2. 代码的可测试性"></a>2. 代码的可测试性</h1><p>做重构，如何保证你做的改动能够按照既定的想法运行，那么我们需要来写单元测试，来保证新的代码仍然能够通过，即原有的逻辑的正确性没有被破坏。</p><p>另外，单元测试的阅读实际上是快速熟悉代码的一种方式</p><p>一些常见的Anti-patterns:</p><ul><li>未决行为<ul><li>代码的输出是随机的，或者不确定的</li></ul></li><li>全局变量</li><li>静态方法</li><li>复杂继承</li><li>高耦合代码</li></ul><h1 id="3-编程规范"><a href="#3-编程规范" class="headerlink" title="3. 编程规范"></a>3. 编程规范</h1><h2 id="3-1-命名与注释"><a href="#3-1-命名与注释" class="headerlink" title="3.1 命名与注释"></a>3.1 命名与注释</h2><ol><li>在足够表达含义的情况下，命名尽量短</li></ol><p>命名时候的缩写，只对大家比较熟知的使用，减少阅读时候的障碍的感觉。</p><ol start="2"><li>利用上下文简化命名</li></ol><p>比如POJO当中，类名往往对这是个什么类做了定义了，成员变量就不用再添加类前缀了</p><ol start="3"><li>命名需要可读，可搜索</li></ol><p>英文上可读，方便发音，哪怕是第一次见到，也需要尽可能简单的能够直接读出来</p><p>另外需要遵从一些大家约定俗成的规范，即比如使用selectXXX 还是queryXXX 来表示选择，从数据库里面拿东西，一旦选定，就需要一起遵从规定了。</p><ol start="4"><li>对于接口，抽象类的命名</li></ol><ul><li><p>对于接口的命名</p><ul><li>加前缀I，比如IUserService</li><li>或者加后缀Impl, UserServiceImpl</li></ul></li><li><p>抽象类的命名</p><ul><li>加上前缀Abstract</li><li>或者不带</li></ul></li></ul><p>皆可，但是需要形式上的统一。</p><ol start="5"><li>注释</li></ol><ul><li><p>目的</p><ul><li>让代码更容易看懂</li></ul></li><li><p>写什么</p><ul><li>是什么，为什么，怎么办 三大问题</li><li>能够起到总结性和文档的作用</li><li>总结性注释也能够让整个代码更加清晰</li></ul></li><li><p>在哪里写</p><ul><li>一般来说是在类和函数上写注释</li><li>函数内部尽量通过好的命名，提炼函数，解释性的变量来提高代码的可读性</li></ul></li></ul><h2 id="3-2-代码风格"><a href="#3-2-代码风格" class="headerlink" title="3.2 代码风格"></a>3.2 代码风格</h2><ol><li>类和函数的大小</li></ol><p>软标准，只是要尽量注意，对于很大的类，最好将其分割开</p><ol start="2"><li>一行代码的长度的限制，譬如100字符或者150字符</li><li>使用空行分割单元块</li></ol><ul><li>对于比较长的函数，如果逻辑上可以分为几个独立的代码块，可以使用空行来分割各个代码块</li><li>在类的成员变量和函数之间</li><li>静态成员变量和普通成员变量之间</li><li>各个函数之间</li><li>各个成员变量之间</li></ul><ol start="4"><li>缩进风格的统一</li><li>类当中成员的排列顺序</li></ol><ul><li>首先是类的所属包名</li><li>然后罗列import引入的依赖类</li><li>类当中<ul><li>大原则<ul><li>先静态，后普通</li><li>作用域从大到小来排序</li></ul></li><li>成员变量</li><li>各种方法</li></ul></li></ul><h2 id="3-3-编程技巧"><a href="#3-3-编程技巧" class="headerlink" title="3.3 编程技巧"></a>3.3 编程技巧</h2><ol><li>将代码分割为更小的单元块</li></ol><p>大部分人阅读代码的习惯都是先看整体再看细节，因为我们要有模块化和抽象思维，善于将大块的负责逻辑提炼成类或者函数，屏蔽掉细节</p><p>通过提炼函数，通过函数名字，直接读懂这段代码是做什么用的</p><ol start="2"><li>避免函数参数过多</li></ol><ul><li>考虑函数是否职责单一，能否通过拆分多个函数的方式来减少参数</li><li>将函数的参数封装成对象</li><li>不要使用函数的参数(true/ false) 来控制逻辑，直接分成几个不同的函数会更好</li></ul><ol start="3"><li>函数的设计，职责单一</li><li>移除过深的嵌套层次</li></ol><ul><li>去掉多余的if else语句</li><li>使用continue break return等关键字，来提前退出嵌套</li><li>调整执行顺序来减少嵌套</li><li>将部分嵌套逻辑封装成函数调用，以此来减少嵌套</li></ul><ol start="5"><li>使用解释性变量</li></ol><ul><li>常量替代magic number</li><li>使用解释性变量来解释复杂表达式</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-如何重构&quot;&gt;&lt;a href=&quot;#1-如何重构&quot; class=&quot;headerlink&quot; title=&quot;1. 如何重构&quot;&gt;&lt;/a&gt;1. 如何重构&lt;/h1&gt;&lt;h2 id=&quot;1-1-为什么要重构代码？&quot;&gt;&lt;a href=&quot;#1-1-为什么要重构代码？&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
  </entry>
  
  <entry>
    <title>Enzyme + Jest Practice</title>
    <link href="https://www.llchen60.com/Enzyme-Jest-Practice/"/>
    <id>https://www.llchen60.com/Enzyme-Jest-Practice/</id>
    <published>2020-05-23T00:29:18.000Z</published>
    <updated>2020-05-23T00:29:58.284Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-How-to-use-enzyme-with-jest"><a href="#1-How-to-use-enzyme-with-jest" class="headerlink" title="1. How to use enzyme with jest"></a>1. How to use enzyme with jest</h1><h2 id="1-1-children"><a href="#1-1-children" class="headerlink" title="1.1 children()"></a>1.1 children()</h2><p>This blog mainly describe some practice on how to write tests in jest with enzyme. </p><pre><code>// This test make sure the component only have one h1 element describe(&#39;&lt;Add /&gt; rendering&#39;, () =&gt; {    it(&#39;should render one &lt;h1&gt;&#39;, () =&gt; {        let wrapper = shallow(&lt;Add /&gt;);        expect(wrapper.children(&#39;h1&#39;)).toHaveLength(1);    });});</code></pre><h2 id="1-2-snapshot"><a href="#1-2-snapshot" class="headerlink" title="1.2 snapshot"></a>1.2 snapshot</h2><pre><code>// For snapshot test, jest will help you create a directory named __snapshots__ with the autogenerated file inside with the extension `.snap`. Push snapshot into the repository and store it along with the test // it means same as test it(&#39;render correctly text component&#39;, () =&gt; {      const TextInputComponent = renderer.create(&lt;TextInput /&gt;).toJSON();    expect(TextInputComponent).toMatchSnapshot();});</code></pre><h2 id="1-3-Test-with-props-in-your-component"><a href="#1-3-Test-with-props-in-your-component" class="headerlink" title="1.3 Test with props in your component"></a>1.3 Test with props in your component</h2><pre><code>it(&#39;check month and years dropdowns displayed&#39;, () =&gt; {      const props = {            showMonthYearsDropdowns: true        },        DateInputComponent = mount(&lt;DateInput {...props} /&gt;).find(&#39;.datepicker&#39;);    expect(DateInputComponent.hasClass(&#39;react-datepicker-hide-month&#39;)).toEqual(true);});it(&#39;render date input correctly with null value&#39;, () =&gt; {      const props = {            value: null        },        DateInputComponent = mount(&lt;DateInput {...props} /&gt;);    expect((DateInputComponent).prop(&#39;value&#39;)).toEqual(null);});it(&#39;check the type of value&#39;, () =&gt; {      const props = {            value: &#39;10.03.2018&#39;        },        DateInputComponent = mount(&lt;DateInput {...props} /&gt;);    expect(DateInputComponent.prop(&#39;value&#39;)).toBeString();});</code></pre><h2 id="1-4-Test-events"><a href="#1-4-Test-events" class="headerlink" title="1.4 Test events"></a>1.4 Test events</h2><pre><code>it(&#39;check the onChange callback&#39;, () =&gt; {      const onChange = jest.fn(),        props = {            value: &#39;20.01.2018&#39;,            onChange        },        DateInputComponent = mount(&lt;DateInput {...props} /&gt;).find(&#39;input&#39;);    DateInputComponent.simulate(&#39;change&#39;, { target: {value: moment(&#39;2018-01-22&#39;)} });    expect(onChange).toHaveBeenCalledWith(&#39;22.01.2018&#39;);});it(&#39;check DatePicker popup open&#39;, () =&gt; {      const DateComponent = mount(&lt;DateInput /&gt;),        dateInput = DateComponent.find(&quot;input[type=&#39;text&#39;]&quot;);    dateInput.simulate(&#39;click&#39;);    expect(DateComponent.find(&#39;.react-datepicker&#39;)).toHaveLength(1);});</code></pre><h1 id="2-Some-tips"><a href="#2-Some-tips" class="headerlink" title="2. Some tips"></a>2. Some tips</h1><ol><li><p>One component should have only one snapshot. </p><ol><li>mainly because if one fails, most likely the others will fail too </li></ol></li><li><p>Test props. </p><ol><li>check the render od default prop values </li><li>check the custom value of the prop, set your own value and do tests </li></ol></li><li><p>Testing data types </p><ol><li>you could use <code>jest-extended</code> to test the type of data </li></ol></li><li><p>Event testing </p><ol><li>mock event -&gt; simulate it -&gt; expect event was called </li><li>mock event -&gt; simulate event with params -&gt; expect event was called with passed params </li><li>pass necessary props -&gt; render component -&gt; simulate event -&gt; expect a certain behavior on called event </li></ol></li></ol><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://blog.bitsrc.io/how-to-test-react-components-with-jest-and-enzyme-in-depth-145fcd06b90" target="_blank" rel="noopener">https://blog.bitsrc.io/how-to-test-react-components-with-jest-and-enzyme-in-depth-145fcd06b90</a> </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-How-to-use-enzyme-with-jest&quot;&gt;&lt;a href=&quot;#1-How-to-use-enzyme-with-jest&quot; class=&quot;headerlink&quot; title=&quot;1. How to use enzyme with jest&quot;&gt;&lt;/
      
    
    </summary>
    
    
      <category term="FrondEnd" scheme="https://www.llchen60.com/categories/FrondEnd/"/>
    
    
  </entry>
  
  <entry>
    <title>如何高效开Design Meetings</title>
    <link href="https://www.llchen60.com/%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E5%BC%80Design-Meetings/"/>
    <id>https://www.llchen60.com/%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E5%BC%80Design-Meetings/</id>
    <published>2020-05-21T20:33:43.000Z</published>
    <updated>2020-05-21T20:34:49.944Z</updated>
    
    <content type="html"><![CDATA[<p>能靠规范做的事情就尽量不要靠直觉，把直觉用在更需要直觉的地方吧。</p><p>工作的日常一定少不了开会的，但是你会有感觉到有一些会议效率非常高，你带着问题来开会，问题迅速被解决，每个人都对下一步很清晰，然后会议结束。但是我们也时常经历完全相反的过程，你带着问题进入，但是问题没有被解答，每个人变得更加困惑的结束会议。</p><p>问题在于，如何能够确保我们的会议是有效率的，能够解决问题的，这需要一些规则和日程上的安排，来确保其效率。</p><h1 id="1-清晰认知会议的类型"><a href="#1-清晰认知会议的类型" class="headerlink" title="1. 清晰认知会议的类型"></a>1. 清晰认知会议的类型</h1><p>在项目的设计过程当中，我们可以根据输入和输出将会议分为三个主要的类型：定义，设计与开发</p><h2 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h2><p>定义类型的会议指的是开展一个新项目，以及设定需求的过程。在这个会议当中，我们需要定义：</p><ul><li>问题是什么</li><li>用户是谁</li><li>有哪些限制</li><li>时间轴</li></ul><p>一般来说，需求定义的会议参加的人数少效果会更加理想一些，比如只带产品经理以及设计师。</p><h2 id="1-2-设计"><a href="#1-2-设计" class="headerlink" title="1.2 设计"></a>1.2 设计</h2><p>设计是个交互的过程，会需要大量的和产品，设计，技术来进行交流。可以将整个设计过程划分为以下的步骤：</p><ul><li><p>调研 (Research)</p><ul><li>看看问题和用户是否已经被定义了，花点时间去看看其他人是如何解决这个问题的（不仅限于你的公司，包括工业界）</li></ul></li><li><p>草拟 (Sketch)</p><ul><li>探索不同的选择，然后判断哪一个能够满足需求</li></ul></li><li><p>反馈 (Feedback)</p><ul><li>注意想要得到哪方面的反馈 </li><li>最好专注在某一个方向上</li></ul></li><li><p>迭代 (Refine)</p><ul><li>根据时间轴不断获取反馈，完成迭代</li></ul></li></ul><p>设计会议的关键在于需求解决哪方面的问题，我们需要聚焦于这个问题。对于不同的设计的选择，我们需要从开发者那里拿到反馈。</p><h2 id="1-3-开发"><a href="#1-3-开发" class="headerlink" title="1.3 开发"></a>1.3 开发</h2><p>当我们进入这部分的会议的时候，我们已经有了大致上的设计的思路，这个时候会更多的考虑一些edge case，还有技术上的限制。这里会有一些技术和设计方面的权衡，我们可能会需要调整我们的设计，来满足从技术角度的考量。设计和产品需要一直参与在这个过程当中，以保证哪怕细节上有调整，但是设计的初衷/理念不会被改变。</p><h1 id="2-邀请正确的人"><a href="#2-邀请正确的人" class="headerlink" title="2. 邀请正确的人"></a>2. 邀请正确的人</h1><p>我们需要很清楚这个会议是关于什么的，以及谁应该出现在这里。一个组往往可能会有3 - 10人左右，一般来说，让10个人全都出现在会议当中不是很有效率的方式，我们需要一个模型来决定谁应该出现在会议当中。 </p><p>Decide, Console, Inform模型</p><h2 id="2-1-决策"><a href="#2-1-决策" class="headerlink" title="2.1 决策"></a>2.1 决策</h2><p>决策者是可以对项目付出时间精力以及金钱的人。他们会最终决定要做什么，以及为什么要这样做。我们需要将所有的决策者带入到会议室当中，这样如果相互之间有不同意见，可以很及时的解决。并且提供下一步。</p><p>这种时候，往往相对比较小的会议更容易达成好的结果，即只带入必要的人，一般来说，是产品的带头人，设计的带头人，以及技术方面的带头人。</p><h2 id="2-2-咨询"><a href="#2-2-咨询" class="headerlink" title="2.2 咨询"></a>2.2 咨询</h2><p>这里指的是对这个领域很了解的人，他们会提出很有价值的建议，不过决定权还在决策者手中。比如几种技术方案的最终选择，就需要引入对框架，各种方法很熟悉的工程师来给出建议了。</p><h2 id="2-3-通知"><a href="#2-3-通知" class="headerlink" title="2.3 通知"></a>2.3 通知</h2><p>组里的一员，被邀请 == 被通知，lol </p><h1 id="3-按照时间安排展开会议"><a href="#3-按照时间安排展开会议" class="headerlink" title="3. 按照时间安排展开会议"></a>3. 按照时间安排展开会议</h1><p>我们需要十分清楚这个会议的目的是什么，我们最终想达到什么样的成果</p><ul><li>我们解决了什么样的问题</li><li>我们可以做出什么样的决定</li><li>下一步措施是什么</li></ul><p>一些比较好的行为，强烈推荐：</p><ul><li><p>会议前</p><ul><li>发送邮件，给出安排</li><li>给出相关的链接，使得参会人可以在参会前可以做一些准备</li></ul></li><li><p>会议开始</p><ul><li>说整个会议的安排<ul><li>比如想看看几种设计</li><li>需要基于什么什么得到反馈</li><li>下一步</li></ul></li></ul></li><li><p>会议结束</p><ul><li>总结反馈 以及下一步<ul><li>在会议还剩下5min左右的时候来做总结和下一步计划</li><li>总结获得的反馈，和决定  这样子如果我们忘记了一些东西，其他人可以给我们做补充</li><li>问下一步是什么，以及每一步的负责人</li></ul></li></ul></li><li><p>会议后</p><ul><li>发送邮件总结会议<ul><li>讨论了什么</li><li>下了什么决定</li><li>下一步工作，是什么，谁来做</li></ul></li></ul></li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://blog.prototypr.io/3-tips-to-run-effective-design-meetings-dec2ec238b56" target="_blank" rel="noopener">https://blog.prototypr.io/3-tips-to-run-effective-design-meetings-dec2ec238b56</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;能靠规范做的事情就尽量不要靠直觉，把直觉用在更需要直觉的地方吧。&lt;/p&gt;
&lt;p&gt;工作的日常一定少不了开会的，但是你会有感觉到有一些会议效率非常高，你带着问题来开会，问题迅速被解决，每个人都对下一步很清晰，然后会议结束。但是我们也时常经历完全相反的过程，你带着问题进入，但是问
      
    
    </summary>
    
    
      <category term="Notes" scheme="https://www.llchen60.com/categories/Notes/"/>
    
    
      <category term="meeting" scheme="https://www.llchen60.com/tags/meeting/"/>
    
      <category term="tips" scheme="https://www.llchen60.com/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>Enzyme -- React测试库</title>
    <link href="https://www.llchen60.com/Enzyme-React%E6%B5%8B%E8%AF%95%E5%BA%93/"/>
    <id>https://www.llchen60.com/Enzyme-React%E6%B5%8B%E8%AF%95%E5%BA%93/</id>
    <published>2020-05-18T23:06:42.000Z</published>
    <updated>2020-05-18T23:07:22.568Z</updated>
    
    <content type="html"><![CDATA[<p>这是前端用于对React的组件进行测试的一个工具类，我们可以使用这个工具来遍历，控制，以及一定程度上的模拟运行时输出。我们主要是将该工具类和Jest一起使用，写我们的react组件的单元测试们。</p><h1 id="1-Shalow-Rendering"><a href="#1-Shalow-Rendering" class="headerlink" title="1. Shalow Rendering"></a>1. Shalow Rendering</h1><p>用于以单个组件为单元来进行测试，然后确保你的测试不会依赖于子组件的状态。从Enzyme v3开始，shallow API会call React生命周期方法了，譬如<code>componentDidUpdate</code>和<code>componentDidMount</code></p><pre><code>import { shallow } from &#39;enzyme&#39;;import sinon from &#39;sinon&#39;;import Foo from &#39;./Foo&#39;;describe(&#39;&lt;MyComponent /&gt;&#39;, () =&gt; {  it(&#39;renders three &lt;Foo /&gt; components&#39;, () =&gt; {    const wrapper = shallow(&lt;MyComponent /&gt;);    expect(wrapper.find(Foo)).to.have.lengthOf(3);  });  it(&#39;renders an `.icon-star`&#39;, () =&gt; {    const wrapper = shallow(&lt;MyComponent /&gt;);    expect(wrapper.find(&#39;.icon-star&#39;)).to.have.lengthOf(1);  });  it(&#39;renders children when passed in&#39;, () =&gt; {    const wrapper = shallow((      &lt;MyComponent&gt;        &lt;div className=&quot;unique&quot; /&gt;      &lt;/MyComponent&gt;    ));    expect(wrapper.contains(&lt;div className=&quot;unique&quot; /&gt;)).to.equal(true);  });  it(&#39;simulates click events&#39;, () =&gt; {    const onButtonClick = sinon.spy();    const wrapper = shallow(&lt;Foo onButtonClick={onButtonClick} /&gt;);    wrapper.find(&#39;button&#39;).simulate(&#39;click&#39;);    expect(onButtonClick).to.have.property(&#39;callCount&#39;, 1);  });});</code></pre><p><a href="https://enzymejs.github.io/enzyme/docs/api/shallow.html" target="_blank" rel="noopener">API Reference</a></p><h1 id="2-Full-Dom-Rendering"><a href="#2-Full-Dom-Rendering" class="headerlink" title="2. Full Dom Rendering"></a>2. Full Dom Rendering</h1><p>这种测试方式在你需要和DOM API进行交互，或者需要测试在更高次位的组件的时候非常有用。</p><p>需要运行在浏览器环境当中，如果无法运行在真实的浏览器当中，那我们就需要依赖于<code>mount</code>指令，在指令之下，是调用了一个叫做jsdom的包，完全使用JavaScript实现了一个浏览器。</p><p>值得注意的是，full dom rendering是真实的将当前组件渲染到DOM树当中，这也意味着如果用的是同一棵DOM树，那么你做的改动很可能会影响其他的测试，这点是值得我们注意的。</p><pre><code>import { mount } from &#39;enzyme&#39;;import sinon from &#39;sinon&#39;;import Foo from &#39;./Foo&#39;;describe(&#39;&lt;Foo /&gt;&#39;, () =&gt; {  it(&#39;calls componentDidMount&#39;, () =&gt; {    sinon.spy(Foo.prototype, &#39;componentDidMount&#39;);    const wrapper = mount(&lt;Foo /&gt;);    expect(Foo.prototype.componentDidMount).to.have.property(&#39;callCount&#39;, 1);  });  it(&#39;allows us to set props&#39;, () =&gt; {    const wrapper = mount(&lt;Foo bar=&quot;baz&quot; /&gt;);    expect(wrapper.props().bar).to.equal(&#39;baz&#39;);    wrapper.setProps({ bar: &#39;foo&#39; });    expect(wrapper.props().bar).to.equal(&#39;foo&#39;);  });  it(&#39;simulates click events&#39;, () =&gt; {    const onButtonClick = sinon.spy();    const wrapper = mount((      &lt;Foo onButtonClick={onButtonClick} /&gt;    ));    wrapper.find(&#39;button&#39;).simulate(&#39;click&#39;);    expect(onButtonClick).to.have.property(&#39;callCount&#39;, 1);  });});</code></pre><p><a href="https://enzymejs.github.io/enzyme/docs/api/mount.html" target="_blank" rel="noopener">API Reference</a></p><h1 id="3-Static-Rendering"><a href="#3-Static-Rendering" class="headerlink" title="3. Static Rendering"></a>3. Static Rendering</h1><p>Render 使用的是Cheerio这个HTML转化库，用于从我们的React树来生成HTML，然后分析HTML的整个架构。</p><pre><code>import React from &#39;react&#39;;import { render } from &#39;enzyme&#39;;import PropTypes from &#39;prop-types&#39;;describe(&#39;&lt;Foo /&gt;&#39;, () =&gt; {  it(&#39;renders three `.foo-bar`s&#39;, () =&gt; {    const wrapper = render(&lt;Foo /&gt;);    expect(wrapper.find(&#39;.foo-bar&#39;)).to.have.lengthOf(3);  });  it(&#39;rendered the title&#39;, () =&gt; {    const wrapper = render(&lt;Foo title=&quot;unique&quot; /&gt;);    expect(wrapper.text()).to.contain(&#39;unique&#39;);  });  it(&#39;renders a div&#39;, () =&gt; {    const wrapper = render(&lt;div className=&quot;myClass&quot; /&gt;);    expect(wrapper.html()).to.contain(&#39;div&#39;);  });  it(&#39;can pass in context&#39;, () =&gt; {    function SimpleComponent(props, context) {      const { name } = context;      return &lt;div&gt;{name}&lt;/div&gt;;    }    SimpleComponent.contextTypes = {      name: PropTypes.string,    };    const context = { name: &#39;foo&#39; };    const wrapper = render(&lt;SimpleComponent /&gt;, { context });    expect(wrapper.text()).to.equal(&#39;foo&#39;);  });});</code></pre><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://enzymejs.github.io/enzyme/" target="_blank" rel="noopener">https://enzymejs.github.io/enzyme/</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是前端用于对React的组件进行测试的一个工具类，我们可以使用这个工具来遍历，控制，以及一定程度上的模拟运行时输出。我们主要是将该工具类和Jest一起使用，写我们的react组件的单元测试们。&lt;/p&gt;
&lt;h1 id=&quot;1-Shalow-Rendering&quot;&gt;&lt;a href
      
    
    </summary>
    
    
      <category term="FrontEnd" scheme="https://www.llchen60.com/categories/FrontEnd/"/>
    
    
      <category term="Enzyme" scheme="https://www.llchen60.com/tags/Enzyme/"/>
    
  </entry>
  
  <entry>
    <title>应用设计 Practice</title>
    <link href="https://www.llchen60.com/%E5%BA%94%E7%94%A8%E8%AE%BE%E8%AE%A1-Practice/"/>
    <id>https://www.llchen60.com/%E5%BA%94%E7%94%A8%E8%AE%BE%E8%AE%A1-Practice/</id>
    <published>2020-05-17T20:03:10.000Z</published>
    <updated>2020-05-20T00:12:33.088Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-thought"><a href="#1-thought" class="headerlink" title="1. thought"></a>1. thought</h1><p>实际应用设计，首先还是需要将工作进行合理分割：</p><ul><li>前期需求沟通分析<ul><li>工程师应该尽量参与到产品设计当中</li><li>寻找类似的产品，进行借鉴</li><li>将借鉴来的东西努力融合到我们自己的产品当中</li></ul></li><li>中期代码设计实现</li><li>后期系统上线维护 <h1 id="2-业务系统设计-–-积分系统"><a href="#2-业务系统设计-–-积分系统" class="headerlink" title="2. 业务系统设计 – 积分系统"></a>2. 业务系统设计 – 积分系统</h1></li></ul><h2 id="2-1-业务需求"><a href="#2-1-业务需求" class="headerlink" title="2.1 业务需求"></a>2.1 业务需求</h2><ul><li><p>功能点</p><ul><li>赚取积分<ul><li>积分赚取渠道<ul><li>订单</li><li>签到</li><li>评论</li></ul></li><li>积分兑换规则<ul><li>订单金额与积分的兑换比例</li><li>签到赠送积分数量等</li></ul></li></ul></li><li>消费积分<ul><li>积分消费渠道<ul><li>抵扣订单金额</li><li>兑换优惠券</li><li>积分换购</li><li>参与活动</li></ul></li></ul></li></ul></li><li><p>方式方法</p><ul><li>借鉴已经相对成熟的产品<ul><li>看其实现的方式方法</li></ul></li><li>通过产品线框图</li><li>user case<ul><li>模拟用户是如何使用我们的产品的</li><li>描述用户在特定的应用场景当中的一个完整的业务操作流程</li></ul></li></ul></li></ul><h2 id="2-2-系统设计"><a href="#2-2-系统设计" class="headerlink" title="2.2 系统设计"></a>2.2 系统设计</h2><h3 id="2-2-1-功能模块划分"><a href="#2-2-1-功能模块划分" class="headerlink" title="2.2.1 功能模块划分"></a>2.2.1 功能模块划分</h3><ul><li>将功能划分到不同的模块当中 <ul><li>做到模块层面的高内聚，低耦合</li></ul></li></ul><ul><li>针对上述的业务需求，我们可以采用<ul><li><ol><li>将关于积分的赚取消费的规则的管理维护放到更上层的营销系统当中，这样积分系统就只负责增删改查的数据库操作了</li></ol></li><li><ol start="2"><li>将规则分散到各个子系统当中，譬如订单系统，评论系统，签到系统，诸如此类</li></ol></li><li><ol start="3"><li>所有功能划分到积分系统当中</li></ol></li></ul></li></ul><p>值得注意的是，为了避免业务知识的耦合，让下层系统更加通用，我们不希望下层系统（被调用系统）包含太多上层系统（调用系统）的业务信息。但上层系统是可以包含下层系统的业务信息的，比如，订单系统、优惠券系统、换购商城等作为调用积分系统的上层系统，可以包含一些积分相关的业务信息。但是，反过来，积分系统中最好不要包含太多跟订单、优惠券、换购等相关的信息。</p><p>因此，1，2都是相对不错的选择，我们希望做的是让积分系统模块只包含积分的增删改查的操作，而不包含太多的业务层面的逻辑。</p><h3 id="2-2-2-模块间交互"><a href="#2-2-2-模块间交互" class="headerlink" title="2.2.2 模块间交互"></a>2.2.2 模块间交互</h3><p>定位需要和积分系统之间进行交互的系统，以及交互方式。</p><p>一般来说，系统之间的交互方式有两大类：</p><ul><li>同步接口调用</li><li>利用信息中间件异步调用</li></ul><h3 id="2-2-3-设计模块的接口、数据库、业务模型"><a href="#2-2-3-设计模块的接口、数据库、业务模型" class="headerlink" title="2.2.3 设计模块的接口、数据库、业务模型"></a>2.2.3 设计模块的接口、数据库、业务模型</h3><p>数据库和接口的设计相对来说都比较重要，一旦设计好，都不能轻易改动。尤其是当有不同的组来调用你的API的时候，让所有的组都快速迁移到新的API上是一件相对比较困难的事情了。  改动数据库表的结构，需要涉及数据的迁移和适配。</p><p>而业务模型，即业务逻辑代码，因为都是内部使用，改动的可能性比较大，对外是不可见的。</p><ul><li><p>数据库设计：</p><ul><li>id - 明细ID</li><li>user_id - 用户ID</li><li>channel_id - 赚取或消费渠道ID</li><li>event_id - 相关事件ID，例如订单ID，评论ID，优惠券换购ID等</li><li>credit - 积分 </li><li>create_time - 积分赚取或消费时间</li><li>expired_time - 积分过期时间</li></ul></li><li><p>接口设计</p><ul><li>单一职责原则 <ul><li>但是粒度太小也不好，比如一个功能的实现需要多个接口，但是每个接口如果都是RPC的一次远程调用的话，那网络上的损耗就很多，多次远程调用会影响性能的</li><li>另外还有数据一致性 - 即操作的原子性方面的考量</li><li>可以借鉴facade外观设计模式，在职责单一的细粒度接口之上，封装一层粗粒度的接口给外部使用</li></ul></li></ul></li><li><p>MVC </p><ul><li>controller负责接口暴露</li><li>service 负责核心业务逻辑</li><li>repository负责数据读写</li><li>为什么要分成MVC三层？<ul><li>代码复用</li><li>隔离变化</li><li>隔离关注点</li><li>提高代码的可测试性</li><li>能够应对系统的复杂性</li></ul></li></ul></li></ul><h1 id="3-非业务通用框架设计"><a href="#3-非业务通用框架设计" class="headerlink" title="3. 非业务通用框架设计"></a>3. 非业务通用框架设计</h1><p>假设我们要设计开发一个小框架，来获取接口调用的各种统计信息。</p><ul><li>响应时间<ul><li>max/ min/ avg/ percentile/ count/ tps </li></ul></li></ul><h2 id="3-1-需求分析"><a href="#3-1-需求分析" class="headerlink" title="3.1 需求分析"></a>3.1 需求分析</h2><p>是一个和业务无关的独立功能，我们可以将其开发成一个独立的框架或者库，集成到很多的业务系统当中。作为一个需要复用性的框架，除了功能上的需求以外，非功能性的需求也非常重要。</p><ul><li><p>功能性需求分析</p><ul><li><p>接口统计信息</p><ul><li>响应时间</li><li>接口调用次数</li></ul></li><li><p>统计信息的类型</p><ul><li>max min ave percentile tps count </li></ul></li><li><p>统计信息显示格式</p><ul><li>json</li><li>html</li><li>自定义</li></ul></li><li><p>统计信息显示终端</p><ul><li>console</li><li>email</li><li>http 页面</li><li>日志</li><li>自定义</li></ul></li><li><p>统计触发方式</p></li><li><p>统计时间区间</p></li><li><p>统计时间间隔</p></li></ul></li></ul><ul><li><p>非功能性需求分析</p><ul><li><p>易用性</p><ul><li>框架是否易集成，易拔插</li><li>跟业务代码是否为松耦合</li><li>提供的接口是否足够灵活</li></ul></li><li><p>性能</p><ul><li>不希望框架本身的代码执行效率会对业务系统有太多性能上的影响</li><li>希望框架低延迟，并且对内存的消耗不能太大</li></ul></li><li><p>扩展性</p><ul><li>在不修改或者尽量少修改代码的情况下添加新功能的能力</li></ul></li><li><p>容错性</p></li><li><p>通用性</p><ul><li>除了接口数据统计，能否将其放到其他事件上来做统计呢？ </li></ul></li></ul></li></ul><h2 id="3-2-框架设计"><a href="#3-2-框架设计" class="headerlink" title="3.2 框架设计"></a>3.2 框架设计</h2><p>可以借鉴TDD (测试驱动开发)和Prototype(最小原型)的思想，先聚焦于一个简单的应用场景，基于此来设计一个简单的原型，然后不断进行迭代。</p><p>而后是将整个框架分为多个模块，分模块进行思考：</p><ul><li>数据采集<ul><li>打点采集原始数据</li><li>记录每次接口请求的响应时间和请求时间</li><li>数据采集过程要高度容错，不能影响到接口本身的可用性</li></ul></li><li>存储<ul><li>负责将采集的原始数据保存下来，以便后面做聚合统计</li><li>数据可以存储在<ul><li>redis</li><li>mysql</li><li>hbase</li><li>日志</li><li>文件</li><li>内存</li></ul></li></ul></li><li>聚合统计<ul><li>将原始数据聚合为统计数据</li></ul></li><li>显示<ul><li>将统计数据以某种格式显示到终端当中</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-thought&quot;&gt;&lt;a href=&quot;#1-thought&quot; class=&quot;headerlink&quot; title=&quot;1. thought&quot;&gt;&lt;/a&gt;1. thought&lt;/h1&gt;&lt;p&gt;实际应用设计，首先还是需要将工作进行合理分割：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前期需
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="System Design" scheme="https://www.llchen60.com/tags/System-Design/"/>
    
  </entry>
  
  <entry>
    <title>中台(二) - 略深入些的探究</title>
    <link href="https://www.llchen60.com/%E4%B8%AD%E5%8F%B0-%E4%BA%8C-%E7%95%A5%E6%B7%B1%E5%85%A5%E4%BA%9B%E7%9A%84%E6%8E%A2%E7%A9%B6/"/>
    <id>https://www.llchen60.com/%E4%B8%AD%E5%8F%B0-%E4%BA%8C-%E7%95%A5%E6%B7%B1%E5%85%A5%E4%BA%9B%E7%9A%84%E6%8E%A2%E7%A9%B6/</id>
    <published>2020-05-16T00:38:41.000Z</published>
    <updated>2020-05-30T00:39:49.461Z</updated>
    
    <content type="html"><![CDATA[<p>中台是企业级能力复用平台，整个中台的构建，实际上是将业务数据化，将数据业务化。是需要建立业务中台和数据中台的。业务中台通过抽象，封装可复用的逻辑，提升企业的响应力；数据中台通过打通企业的数据，构建自学习服务的数据能力，让企业更加智慧。</p><h1 id="1-通用化通用能力"><a href="#1-通用化通用能力" class="headerlink" title="1. 通用化通用能力"></a>1. 通用化通用能力</h1><p>目前大部分企业实现的中台，主要是将遗留下的后台系统，比如ERP MES CRM的公共部分进行拆解复用，形成类似交易中心，用户中心，订单中心这样的微服务集合供前台调用，从而保证<strong>逻辑的一致性</strong>同时更快响应前台的变化</p><p>Reference <a href="https://www.infoq.cn/article/wCZV6X5uujxDXFP0Eub9?utm_source=rss&utm_medium=article" target="_blank" rel="noopener">1</a> 当中举了订单服务的演进过程的例子，很值得一看。当平台需要开放多渠道来完成订单的时候，保证用户有着类似的体验是很重要的一项，包括整个系统的的scalability。</p><p>在这种情况下，一个数据中台能够使得用户可以看到在各个平台各个渠道自己下的订单。从平台角度来说，有了数据中台，维护成本，发生错误以后的修改成本都会减轻很多。</p><p>略微解释下，如果是分开的系统，那么每个系统都会有自己的数据库，我们需要做数据的join操作，然后返回给前端用户需要的正确的信息。当发生了逻辑上的错误以后，我们很有可能需要在分开的几个子系统当中来做修改，很容易出错，修改的整个时间消耗也会很长。而且数据仓库在多个系统的情况下，抽取数据，再进行分析是有比较大的时延的，一般都是加一天的样子，无法看到实时的数据。</p><h1 id="2-使用中台去ERP化"><a href="#2-使用中台去ERP化" class="headerlink" title="2. 使用中台去ERP化"></a>2. 使用中台去ERP化</h1><p>ERP， 即企业资源管理系统。最最开始的时候，企业的需求是将企业的流程梳理清晰，做到资源的集约化管理，本质上来讲是为了解决流程复用，业务能力化的问题。</p><p>但是当前ERP软件存在着如下的一些问题：</p><ol><li>商业软件，响应慢<br>企业只有使用权，这就导致企业的业务发生变化的时候，需要找到原厂重新配置或者重新开发，响应比较慢</li><li>封闭架构，不开放<br>套装ERP软件是封闭架构，技术不开放，导致企业无法对其进行大的功能上的扩展，只能像打补丁一样，构建一些外挂，而且效果往往不会很好</li><li>单体架构，弹性不够<br>单体架构，很难支持持续增长的各种需求</li><li>升级 维护成本<br>套装软件升级和维护成本非常高</li></ol><p>过去人们需要ERP更多的是因为我们需要流程，需要知道具体应该如何去组织。但是在互联网化的今天，原来静态化，标准化的业务流程已经不足以支撑企业的快速响应了。因此，诉求<strong>从原来的流程化变成了需要能够快速响应前台市场的变化</strong>。</p><p>企业组织结构从流程式协作走向了平台式协作。</p><p>ERP更像是一种计划式的经济，希望每个角色都按照分配的任务来走，共同完成一个任务，但是这种共同完成会导致不同角色之间的利益相互冲突。局部利益大于整体利益。</p><p>需要的转变是 —- 要开始学习以客户为中心去动态组织资源来提供服务，将原本<strong><em>以流程为独立单元的模块拆解为以客户价值为独立单元的模块</em></strong>。</p><p>以客户价值为独立单元，如何评定绩效就是个很关键也很困难的问题，尤其是对于那些为后端赋能的业务单元，如何将其关联到直接的客户价值当中。这需要数据中台提供这方面的能力，来利用全域的数据分析，建模，通过敏感性分析等算法技术来实时计算。</p><h1 id="3-数据中台成熟度的评估维度"><a href="#3-数据中台成熟度的评估维度" class="headerlink" title="3. 数据中台成熟度的评估维度"></a>3. 数据中台成熟度的评估维度</h1><ul><li><p>数据战略</p><ul><li><p>理念</p><ul><li>究竟做数据中台是为了什么</li><li>一个组织的愿景和目标，来指导我们接下来的行动</li><li>确定组织，团队对于战略的理解是一致的</li></ul></li><li><p>行动</p><ul><li>一个管理组织<ul><li>确保战略目标能够被有效分解</li><li>能够在部门团队之间落地</li></ul></li><li>制度建设<ul><li>如何保证战略落地</li><li>如何处理冲突，不一致</li><li>如果构建决策流程</li><li>战略/行动的优化和调整机制</li></ul></li></ul></li></ul></li><li><p>数据治理</p><ul><li><p>元数据相关</p><ul><li>如何做元数据分类</li><li>技术和业务元数据的管理</li><li>维护机制</li></ul></li><li><p>数据字典相关</p></li><li><p>数据模型相关</p></li><li><p>数据质量相关</p></li><li><p>数据标准相关</p></li><li><p>数据安全相关</p></li><li><p>数据生命周期相关</p></li></ul></li><li><p>数据资产管理</p><ul><li><p>数据资产审核能力</p><ul><li>注册申请</li></ul></li><li><p>数据资产发布能力</p><ul><li>将数据提供给消费者查询使用的能力</li></ul></li><li><p>数据资产标签</p><ul><li>客户特征标签</li><li>关键业务的指标标签</li></ul></li><li><p>数据资产地图</p><ul><li>通过地图或者目录的形式，提供数据资产的查询功能</li><li>实现数据资产的可视化</li></ul></li><li><p>数据资产开放能力</p><ul><li>通过接口提供给内外部用户使用</li></ul></li><li><p>数据资产盘点能力</p></li><li><p>数据资产定价</p></li><li><p>效益评估</p></li></ul></li><li><p>数据平台和架构</p><ul><li>基准<ul><li>易用</li><li>稳定</li><li>可扩展</li><li>支持多应用的平台架构</li></ul></li><li>架构标准<ul><li>架构选择的流程<ul><li>同业调研</li><li>选型</li><li>POC</li><li>决策部门</li></ul></li><li>架构方法<ul><li>架构规划</li><li>基础架构</li><li>评估机制</li></ul></li></ul></li></ul></li><li><p>数据服务化</p><ul><li><p>数据中心以什么样的方式向外界提供服务呢？</p><ul><li><p>API调用</p></li><li><p>服务标准的确立</p><ul><li>服务目标</li><li>提供方式</li><li>流程</li><li>优先级</li></ul></li><li><p>服务监控和维护</p><ul><li>量化的评估标准</li></ul></li><li><p>数据服务的评估和优化</p></li></ul></li></ul></li><li><p>数据产品化</p><ul><li>产品<ul><li>报表分析等</li></ul></li><li>业务支撑能力<ul><li>所能支撑的业务是否能反映战略的方向或战略的执行情况，功能支撑能力是不是能被周期性评估和优化</li></ul></li><li>业务分析响应能力<ul><li>响应机制</li></ul></li><li>数据可视化能力<ul><li>是否支持业务友好的使用方式</li></ul></li><li>统一服务的能力<ul><li>是否能够将业务需求沉淀成统一的服务的能力，从而服务更多业务团队</li></ul></li></ul></li><li><p>中台运营</p><ul><li>将整个平台作为一个产品来看，是否有运营的指标和控制机制</li><li>中台管理平台<ul><li>文档</li><li>规范</li><li>流程等</li></ul></li><li>成本分析<ul><li>存储</li><li>计算</li><li>研发 <h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1></li></ul></li></ul></li></ul><ol><li><a href="https://www.infoq.cn/article/wCZV6X5uujxDXFP0Eub9?utm_source=rss&amp;utm_medium=article" target="_blank" rel="noopener">https://www.infoq.cn/article/wCZV6X5uujxDXFP0Eub9?utm_source=rss&amp;utm_medium=article</a></li><li><a href="https://insights.thoughtworks.cn/data-zhongtai-maturity-model/" target="_blank" rel="noopener">https://insights.thoughtworks.cn/data-zhongtai-maturity-model/</a> </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;中台是企业级能力复用平台，整个中台的构建，实际上是将业务数据化，将数据业务化。是需要建立业务中台和数据中台的。业务中台通过抽象，封装可复用的逻辑，提升企业的响应力；数据中台通过打通企业的数据，构建自学习服务的数据能力，让企业更加智慧。&lt;/p&gt;
&lt;h1 id=&quot;1-通用化通用
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="中台" scheme="https://www.llchen60.com/tags/%E4%B8%AD%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>Jest - JS测试框架</title>
    <link href="https://www.llchen60.com/Jest-JS%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
    <id>https://www.llchen60.com/Jest-JS%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/</id>
    <published>2020-05-14T04:31:23.000Z</published>
    <updated>2020-05-15T04:11:30.500Z</updated>
    
    <content type="html"><![CDATA[<p>JJest是一个简洁的JavaScript测试框架，我们可以将其与Babel, TS, Node, React, Angular, Vue等来共同使用</p><h1 id="1-Intro"><a href="#1-Intro" class="headerlink" title="1. Intro"></a>1. Intro</h1><p>首先jest是希望能够用很轻量的方式来进行前端测试，自己最近在做一个偏向前端的项目，希望把组里的对外页面从其他平台转移出来，通过router完成路径的转接，然后在自己的平台上，就可以更自由，更快捷的进行迭代了。</p><p>整个架构还是RPC 暴露RESTFul接口，用类似于API Gateway的系统完成Authorization Authentication的工作，前端直接调用后端的信息这样子。想要达到的最终的目标就是易于维护且易于扩展的一个前端小平台，几个基本需求，也是要做转移的原因：</p><ul><li><p>前端的埋点，希望有更多的metrics以知道用户的行为</p><ul><li>各个页面的浏览时长</li><li>跳出率</li><li>哪个步骤过滤走了最多的用户请求，诸如此类</li></ul></li><li><p>CI/ CD</p><ul><li>手动QA太容易犯错了，如果能写一部分unit tests &amp; integration tests,实现整个前端页面的可测试，那么就可以实现持续继承持续部署，会很大程度上提高可交付能力</li></ul></li><li><p>访问速度</p><ul><li>利用S3 host页面，使用CDN完成分布，会提高整体的响应速度</li></ul></li></ul><p>Jest是实现CI/CD的很不错的一个工具，on my way learning it ;) </p><h2 id="1-1-匹配器"><a href="#1-1-匹配器" class="headerlink" title="1.1 匹配器"></a>1.1 匹配器</h2><p>与Junit类似，使用expect做关键词，E.G</p><pre><code>test(&#39;two plus two is four&#39;, () =&gt; {  expect(2 + 2).toBe(4);});</code></pre><ul><li><p>toBe </p><ul><li>匹配器，内部使用的是<code>Object.is</code>来做精确相等</li></ul></li><li><p>toEqual</p><ul><li>来检查对象的值</li></ul></li><li><p>比较真实性</p><ul><li>toBeNull</li><li>toBeUndefined</li><li>toBeTruthy<ul><li>匹配任何if语句为真</li></ul></li><li>toBeFalsy <ul><li>匹配任何if语句为假 </li></ul></li></ul></li><li><p>比较数字</p><ul><li>toBeGreaterThan()</li><li>toBeGreaterThanOrEqual()</li><li>toBeLessThan()</li><li>toBeLessThanOrEqual()</li><li>toBe()</li><li>toEqual()</li></ul></li><li><p>字符串</p><ul><li>toMatch()  match一个正则表达式</li></ul></li><li><p>数组 </p><ul><li>toContain() 检查一个数组或可迭代的对象是否包含某个特定项</li></ul></li></ul><pre><code>const shoppingList = [  &#39;diapers&#39;,  &#39;kleenex&#39;,  &#39;trash bags&#39;,  &#39;paper towels&#39;,  &#39;beer&#39;,];test(&#39;the shopping list has beer on it&#39;, () =&gt; {  expect(shoppingList).toContain(&#39;beer&#39;);  expect(new Set(shoppingList)).toContain(&#39;beer&#39;);});</code></pre><h2 id="1-2-测试异步代码"><a href="#1-2-测试异步代码" class="headerlink" title="1.2 测试异步代码"></a>1.2 测试异步代码</h2><pre><code>// 对于回调函数的测试test(&#39;the data is peanut butter&#39;, done =&gt; {  function callback(data) {    try {      expect(data).toBe(&#39;peanut butter&#39;);      done();    } catch (error) {      done(error);    }  }  fetchData(callback);});// Promisestest(&#39;the data is peanut butter&#39;, () =&gt; {  return fetchData().then(data =&gt; {    expect(data).toBe(&#39;peanut butter&#39;);  });});// Resolve/ rejecttest(&#39;the data is peanut butter&#39;, () =&gt; {  return expect(fetchData()).resolves.toBe(&#39;peanut butter&#39;);});// async/ awaittest(&#39;the data is peanut butter&#39;, async () =&gt; {  const data = await fetchData();  expect(data).toBe(&#39;peanut butter&#39;);});test(&#39;the fetch fails with an error&#39;, async () =&gt; {  expect.assertions(1);  try {    await fetchData();  } catch (e) {    expect(e).toMatch(&#39;error&#39;);  }});</code></pre><h2 id="1-3-测试前后的utility方法"><a href="#1-3-测试前后的utility方法" class="headerlink" title="1.3 测试前后的utility方法"></a>1.3 测试前后的utility方法</h2><ul><li>重复设置值 </li></ul><pre><code>beforeEach(() =&gt; {});afterEach(() =&gt; {});</code></pre><ul><li><p>一次性设置 – 单个测试不会改变其值</p><p>  beforeAll(() =&gt; {</p><p>  });</p><p>  afterAll(() =&gt; {</p><p>  });</p></li><li><p>作用域 </p><ul><li>通过describe来将测试进行分组操作 </li><li>注意describe的执行顺序 <ul><li>在真正的测试开始之前执行测试文件当中的所有的describe处理程序</li><li>当describe块运行完后，Jest会按照test出现的顺序依次运行所有测试，等待每一个测试完成并整理好，然后继续往下走</li></ul></li><li>通用建议<ul><li>当测试失败的时候，首先要检查的是如果仅运行这条测试，是否仍然失败</li><li>通过将test指令改为test.only指令来实现</li></ul></li></ul></li></ul><h2 id="1-4-Mock-方法"><a href="#1-4-Mock-方法" class="headerlink" title="1.4 Mock 方法"></a>1.4 Mock 方法</h2><p>Mock函数允许我们来测试代码之间的连接，和Mockito， EasyMock其实是一个理念的，擦除函数的实际实现，专注于当前的文件的方法本身，捕获对函数的调用，实例等</p><pre><code>function forEach(items, callback) {  for (let index = 0; index &lt; items.length; index++) {    callback(items[index]);  }}const mockCallback = jest.fn(x =&gt; 42 + x);forEach([0, 1], mockCallback);// 此 mock 函数被调用了两次expect(mockCallback.mock.calls.length).toBe(2);// 第一次调用函数时的第一个参数是 0expect(mockCallback.mock.calls[0][0]).toBe(0);// 第二次调用函数时的第一个参数是 1expect(mockCallback.mock.calls[1][0]).toBe(1);// 第一次函数调用的返回值是 42expect(mockCallback.mock.results[0].value).toBe(42);</code></pre><h1 id="2-测试方法"><a href="#2-测试方法" class="headerlink" title="2. 测试方法"></a>2. 测试方法</h1><h2 id="2-1-Snapshot-测试"><a href="#2-1-Snapshot-测试" class="headerlink" title="2.1 Snapshot 测试"></a>2.1 Snapshot 测试</h2><p>给当前的UI做快照，然后和过去做过的快照进行比较，看是否有不同。</p><pre><code>import React from &#39;react&#39;;import Link from &#39;../Link.react&#39;;import renderer from &#39;react-test-renderer&#39;;it(&#39;renders correctly&#39;, () =&gt; {  const tree = renderer    .create(&lt;Link page=&quot;http://www.facebook.com&quot;&gt;Facebook&lt;/Link&gt;)    .toJSON();  expect(tree).toMatchSnapshot();});</code></pre><p>实际上是生成一个DOM树，然后来比较两颗DOM树的节点，看设置是否相同。</p><p>在每次提交的时候，会记录下当前的快照，下次提交的时候会和这次的来进行比较。</p><p>然后当我们有目的的引入了变化的时候，我们需要告诉jest 需要更新现在保存的snapshot了，这种情况下需要运行指令<code>jest --updateSnapshot</code>.</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://jestjs.io/docs/en/getting-started" target="_blank" rel="noopener">https://jestjs.io/docs/en/getting-started</a> </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JJest是一个简洁的JavaScript测试框架，我们可以将其与Babel, TS, Node, React, Angular, Vue等来共同使用&lt;/p&gt;
&lt;h1 id=&quot;1-Intro&quot;&gt;&lt;a href=&quot;#1-Intro&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="FrontEnd" scheme="https://www.llchen60.com/categories/FrontEnd/"/>
    
    
      <category term="Jest" scheme="https://www.llchen60.com/tags/Jest/"/>
    
  </entry>
  
  <entry>
    <title>好玩的网站列表</title>
    <link href="https://www.llchen60.com/%E5%A5%BD%E7%8E%A9%E7%9A%84%E7%BD%91%E7%AB%99%E5%88%97%E8%A1%A8/"/>
    <id>https://www.llchen60.com/%E5%A5%BD%E7%8E%A9%E7%9A%84%E7%BD%91%E7%AB%99%E5%88%97%E8%A1%A8/</id>
    <published>2020-05-13T04:33:52.000Z</published>
    <updated>2020-06-08T04:02:10.319Z</updated>
    
    <content type="html"><![CDATA[<p>好玩的东西，持续更新~ </p><ul><li><p>digital nomad</p><ul><li>以数字技术为生，搬到风景优美，气候温和，物价便宜的地方，做自己想做的事情，这概念有意思的</li><li><a href="https://nomadlist.com/" target="_blank" rel="noopener">https://nomadlist.com/</a> </li></ul></li><li><p>Regex 101 </p><ul><li>神一样的正则网站，可以做在线debug</li><li><a href="https://regex101.com/" target="_blank" rel="noopener">https://regex101.com/</a> </li></ul></li><li><p>中国互联网中讨论的消亡</p><ul><li><a href="https://mp.weixin.qq.com/s/a-32UpINmb_vSj17epysiA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/a-32UpINmb_vSj17epysiA</a></li></ul></li><li><p>经济机器是怎样运行的 by Ray Dalio </p><ul><li>在2020年对着现在的经济形势看，别有一番滋味 lol</li><li>tips<ul><li>不要让债务的增长速度超过收入</li><li>不要让收入的增长速度超过生产率</li><li>尽一切努力提高生产率</li></ul></li><li><a href="https://www.bilibili.com/video/av6496369/" target="_blank" rel="noopener">https://www.bilibili.com/video/av6496369/</a></li></ul></li><li><p>大国周期及储备货币变迁 by Ray Dalio</p><ul><li><a href="https://www.chainnews.com/articles/678538813470.htm" target="_blank" rel="noopener">link</a></li></ul></li><li><p>思考工具的📱</p><ul><li><a href="https://untools.co/" target="_blank" rel="noopener">link</a></li></ul></li><li><p>设计模式的讲解</p><ul><li><a href="https://refactoringguru.cn/design-patterns" target="_blank" rel="noopener">link</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;好玩的东西，持续更新~ &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;digital nomad&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以数字技术为生，搬到风景优美，气候温和，物价便宜的地方，做自己想做的事情，这概念有意思的&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://nomadlist.
      
    
    </summary>
    
    
      <category term="Notes" scheme="https://www.llchen60.com/categories/Notes/"/>
    
    
  </entry>
  
  <entry>
    <title>中台(三) - 看白话中台系列的一些总结</title>
    <link href="https://www.llchen60.com/%E4%B8%AD%E5%8F%B0-%E4%B8%89-%E7%9C%8B%E7%99%BD%E8%AF%9D%E4%B8%AD%E5%8F%B0%E7%B3%BB%E5%88%97%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/"/>
    <id>https://www.llchen60.com/%E4%B8%AD%E5%8F%B0-%E4%B8%89-%E7%9C%8B%E7%99%BD%E8%AF%9D%E4%B8%AD%E5%8F%B0%E7%B3%BB%E5%88%97%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/</id>
    <published>2020-05-12T03:36:52.000Z</published>
    <updated>2020-05-12T03:40:08.892Z</updated>
    
    <content type="html"><![CDATA[<p>前面两篇文章讲了一些关于中台的信息, <a href="https://llchen60.com/%E4%B8%AD%E5%8F%B0/" target="_blank" rel="noopener">中台1</a>,<a href="https://llchen60.com/%E4%B8%AD%E5%8F%B0-%E4%BA%8C-%E7%95%A5%E6%B7%B1%E5%85%A5%E4%BA%9B%E7%9A%84%E6%8E%A2%E7%A9%B6/" target="_blank" rel="noopener">中台2</a>。</p><ul><li><p>为什么需要平台化</p><ul><li>赋予企业用户响应力</li></ul></li><li><p>什么是中台</p><ul><li><strong>企业级能力复用平台</strong></li><li>基础的理念和架构</li><li>可以联通，支持上端的业务</li><li>需要能够将后台各式各样的资源转化为前台易于使用的能力 –&gt; 以用户为中心的持续规模化创新</li><li>Platform as a product </li><li>亚马逊大量使用微服务，关于微服务与中台，可以想象成中台是多个有平台化能力的微服务的集合，通过隐藏内部的信息和不必要的接口，对外呈现为单独一个具有平台服务能力的微服务。</li></ul></li><li><p>中台分类/ 为什么要建平台</p><ul><li>内部研发效能提升</li><li>资源整合</li><li>新零售</li><li>全周期</li><li>全渠道</li><li>开放银行</li><li>多品牌战略</li><li>全球化战略</li><li>产业互联</li><li>构建商业生态</li></ul></li><li><p>阿里的数据业务双中台</p><ul><li>业务中台将后台资源进行抽象包装整合，转化为前台友好的可重用可共享的核心能力，实现后端业务资源到前台易用能力的转化</li><li>数据中台从后台及业务中台将数据流入，完成海量数据的存储，计算，产品化包装的过程，构成企业的核心数据能力</li></ul></li><li><p>阿里技术中台</p><ul><li>将使用云或者其他基础设施的能力以及应用各种技术中间件的能力进行整合包装，过滤掉技术细节，提供简单一致，易于使用的应用技术基础设施的能力接口，助力前台和业务中台数据中台的快速建设</li></ul></li><li><p>组织中台</p><ul><li>中台建设真正困难的地方在于组织上的重构，技术架构与组织架构的匹配！！</li><li>组织中台很像企业中的内部风投和创新孵化机构，为前台组织和团队构建创新型前台应用提供类似于投资评估（项目甄别）、投资管理、投后管理（孵化与风控），真正从组织和制度上支撑前台组织和应用的快速迭代规模化创新</li></ul></li><li><p>中台建设的难点 – 需要关注组织架构的调整</p><ul><li>组织架构的调整和演进以及利益的重新分配 </li><li>战略的落地是需要靠组织架构的调整来实现的，企业的发展取决于企业正确的战略以及企业的组织结构。前者决定了后者，后者能够保证前者的落地实现</li><li>如果将中台和前台之间的关系定义成服务和被服务的关系，很容易会因为大量需求占据大量时间，短期利益和长期利益的博弈，造成很多问题</li><li>产品化思维，将中台当做一个产品，和其他组是产品之间互通的关系</li></ul></li><li><p>关于中台 - 产品化思考以后的问题</p><ul><li>愿景是什么？<ul><li>中台作为产品需要有自己的愿景定位，不一定需要满足所有前台客户的需求，这同样也意味着前台可以选择不使用中台的某些能力而选择自建。</li></ul></li><li>用户是谁？ 如何划分？<ul><li>中台作为产品需要有自己清晰的用户定位和用户划分，前台作为中台的用户不再是平等的，VIP 前台用户的需求要优于免费前台用户的诉求，通过产品上常见的用户划分来解决需求膨胀、排期、优先级和冲突问题</li></ul></li><li>解决了什么问题？<ul><li>中台作为一个产品，需要想方设法体现自身的价值，真正为前台客户解决实际问题，并关注前台用户体验，通过营销和售前等手段获取前台客户，通过清晰的用户定位和产品力吸引前台客户，让其主动选择采购中台产品</li></ul></li><li>竞争环境？ 团队构成？<ul><li>产品的建设初期，不一定启动资金直接从业务上切分，可能需要类似于天使投资的企业战略投资进行初始孵化，减少中台前期建设的业务交付压力，甚至作为企业的战略级产品，需要一些内部保护和孵化，但仍需要快速验证其价值，获取客户，实现自负盈亏</li></ul></li><li>如何获取用户？营销？售前？</li><li>如何向用户提供服务？<ul><li>产品的建设过程可以借鉴精益创业思路，需要尽快体现其商业价值，如果一定时期内无法获取相应的前台用户（前台不用），或是其他考核指标不达标，则需要进行中台建设止损，类似于创业失败</li><li>甚至在特殊情况下，允许同一类型的中台产品存在合理的内部竞争，同时对两个相似的中台产品进行孵化，使用类似于内部赛马的机制解决内部服务差异性带来的内部产品垄断和定价困难问题</li><li>中台产品为了用户留存，需要对于前台客户提供产品级 SLA，提供客户运营，客户售后服务，保持产品平滑更新，关注用户满意度，实现客户留存与转化</li></ul></li><li>如何验证价值？成本核算？ 定价机制？</li><li>如何保证服务质量？ </li><li>如何升级演进？产品运营？<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1></li></ul></li></ul><ol><li><a href="https://www.infoq.cn/profile/1084916/publish" target="_blank" rel="noopener">https://www.infoq.cn/profile/1084916/publish</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前面两篇文章讲了一些关于中台的信息, &lt;a href=&quot;https://llchen60.com/%E4%B8%AD%E5%8F%B0/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;中台1&lt;/a&gt;,&lt;a href=&quot;https://llchen60.co
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="中台" scheme="https://www.llchen60.com/tags/%E4%B8%AD%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>Bash 脚本</title>
    <link href="https://www.llchen60.com/Bash-%E8%84%9A%E6%9C%AC/"/>
    <id>https://www.llchen60.com/Bash-%E8%84%9A%E6%9C%AC/</id>
    <published>2020-05-08T05:24:54.000Z</published>
    <updated>2020-05-10T05:59:04.101Z</updated>
    
    <content type="html"><![CDATA[<p>Bash是大多数Linux发行版的默认Shell（命令行环境），值得去研究一波~</p><p>最近也有很多人转而使用zsh，看到一个不错的<a href="https://apple.stackexchange.com/questions/361870/what-are-the-practical-differences-between-bash-and-zsh" target="_blank" rel="noopener">post</a>,讲了二者的主要区别</p><h1 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1. 基本语法"></a>1. 基本语法</h1><ul><li><p>echo 在屏幕输出一行文本，可以将该命令的参数原样输出</p><ul><li><code>-n</code> 取消末尾的回车符</li><li><code>-e</code> 解释引号当中的特殊字符，进行转义 </li></ul></li><li><p>命令格式</p><ul><li><code>command [arg1 ... argN]</code></li><li><code>ls -l</code> 等于 <code>ls --list</code><ul><li>其实主要是写script的时候为了让语句自己能够解释自己，会选用长形式，其余时候一般都选用短形式的语句</li></ul></li></ul></li><li><p>分号</p><ul><li>命令的结束符，使得一行可以放置多个命令</li><li>上个命令执行完之后，才会执行下一个命令</li><li>后一个指令总会接着第一个来执行，不管第一个成功或者失败</li></ul></li><li><p>命令组合符</p><ul><li><code>command1 &amp;&amp; command2</code> <ul><li>如果command1成功，才会继续执行command2</li></ul></li><li><code>command1 || command2</code><ul><li>如果command1成功，就不执行command2了</li></ul></li></ul></li><li><p>type命令  – 用于判断命令的来源，是内置的命令或者外部程序</p><ul><li><code>-a</code> 去查看一个命令的所有定义</li><li><code>-t</code> 可以返回一个命令的类型<ul><li>alias</li><li>keyword</li><li>function</li><li>builtin</li><li>file</li></ul></li></ul></li><li><p>快捷键</p><ul><li><code>Ctrl + L</code>：清除屏幕并将当前行移到页面顶部。</li><li><code>Ctrl + C</code>：中止当前正在执行的命令。</li><li><code>Shift + PageUp</code>：向上滚动。</li><li><code>Shift + PageDown</code>：向下滚动。</li><li><code>Ctrl + U</code>：从光标位置删除到行首。</li><li><code>Ctrl + K</code>：从光标位置删除到行尾。</li><li><code>Ctrl + D</code>：关闭 Shell 会话。</li></ul></li></ul><h1 id="2-模式扩展"><a href="#2-模式扩展" class="headerlink" title="2. 模式扩展"></a>2. 模式扩展</h1><p>Shell接到用户输入命令，通过空格进行对输入的分割，拆成词元，然后扩展词元里面的特殊字符，来调用相应的命令。</p><ul><li><p>波浪线扩展</p><ul><li>自动扩展为当前用户的主目录</li></ul></li><li><p><code>？</code>扩展</p><ul><li>？代表文件路径里面的任意单个字符，不包括空字符</li><li><code>file???</code>就表示file后面跟着三个字符的文件名</li></ul></li><li><p><code>*</code>扩展</p><ul><li>代表文件路径里面的任意数量的字符，包括零个字符</li><li>注意不会匹配隐藏文件</li></ul></li><li><p><code>[]</code>扩展</p><ul><li>匹配内部包含的任意一个</li><li><code>[abcde]</code>就会匹配abcde里面的任意一个</li><li><code>[!abc]</code> or <code>[^abc]</code> 表示匹配除了abc以外的其他字符</li></ul></li><li><p><code>[start-end]</code>扩展</p><ul><li>表示匹配一个连续的范围</li><li><code>[a-c]</code>等同于[abc]</li></ul></li><li><p><code>{...}</code>扩展</p><ul><li>指分别扩展为大括号当中定义的所有值</li><li>大括号颞部逗号前后不能有空格</li><li><code>echo d{a,e,i,u,o}g</code><ul><li>output:  dag deg dig dug dog</li></ul></li></ul></li><li><p><code>{start..end}</code>扩展</p><ul><li><code>echo {1..4}</code><ul><li>output: 1 2 3 4</li></ul></li></ul></li><li><p>字符类</p><ul><li><code>[[:class:]]</code> 表示一个字符类，扩展成某一类特定字符之中的一个</li><li><code>[[:alnum:]]</code>：匹配任意英文字母与数字</li><li><code>[[:alpha:]]</code>：匹配任意英文字母</li><li><code>[[:blank:]]</code>：空格和 Tab 键。</li><li><code>[[:cntrl:]]</code>：ASCII 码 0-31 的不可打印字符。</li><li><code>[[:digit:]]</code>：匹配任意数字 0-9。</li><li><code>[[:graph:]]</code>：A-Z、a-z、0-9 和标点符号。</li><li><code>[[:lower:]]</code>：匹配任意小写字母 a-z。</li><li><code>[[:print:]]</code>：ASCII 码 32-127 的可打印字符。</li><li><code>[[:punct:]]</code>：标点符号（除了 A-Z、a-z、0-9 的可打印字符）。</li><li><code>[[:space:]]</code>：空格、Tab、LF（10）、VT（11）、FF（12）、CR（13）。</li><li><code>[[:upper:]]</code>：匹配任意大写字母 A-Z。</li><li><code>[[:xdigit:]]</code>：16进制字符（A-F、a-f、0-9）</li></ul></li><li><p>量词语法</p><ul><li><code>?(pattern-list)</code>：匹配零个或一个模式。</li><li><code>*(pattern-list)</code>：匹配零个或多个模式。</li><li><code>+(pattern-list)</code>：匹配一个或多个模式。</li><li><code>@(pattern-list)</code>：只匹配一个模式。</li><li><code>!(pattern-list)</code>：匹配零个或一个以上的模式，但不匹配单独一个的模式</li></ul></li><li><p>shopt 命令 – 用来调整bach的行为</p><ul><li>-s 打开某个参数</li><li>-u 关闭某个参数</li><li>直接加 optionName  可以来查询某个参数是关闭的还是打开的</li><li>参数<ul><li>dotglob  让扩展结果包括隐藏文件</li><li>nullglob 让通配符不匹配任何文件名，返回空字符</li><li>failglob 使得通配符不匹配任何文件名时，Bash 会直接报错，而不是让各个命令去处理</li><li>extglob 支持ksh的一些扩展语法</li><li>nocaseglob 让通配符扩展不区分大小写</li><li>globstar  是的<code>**</code>可以匹配零个或多个子目录</li></ul></li></ul></li><li><p>tips</p><ul><li>通配符是先解释，再执行</li><li>文件名扩展不匹配的时候，会原样输出</li><li>只适用于单层路径 </li></ul></li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://wangdoc.com/bash/grammar.html" target="_blank" rel="noopener">https://wangdoc.com/bash/grammar.html</a> </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Bash是大多数Linux发行版的默认Shell（命令行环境），值得去研究一波~&lt;/p&gt;
&lt;p&gt;最近也有很多人转而使用zsh，看到一个不错的&lt;a href=&quot;https://apple.stackexchange.com/questions/361870/what-are-
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.llchen60.com/categories/Linux/"/>
    
    
      <category term="bash" scheme="https://www.llchen60.com/tags/bash/"/>
    
  </entry>
  
  <entry>
    <title>关于时间管理</title>
    <link href="https://www.llchen60.com/%E5%85%B3%E4%BA%8E%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/"/>
    <id>https://www.llchen60.com/%E5%85%B3%E4%BA%8E%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/</id>
    <published>2020-05-06T05:33:31.000Z</published>
    <updated>2020-05-06T05:34:05.299Z</updated>
    
    <content type="html"><![CDATA[<p>最近给自己添了些个人的项目，然后，瞬间感觉到时间不够用。会有忙了一天不知道自己忙什么了的感觉，会有一天被无穷的琐事，被各种问题，沟通占满，然后本来计划做的事情什么都没做的时候。hmm，看了一些博客和书，试着将学到的一些方法用在每天的安排上，发现效果还不错. </p><p>整理了思维导图，和大家分享下。其中对我帮助最大的一条，是关于如何真正的分清楚一件事情的重要程度和紧急程度，不是老板跟你说很重要，PM在屁股后面追着你这件事情就是很重要的。弄清楚他们为什么有这个需求，有没有更加快捷的解决方式更重要。如果更近距离的看，一种理解就是–不是别人用通信软件找你，你就必须当下看当下回，按照自己的工作节奏，保证自己在做的事情没有被打断，这往往是更有效率的方式。</p><p>喜欢书中所说的”做事情靠系统，而不是靠直觉“。希望大家都能建立自己的系统！ </p><p><img src="https://i.loli.net/2020/05/06/rqCPTkEKiV5pYM3.png" alt="时间管理思维导图"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近给自己添了些个人的项目，然后，瞬间感觉到时间不够用。会有忙了一天不知道自己忙什么了的感觉，会有一天被无穷的琐事，被各种问题，沟通占满，然后本来计划做的事情什么都没做的时候。hmm，看了一些博客和书，试着将学到的一些方法用在每天的安排上，发现效果还不错. &lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
    
      <category term="Notes" scheme="https://www.llchen60.com/categories/Notes/"/>
    
    
      <category term="时间管理" scheme="https://www.llchen60.com/tags/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Java 多线程 基础知识(二)</title>
    <link href="https://www.llchen60.com/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E4%BA%8C/"/>
    <id>https://www.llchen60.com/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E4%BA%8C/</id>
    <published>2020-05-03T17:51:40.000Z</published>
    <updated>2020-05-03T18:20:26.370Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-并发容器"><a href="#1-并发容器" class="headerlink" title="1. 并发容器"></a>1. 并发容器</h1><h2 id="1-1-ConcurrentHashMap"><a href="#1-1-ConcurrentHashMap" class="headerlink" title="1.1 ConcurrentHashMap"></a>1.1 ConcurrentHashMap</h2><ul><li><p>HashMap不是线程安全的</p></li><li><p>并发情况下一个可行的方式是使用Collections.synchronizedMap()来包装HashMap。</p><ul><li>但问题在于一个全局的锁同步不同线程之间的并发访问，会带来不可忽视的性能问题</li></ul></li><li><p>故而使用ConcurrentHashMap</p><ul><li>读写都能保证较高的性能</li><li>读操作时几乎不需要加锁</li><li>写操作的时候通过锁分段技术只对所操作的段加锁而不影响客户端对其他段的访问</li></ul></li></ul><ul><li><p>ConcurrentHashMap和HashTable的区别主要体现在实现线程安全的方式上不同</p><ul><li>底层数据结构<ul><li>ConcurrentHashMap使用分段的数组和链表</li><li>Hashtable用数组和链表，数组为主体，链表是为了解决哈希冲突的</li></ul></li><li>线程安全的实现方式<ul><li>使用node数组 + 链表 + 红黑树的数据结构来实现，并发控制使用synchronized和CAS操作</li><li>Hashtable是使用synchronized来保证线程安全的，效率相对较低<h2 id="1-2-CopyOnWriteArrayList"><a href="#1-2-CopyOnWriteArrayList" class="headerlink" title="1.2 CopyOnWriteArrayList"></a>1.2 CopyOnWriteArrayList</h2></li></ul></li></ul></li><li><p>针对现实应用场景当中，读操作远远多于写操作，因为读操作不会修改原有数据，所以就不对读进行加锁操作了。允许多个线程同时访问list的内部数据。</p></li><li><p>ReentranReadWriteLock 读写锁是读读共享、写写互斥、读写互斥、写读互斥</p></li><li><p>而CopyOnWriteArrayList 是读取完全不加锁，写入也不会阻塞读取操作，只有写入和写入之间需要进行同步等待。</p></li></ul><ul><li>如何实现的<ul><li>所有可变操作（add，set 等等）都是通过创建底层数组的新副本来实现的。当 List 需要被修改的时候，我并不修改原有内容，而是对原有数据进行一次复制，将修改的内容写入副本。写完之后，再将修改完的副本替换原来的数据，这样就可以保证写操作不会影响读操作了。</li><li>从计算机系统的角度来说，实际上是拷贝内存，在新内存完成写操作，并将原先的内存指针指向新的内存，原有的内存就可以被回收掉了</li></ul></li></ul><pre><code>    /** The array, accessed only via getArray/setArray. */    private transient volatile Object[] array;    public E get(int index) {        return get(getArray(), index);    }    @SuppressWarnings(&quot;unchecked&quot;)    private E get(Object[] a, int index) {        return (E) a[index];    }    final Object[] getArray() {        return array;    }        /**     * Appends the specified element to the end of this list.     *     * @param e element to be appended to this list     * @return {@code true} (as specified by {@link Collection#add})     */    public boolean add(E e) {        final ReentrantLock lock = this.lock;        lock.lock();//加锁        try {            Object[] elements = getArray();            int len = elements.length;            Object[] newElements = Arrays.copyOf(elements, len + 1);//拷贝新数组            newElements[len] = e;            setArray(newElements);            return true;        } finally {            lock.unlock();//释放锁        }    }</code></pre><h2 id="1-3-ConcurrentLinkedQueue"><a href="#1-3-ConcurrentLinkedQueue" class="headerlink" title="1.3 ConcurrentLinkedQueue"></a>1.3 ConcurrentLinkedQueue</h2><p>Java 提供的线程安全的 Queue 可以分为阻塞队列和非阻塞队列，其中阻塞队列的典型例子是 BlockingQueue，非阻塞队列的典型例子是 ConcurrentLinkedQueue，在实际应用中要根据实际需要选用阻塞队列或者非阻塞队列。 阻塞队列可以通过加锁来实现，非阻塞队列可以通过 CAS 操作实现。</p><p>从名字可以看出，ConcurrentLinkedQueue这个队列使用链表作为其数据结构．ConcurrentLinkedQueue 应该算是在高并发环境中性能最好的队列了。它之所有能有很好的性能，是因为其内部复杂的实现。</p><p>其中主要使用CAS非阻塞算法来实现</p><h1 id="2-乐观锁悲观锁"><a href="#2-乐观锁悲观锁" class="headerlink" title="2. 乐观锁悲观锁"></a>2. 乐观锁悲观锁</h1><p>乐观锁适用于写比较少的情况，即冲突本身发生的可能性就比较低，这样就能省去锁的开销，加大整个系统的吞吐量；但是多写的情况下，会比较容易产生冲突，这样就会导致上层不断进行retry，反倒会降低性能，所以一般多写的场景下用悲观锁比较合适。</p><h2 id="2-1-乐观锁"><a href="#2-1-乐观锁" class="headerlink" title="2.1 乐观锁"></a>2.1 乐观锁</h2><p>总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用<strong>版本号机制</strong>和<strong>CAS算法</strong>实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。</p><p>关于CAS算法，实质上就先拿到指定内存上的数据，（读取操作），线程操作处理数据，在要写入之前，再次查询该内存位置上的数据，如果数据一致，那就可以写入，如果数据不一致，就throw exception，告知系统出现了问题。</p><h3 id="2-1-1-乐观锁实现方式"><a href="#2-1-1-乐观锁实现方式" class="headerlink" title="2.1.1 乐观锁实现方式"></a>2.1.1 乐观锁实现方式</h3><p>乐观锁可以使用版本号机制或者CAS算法来进行实现</p><ul><li><p>版本号机制</p><ul><li>在数据表中加上数据版本号version字段，表示数据被修改的次数</li><li>被修改，version值会+1</li><li>当线程A要更新数据时，读数据的同时也会读取version值，提交更新的时候，若刚才读取到的version值和当前数据库的version值相等才更新，否在重试</li></ul></li><li><p>CAS算法</p><ul><li>compare and swap算法，无锁编程</li><li>不使用锁的情况下实现多线程之间的变量同步，即在没有线程被阻塞的情况下实现变量的同步 – 非阻塞同步 Non=blocking synchronization </li></ul></li></ul><h3 id="2-1-2-缺点"><a href="#2-1-2-缺点" class="headerlink" title="2.1.2 缺点"></a>2.1.2 缺点</h3><ul><li><p>ABA 问题</p><ul><li>一个变量初始值为A，在准备赋值的时候仍为A，但是在这段时间当中它有可能已经被改为了其他的值了，CAS操作会认为它从来没有被修改过</li><li>可以使用AtomicStampedReference类，compareAndSet方法首先检查当前引用是否等于预期引用，以及当前标志是否等于预期标志。如果全部相等，就以原子方式将该引用和该标志的值设置为给定的更新值。</li></ul></li><li><p>循环时间开销大</p><ul><li>自旋CAS如果长时间不成功，会给CPU带来很大的执行开销</li></ul></li><li><p>只能保证一个共享变量的原子操作</p><ul><li>CAS只对单个共享变量有效，当操作涉及多个共享变量的时候CAS无效</li><li>AtomicReference这一类能够保证引用对象之间的原子性，可以将多个变量放在一个对象里进行CAS操作</li></ul></li></ul><h2 id="2-2-悲观锁"><a href="#2-2-悲观锁" class="headerlink" title="2.2 悲观锁"></a>2.2 悲观锁</h2><p>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。</p><h1 id="3-线程池"><a href="#3-线程池" class="headerlink" title="3. 线程池"></a>3. 线程池</h1><ul><li>线程池用来限制和管理资源，每个线程池还可以维护一些基本统计信息</li><li>好处<ul><li>降低资源消耗<ul><li>重复利用已经创建的线程，来降低线程创建和销毁造成的消耗</li></ul></li><li>提高响应速度<ul><li>当任务到达时，任务可以不需要的等到线程创建就能立即执行</li></ul></li><li>提高线程的可管理性<ul><li>线程是稀缺资源，无限制创建会消耗系统资源，并且降低系统稳定性；使用线程池可以进行统一分配，调优和监控</li></ul></li></ul></li></ul><h2 id="3-1-ThreadPoolExecutor详解"><a href="#3-1-ThreadPoolExecutor详解" class="headerlink" title="3.1 ThreadPoolExecutor详解"></a>3.1 ThreadPoolExecutor详解</h2><pre><code>/** * 用给定的初始参数创建一个新的ThreadPoolExecutor。 */public ThreadPoolExecutor(int corePoolSize,                          int maximumPoolSize,                          long keepAliveTime,                          TimeUnit unit,                          BlockingQueue&lt;Runnable&gt; workQueue,                          ThreadFactory threadFactory,                          RejectedExecutionHandler handler) {    if (corePoolSize &lt; 0 ||        maximumPoolSize &lt;= 0 ||        maximumPoolSize &lt; corePoolSize ||        keepAliveTime &lt; 0)        throw new IllegalArgumentException();    if (workQueue == null || threadFactory == null || handler == null)        throw new NullPointerException();    this.corePoolSize = corePoolSize;    this.maximumPoolSize = maximumPoolSize;    this.workQueue = workQueue;    this.keepAliveTime = unit.toNanos(keepAliveTime);    this.threadFactory = threadFactory;    this.handler = handler;}</code></pre><ul><li>corePoolSize <ul><li>定义了不会timeout的最小的同时工作的线程数量</li></ul></li><li>maxPoolSize<ul><li>定义了可以被创建的线程的最大数量</li><li>和CorePoolSize的区别在于当提交一个新的任务，当前线程数量小于corePoolSize的时候，哪怕现在存在的线程是空闲的，还是会创建新线程来运行这个任务；maxPoolSize说的是最多能够创建的线程数量，是上限</li></ul></li><li>workQueue<ul><li>当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中</li></ul></li><li>handler 饱和策略 - 当当前同时运行的线程数量达到最大线程数量，并且队列已经被放满了的时候的策略<ul><li>AbortPolicy<ul><li>抛出RejectedExecutionException来拒绝新的任务的处理</li></ul></li><li>CallerRunsPolicy <ul><li>调用执行自己的线程运行任务，会有延迟</li></ul></li><li>DiscardPolicy  <ul><li>不处理新任务，直接丢弃掉</li></ul></li><li>DiscardOldestPolicy <ul><li>丢弃最早的未处理的任务请求</li></ul></li></ul></li></ul><ul><li><p>Executor.execute代码的源码如下： </p><pre><code>  // 存放线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)  private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));  private static int workerCountOf(int c) {      return c &amp; CAPACITY;  }  private final BlockingQueue&lt;Runnable&gt; workQueue;  public void execute(Runnable command) {      // 如果任务为null，则抛出异常。      if (command == null)          throw new NullPointerException();      // ctl 中保存的线程池当前的一些状态信息      int c = ctl.get();      //  下面会涉及到 3 步 操作      // 1.首先判断当前线程池中之行的任务数量是否小于 corePoolSize      // 如果小于的话，通过addWorker(command, true)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。      if (workerCountOf(c) &lt; corePoolSize) {          if (addWorker(command, true))              return;          c = ctl.get();      }      // 2.如果当前之行的任务数量大于等于 corePoolSize 的时候就会走到这里      // 通过 isRunning 方法判断线程池状态，线程池处于 RUNNING 状态才会被并且队列可以加入任务，该任务才会被加入进去      if (isRunning(c) &amp;&amp; workQueue.offer(command)) {          int recheck = ctl.get();          // 再次获取线程池状态，如果线程池状态不是 RUNNING 状态就需要从任务队列中移除任务，并尝试判断线程是否全部执行完毕。同时执行拒绝策略。          if (!isRunning(recheck) &amp;&amp; remove(command))              reject(command);              // 如果当前线程池为空就新创建一个线程并执行。          else if (workerCountOf(recheck) == 0)              addWorker(null, false);      }      //3. 通过addWorker(command, false)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。      //如果addWorker(command, false)执行失败，则通过reject()执行相应的拒绝策略的内容。      else if (!addWorker(command, false))          reject(command);  }</code></pre></li></ul><p><img src="https://i.loli.net/2020/05/02/t7yVTDjNZdnEahw.png" alt="execute process"></p><h2 id="3-2-Executor框架"><a href="#3-2-Executor框架" class="headerlink" title="3.2 Executor框架"></a>3.2 Executor框架</h2><p>Java5以后引入的Executor，用其启动线程比使用Thread的start方法更好，易管理，效率高，还可以帮助避免this逃逸的问题。Executor框架提供了：</p><ul><li>线程池管理</li><li>线程工厂</li><li>队列</li><li>拒绝策略</li></ul><h3 id="3-2-1-框架结构"><a href="#3-2-1-框架结构" class="headerlink" title="3.2.1 框架结构"></a>3.2.1 框架结构</h3><ul><li>任务<ul><li>执行任务实现Runnable或者Callable接口，然后被ThreadPoolExecutor或者ScheduledThreadPoolExecutor来执行</li></ul></li><li>任务执行<ul><li>Executor</li></ul></li><li>异步计算的结果<ul><li>Future接口以及Future接口实现类FutureTask都可以来代表异步计算的结果</li></ul></li></ul><p><img src="https://i.loli.net/2020/05/04/pxtNFGULRe3IT6a.png" alt="Exectuor 流程图"></p><p>整个过程中，主线程首先创建并实现了Runnable或者Callable的任务对象，而后将对象交给ExecutorService来执行，然后拿到返回的Future接口，执行FutureTask.get（）等方法来等待任务执行完成</p><h2 id="3-3-常用线程池"><a href="#3-3-常用线程池" class="headerlink" title="3.3 常用线程池"></a>3.3 常用线程池</h2><h3 id="3-3-1-FixedThreadPool"><a href="#3-3-1-FixedThreadPool" class="headerlink" title="3.3.1 FixedThreadPool"></a>3.3.1 FixedThreadPool</h3><ul><li><p>FixedThreadPool</p><ul><li>如果当前运行的线程数小于 corePoolSize， 如果再来新任务的话，就创建新的线程来执行任务；</li><li>当前运行的线程数等于 corePoolSize 后， 如果再来新任务的话，会将任务加入 LinkedBlockingQueue；</li><li>线程池中的线程执行完 手头的任务后，会在循环中反复从 LinkedBlockingQueue 中获取任务来执行；</li></ul></li><li><p>不推荐使用</p><ul><li><p>线程池中的线程数达到 corePoolSize 后，新任务将在无界队列中等待，因此线程池中的线程数不会超过 corePoolSize</p></li><li><p>由于使用无界队列时 maximumPoolSize 将是一个无效参数，因为不可能存在任务队列满的情况。所以，通过创建 FixedThreadPool的源码可以看出创建的 FixedThreadPool 的 corePoolSize 和 maximumPoolSize 被设置为同一个值</p></li><li><p>由于上述两点，keepAliveTime就会是一个无效参数了</p></li><li><p>因为无法执行shutdown() shutdownNow()，不会拒绝任务，在任务比较多的时候会导致OOM(内存溢出的问题)</p><p>public static ExecutorService newFixedThreadPool(int nThreads) {<br>  return new ThreadPoolExecutor(nThreads, nThreads,</p><pre><code>                            0L, TimeUnit.MILLISECONDS,                            new LinkedBlockingQueue&lt;Runnable&gt;());</code></pre><p>}</p></li></ul></li></ul><h3 id="3-3-2-CachedThreadPool"><a href="#3-3-2-CachedThreadPool" class="headerlink" title="3.3.2 CachedThreadPool"></a>3.3.2 CachedThreadPool</h3><p>可以根据需要来创建新线程的线程池</p><pre><code>    /**     * 创建一个线程池，根据需要创建新线程，但会在先前构建的线程可用时重用它。     */    public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) {        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,                                      60L, TimeUnit.SECONDS,                                      new SynchronousQueue&lt;Runnable&gt;(),                                      threadFactory);    }</code></pre><p>注意看源码中，corePoolSize设置为空，maximumPoolSize设置为无界的了，如果主线程提交任务的速度高于maximumPool中线程处理任务的速度，CachedThreadPool会不断创建新的线程，极端情况下，会耗尽CPU和内存资源的。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://github.com/Snailclimb/JavaGuide/" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide/</a> </li><li><a href="https://howtodoinjava.com/java/multi-threading/compare-and-swap-cas-algorithm/" target="_blank" rel="noopener">https://howtodoinjava.com/java/multi-threading/compare-and-swap-cas-algorithm/</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-并发容器&quot;&gt;&lt;a href=&quot;#1-并发容器&quot; class=&quot;headerlink&quot; title=&quot;1. 并发容器&quot;&gt;&lt;/a&gt;1. 并发容器&lt;/h1&gt;&lt;h2 id=&quot;1-1-ConcurrentHashMap&quot;&gt;&lt;a href=&quot;#1-1-Concurrent
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
      <category term="Multi-threading" scheme="https://www.llchen60.com/tags/Multi-threading/"/>
    
  </entry>
  
  <entry>
    <title>货币,信贷,债务是如何运作的 from Ray Dalio</title>
    <link href="https://www.llchen60.com/%E8%B4%A7%E5%B8%81-%E4%BF%A1%E8%B4%B7-%E5%80%BA%E5%8A%A1%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E4%BD%9C%E7%9A%84-from-Ray-Dalio/"/>
    <id>https://www.llchen60.com/%E8%B4%A7%E5%B8%81-%E4%BF%A1%E8%B4%B7-%E5%80%BA%E5%8A%A1%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E4%BD%9C%E7%9A%84-from-Ray-Dalio/</id>
    <published>2020-05-02T20:55:48.000Z</published>
    <updated>2020-05-02T20:56:34.090Z</updated>
    
    <content type="html"><![CDATA[<p>Ray Dalio在LinkedIn上的长文，主要分析了在长期债务周期当中，货币、信贷、债务之间的相互运作关系，以及它们驱动全球经济和政治变化的方式。</p><h1 id="1-货币和信贷"><a href="#1-货币和信贷" class="headerlink" title="1. 货币和信贷"></a>1. 货币和信贷</h1><p>所有实体（国家、公司、非营利组织和个人）都需处理基本财务，他们的收入和支出构成了净收入，而这些流动是可以用资产负债表中的数字来衡量的。如果一个人赚的比花的多，他就会有利润，从而使他的储蓄增加。而如果一个人的支出大于收入，那么他的储蓄就会减少，或者他不得不通过借钱或来弥补差额。<br>如果一个实体拥有巨额净资产，它的支出将可以高于收入，直到资金耗尽，这时它必须削减开支。如果不削减开支，它将会有大量负债/债务，如果它没有足够的收入来偿还，它就会违约。<br><strong>由于一个人的债务是另一个人的资产，债务违约会减少其他实体的资产，进而要求它们削减开支，从而导致债务下降和经济收缩。</strong></p><p>这种货币和信用体系适用于所有人、公司、非营利组织和政府，但有一个重要的例外。所有国家都可以印钞给人们消费或放贷。然而，<strong>并不是所有政府发行的货币都具有相同的价值</strong>。</p><p>在世界范围内被广泛接受的被称为储备货币。而在当今世界上，占主导地位的储备货币是美元，由美联储发行，占所有国际交易的55%。另一种则是欧元，由欧洲央行发行，占所有国际交易的25%。目前，日元、人民币和英镑都是相对较小的储备货币，尽管人民币的重要性正迅速上升。</p><p>拥有储备货币的国家更容易通过大量借贷摆脱困境。原因在于，世界上其他国家倾向于持有这些债务和货币，因为它们可以用来在世界各地消费。因此，拥有储备货币的国家可以发行大量以储备货币计价的信贷/债务，尤其是在目前这种储备货币短缺的情况下。</p><p>而相比之下，没有储备货币的国家则没有这种选择。它们在以下情况中，特别需要这些储备货币（如美元）：（1）他们有很多以他们不能印刷的储备货币计价的债务（如美元）；（2）他们在这些储备货币上没有多少储蓄；（3）他们获得所需货币的能力下降。当没有储备货币的国家急需储备货币来偿还他们的债务，以储备货币计价和交易的卖家希望它们用储备货币来支付时，它们就只能破产。这就是现在许多国家的情况。</p><p>这也是许多州、地方政府、公司、非营利组织和个人会面临的情况。当它们遭受了收入损失，有没有多少存款来弥补损失时，它们将不得不削减开支或通过其他方式获得资金和信贷。</p><p>这就是现在的世界上正在发生的事情：<strong><em>风险储蓄即将耗尽，以及债务违约的风险。有能力这样做的政府正在印钞，以帮助减轻债务负担，并帮助为以本国货币计价的开支提供资金。但这将削弱本国货币，提高本币的通胀水平，以抵消需求减少和被迫出售资产所造成的通货紧缩，而那些资金紧张的国家就不得不筹集现金</em></strong>。</p><ul><li>Essense<ul><li>一个人的债务是另外一个人的资产，债务违约会减少其他实体的资产，进而要求其消减开支，从而导致债务下降和经济收缩的自我强化。 </li><li>美国最近的大撒钱计划，致使美元指数强势增长，这是市场的避险情绪的体现。美元是全兑换，全流通的。市场的担忧，降息，使得直接持有美元的成本降低了。机构企业采取增加现金流的方式来防止出现流动性危机</li><li>美国政府通过印钞来减轻债务负担，提供商业运作所需的资金。</li></ul></li></ul><h1 id="2-什么是货币"><a href="#2-什么是货币" class="headerlink" title="2. 什么是货币"></a>2. 什么是货币</h1><p>货币本质上是一种交换媒介，也可以用来储存财富。</p><p>不言而喻，“交换媒介”指的是可以用来买东西的工具。而所谓财富储备，指的是在获取和消费之间储存购买力的工具。最合理的方式显然就是把钱存起来，以备不时之需，但人们往往不愿意持有货币，而总想把货币兑换成他们想买的东西。这就是信贷和债务发挥作用的地方。</p><p>当出借人放贷时，他们认为收回的钱会比本身持有的钱购买更多的商品和服务。如果做得好，借贷者就能有效地使用这些钱并获得利润，进而偿还贷款并保留一些额外的钱。当贷款尚未偿还时，它是贷款人的资产，也是借款人的负债。当钱被偿还时，资产和负债就消失了，这种交换对借方和贷方都有好处。他们从本质上分享了这种生产性贷款的利润。整个社会也得益于这种机制所带来的的生产力提高。</p><p>因此，重要的是要意识到：<br>1.大多数货币和信贷（尤其是现存的法定货币）<strong>没有内在价值</strong>；<br>2.它们只是会计系统中的账目，可以很容易地改变；<br>3.系统的目的是<strong>帮助有效地分配资源以便生产力增长</strong>；<br>4.该系统会周期性崩溃。所有的货币不是被摧毁就是贬值，财富随之发生大规模转移，对经济和市场产生巨大影响。</p><p>更具体地说，货币和信贷系统并没有完美地运转，而是<strong>在循环中改变货币的供应、需求和价值，在上升时产生富裕，在下降时产生重组</strong>。</p><h2 id="2-1-从基本面出发研究货币和信贷系统的周期"><a href="#2-1-从基本面出发研究货币和信贷系统的周期" class="headerlink" title="2.1 从基本面出发研究货币和信贷系统的周期"></a>2.1 从基本面出发研究货币和信贷系统的周期</h2><p><strong>虽然金钱和信贷与财富有关，但它们不是财富</strong>。因为钱和信贷可以买到财富（即商品和服务），所以一个人拥有的金钱和信贷的数量和财富的数量看起来差不多。</p><p>但是，一个人不能仅仅通过创造更多的金钱和信贷来创造更多的财富。要创造更多的财富，就必须要有更高的生产力。金钱和信贷的创造与财富（实际商品和服务）的创造之间的关系经常被混淆，但它是经济周期的最大驱动力，因此，让我们更仔细地研究一下这种关系。</p><p>一般来说，货币和信贷的创造与商品、服务和投资资产的数量之间存在正相关关系，因此很容易混淆。当人们有更多的钱和信贷时，他们就会想消费更多。从某种程度上说，消费增加了经济生产，提高了商品、服务和金融资产的价格，这可以说是增加了财富，因为拥有这些资产的人在我们衡量财富的方式下变得“更富有”。</p><p>然而，这种形式的财富增加更像是一种幻觉。原因有二：<strong>推动价格和生产上升的信贷必须偿还；事物的内在价值并不会增加</strong>。</p><p>举个例子，如果你有一套房子，政府创造了大量的货币和信贷，你的房子的价格会上升，但它仍然是原来的样子。你的实际财富没有增加，只是你计算出来的财富增加了。同样地，如果政府创造了大量的货币和信贷，用于购买商品、服务和金融资产（如股票、债券和房地产），那么你计算所得的财富数量就会增加，但实际财富仍将保持不变。换句话说，用一个人所拥有的市场价值来衡量他的财富，会给人一种财富变化的错觉，而这种变化实际上并不存在。</p><p>重要的是，<strong>货币和信贷在发放时具有刺激作用，而在必须偿还时却有抑制作用。</strong>这就是货币、信贷和经济增长如此具有周期性的原因。</p><p>为了控制市场和整体经济，货币和信贷的成本和可获得性各不相同。当经济增长过快，他们想要放缓增长速度时，就会减少货币和信贷投放，导致两者都变得更加昂贵。这鼓励了人们充当贷方而不是借钱和消费。当经济增长太慢，央行想要刺激经济时，他们就会让货币和信贷廉价而充足，从而鼓励人们借贷、投资和/或消费。货币和信贷的成本和可用性的这些变化也会导致商品、服务和金融资产的价格和数量的涨跌。但是，银行只能在其产生货币和信贷增长的能力范围内控制经济，而它们这样做的能力是有限的。</p><p>想象一下，中央银行有一瓶兴奋剂，他们可以根据需要注入经济，而瓶中的兴奋剂数量是有限的。当市场和经济衰退时，他们会提供货币和信贷刺激来提振经济，当市场过热时，他们会减少刺激。这些变动导致货币、信贷、商品、服务和金融资产的数量和价格的周期性涨跌。而这些举措通常以短期债务周期和长期债务周期的形式出现。</p><p>短期债务周期（即通常所说的“商业周期”）通常持续8年左右。时机取决于刺激措施将需求提升至实体经济生产能力极限所需的时间。而长期债务周期就是将这些短期债务周期加起来，通常持续50-75年。因为可能很多人的一生只会出现一次长期债务周期，所以大多数人都没有意识到。</p><p>长期债务周期通常开始于重组后的低水平债务时期，央行的瓶子里有很多刺激，而结束于高水平债务时期，央行的瓶子里就没有多少刺激了。更具体地说，当央行失去通过经济体系产生货币和信贷增长、进而推动实体经济增长的能力时，央行的刺激能力就会终止。当债务水平高企、利率无法充分降低、货币和信贷的创造对金融资产价格的影响大于对实际经济活动的影响时，央行就会丧失这种能力。在这种时候，那些持有债务的人通常想要把他们持有的货币债务换成其他的财富。当人们普遍认为，将获得资金的货币和债务资产并不是良好的财富储备时，长期债务周期就结束了，必须对货币体系进行重组。</p><ul><li>Essense <ul><li>货币和信贷系统在运行过程中，下降周期里会带来重组，会造成财富的巨大转移。</li><li>金钱和信贷不是财富，但可以买到财富。创造更多的金钱和信贷不意味着更多的财富，更多的生产力才是。</li></ul></li></ul><h1 id="3-长期债务周期"><a href="#3-长期债务周期" class="headerlink" title="3. 长期债务周期"></a>3. 长期债务周期</h1><ol><li>始于无或低债务和“硬通货”</li></ol><p>金银（有时还有铜和镍等其他金属）是首选的货币形式，因为它们具有内在价值，而且可以很容易地塑形，便于携带和兑换。具有内在价值很重要，因为与他们进行交易不需要任何的信任或信用。任何交易都可以当场成交，即使买卖双方是陌生人或敌人。</p><ol start="2"><li>“纸币”的诞生</li></ol><p>因为金属货币携带不便的原因，人们很快就把纸上的“货币债权”当成了货币本身。这种类型的货币系统被称为挂钩货币系统，因为货币的价值与某种东西的价值挂钩，通常是“硬通货”，如黄金。</p><p>3.债务增加</p><p>起初，“硬通货”的债权数量与银行里的硬通货数量相同。然而，持有人和银行发现了信贷和债务的奥妙之处：人们可以把“纸币”借给银行，以换取利息；而向他们借钱的银行又可以把钱借给其他人，换取更高的利息；而那些从银行借钱的人获得了前所未有的购买力。这个过程导致了<strong>资产价格和生产的上升</strong>。</p><p>然而，当一个人没有足够的收入/钱来偿还债务时，麻烦就来了。人们期望通过出售这些债权来获得购买商品和服务的资金，其增长速度超过了商品和服务的数量，这使得从这些债务资产（例如债券）的转换变得不可能。这两个问题往往同时出现。<br>关于第一个问题，可以把债务看作是负收益和负资产，负资产吞噬收益（因为收益必须用来偿还债务），吞噬其他资产（因为必须出售其他资产来获得偿还债务的资金）。它具有更高的优先级，意思是它必须在任何其他类型的资产之前得到支付，所以当收入和一个人的资产价值下降时，有必要削减开支和出售资产来筹集所需的现金。当这还不够时，就需要：</p><p>（1）债务重组，减少债务和债务负担。这对债务人和债权人都是有问题的，因为一个人的债务就是另一个人的资产。</p><p>（2）央行印钱、中央政府<strong>发放货币和信贷，以填补收入和资产负债表的漏洞</strong>（这也是现在正在发生的事情）。</p><p>当债务持有者不相信他们将从债务中获得足够的回报时，就会出现第二个问题。债务资产（如债券）是由投资者持有的，他们认为这些资产是可以出售来获得财富（钱）的，而这些钱可以用来买东西。当债务资产的持有者试图将其转换成真实的货币、真实的商品和服务，却发现他们做不到的时候，这个问题就出现了。然后就会发生所谓的“挤兑”。</p><p>无论是商业银行还是央行，都会面临着这样的选择：允许资金从债务资产中流出，从而提高利率，并导致债务和经济问题恶化；或者“印钞”，购买足够的债券，以防止利率上升，并逆转资金耗尽的趋势。</p><p>但如果货币债权和与货币数量和所要购买的商品和服务数量之比过高，银行就会陷入无法摆脱的困境，因为它根本没有足够的钱来满足这些债权，因此它将不得不违约。</p><p>当这种情况发生在央行身上时，它可以选择要么违约，要么印钞并使其贬值。贬值是无法避免的。当这些债务重组和货币贬值规模很大时，它们会导致货币体系崩溃。无论银行或中央银行做什么，债务越多，货币贬值的可能性就越大。记住，商品和服务的数量总是有限的，因为数量受到生产能力的限制。</p><p>在这里，明白金钱和债务的区别是很重要的。</p><p>金钱是用来应对债权的，也就是说，一个人为他的账单付了钱就完了。债务是未来交付金钱的承诺。</p><p>在观察经济机器是如何运作的过程中，重要的是观察a)债务和货币的数量相对于银行中的硬通货（如黄金）的数量，以及b)商品和服务的数量。</p><p>这两者的数量可能会有所不同，但是要记住，债务周期之所以发生，是因为绝大多数人喜欢扩大购买力（一般是通过债务），而中央银行倾向于扩大货币的数量，因为这样做的时候人们会更高兴。</p><p>但这种情况不可能一直持续下去。重要的是要记住，当银行——无论是私有银行还是中央银行——创造了比银行里的硬通货多得多的凭证（纸币和债务）时，终有一天拿来兑换的纸质凭证的数量会超过银行的偿付能力。</p><ol start="4"><li>随之而来的是债务危机、违约和货币贬值</li></ol><p>历史表明，当银行对货币的索取权的增长速度超过银行的货币总量时，“银行挤兑”就发生了。人们可以通过观察银行的资金数量下降，以及由于提款而接近枯竭的程度，准确地判断出什么时候发生了银行挤兑，什么时候银行业危机即将来临。</p><p>如果一家银行无法提供足够的硬通货来满足人们对它的要求，那么无论它是一家商业银行还是一家央行，都会陷入困境，尽管一般而言，央行比商业银行的选择更多一些。这是因为商业银行不能简单地印钞或修改法律以使其更容易地偿还债务，而中央银行可以。当私人银行家陷入困境时，他们要么违约，要么接受政府的救助。如果他们的债务是以本国货币计价的，中央银行可以贬值他们的债权（例如，偿还50-70%）。但如果债务是以他国货币计价的，那么他们最终也势必违约。</p><ol start="5"><li>法定货币</li></ol><p>央行希望拉长货币和信贷周期，使其持续尽可能长的时间，因为这比其他办法要好得多。所以，当 “硬通货”和”对硬通货的追索权”成为他们的严重束缚时，政府通常会放弃它们，转而采用所谓的 “法定”货币。</p><p>在法币体系中不需要硬通货，有的只是中央银行可以无限制”印制”的”纸币”。因此，央行不会面临 “硬通货”被抽干从而违约的风险。</p><p>此时的风险在于，摆脱了对持有有形黄金或其他 “硬”资产的限制，控制印刷厂的人（即与商业银行家一起工作的中央银行家）将不断创造出更多的货币、债务资产和负债，直到有一天，与商品和服务的数量相比，那些持有大量债务的人将试图把它们换成商品和服务时，会产生与银行挤兑一样的效果，导致债务违约或货币贬值。</p><p>这种转变：从a)债务追索权可按固定比例兑换成有形资产(如黄金)的体系转变为b)不在存在这种兑换的法币体系，最近一次发生是在1971年。</p><p>当年8月15日晚上，尼克松告诉全世界，美元将不再与黄金挂钩，我在电视上看到这些，心想，”我的天，我们所熟悉的货币体系就要结束了，”事实的确如此。</p><p>我当时在纽约证券交易所做职员，那个周一早上，我本来以为股票会下跌，从而出现大乱，结果发现股票上涨而导致大乱。</p><p>因为我从来没有见过贬值，不明白它们是如何运作的。然后我查了一下历史，发现在罗斯福发表类似讲话的那个3月5日星期天晚上，他也做了基本相同的事情，在接下来的几个月里，结果基本相同（货币贬值，股市大涨，金价大涨）。这种情况后来我看到很多国家发生过多次，包括国家元首们发表的基本相同的宣言。</p><p>在1971年之前的几年里，美国政府花了很多钱在军事和社会项目上，当时这被称为 “枪支和黄油”政策，它通过借钱来完成支付，而这些钱就产生了债务。</p><p>这些债务就是他人对货币的追索权，而这些追索权就可以用来换取黄金。投资者购买这些债务作为资产，因为他们得到了这笔政府债务的利息，而且美国政府承诺允许这些票据的持有者用这些票据换取美国金库中的黄金。</p><p>随着美国的支出和预算赤字的增长，美国不得不发行更多的债务，也就是说，创造了更多的黄金债权，但银行里的黄金数量却没有增加。</p><p>自然而然，用这种追索权换取黄金的投资者越来越多。明眼人都能看出美国的黄金已经快用完了，而未偿付的黄金债权数量远远大于银行里的黄金数量，所以他们意识到如果这样下去，美国就会违约。</p><p>当然，在那个时候，很多人看到了美国政府表面上的富有，认为它是不可能在偿付黄金债权上违约的。因此，大多数人对这一宣布以及对市场的影响感到惊讶，不过那些了解货币和信贷运作机制的人却不以为然。</p><p>当信贷周期达到极限时，中央政府及其央行的经典反应是创造大量的债务，并印钞，把钱花在商品、服务和投资资产上，以维持经济的发展。</p><p>这就是2008年债务危机期间的做法，当时利率已经达到0%，无法再降低。正如前文所解释的那样，这也是为了应对1929-32年的债务危机而做的，当时利率已经跌到0%。这种债务和货币的创造，现在出现的数额比二战以来的任何时候都要大。</p><p>说白了，央行 “印钱 “并将其用于支出，而不是用债务增长来支持支出，这并非没有好处。例如，钱可以像信贷一样用于消费，但实际上（而不是理论上）不需要偿还。换句话说，只要货币增长而不是信贷/债务增长，只要把钱用在生产性的用途上，就没有错。</p><p>不过采取印钱手段而不是促进信贷增长的主要风险在于：a)市场参与者不会仔细分析这些钱是否用于生产性用途；b)它省去了让还钱的必要性。</p><p>这两点都会增加激进印钱的概率，而且这些钱也不一定用于生产，所以人们就会停止把钱作为财富储藏手段，并将财富转移到其他东西上。</p><p>纵观历史，当硬通货（债务和货币凭证）的未偿还债权远远大于硬通货和商品和服务的数量时，总会发生大量违约或大量印钞和贬值。</p><p>历史已经告诉我们，我们不应该依赖政府在经济上保护我们。相反，我们应该知道，大多数政府会滥用他们作为货币和信贷的创造者和使用者的特权地位。假设你站在他们的立场上，你可能会做出一样的举动。</p><p>这是因为没有一个政策制定者能够驾驭整个周期。每一个人都是周期的某个阶段参与进来，他们只能根据当时的情况，做着对他们有利的事情。</p><p>因为在债务周期的早期，政府是值得信赖的，他们和其他人一样需要钱，甚至比其他人更需要钱，所以他们通常是最大的借款人。</p><p>而在周期的后期，当后续领导人上台执掌政府时，会面临更多债务。这时新的政府领导人和新的央行决策者们就要面对更大的挑战，此时一方面他们的刺激手段较少，同时还要必须偿还债务。</p><p>更为糟糕的是，政府还必须救助债务人，因为他们的倒下又会伤害到整个系统。因此，他们往往会陷入比个人、公司和大多数其他实体更大的现金流困境。</p><p>换句话说，在几乎所有情况下，政府在行动上助长了债务的积累，成为大的债务人，当债务泡沫破灭时，政府通过印钞和贬值来拯救自己和他人。债务危机越大，就越是如此。</p><p>虽然不可取，但出现这种情况也是可以理解的。当你可以制造货币和信贷，并把它传给每个人，让他们高兴的时候，你很难抵挡住诱惑。”这是典型的金融举动。纵观历史上的统治者，他们都会累积起大量在其统治期结束后很久才会到期的债务，让他们的继任者来收拾残局。</p><p>当政府出现债务问题时，他们会如何应对？</p><p>他们会和任何一个实际债务负担沉重的实体一样，用印钞来解决。无一例外，如果债务是以自己的货币计价，他们就会印钱让货币贬值。</p><p>当央行印钱买入债务，这就把钱放进了金融系统，并使金融资产的价格竞相上涨（这也扩大了贫富差距，因为它让那些拥有金融资产的人相对于没有金融资产的人受益更多）。</p><p>同时，它还把大量的债务掌握在央行手中，让央行可以随心所欲地处理这些债务。而且他们印钱和买入金融资产（主要是债券），也就把利率压低了，这就刺激了借钱和买入，并鼓励那些持有这些债券的人卖出债券，鼓励他们以低利率借钱，把钱投资于回报率较高的资产，这就导致央行印更多的钱，买入更多的债券，有时也买入其他金融资产。</p><p>这通常能很好地推高金融资产价格，但在把钱和信贷以及购买力送到最需要的人手中时，效率就很低了。这就是2008年发生的情况，在那之后的大部分时间里，直到最近也是如此。</p><p>然后，当印钞和央行买入金融资产无法把钱和信贷送到需要的地方时，中央政府——它可以决定把钱花在什么地方——从央行（印钞票的央行）那里借钱，这样它就可以把钱花在需要花的地方。在美国，美联储在2020年4月9日宣布了这一计划。</p><p>这种通过印钱买债（称为债务货币化）的方式，作为一种获取金钱和将财富从拥有金钱的人手中转移到需要金钱的人手中的方式，比起征税导致纳税人不满，在政治上要好得多。这就是为什么央行总是印钞票、让货币贬值的原因。</p><p>当政府印了很多钱，买了很多债，这样钱和债的数量都增加了，钱和债的价格就会便宜，这实质上是向拥有这些钱和债的人征税。</p><p>当这种情况发生得足够多，让这些钱和债务资产的持有者意识到发生了什么，他们就会寻求出售他们的债务资产和借钱，以获得他们可以用低廉资金来偿还的债务。</p><p>他们还经常将财富转移到其他的财富存储工具中，如黄金、某些类型的股票和其他地方（如另一个没有这些问题的国家）。在这种时候，央行通常会继续印钱，直接或间接地购买债务（例如，让银行代为购买），并禁止货币流向可以对冲通胀的资产和其他货币及场所。</p><p>这样的通胀期要么刺激货币和信贷扩张，为另一次经济扩张提供资金（这对股票有好处），要么使货币贬值，从而产生货币通胀（这对黄金等通胀对冲资产有好处）。</p><p>在长期债务周期较早的时候，当未偿债务数额不大，有很大的空间通过降息来刺激（如果不降息，就印钱和买入金融资产），那么信贷增长和经济增长的可能性就越大。</p><p>而在长期债务周期较晚的时候，当债务数额较大，没有太多空间通过降息（或印钱和买入金融资产）来刺激，那么伴随着经济疲软而出现货币通胀的可能性就越大。</p><ol start="6"><li>重回硬通货</li></ol><p>过度印制法币会导致债务资产的抛售，以及之前描述的类似银行”挤兑”的情况，最终会降低货币和信贷的价值，促使人们逃离货币和债务（如债券）。他们也就需要决定将使用何种替代性的财富存储方式。</p><p>历史经验告诉我们，他们通常会转向黄金、其他货币、其他国家没有这些问题的资产，以及能够保留其实际价值的股票。</p><p>有些人认为，世界需要另一种可供选择的储备货币，但事实并非如此，因为在没有可供选择的货币的情况下，从历史上看，货币体系崩溃和财富涌向其他资产，也同样会发生。</p><p>货币自身价值的减弱，会导致货币贬值，人们也会抛弃这种货币，并将资产投入其他地方。历史上，当货币贬值的时候，人们会奔向大量其他东西，甚至包括德国魏玛共和国的石头（用于建筑）。</p><p>通常情况下，在这个阶段的债务周期中，也会出现贫富差距过大造成的经济压力，这就导致了更高的税收和贫富之间的争斗，也使得那些拥有财富的人想要转移到硬资产和其他货币和其他国家。</p><p>很自然的，国家会阻止这种外逃。所以，在这种时候，政府就会加大对黄金（例如，通过取缔黄金的交易和所有权）、外国货币（通过取消其交易能力）、外国资产（通过建立外汇管制来防止资金流出国境）的投资难度。</p><p>最终，债务基本上被消灭，通常是通过让还债的钱既多又便宜，使货币和债务都贬值。</p><p>当这种情况变得极端，以至于货币和信贷体系崩溃，债务贬值和/或违约出现时，政府通常不得不回到某种形式的硬通货，以重建人们对货币作为财富存储的价值的信心，从而恢复信贷增长。</p><p>很多时候，尽管并非总是如此，但政府往往会将其货币与某种硬通货（如黄金或硬储备货币）挂钩，并承诺允许新货币的持有者将其兑换成硬通货。</p><p>有时，这些硬通货可能是另一个国家的硬通货。例如，在过去几十年里，许多弱货币国家将其货币与美元挂钩，或者干脆将其经济美元化（即，将美元作为自己的交易媒介和财富储存手段）。</p><p>回顾一下，在长期的债务周期中，将债务作为一种提供利息的资产持有，在周期初期没有大量债务未还的时候，通常会有回报。但这在周期后期有大量债务未还，且更接近于违约或贬值的时候，相对于给出的利息而言，持有债务是有风险的。</p><p>所以，持有债务（如债券）有点像持有一个定时炸弹，在它还在滴答的时候给你奖励，但一旦爆炸也会将你炸飞。而正如我们所看到的，大爆炸（即大违约或大贬值）大概每50-75年就会发生一次。</p><p>这些债务周期和注销债务的周期已经存在了几千年，在某些情况下已经制度化了。知道债务周期会在这个时间表上发生，会让每个人都能以理性的方式行事，为之做准备。帮助你了解这个情况，让你做好准备，而不是被它吓到，这是我写这篇文章的主要目的。</p><p>因为大多数人对这个周期与他们所经历的事情并不太注意，讽刺的是，越是接近被炸的人往往越是觉得安全。</p><p>那是因为他们一直持有债务，并享受着这样做的回报，而且从上一次爆仓的时间越长，随着上一次爆仓的记忆消退，他们就越是舒服——即使持有这笔债务的风险上升，而回报下降。</p><p>盯住需要偿还的债务相对于硬通货的数量，需要偿还的债务总量相对于债务人的现金流，以及借出资金的利息回报，就可以评估持有这颗定时炸弹的风险/回报。</p><h1 id="4-长期债务周期总结"><a href="#4-长期债务周期总结" class="headerlink" title="4. 长期债务周期总结"></a>4. 长期债务周期总结</h1><p>几千年来，货币制度一直有三种类型：</p><ul><li>硬通货（如金属硬币）</li><li>以“纸币”形式存在的对硬通货的的追索权</li><li>法定货币（如今天的美元）</li></ul><p>硬通货是最具限制性的货币体系，因为除非增加金属或其他具有内在价值的商品（即货币）的供应量，否则就无法创造货币。第二种类型更容易创造货币和信贷，因此硬通货债权与实际持有的硬通货之间的比率上升，最终导致银行挤兑。</p><p>结果有二：一是违约，银行关门且储户失去硬资产；二是有可能跟前者一起发生的债权货币贬值，这意味着储户拿回来的钱变少了。而在第三种类型中，政府可以自由地创造货币和信贷。只要人们对货币有信心，这种做法就持续有效，反之则无效。</p><p>纵观历史，各国在这些不同类型的制度之间过渡，都有合乎逻辑的原因。当一个国家需要的货币和信贷比现有数量更多时，无论是出于应对债务、战争还是其他原因，它自然会从第一种类型过渡到第二种类型，或从第二种类型过渡到第三种类型，这样它就有了更多的印钞灵活性。</p><p>此后，过多的货币供应和债务带来了货币贬值，致使人们不再持有债务和货币作为财富储备，转而回流到硬资产（如黄金）和其他货币中。鉴于这种情况一般发生在产生财富冲突或战争时期，人们通常也会想逃离此地。这类国家需要重新建立起以货币作为财富储备的信心，才能恢复信贷市场。</p><p>下图表达了上述不同的过渡历程。从宋朝到魏玛德国，历史上有很多这样的例子。有很多国家从约束型货币（第一类和第二类）全面过渡到法币，然后随着旧的法币超发，又回到约束型货币。</p><p><img src="https://i.loli.net/2020/05/03/sQkeWX7tDlzEGFn.png" alt="过渡历程"></p><p>如前所述，这个巨大的债务周期将会持续很长一段时间——大约50到75年。在周期结束时，其特征是债务和货币体系的重组。重组的突然之处在于，比如在债务和货币危机时期，重组通常发生得很快，且仅持续数月至三年，具体时间取决于政府采取这些措施所需的时间。然而，此后涟漪效应可能是长期的。</p><p>例如，这样的情况会导致储备货币不再是储备货币。在这些货币制度中，通常会有两到四次大的债务危机，大到足以导致银行业危机和债务减记或贬值30%以上的那种，但这还不足以打破货币体系。</p><p>我在许多国家投资了大约50年，经历了几十次债务危机。它们的运行方式都是一样的，我在《Principles for Navigating Big Debt Crises》一书中曾对此进行了更深入的解释。</p><h1 id="5-拥有储备货币给一个国家带来的不可思议的力量"><a href="#5-拥有储备货币给一个国家带来的不可思议的力量" class="headerlink" title="5. 拥有储备货币给一个国家带来的不可思议的力量"></a>5. 拥有储备货币给一个国家带来的不可思议的力量</h1><p>储备货币是一种在世界范围内被广泛用作交换媒介和财富储备的货币。使用越广泛、对其的依赖程度越深，储备货币和拥有储备货币的国家的实力也就越强。在此，我冒着重复一些之前讲过的东西并让你们觉得无聊的风险来回顾一下美国的情况，以及致使美国和美元让世界变成现在这样的环境情况。</p><p>如前文所述，世界新秩序始于1945年第二次世界大战结束之后，而布雷顿森林协定在1944年确立了美元作为世界主要储备货币的地位。</p><p>美国和美元自然而然地符合这一角色，因为战争结束时，美国政府持有全球约三分之二的黄金（当时是世界货币），美国占世界经济产出的50%，还在军事上占主导地位。新的货币制度属于第二类（即硬通货的债权），其他国家的央行可以35美元/盎司的价格将“纸质美元”兑换成黄金。</p><p>当时，个人持有黄金属于非法，其原因在于政府领导人不想让黄金作为财富储备来与货币和信贷竞争。所以，在那个时候，黄金就是银行里的钱，而纸币就像支票簿里的支票一样，可以兑换成真金白银。</p><p>在这个全新货币体系建立的时候，美国政府每持有一盎司黄金就拥有50美元的纸币，所以几乎100%有黄金做后盾。其他主要的美国盟国（如英国、法国和英联邦国家）或受美国控制的国家（德国、日本和意大利）都有受美国控制的货币与美元挂钩。</p><p>在此后的几年里，为了给自己的活动提供资金，美国政府的支出超过了税收收入，因此不得不借钱，从而产生了更多以美元计价的债务。美联储所允许建立的黄金债权数量（如美元计价的货币和信贷），远远超过了能以35美元价格兑换成的黄金实际数量。在纸币被兑换成硬通货（黄金）之后，美国银行之中的黄金数量随之下降，黄金债权则继续上升。其结果就是，在1971年8月15日，布雷顿森林货币体系崩溃了。</p><p>当时，时任美国总统尼克松和1933年3月5日的罗斯福一样，未能履行当局承诺，即允许美元持有者将其兑换成黄金。于是，美元对黄金和和其他货币贬值。这时，美国和所有国家都进入了第三种类型，法币体系。如果你想读一读有关如何从旧货币体系到新货币体系的精彩过程，我推荐保罗·沃尔克的《Changing Fortunes》，在谈判美国新货币体系应该运作时，他是首席谈判代表。</p><p>这种向法币体系的转变使美联储和其他中央银行得以创造大量以美元计价的货币和信贷，从而导致了1970年代的通货膨胀，其特点是从美元和美元债逃向商品、服务以及黄金等可以对冲通胀的资产。这种对美元债的恐慌情绪还导致了利率走高，并将金价从1944年至1971年期间固定的35美元推至当时的历史高位——1980年的670美元。</p><p>20世纪70年代，货币和信贷主要通过上述方式管理。这时，借入美元并将其转换为商品和服务是有利可图的，所以许多国家的许多实体都大量通过美国银行借入美元。结果，以美元计价的债务在全球范围内迅速增长，而美国银行通过把美元放给借款人来赚了很多钱。</p><p>这种贷款导致了债务周期中经典的债务泡沫。恐慌情绪让人逃离美元和美元债资产并转向通胀对冲资产，快速借入美元和背负债务的速度也在加快。这就造成了1979-1982年期间的货币和信贷危机。</p><p>在那期间，美元和美元债面临着不再担任公认财富储备的风险。当然，普通老百姓并不了解这种货币和信贷的动态是如何运作的，但他们以高通胀和高利率的形式感受到了它，这就成了一个巨大的政治问题。时任总统卡特和大多数政治领导人一样并不太了解货币机制，但他知道必须做点什么来阻止危机，于是任命了一位强有力的货币政策制定者——保罗·沃尔克。</p><p>几乎所有关注危机的人，包括我在内，都会注意听他说的每一句话。他足够强大，能够做一些令人痛苦但正确的事情来打破通货膨胀。他成为了我的英雄，最终还因其很棒的性格和出色的能力，成为了我的好朋友，我也喜欢他冷嘲式的幽默。 </p><p>德国前总理赫尔穆特·施密特认为，为了应对这场货币通胀危机并打破通货膨胀，沃尔克收紧了货币供应，将利率推到了”自耶稣基督诞生以来”的最高水平。</p><p>债务人就不得不在收入和资产贬值的同时，支付更多的偿债款。由此，债务人受到压榨，被逼出售资产。由于美元需求巨大，美元走强。基于这些原因，通货膨胀下降，美联储随之降低利率，放松了美国人的货币和信贷。</p><p>当然，许多债务人和贬值资产持有人都破产了。因此，在80年代，这些债务人，尤其是外国债务人，更尤其是新兴国家的债务人，经历了长达十年的经济萧条和债务重组时期。美联储通过向美国银行提供所需的资金来保护他们，而美国的会计制度则不要求银行将这些坏账作为损失来核算，或无需按照实际价格来对这些债务资产进行估值，从而保护美国银行免于破产。</p><p>这一债务管理和重组过程一直持续到1991年，最后以迎来用时任美国财政部长尼古拉斯·布雷迪名字命名的”布雷迪债券协议”而告终。1971-1991年整个周期几乎影响了世界上所有的人，这是美国脱离金本位的结果。</p><p>它导致了70年代的通胀和通胀对冲资产的飙升，随后又带来1979-1981年的紧缩、非美债务人大量的通缩债务重组、通胀率下降，以及1980年代债券和其他通缩资产的出色表现。这整个时期都有力地证明了拥有世界储备货币的美国具有怎样的力量，以及储备货币管理方式对世界各国的影响。</p><p>从1979-1981年期间以美元计价的通货膨胀率和利率双双达到峰值到现在，通胀和利率都降到了接近0%。你可以清楚地看到，自新的美元计价货币体系建立以来，利率和通胀整个大型周期的起起伏伏。</p><p><img src="https://i.loli.net/2020/05/03/QOHUyPVpERgM2AD.jpg" alt="通胀及利率的起伏"></p><p>在整个这段时间里，世界上以美元计价的货币、信贷和债务以及其他非债务性负债（如养老金和医保等）相对于收入而言持续上升。因为美联储有独特的能力来支撑这种债务增长，上述情况在美国尤为明显。</p><p>20世纪80年代债务重组完成后，全球货币、信贷和债务的全新增长又在90年代开始了。这再次带来了经济繁荣，并且导致投资者举债进行投机性投资，最终形成在2000年破裂的科网泡沫。</p><p>泡沫的破裂引出了2000-2001年的经济衰退，并刺激美联储放宽货币和信贷，将债务水平推到了新的高点。接下来，又一次的经济繁荣到来，另一个更大的债务泡沫在2007年诞生，于2008年破裂。</p><p>于是美联储和其他储备货币国家的央行再次宽松，又带来了近期刚刚破裂的下一个泡沫。然而，这一次创造应对经济衰退所需货币和信贷的方式却被设计得十分不同。</p><p>短期利率在2008年达到0%，而这个降息的幅度尚无法满足货币和信贷扩张的需要。通过降息刺激货币和信贷增长是央行的首选货币政策。我称其为”货币政策1”。随着这种方法不再适用于中央银行，他们就转向了第二选择（我称之为”货币政策2”），即印钞和购买以国债、优质债务为主的金融资产。</p><p>央行上一次需要这样做，是因为利率从1933年开始触及0%，且在战争年代也一直保持零利率。这种做法被称为”量化宽松”而不是”债务货币化”，是因为QE听起来没有那么大的威胁性。世界上所有的主要储备货币央行都已经这么做了。</p><p>这就带来了下一个货币/信贷/经济范式，直到我们现在经历的经济衰退之前，这一范式一直在持续。</p><p>自2008年开始的这一范式是这样的。</p><p>正如从1933年开始所做的那样，央行通过印钞和购买债券维持了货币和债务扩张周期。</p><p>通过购买债券，央行推高了债券价格，并为这些债券的卖家提供现金，致使他们去购买其他资产。这就推高了其他资产的价格，而随着这些资产价格上涨，未来的预期回报率随之下降。</p><p>由于利率低于其他投资的预期回报率，而相对于投资者为其各种支出义务提供资金所需的回报率而言，债券收益率和其他未来预期回报率的水平都很低，因此，投资者越来越频繁地借钱购买他们认为收益将高于借贷成本的资产。</p><p>这既推高了上述资产的价格，又造成了新的债务泡沫脆弱性——如果他们所购资产收益低于其借贷成本，就会产生新的债务泡沫。由于长期和短期利率都在0%左右，而且央行购买债券的资金无法刺激经济增长和帮助那些最需要帮助的人，所以我觉得第二种货币政策显然不能很好地发挥作用，这就需要第三种货币政策——“货币政策3”。</p><p>“货币政策3”的工作原理是，储备货币中央政府增加借贷，并将其支出和贷款的目标定在他们想要的地方，而储备货币中央银行则创造货币和信贷，并购买债务（可能还有其他资产，如股票）来提供资金。虽然我不会在这里解释各种方法，但在我的书《Principles for Navigating Big Debt Crises》当中已经解释过了。</p><p>因此，在疫情引发经济衰退之前，我们就已经做好了准备：一旦经济滑入衰退，就必须走这条路。如果你想要看我更为深入地研究相关话题的文章，可以点击economicprinciples.org。</p><p>无论如何，在这段时期内，债务和非债务性负债（如养老金和医保）相对于收入而言继续上升，而中央银行设法压低了偿债成本（详见我的报告”The Big Picture”，里面对此举所导致的、即将到来的“挤兑”解释得更完整）。</p><p>这就把利率推向了零，并使债务长期化，从而使本金偿付水平降低。诸如中央银行拥有大量的债务、利率在0%左右因此不需要支付利息、构建可以长期偿还的债务并使本金可以分散偿还甚至不用偿还之类的条件，意味着中央银行创造货币和信贷的能力几乎没有限制。这一系列的条件为接下来的事情奠定了基础。</p><p>新冠疫情引发了世界各地的经济和市场衰退，造成了收入和资产负债表方面的窟窿，特别是对那些收入受到衰退影响的负债实体来说，更是如此。</p><p>传统上，中央政府和央行必须创造货币和信贷，才能把钱和信贷送到他们想救的实体手中。如果没有这些钱和信贷，这些实体在财务上是无法生存的。</p><p>由此，2020年4月9日，美国中央政府（总统和国会）和美国央行（美联储）宣布了一项大规模的货币和信用创造计划，采用了“货币政策3”之中所有经典的手法，包括直升机撒钱（政府直接给公民发钱）。</p><p>这基本上与罗斯福在1933年3月5日宣布的计划是一样的。虽然是疫情引发了这次特殊的金融和经济衰退，但就算没有疫情，其他东西最终也会触发衰退。</p><p>无论衰退的起因是什么，但动力基本上都是一样的，因为只有“货币政策3”才会起到扭转经济衰退的作用。欧洲央行、日本央行以及中国人民银行也都采取了类似措施，不过最重要的仍是美联储的举动，因为它是美元的创造者，而美元仍然是世界上占主导地位的货币和信贷。</p><p>目前，美元在全球的国际交易、储蓄、借贷中约占55%。欧元区的欧元约占25%。日元占比不到10%。中国的人民币占2%左右。其他大多数货币都没有在国际上用作交换媒介和财富储存手段，仅在各国国内使用。</p><p>无论是上述各国国内的聪明人，还是这些国家以外的几乎所有人，都不会持有这部分货币并将其作为财富储备。相比之下，我提到的储备货币，就是全世界大多数人喜欢储蓄、借贷、交易的货币，大致比例和我上文所说的相同。</p><p>拥有世界储备货币的国家拥有惊人的力量——储备货币可能是最重要的力量，重要程度甚至超过军事力量。</p><p>这是因为当一个国家拥有储备货币时，它可以在合适的时候像美国现在这样印钱、借钱来消费，而那些没有储备货币的国家则必须先获得他们所需要的钱和信贷（以世界储备货币计价）才能进行交易和储蓄。</p><p>比如说现在，截止发稿，那些有很多债务需要偿还的人对美元的需求很强，因其需要更多的美元来购买商品和服务，但他们的美元收入已经下降。</p><p>正如章节一中表明衡量一国国力上升和下降的八项指标的图表所示，储备货币实力（以该货币的交易和储蓄份额来衡量）明显落后于衡量国家实力的其他指标。美国和美元的情况也是如此。</p><p>例如，在1944年，当美元被选定为全球主要储备货币时，美国政府持有的黄金占全球黄金总量的约三分之二（黄金当时被视为货币），美国经济则约占全球GDP的一半。</p><p>如今，美国GDP只占全球的20%左右，但美元仍占全球外汇储备的60%左右，还占有国际交易量的半壁江山。所以，美元和以美元为基础的货币和支付体系仍然占据着至高无上的地位，相对于美国经济的规模而言，它的规模还是特大号。</p><p>和所有印制储备货币的银行一样，美联储现在处于强势但尴尬的地位。其货币政策的运行方式对美国人有利，但对世界上其他依赖美元的国家来说，可能并不是好事。</p><p>比如美国中央政府最近刚刚决定，将借贷给美国人发放美元和美元信贷，美联储则决定购买美国政府的那笔国债和美国人其他的债务，帮助他们度过这次金融危机。可以理解的是，这些钱几乎没有多少会流向外国人。</p><p>欧洲央行也将对欧元区国家采取类似措施。世界影响力仍旧较小的日本央行也会为日本人做同样的事情，中国人民银行同样会为中国人做类似的事情。</p><p>其他几个相对较小的国家（如瑞士）也许可以为本国人民做类似的事情，但世界上大多数人无法像美国人那样，得到他们所需要的钱和信贷来填补收入和资产负债表的窟窿。</p><p>这一动态，即国家无法获得他们所需要的硬通货就像1982-1991年期间发生的事情一样，只是这次无法再靠大幅削减利率解决问题，而那个时候可以。</p><p>与此同时，非美国人（即新兴市场、欧洲国家和中国）持有的美元债总额约为20万亿美元（比2008年时高50%左右），其中短期债务不到一半。这些美元债务人将不得不拿出美元来偿还这些债务，还要拿出更多的美元来在世界市场上购买商品和服务。</p><p>所以，通过拥有美元作为世界储备货币并拥有生产这种货币的银行，且拥有把这些急需的美元放入美国人手中的实力，美国就可以比其他国家的政府更有效地帮助本国公民。</p><p>同时，美国也有可能会因为制造了太多的货币和债务而失去这种特权地位。在本章的附录中，我们将更深入地研究曾经拥有储备货币的国家是如何失去储备货币的，以及货币贬值是如何运作的。</p><h1 id="6-Summary"><a href="#6-Summary" class="headerlink" title="6. Summary"></a>6. Summary</h1><p>回过头来从大格局的角度看这一切，我想谈论的关系包括1）经济之间（即货币、信贷、债务、经济活动和财富）和2）政治之间（国家内部和各国之间），具体起起落落如下图所示。</p><p><img src="https://i.loli.net/2020/05/03/YEnmcZpRXAota3T.png" alt="债务周期"></p><p>通常情况下，大的周期始于一个全新的世界秩序，即一种囊括全新货币体系和政治制度、包含国内和国际运作的一种全新方式。最近的一次大周期始于1945年。</p><p>因为在那样的时期，冲突之后出现了具有主导力量的大国，大家都不愿意打仗，人们也厌倦了战斗，于是就有了和平重建和日益繁荣的局面，而这种繁荣是由可持续的信贷扩张来支撑的。</p><p>之所以说是可持续的，是因为收入的增长超过或跟上了偿还不断增长的债务所需的偿债支出，也是因为央行有能力刺激信贷，经济增速也很强劲。一路走来，过程中会出现短期的债务和经济周期，我们称之为衰退和扩张。</p><p>随着时间的推移，投资者以过去的收益推断未来，并借钱来押注收益可以实现。这就在贫富差距扩大（有些人的收益比其他人更多）的同时产生了债务泡沫。这种情况将一直持续下去，直到各国央行耗尽一切有效刺激信贷和经济增长的能力。</p><p>随着货币紧缩，债务泡沫破裂，信贷收缩，经济也随之萎缩。同时，当出现巨大的贫富差距、严重的债务问题且经济萎缩时，国家内部和国家之间往往会发生争夺财富和权力的斗争。</p><p>在债务和经济出现问题的时候，中央政府和中央银行通常会发行货币和信贷，并有可能使本币贬值。这些事态发展导致了债务、货币体系、国内秩序和世界秩序的重组。然后，事情又开始了。</p><p>虽然没有一个周期完全符合描述，但几乎所有周期都与之相差无几。比如说，虽然债务泡沫破裂一般会导致经济萎缩，经济萎缩叠加巨大的贫富差距通常会导致内斗和外斗，但有时顺序有些不同。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://www.thepaper.cn/newsDetail_forward_7147656" target="_blank" rel="noopener">https://www.thepaper.cn/newsDetail_forward_7147656</a></li><li><a href="https://www.linkedin.com/in/raydalio/detail/recent-activity/" target="_blank" rel="noopener">https://www.linkedin.com/in/raydalio/detail/recent-activity/</a></li><li><a href="https://m.chinanews.com/wap/detail/zw/cj/2020/03-19/9131125.shtml" target="_blank" rel="noopener">https://m.chinanews.com/wap/detail/zw/cj/2020/03-19/9131125.shtml</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Ray Dalio在LinkedIn上的长文，主要分析了在长期债务周期当中，货币、信贷、债务之间的相互运作关系，以及它们驱动全球经济和政治变化的方式。&lt;/p&gt;
&lt;h1 id=&quot;1-货币和信贷&quot;&gt;&lt;a href=&quot;#1-货币和信贷&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="Notes" scheme="https://www.llchen60.com/categories/Notes/"/>
    
    
      <category term="Economy" scheme="https://www.llchen60.com/tags/Economy/"/>
    
  </entry>
  
</feed>
