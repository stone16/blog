<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Leilei&#39;s Blog | 磊磊的博客</title>
  
  <subtitle>Because it&#39;s there</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.llchen60.com/"/>
  <updated>2020-02-04T04:27:50.684Z</updated>
  <id>https://www.llchen60.com/</id>
  
  <author>
    <name>Leilei Chen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>架构学习-高性能架构模式</title>
    <link href="https://www.llchen60.com/%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.llchen60.com/%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-02-04T04:25:06.000Z</published>
    <updated>2020-02-04T04:27:50.684Z</updated>
    
    <content type="html"><![CDATA[<p>高性能架构模式，本文会总结业界相对比较成熟的各种架构模式，大部分情况下，我们会基于这些已有的成熟模式，结合业务和团队的具体情况来进行一定的优化或调整。</p><p>很多情况下高性能的设计最核心的部分就是关系数据库的设计。单个数据库在当前情况下是很难满足业务需求的了，必须考虑<strong>数据库集群</strong>的方式来提升性能。高性能架构，其关键点就在于数据库层如何实现高性能，有很多种方式，先来介绍读写分离原理。</p><h1 id="1-高性能数据库集群-读写分离"><a href="#1-高性能数据库集群-读写分离" class="headerlink" title="1. 高性能数据库集群 - 读写分离"></a>1. 高性能数据库集群 - 读写分离</h1><p>读写分离的基本原理就是将数据库读写操作分散到不同的节点上。<br><img src="https://i.loli.net/2020/02/04/DHT92UafyWt4hZx.png" alt="fig1.png"></p><h2 id="1-1-基本实现-主从集群"><a href="#1-1-基本实现-主从集群" class="headerlink" title="1.1 基本实现 - 主从集群"></a>1.1 基本实现 - 主从集群</h2><ul><li>数据库服务器搭建主从集群，一主一从到一主多从皆可。</li><li>数据库主机负责读写操作，从机只负责读操作</li><li>数据库主机通过复制将数据同步到从机，每台数据库服务器都存储了所有的业务数据</li><li>业务服务器将写操作发给数据库主机，将读操作发给数据库从机</li></ul><p>注意这里实现的主从集群，而不是主备集群，主从，从属的还是要接收请求的，主备中的备是完全的备用目的，基本不会有流量。</p><h2 id="1-2-主从复制延迟"><a href="#1-2-主从复制延迟" class="headerlink" title="1.2 主从复制延迟"></a>1.2 主从复制延迟</h2><p>以 MySQL 为例，主从复制延迟可能达到 1 秒，如果有大量数据同步，延迟 1 分钟也是有可能的。主从复制延迟会带来一个问题：如果业务服务器将数据写入到数据库主服务器后立刻（1 秒内）进行读取，此时读操作访问的是从机，主机还没有将数据复制过来，到从机读取数据是读不到最新数据的，业务上就可能出现问题。例如，用户刚注册完后立刻登录，业务服务器会提示他“你还没有注册”，而用户明明刚才已经注册成功了。</p><p>解决复制延迟的常见方法：</p><ul><li>写操作以后的读操作指定发给数据库主服务器<ul><li>和业务强绑定，容易发生bug</li></ul></li><li>读从机失败之后再读一次主机<ul><li>二次读取和业务无绑定，只需要对底层数据库访问的API进行封装即可，实现代价小</li><li>不足之处是如果有大量二次读取，那么主机压力会很大，可能会导致崩溃</li><li>关键业务读写操作全部指向主机，非关键业务采用读写分离</li></ul></li></ul><h2 id="1-3-分配机制-如何区分读写操作，访问不同的数据库服务器"><a href="#1-3-分配机制-如何区分读写操作，访问不同的数据库服务器" class="headerlink" title="1.3 分配机制 - 如何区分读写操作，访问不同的数据库服务器"></a>1.3 分配机制 - 如何区分读写操作，访问不同的数据库服务器</h2><h3 id="1-3-1-程序代码封装"><a href="#1-3-1-程序代码封装" class="headerlink" title="1.3.1 程序代码封装"></a>1.3.1 程序代码封装</h3><p>指在代码中抽象出一个数据访问层，实现读写分离的操作和数据库服务器的连接管理。例如基于Hibernate进行简单封装</p><p><img src="https://i.loli.net/2020/02/04/MjT7sUolRfiI1x4.png" alt="fig2.png"></p><ul><li>实现简单，可以根据业务做较多的定制化功能</li><li>每个编程语言都要自己实现一次，没法通用，如果一个业务包含多个编程语言的多个子系统，那么重复开发工作量比较大</li><li>故障情况下，如果主从切换，那么所有系统都很可能需要修改配置并重启</li></ul><h3 id="1-3-2-中间件封装"><a href="#1-3-2-中间件封装" class="headerlink" title="1.3.2 中间件封装"></a>1.3.2 中间件封装</h3><p>指独立出一套系统来，实现读写操作分离和数据库服务器连接的管理。中间件对业务服务器提供SQL兼容的协议，业务服务器无须自己进行读写分离。对于业务服务器来说，访问中间件</p><p><img src="https://i.loli.net/2020/02/04/26cDtZv1Ia5rSye.png" alt="fig3.png"></p><ul><li>能够支持多种编程语言，因为中间件对业务服务器提供的是标准SQL接口</li><li>中间件要支持完整的SQL语法和数据库服务器的协议，实现复杂，bug会比较多，需要较长时间才可以稳定下来</li><li>中间件自己不执行读写，但是所有数据库的操作请求都要经过中间件，所以对于性能有很高的要求</li><li>数据库主从切换对业务服务器无感知，数据库中间件可以探测数据库服务器的主从状态</li></ul><p>现在市面上有的中间件，MySQL Router, Atlas </p><h1 id="2-分库分表"><a href="#2-分库分表" class="headerlink" title="2. 分库分表"></a>2. 分库分表</h1><p>读写分离可以分散数据库读写操作的压力，但没有分散存储压力，当数据量达到千万级别的时候，单台数据库服务器的存储能力会成为系统的瓶颈, 这体现在：</p><ul><li>数据量过大，读写性能会下降；即使有索引，索引也会变大，性能同样会下降</li><li>数据文件会变得很大，数据库北非和恢复需要耗费很长时间</li><li>数据文件越大，极端情况下丢失数据的风险就越高</li></ul><p>基于上述原因，单个数据库服务器存储的数据量不能太大，需要控制在一定的范围内。将存储分散到多台数据库服务器上。</p><h2 id="2-1-业务分库"><a href="#2-1-业务分库" class="headerlink" title="2.1 业务分库"></a>2.1 业务分库</h2><blockquote><p>业务分库指的是按照业务模块将数据分散到不同的数据库服务器。</p></blockquote><p>譬如一个电商网站，将用户数据，商品数据，订单数据分开放到三台不同的数据库服务器上。虽然业务分库能够分散存储和访问的压力，但是也带来了新的问题。</p><h3 id="2-1-1-join操作问题"><a href="#2-1-1-join操作问题" class="headerlink" title="2.1.1 join操作问题"></a>2.1.1 join操作问题</h3><p>原先在一个表里的数据现在分散到了多个表当中，这就导致无法使用SQL的join来进行查询了。</p><h3 id="2-1-2-事务问题"><a href="#2-1-2-事务问题" class="headerlink" title="2.1.2 事务问题"></a>2.1.2 事务问题</h3><p>原本在同一个数据库中不同的表可以在同一个事务中修改，业务分库以后，表分散到了不同的数据库当中，无法通过事务统一修改。 尽管有一个分布式事务的解决方案，但性能太低，与高性能的存储的目标是相违背的。</p><h3 id="2-1-3-成本问题"><a href="#2-1-3-成本问题" class="headerlink" title="2.1.3 成本问题"></a>2.1.3 成本问题</h3><p>一台变多台</p><h2 id="2-2-业务分表"><a href="#2-2-业务分表" class="headerlink" title="2.2 业务分表"></a>2.2 业务分表</h2><p>将不同业务数据分散存储到不同的数据库服务器，能够支撑百万甚至千万用户规模的业务，但如果业务继续发展，同一业务的单表数据也会达到单台数据库服务器的处理瓶颈。例如，淘宝的几亿用户数据，如果全部存放在一台数据库服务器的一张表中，肯定是无法满足性能要求的，此时就需要对单表数据进行拆分。</p><p>单表数据的拆分有两种方式： 垂直分表和水平分表</p><h3 id="2-2-1-垂直分表"><a href="#2-2-1-垂直分表" class="headerlink" title="2.2.1 垂直分表"></a>2.2.1 垂直分表</h3><p>原先比如是id, name, age, sex, nickname, 垂直分表以后可以变成</p><ul><li>id, name, age</li><li>id, sex, nickname </li></ul><p>也会带来复杂性，即表操作的数量要增加，原来的一次查询现在要变成多次查询了</p><h3 id="2-2-2-水平分表"><a href="#2-2-2-水平分表" class="headerlink" title="2.2.2 水平分表"></a>2.2.2 水平分表</h3><p>用2.2.1的例子来说明的话，会包含一样的attributes，只是总共行数变le</p><p>水平分表以后，某条数据具体属于哪个切分以后的子表，需要依靠路由算法来进行计算</p><ul><li>范围路由<ul><li>使用用户ID等分段</li><li>好处<ul><li>随数据增加平滑的扩充新表</li></ul></li><li>坏处<ul><li>分布不均</li></ul></li></ul></li><li>Hash路由<ul><li>选取某个列的值进行Hash运算，然后根据Hash结果分散到不同的数据表当中</li><li>复杂点<ul><li>初始表的数量选取，太多维护麻烦，太少可能会让单表性能存在问题</li><li>用了Hash以后重Hash(增加表数量)会非常麻烦</li></ul></li><li>好处  分布均匀</li></ul></li><li>配置路由<ul><li>路由表，用独立的表来记录路由信息 </li><li>缺点就是会多查询一次，先看了一眼路由表嘛</li></ul></li></ul><h1 id="3-高性能NoSQL"><a href="#3-高性能NoSQL" class="headerlink" title="3. 高性能NoSQL"></a>3. 高性能NoSQL</h1><p>关系型数据库存在问题：</p><ul><li>关系数据库存储的是行记录，无法存储数据结构</li><li>关系数据库的schema扩展不方便<ul><li>schema是强约束的，操作不存在的列会报错，业务变化时扩充列也会比较麻烦，需要执行DDL (data definition language  create, alter, drop等) 语句修改，而且修改时可能会长时间锁表</li></ul></li><li>关系数据库在大数据场景下I/O较高<ul><li>对于每一行数据量都很大的表做统计之类的运算的时候I/O会很高，因为即使只针对其中某一列进行运算，关系数据库也会将整行数据从存储设备读入内存。 </li></ul></li><li>关系数据库的全文搜索功能比较弱</li></ul><p>针对上面的问题，产生了不同的NoSQL解决方案，在某一方面会有更好的表现。此外，NoSQL的方案带来的优势，本质上是牺牲ACID中的某个或者某几个特性，因此我们不能盲目地迷信NoSQL是银弹，应该将NoSQl作为SQL的一个有力补充。</p><p>常见NoSQL分类：</p><ul><li>K-V 存储: 解决SQL无法存储数据结构的问题</li><li>文档数据库：解决SQL强schema约束的问题</li><li>列式数据库：解决SQL大数据场景下的I/O问题，以HBase为代表</li><li>全文搜索引擎：解决关系数据库的全文搜索性能问题， ElasticSearch </li></ul><h2 id="3-1-Key-Value存储"><a href="#3-1-Key-Value存储" class="headerlink" title="3.1 Key - Value存储"></a>3.1 Key - Value存储</h2><p>Redis 是 K-V 存储的典型代表，它是一款开源（基于 BSD 许可）的高性能 K-V 缓存和存储系统。Redis 的 Value 是具体的数据结构，包括 string、hash、list、set、sorted set、bitmap 和 hyperloglog，所以常常被称为数据结构服务器。</p><p>更灵活的对数据的操作：</p><ul><li>LPOP key 从队列的左边出队一个元素。</li><li>LINDEX key index 获取一个元素，通过其索引列表。</li><li>LLEN key 获得队列（List）的长度。</li></ul><p>Redis 的缺点主要体现在并不支持完整的 ACID 事务，Redis 虽然提供事务功能，但 Redis 的事务和关系数据库的事务不可同日而语，Redis 的事务只能保证隔离性和一致性（I 和 C），无法保证原子性和持久性（A 和 D）。</p><h2 id="3-2-文档数据库"><a href="#3-2-文档数据库" class="headerlink" title="3.2 文档数据库"></a>3.2 文档数据库</h2><p>最大特点是no-schema，可以存储和读取任意的数据。带来优势：</p><ul><li>新增字段简单</li><li>历史数据不会出错</li><li>可以很容易存储复杂数据</li></ul><p>缺陷</p><ul><li>事务</li><li>没有join操作</li></ul><h2 id="3-3-列式数据库"><a href="#3-3-列式数据库" class="headerlink" title="3.3 列式数据库"></a>3.3 列式数据库</h2><p>按照列来存储数据，典型场景海量数据统计，只需要其中的一两列的数据即可。I/O相对低一些。</p><p>列式存储有更高的存储压缩比，因为单个列的数据相似度一般来说比行更高，能够达到更高的压缩率。</p><p>一般将其用在离线的大数据分析和统计的场景当中，因为这种场景经常是针对部分单列来进行操作的，数据写入以后无须更新删除。</p><h2 id="3-4-全文搜索引擎"><a href="#3-4-全文搜索引擎" class="headerlink" title="3.4 全文搜索引擎"></a>3.4 全文搜索引擎</h2><ul><li>全文搜索的条件可以随意排列组合，如果通过索引来满足，则索引的数量会非常多</li><li>全文搜索的模糊匹配方式，索引无法满足，只能用like，而like是整表扫描，很慢</li></ul><h3 id="3-4-1-基本原理"><a href="#3-4-1-基本原理" class="headerlink" title="3.4.1 基本原理"></a>3.4.1 基本原理</h3><ul><li>倒排索引/ 反向索引<ul><li>建立单词到文档的索引 </li><li>即用关键词来查，显示出出现的地方</li></ul></li></ul><h3 id="3-4-2-使用方式"><a href="#3-4-2-使用方式" class="headerlink" title="3.4.2 使用方式"></a>3.4.2 使用方式</h3><p>将数据库里面的内容转成JSON格式，然后输入全文搜索引擎进行搜索。 ES能够以实时化的方式，存储和检索复杂的数据结构，并令每个字段都默认可以被索引。</p><h1 id="4-高性能缓存结构"><a href="#4-高性能缓存结构" class="headerlink" title="4. 高性能缓存结构"></a>4. 高性能缓存结构</h1><p>存储系统的能力有的时候并不够用，比如</p><ul><li>需要经过复杂运算得出的数据  – 比如实时在线人数</li><li>读多写少的数据</li></ul><p>缓存就是为了弥补存储系统在这些复杂业务场景下的不足，其基本原理就是将可能重复使用的数据放到内存当中，一次生成，多次使用，避免每次使用都去访问存储系统。</p><p>缓存能够带来性能的大幅提升，以memcache为例，单台就可以达到TPS50000以上，基本架构就是第一次从数据库拿数据，第二次及以后就可以从memcached中来取得数据了。</p><h2 id="4-1-缓存穿透"><a href="#4-1-缓存穿透" class="headerlink" title="4.1 缓存穿透"></a>4.1 缓存穿透</h2><p>指缓存没有发挥作用，虽然去查询了缓存数据，但是不在那里面，业务系统就需要再次去存储系统查询数据，这种情况的出现通常是因为：</p><ul><li>存储数据不存在</li></ul><p>黑客攻击，故意大量访问某些读取不存在数据的业务。解决方案就是设置一个默认值，放到缓存里面，这样第二次读取缓存的时候就会获取默认值，而不会继续访问存储系统。</p><ul><li>缓存数据生成耗费大量的时间或者资源</li></ul><p>第二种情况是存储系统中存在数据，但生成缓存数据需要耗费较长时间或者耗费大量资源。如果刚好在业务访问的时候缓存失效了，那么也会出现缓存没有发挥作用，访问压力全部集中在存储系统上的情况。</p><p>典型的就是电商的商品分页，假设我们在某个电商平台上选择“手机”这个类别查看，由于数据巨大，不能把所有数据都缓存起来，只能按照分页来进行缓存，由于难以预测用户到底会访问哪些分页，因此业务上最简单的就是每次点击分页的时候按分页计算和生成缓存。通常情况下这样实现是基本满足要求的，但是如果被竞争对手用爬虫来遍历的时候，系统性能就可能出现问题。</p><h2 id="4-2-缓存雪崩"><a href="#4-2-缓存雪崩" class="headerlink" title="4.2 缓存雪崩"></a>4.2 缓存雪崩</h2><p>是指当缓存失效（过期）后引起系统性能急剧下降的情况。当缓存过期被清除后，业务系统需要重新生成缓存，因此需要再次访问存储系统，再次进行运算，这个处理步骤耗时几十毫秒甚至上百毫秒。而对于一个高并发的业务系统来说，几百毫秒内可能会接到几百上千个请求。由于旧的缓存已经被清除，新的缓存还未生成，并且处理这些请求的线程都不知道另外有一个线程正在生成缓存，因此所有的请求都会去重新生成缓存，都会去访问存储系统，从而对存储系统造成巨大的性能压力。这些压力又会拖慢整个系统，严重的会造成数据库宕机，从而形成一系列连锁反应，造成整个系统崩溃。</p><p>为了解决，通常可以采用两种方案： 更新锁机制和后台更新机制。</p><h3 id="4-2-1-更新锁"><a href="#4-2-1-更新锁" class="headerlink" title="4.2.1 更新锁"></a>4.2.1 更新锁</h3><p>对缓存更新操作进行加锁保护，保证只有一个线程能够进行缓存更新，未能获取更新锁的线程要么等待锁释放以后重新读取缓存，要么就返回空值或者默认值。</p><p>对于采用分布式集群的业务系统，由于存在几十上百台服务器，即使单台服务器只有一个线程更新缓存，但几十上百台服务器一起算下来也会有几十上百个线程同时来更新缓存，同样存在雪崩的问题。因此分布式集群的业务系统要实现更新锁机制，需要用到分布式锁，如 ZooKeeper。</p><h3 id="4-2-2-后台更新"><a href="#4-2-2-后台更新" class="headerlink" title="4.2.2 后台更新"></a>4.2.2 后台更新</h3><p>由后台线程来更新缓存，而不是业务线程。缓存本身的有效期设置为永久，后台线程定时更新缓存。</p><p>后台定时机制需要考虑一种特殊的场景，当缓存系统内存不够时，会“踢掉”一些缓存数据，从缓存被“踢掉”到下一次定时更新缓存的这段时间内，业务线程读取缓存返回空值，而业务线程本身又不会去更新缓存，因此业务上看到的现象就是数据丢了。解决的方式有两种：</p><ul><li>后台线程除了定时更新缓存，还要频繁地去读取缓存（例如，1 秒或者 100 毫秒读取一次），如果发现缓存被“踢了”就立刻更新缓存，这种方式实现简单，但读取时间间隔不能设置太长，因为如果缓存被踢了，缓存读取间隔时间又太长，这段时间内业务访问都拿不到真正的数据而是一个空的缓存值，用户体验一般。</li><li>业务线程发现缓存失效后，通过消息队列发送一条消息通知后台线程更新缓存。可能会出现多个业务线程都发送了缓存更新消息，但其实对后台线程没有影响，后台线程收到消息后更新缓存前可以判断缓存是否存在，存在就不执行更新操作。这种方式实现依赖消息队列，复杂度会高一些，但缓存更新更及时，用户体验更好。</li></ul><h2 id="4-3-缓存热点"><a href="#4-3-缓存热点" class="headerlink" title="4.3 缓存热点"></a>4.3 缓存热点</h2><p>复制多份缓存副本，将请求分散到多个缓存服务器上，减轻缓存热点导致的单台缓存服务器的压力。</p><p>注意不同的缓存副本不要设置统一的过期时间，否则会出现所有缓存副本同时生成同时失效的情况，从而引发缓存雪崩效应。正确的做法是设定一个过期的时间范围，不同的缓存副本的过期时间是指定范围内的随机值。</p><h1 id="5-单服务器高性能模式-并发模型"><a href="#5-单服务器高性能模式-并发模型" class="headerlink" title="5. 单服务器高性能模式 - 并发模型"></a>5. 单服务器高性能模式 - 并发模型</h1><ul><li>影响高性能效果的因素<ul><li>磁盘</li><li>操作系统</li><li>CPU</li><li>内存</li><li>缓存</li><li>网络</li><li>编程语言</li><li>架构</li></ul></li></ul><p>高性能架构设计主要集中在两个方面：</p><ul><li>尽量提升单服务器的性能，将单服务器的性能发挥到极致</li><li>如果单服务器无法支撑性能，设计服务器集群方案</li></ul><ul><li><p>关键设计点</p><ul><li>服务器如何管理连接</li><li>服务器如何处理请求</li></ul></li><li><p>常见分类</p><ul><li>海量连接海量请求：双十一</li><li>常量连接海量请求：中间件</li><li>海量连接常量请求：门户网站</li><li>常量连接常量请求：内部运营系统，管理系统<br>这两个设计点都和操作系统的I/O模型以及进程模型相关。</li></ul></li><li><p>BIO: 一个线程处理一个请求</p></li><li><p>NIO：利用多路复用技术，通过少量的线程处理大量的请求</p></li><li><p>I/O 模型</p><ul><li>阻塞</li><li>非阻塞</li><li>同步</li><li>异步</li></ul></li><li><p>进程模型</p><ul><li>单进程</li><li>多进程</li><li>多线程</li></ul></li></ul><h2 id="5-1-PPC-Process-Per-Connection"><a href="#5-1-PPC-Process-Per-Connection" class="headerlink" title="5.1 PPC - Process Per Connection"></a>5.1 PPC - Process Per Connection</h2><p>每次有新的连接就新建一个进程去专门处理这个连接的请求，这也是传统的UNIX网络服务器锁采用的模型。</p><p><img src="https://i.loli.net/2020/02/04/NDdUCRi3klst8qM.png" alt="fig4.png"></p><ul><li>父进程接受连接</li><li>父进程fork子进程</li><li>子进程处理连接的读写请求</li><li>子进程关闭连接</li></ul><p>PPC 模式实现简单，比较适合服务器的连接数没那么多的情况，例如数据库服务器。对于普通的业务服务器，在互联网兴起之前，由于服务器的访问量和并发量并没有那么大，这种模式其实运作得也挺好，世界上第一个 web 服务器 CERN httpd 就采用了这种模式。但随着互联网星期，服务器的并发量和访问量都有了很大的提高，这种方法就涌现出了不少弊端</p><ul><li>fork代价比较高，要分配很多内核资源，需要将内存映像从父进程复制到子进程。</li><li>父子进程通信复杂，父进程fork子进程时，文件描述符可以通过内存映像复制从父进程传到子进程，但fork完成之后，父子进程通信就比较麻烦了，需要采用IPC(Interprocess Communication)之类的进程通信方案。</li><li>支持的并发连接数量有限，如果每个连接存活时间比较长，而且新的连接又源源不断的来，则进程数量会越来越多，操作系统进程调度和切换的频率也会越来越高，系统的压力也会越来越大。一般来说，PPC方案最大的并发连接数就几百的样子。</li></ul><h2 id="5-2-prefork-提前创建进程"><a href="#5-2-prefork-提前创建进程" class="headerlink" title="5.2 prefork 提前创建进程"></a>5.2 prefork 提前创建进程</h2><p>在启动的时候就预先创建好进程，然后开始接受用户的请求。当有新的连接进来的时候，就可以省去fork进程的操作，让用户访问更快，体验更好。</p><p><img src="https://i.loli.net/2020/02/04/2ukZmRXP8cWyolE.jpg" alt="fig5.jpg"></p><p>实现关键点在多个子进程都accept同一个socket，当有新的连接接入时，操作系统保证只有一个进程能最后accept成功。</p><p>prefork还是和PPC一样，存在父子进程通信复杂，支持的并发连接数量有限的问题。</p><h2 id="5-3-TPC-Thread-Per-Connection"><a href="#5-3-TPC-Thread-Per-Connection" class="headerlink" title="5.3 TPC - Thread Per Connection"></a>5.3 TPC - Thread Per Connection</h2><p>每次有新的连接，就建立一个新的线程去专门处理这个连接的请求。与进程相比，线程更轻量级，创建线程的消耗比进程要少得多；同时因为多线程共享进程内存空间，就可以简化线程之间通信的复杂程度。</p><p><img src="https://i.loli.net/2020/02/04/3qdx1ofOb8sLW4k.png" alt="fig6.png"></p><ul><li>父进程接受连接</li><li>父进程创建子线程</li><li>子线程处理连接的读写请求</li><li>子线程关闭连接</li></ul><p>和PPC相比，主进程不用close了，原因是子线程是共享主进程的进程空间的，连接的文件描述符并没有被复制，因此只需要一次close即可。</p><p>TPC引入了新的问题：</p><ul><li>创建线程依然有耗损，性能问题</li><li>线程间的互斥和共享的复杂度</li><li>多线程会互相影响，某个线程出现异常的时候，可能导致整个进程的退出</li></ul><p>在并发几百的情况下，还是会更多采用PPC的方案，因为无死锁的风险，也不会有多进程之间的相互影响，稳定性更高。</p><h2 id="5-4-prethread"><a href="#5-4-prethread" class="headerlink" title="5.4 prethread"></a>5.4 prethread</h2><p>预先创建线程，然后才开始接受用户的请求，当有新的连接进来的时候，就可以省去创建线程的操作，让用户感觉更快。常用的实现方式：</p><ul><li>主进程accept，然后将连接交给某个线程处理</li><li>子线程都尝试去accept，最终只有一个线程accept成功</li></ul><p><img src="https://i.loli.net/2020/02/04/8GsTH1Fokv2PLYf.jpg" alt="fig7.jpg"></p><h2 id="5-5-Reactor"><a href="#5-5-Reactor" class="headerlink" title="5.5 Reactor"></a>5.5 Reactor</h2><p>PPC模式的问题是每个连接都要创建进程，连接结束进程就被销毁了。为了解决这个问题，瞄准资源复用，即不再单独为每个连接创建进程，而是创建一个进程池，将连接分配给进程，一个进程可以处理多个连接的业务。</p><blockquote><p>一个进程处理多个连接的业务</p></blockquote><p>引入资源池的处理方式后，会引出一个新的问题：进程如何才能高效地处理多个连接的业务？当一个连接一个进程时，进程可以采用“read -&gt; 业务处理 -&gt; write”的处理流程，如果当前连接没有数据可以读，则进程就阻塞在 read 操作上。这种阻塞的方式在一个连接一个进程的场景下没有问题，但如果一个进程处理多个连接，进程阻塞在某个连接的 read 操作上，此时即使其他连接有数据可读，进程也无法去处理，很显然这样是无法做到高性能的。</p><p>为了解决这个问题，可以将read操作改为非阻塞的，然后进程不断轮询多个连接。但是这样做，不好的地方在于轮询耗费CPU资源；其次，如果一个进程处理成千上万的连接，轮询的效率是很低的。</p><blockquote><p>更好的解决办法，只有当连接上有数据的时候进程才去处理，这就是I/O多路复用的技术的来源</p></blockquote><ul><li>当多条连接共用一个阻塞对象后，进程只需要在一个阻塞对象上等待，而无须再轮询所有连接，常见的连接方式有select\epoll\kqueue等。</li><li>当某条连接有新的数据可以处理时，操作系统会通知进程，进程从阻塞状态返回，开始进行业务处理</li></ul><p>I/O多路复用结合线程池，就是我们说的Reactor了，即事件反应的意思</p><p>Reactor会根据事件类型来调用相应的代码进行处理，也成为dispatcher模式，指的是I/O多路复用统一监听事件，收到事件后分配给某个进程的过程。 </p><ul><li>Reactor模式的benefits<ul><li>reactor数量可以变化</li><li>资源池的数量可以变化: 以进程为例，可以是单进程的，也可以是多个进程的</li></ul></li></ul><ul><li>常见的使用方式<ul><li>单 Reactor 单进程 / 线程。</li><li>单 Reactor 多线程。</li><li>多 Reactor 多进程 / 线程。</li></ul></li></ul><p>上述方案选择进程还是线程，更多和平台以及编程语言相关。例如Java一般使用线程 - Netty, Nginx选择进程</p><h3 id="5-5-1-单Reactor-单进程-线程"><a href="#5-5-1-单Reactor-单进程-线程" class="headerlink" title="5.5.1 单Reactor 单进程/ 线程"></a>5.5.1 单Reactor 单进程/ 线程</h3><p><img src="https://i.loli.net/2020/02/04/YW2N7ZBcuirMUAb.png" alt="fig8.png"></p><ul><li>select, accept, read, send是标准的网络编程API</li><li>dispatch和业务处理是需要完成的操作</li><li>Reactor对象通过select监控连接时间，收到事件以后通过dispatch来进行转发</li><li>如果是连接建立事件，就交给Acceptor，来接受连接，并创建一个Handler来处理接下来的各种事件</li><li>如果不是连接事件，就会用上面已经建好的handler来处理请求，做出响应</li><li>Handler会完成read - 业务处理 -send的完整业务流程</li></ul><ul><li>Benefits<ul><li>无进程间通信</li><li>无进程竞争</li></ul></li><li>Weakness<ul><li>只有一个进程，无法发挥出多核CPU的性能</li><li>handler在处理某个连接上的业务时，整个进程就无法处理</li></ul></li></ul><p>只适用于业务处理非常快速的场景，目前比较著名的使用这个的开源软件是Redis</p><h3 id="5-5-2-单Reactor-多线程"><a href="#5-5-2-单Reactor-多线程" class="headerlink" title="5.5.2 单Reactor 多线程"></a>5.5.2 单Reactor 多线程</h3><p><img src="https://i.loli.net/2020/02/04/GlJTpkZ4DojR9HN.png" alt="fig9.png"></p><ul><li>主线程当中，Reactor对象通过select监控连接时间，收到事件后通过dispatch进行分发</li><li>blabla… similar to above</li><li>Handler只负责响应事件，不进行业务处理；Handler通过read读取到数据后，会发给processor进行业务处理</li><li>Processor会在独立的子线程当中完成真正的业务处理，然后将响应结果发给主进程的Handler处理；Handler收到响应以后通过send将响应结果返回给client </li><li>Benefits<ul><li>能够充分利用多核多CPU的处理能力</li></ul></li><li>Weakness<ul><li>多线程数据共享和访问比较复杂</li><li>reactor承担所有事件的监听和响应，只在主线程中进行，瞬间高并发会成为性能瓶颈</li></ul></li></ul><h3 id="5-5-3-多Reactor-多进程-线程"><a href="#5-5-3-多Reactor-多进程-线程" class="headerlink" title="5.5.3 多Reactor 多进程/ 线程"></a>5.5.3 多Reactor 多进程/ 线程</h3><p><img src="https://i.loli.net/2020/02/04/wfyzTL47eUjQaBY.png" alt="fig10.png"></p><ul><li>父进程中mainReactor对象通过select监控连接建立事件，收到事件后通过Acceptor接收，将新的连接分配给某个子进程。</li><li>子进程的subReactor将mainReactor分配的连接加入连接队列进行监听，并创建一个Handler用于处理连接的各种事件</li><li>当有新的事件发生时，subReactor会调用连接对应的handler来进行响应</li><li>handler完成read - 业务处理 -send的流程</li><li>Benefits<ul><li>父进程和子进程的职责非常明确，父进程只负责接收新连接，子进程负责完成后续的业务处理。</li><li>父进程和子进程的交互很简单，父进程只需要把新连接传给子进程，子进程无须返回数据。</li><li>子进程之间是互相独立的，无须同步共享之类的处理（这里仅限于网络模型相关的 select、read、send 等无须同步共享，“业务处理”还是有可能需要同步共享的）。</li></ul></li></ul><h2 id="5-6-Proactor"><a href="#5-6-Proactor" class="headerlink" title="5.6 Proactor"></a>5.6 Proactor</h2><p>Reactor是非阻塞同步网络模型，因为真正的read和send操作都需要用户进程同步操作，proactor将其异步化，</p><p><img src="https://i.loli.net/2020/02/04/gV6YdJM3CLloBiA.png" alt="fig11.png"></p><ul><li>Proactor Initiator 负责创建 Proactor 和 Handler，并将 Proactor 和 Handler 都通过 Asynchronous Operation Processor 注册到内核。</li><li>Asynchronous Operation Processor 负责处理注册请求，并完成 I/O 操作。</li><li>Asynchronous Operation Processor 完成 I/O 操作后通知 Proactor。</li><li>Proactor 根据不同的事件类型回调不同的 Handler 进行业务处理。</li><li>Handler 完成业务处理，Handler 也可以注册新的 Handler 到内核进程。</li></ul><h2 id="5-7-同步阻塞IO-vs-同步非阻塞IO-vs-异步非阻塞IO"><a href="#5-7-同步阻塞IO-vs-同步非阻塞IO-vs-异步非阻塞IO" class="headerlink" title="5.7 同步阻塞IO vs 同步非阻塞IO vs 异步非阻塞IO"></a>5.7 同步阻塞IO vs 同步非阻塞IO vs 异步非阻塞IO</h2><table><thead><tr><th>-</th><th>等待数据准备好的阶段（读到内核缓存）</th><th>将数据从内核读到用户空间</th></tr></thead><tbody><tr><td>同步阻塞IO</td><td>阻塞</td><td>阻塞</td></tr><tr><td>同步非阻塞IO</td><td>非阻塞</td><td>阻塞</td></tr><tr><td>异步非阻塞IO</td><td>非阻塞</td><td>非阻塞</td></tr></tbody></table><h1 id="6-高性能负载均衡-分类及架构-高性能集群"><a href="#6-高性能负载均衡-分类及架构-高性能集群" class="headerlink" title="6. 高性能负载均衡 - 分类及架构 - 高性能集群"></a>6. 高性能负载均衡 - 分类及架构 - 高性能集群</h1><p>高性能集群的本质： 通过增加更多的服务器来提升系统整体的计算能力。</p><p>由于计算本身的特点，即同样的输入数据和逻辑，无论在哪台服务器上执行，都应该得到相同的输出。因此高性能集群设计的复杂度主要体现在<strong>任务分配</strong>这部分，需要设计合理的任务分配策略，将计算任务分配到多台服务器上来执行。</p><p>即复杂性主要体现在需要增加一个任务分配器，以及为任务选择一个合适的任务分配算法。</p><ul><li>任务分配算法的考虑因素<ul><li>计算单元的负载均衡</li><li>基于负载考虑</li><li>基于性能(吞吐量、响应时间)考虑</li><li>基于业务考虑</li></ul></li></ul><h2 id="6-1-负载均衡分类"><a href="#6-1-负载均衡分类" class="headerlink" title="6.1 负载均衡分类"></a>6.1 负载均衡分类</h2><h3 id="6-1-1-DNS负载均衡"><a href="#6-1-1-DNS负载均衡" class="headerlink" title="6.1.1 DNS负载均衡"></a>6.1.1 DNS负载均衡</h3><p>用于实现地理级别的均衡，其原理是DNS解析同一个域名，可以返回不同的IP地址。<br><img src="https://i.loli.net/2020/02/04/9Srot2PfYW35pux.jpg" alt="fig12.jpg"></p><ul><li>Benefits <ul><li>简单，成本低</li><li>负载均衡工作交给DNS服务器来处理，无须自己开发或者维护负载均衡设备</li><li>就近访问，提升访问速度</li></ul></li><li>weakness<ul><li>更新不及时，DNS缓存时间比较长，更新缓存以后，还有很多用户会访问修改前的IP，这样的访问会失败的</li><li>扩展性差，DNS负载均衡控制权在域名商那里，无法根据业务特点针对其做更多的定制化功能和特性的拓展</li><li>分配策略比较简单: DNS负载均衡的支持算法少，不能区分服务器的差异(不能根据系统与服务的状态来判断负载)，也无法感知后端服务器的状态。</li></ul></li></ul><h3 id="6-1-2-硬件负载均衡"><a href="#6-1-2-硬件负载均衡" class="headerlink" title="6.1.2 硬件负载均衡"></a>6.1.2 硬件负载均衡</h3><p>指通过单独的硬件设备来实现负载均衡的功能，类似路由器交换机，可以理解为一个用于负载均衡的基础网络设备。</p><ul><li><p>benefits </p><ul><li>功能强大，支持各层级负载均衡</li><li>性能强大，100万以上的并发</li><li>稳定性高</li><li>支持安全防护  DDos</li></ul></li><li><p>weakness</p><ul><li>价格昂贵</li><li>扩展能力差</li></ul></li></ul><h3 id="6-1-3-软件负载均衡"><a href="#6-1-3-软件负载均衡" class="headerlink" title="6.1.3 软件负载均衡"></a>6.1.3 软件负载均衡</h3><p>通过负载均衡软件来实现负载均衡的功能，常见的有Nginx - 软件的7层负载均衡和LVS - Linux内核的4层负载均衡。</p><p>Nginx支持HTTP，Email协议; 而LVS是4层负载均衡，和协议无关，几乎所有的应用都可以做。</p><p>软硬件最主要的区别在于性能，硬件负载均衡性能要远远高于软件的复杂均衡性能，但是软件的会便宜很多。</p><p><img src="https://i.loli.net/2020/02/04/3of7nFr6Ou1XsHg.jpg" alt="fig13.jpg"></p><ul><li>benefits<ul><li>部署维护简单</li><li>便宜</li><li>灵活，可扩展</li></ul></li></ul><h3 id="6-1-4-负载均衡的典型架构"><a href="#6-1-4-负载均衡的典型架构" class="headerlink" title="6.1.4 负载均衡的典型架构"></a>6.1.4 负载均衡的典型架构</h3><p>是结合起来一起用的，DNS负载均衡用于实现地理级别的负载均衡，硬件负载均衡用于实现集群级别的负载均衡，软件负载均衡用于实现机器级别的负载均衡。</p><p>整个系统的负载均衡分为三层：</p><ul><li>地理级别负载均衡</li><li>集群级别负载均衡  用硬件设备来做平均</li><li>机器级别的负载均衡  用nginx，收到用户的请求之后，将用户的请求发送给集群里面的某台服务器，服务器处理用户的业务请求并返回业务响应</li></ul><h2 id="6-2-高性能负载均衡-算法"><a href="#6-2-高性能负载均衡-算法" class="headerlink" title="6.2 高性能负载均衡 - 算法"></a>6.2 高性能负载均衡 - 算法</h2><h3 id="6-2-1-分类"><a href="#6-2-1-分类" class="headerlink" title="6.2.1 分类"></a>6.2.1 分类</h3><ul><li>任务平分类：负载均衡系统将收到的任务平均分配给服务器进行处理，这里的“平均”可以是绝对数量的平均，也可以是比例或者权重上的平均。</li><li>负载均衡类：负载均衡系统根据服务器的负载来进行分配，这里的负载并不一定是通常意义上我们说的“CPU 负载”，而是系统当前的压力，可以用 CPU 负载来衡量，也可以用连接数、I/O 使用率、网卡吞吐量等来衡量系统的压力。</li><li>性能最优类：负载均衡系统根据服务器的响应时间来进行任务分配，优先将新任务分配给响应最快的服务器。</li><li>Hash 类：负载均衡系统根据任务中的某些关键信息进行 Hash 运算，将相同 Hash 值的请求分配到同一台服务器上。常见的有源地址 Hash、目标地址 Hash、session id hash、用户 ID Hash 等。</li></ul><h3 id="6-2-2-轮询"><a href="#6-2-2-轮询" class="headerlink" title="6.2.2 轮询"></a>6.2.2 轮询</h3><p>负载均衡系统收到请求后，按照顺序轮流分配到服务器上。</p><p>需要注意的是负载均衡系统无须关注“服务器本身状态”，这里的关键词是“本身”。也就是说，只要服务器在运行，运行状态是不关注的。但如果服务器直接宕机了，或者服务器和负载均衡系统断连了，这时负载均衡系统是能够感知的，也需要做出相应的处理。例如，将服务器从可分配服务器列表中删除，否则就会出现服务器都宕机了，任务还不断地分配给它，这明显是不合理的。</p><h3 id="6-2-3-加权轮询"><a href="#6-2-3-加权轮询" class="headerlink" title="6.2.3 加权轮询"></a>6.2.3 加权轮询</h3><p>负载均衡系统根据服务器权重进行任务分配，这里的权重一般是根据硬件配置进行静态配置的，采用动态的方式计算会更加契合业务，但复杂度也会更高。加权轮询主要为了解决不同服务器的处理能力有差异的问题。</p><h3 id="6-2-4-负载最低优先"><a href="#6-2-4-负载最低优先" class="headerlink" title="6.2.4 负载最低优先"></a>6.2.4 负载最低优先</h3><p>从服务器的角度出发来看如何进行负载分配</p><p>负载均衡系统将任务分配给当前负载最低的服务器，这里的负载根据不同的任务类型和业务场景，可以用不同的指标来衡量。例如：</p><ul><li>LVS 这种 4 层网络负载均衡设备，可以以“连接数”来判断服务器的状态，服务器连接数越大，表明服务器压力越大。</li><li>Nginx 这种 7 层网络负载系统，可以以“HTTP 请求数”来判断服务器状态（Nginx 内置的负载均衡算法不支持这种方式，需要进行扩展）。</li><li>如果我们自己开发负载均衡系统，可以根据业务特点来选择指标衡量系统压力。如果是 CPU 密集型，可以以“CPU 负载”来衡量系统压力；如果是 I/O 密集型，可以以“I/O 负载”来衡量系统压力。</li></ul><p>负载最低优先算法解决了轮询算法中无法感知服务器状态的问题，但复杂度会增加很多。</p><ul><li>最少连接数优先的算法要求负载均衡系统统计每个服务器当前建立的连接，其应用场景仅限于负载均衡接收的任何连接请求都会转发给服务器进行处理，否则如果负载均衡系统和服务器之间是固定的连接池方式，就不适合采取这种算法。例如，LVS 可以采取这种算法进行负载均衡，而一个通过连接池的方式连接 MySQL 集群的负载均衡系统就不适合采取这种算法进行负载均衡。</li><li>CPU 负载最低优先的算法要求负载均衡系统以某种方式收集每个服务器的 CPU 负载，而且要确定是以 1 分钟的负载为标准，还是以 15 分钟的负载为标准，不存在 1 分钟肯定比 15 分钟要好或者差。不同业务最优的时间间隔是不一样的，时间间隔太短容易造成频繁波动，时间间隔太长又可能造成峰值来临时响应缓慢。</li></ul><h3 id="6-2-5-性能最优类"><a href="#6-2-5-性能最优类" class="headerlink" title="6.2.5 性能最优类"></a>6.2.5 性能最优类</h3><p>从客户端的角度，和负载最低优先类算法类似，性能最优优先类算法本质上也是感知了服务器的状态，只是通过响应时间这个外部标准来衡量服务器状态而已。因此性能最优优先类算法存在的问题和负载最低优先类算法类似，复杂度都很高，主要体现在：</p><ul><li>负载均衡系统需要收集和分析每个服务器每个任务的响应时间，在大量任务处理的场景下，这种收集和统计本身也会消耗较多的性能。</li><li>为了减少这种统计上的消耗，可以采取采样的方式来统计，即不统计所有任务的响应时间，而是抽样统计部分任务的响应时间来估算整体任务的响应时间。采样统计虽然能够减少性能消耗，但使得复杂度进一步上升，因为要确定合适的采样率</li><li>采样周期，要10s性能最优还是1min性能最优</li></ul><h3 id="6-2-6-Hash类"><a href="#6-2-6-Hash类" class="headerlink" title="6.2.6 Hash类"></a>6.2.6 Hash类</h3><p>负载均衡系统根据任务中的某些关键信息进行 Hash 运算，将相同 Hash 值的请求分配到同一台服务器上，这样做的目的主要是为了满足特定的业务需求。</p><ul><li>源地址Hash<ul><li>将来源于同一个源 IP 地址的任务分配给同一个服务器进行处理，适合于存在事务、会话的业务。例如，当我们通过浏览器登录网上银行时，会生成一个会话信息，这个会话是临时的，关闭浏览器后就失效。网上银行后台无须持久化会话信息，只需要在某台服务器上临时保存这个会话就可以了，但需要保证用户在会话存在期间，每次都能访问到同一个服务器，这种业务场景就可以用源地址 Hash 来实现。</li></ul></li><li>ID Hash<ul><li>将某个 ID 标识的业务分配到同一个服务器中进行处理，这里的 ID 一般是临时性数据的 ID（如 session id）。例如，上述的网上银行登录的例子，用 session id hash 同样可以实现同一个会话期间，用户每次都是访问到同一台服务器的目的。 </li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;高性能架构模式，本文会总结业界相对比较成熟的各种架构模式，大部分情况下，我们会基于这些已有的成熟模式，结合业务和团队的具体情况来进行一定的优化或调整。&lt;/p&gt;
&lt;p&gt;很多情况下高性能的设计最核心的部分就是关系数据库的设计。单个数据库在当前情况下是很难满足业务需求的了，必须考
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="架构" scheme="https://www.llchen60.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>架构学习-高可用架构模式</title>
    <link href="https://www.llchen60.com/%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0-%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.llchen60.com/%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0-%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-02-04T04:21:29.000Z</published>
    <updated>2020-02-04T04:24:26.977Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-CAP-原理"><a href="#1-CAP-原理" class="headerlink" title="1. CAP 原理"></a>1. CAP 原理</h1><p>CAP原理讨论得是对于数据的读写操作，并不是在讨论整个系统的各个方面的功能。并且讨论得是在互联和分享数据过程当中出现的问题</p><ul><li>Consistency  一致性<ul><li>where all nodes see the same data at the same time </li><li>a read is guaranteed to return the most recent write for a given client </li></ul></li><li>Availability 可用性<ul><li>guarantee that every request receives a response about whether it succeed or fail </li><li>a non-faling node will return a reasonable response within a reasonable amount of time (no error or timeout)</li></ul></li><li>Partition tolerance  分区容错性 <ul><li>the system continues to operate even if any one part of the system is lost or fails  </li><li>the system will continue to function when network partitions occur </li></ul></li></ul><h2 id="1-1-CAP的选择"><a href="#1-1-CAP的选择" class="headerlink" title="1.1. CAP的选择"></a>1.1. CAP的选择</h2><p>分布式系统理论上来说无法选择CA架构，因为P是客观存在的，当网络分区发生的时候，为了保证C，那么只能回报错误给Client，这实质上就违反了A了。</p><h3 id="1-1-1-CP架构"><a href="#1-1-1-CP架构" class="headerlink" title="1.1.1 CP架构"></a>1.1.1 CP架构</h3><p>如下图所示，为了保证一致性，当发生分区现象后，N1 节点上的数据已经更新到 y，但由于 N1 和 N2 之间的复制通道中断，数据 y 无法同步到 N2，N2 节点上的数据还是 x。这时客户端 C 访问 N2 时，N2 需要返回 Error，提示客户端 C“系统现在发生了错误”，这种处理方式违背了可用性（Availability）的要求，因此 CAP 三者只能满足 CP。</p><p><img src="https://i.loli.net/2020/02/04/xXwWelYMtLu2hVv.png" alt="fig1.png"></p><h3 id="1-1-2-AP架构"><a href="#1-1-2-AP架构" class="headerlink" title="1.1.2 AP架构"></a>1.1.2 AP架构</h3><p>为了保证可用性，当发生分区现象后，N1 节点上的数据已经更新到 y，但由于 N1 和 N2 之间的复制通道中断，数据 y 无法同步到 N2，N2 节点上的数据还是 x。这时客户端 C 访问 N2 时，N2 将当前自己拥有的数据 x 返回给客户端 C 了，而实际上当前最新的数据已经是 y 了，这就不满足一致性（Consistency）的要求了，因此 CAP 三者只能满足 AP。注意：这里 N2 节点返回 x，虽然不是一个“正确”的结果，但是一个“合理”的结果，因为 x 是旧的数据，并不是一个错乱的值，只是不是最新的数据而已。</p><h2 id="1-2-CAP-细节"><a href="#1-2-CAP-细节" class="headerlink" title="1.2 CAP 细节"></a>1.2 CAP 细节</h2><h3 id="1-2-1-关注粒度-数据"><a href="#1-2-1-关注粒度-数据" class="headerlink" title="1.2.1 关注粒度 - 数据"></a>1.2.1 关注粒度 - 数据</h3><p>每个系统都不可能只处理一种数据，而是包含多种类型的数据，有的数据必须选择CP，有的数据必须选择AP。如果我们从整个系统的角度上去选择CP还是AP，很容易顾此失彼，无论怎么做都有问题。</p><p>比如用户管理系统，那么用户账户数据会选择CP，而用户信息数据会选择AP。因为在真的对CAP做应用的时候，我们需要将系统内的数据按照不同的应用场景和要求来进行分类，每类数据选择不同的策略，而不是限定整个系统的所有数据都是同一个策略。</p><h3 id="1-2-2-CAP是忽略网络延迟的"><a href="#1-2-2-CAP是忽略网络延迟的" class="headerlink" title="1.2.2 CAP是忽略网络延迟的"></a>1.2.2 CAP是忽略网络延迟的</h3><p>从节点A到节点B的复制，一定是需要花费一定的时间的，从几毫秒到几十毫秒不等。这意味着，CAP的理论当中的C在实践中是不可能完美实现的。</p><p>因此对于和金钱相关的，或者是和抢购相关的商品库存，技术上是无法做到分布式场景下完美的一致性的。而业务上又必须要求一致性，因此单个用户的余额，商品库存等只能单点写入，然后让其他节点做备份，无法做到分布式情况下的多点写入。</p><p><img src="https://i.loli.net/2020/02/04/FkRpQHwIXcj5hCW.png" alt="fig3.png"></p><p>这种设计的问题在于某个节点故障的时候，这个节点上的用户就无法进行读写操作了，但站在整体上来看，这种设计可以降低故障时受影响的用户的数量和范围。</p><h3 id="1-2-3-分区处理"><a href="#1-2-3-分区处理" class="headerlink" title="1.2.3 分区处理"></a>1.2.3 分区处理</h3><p>如果出现了分区，那么就需要在分区期间记录足够多的日志，当分区故障解决之后，系统根据日志进行数据恢复，使得重新达到CA的状态</p><h2 id="1-3-BASE"><a href="#1-3-BASE" class="headerlink" title="1.3 BASE"></a>1.3 BASE</h2><ul><li>basically available 基本可用<ul><li>出现故障的时候，允许损失部分可用性，即保证核心可用</li></ul></li><li>soft state 软状态<ul><li>允许系统存在中间状态，而该中间状态不会影响系统的整体可用性。这里的中间状态是CAP理论中的数据不一致 </li></ul></li><li>eventual consistency  最终一致性 <ul><li>系统的所有数据副本经过一定时间之后，最终能够达到一致的状态。</li></ul></li></ul><h2 id="2-3-FMEA分析表"><a href="#2-3-FMEA分析表" class="headerlink" title="2.3 FMEA分析表"></a>2.3 FMEA分析表</h2><h3 id="2-3-1-功能点"><a href="#2-3-1-功能点" class="headerlink" title="2.3.1 功能点"></a>2.3.1 功能点</h3><ul><li>从用户角度看涉及到的功能点<ul><li>用户角度，即登录注册这种功能</li><li>而不是数据库缓存这种</li></ul></li></ul><h3 id="2-3-2-故障模式"><a href="#2-3-2-故障模式" class="headerlink" title="2.3.2 故障模式"></a>2.3.2 故障模式</h3><ul><li>系统会出现什么样的故障<ul><li>包括故障点</li><li>故障模式<ul><li>假设某种故障现象即可</li></ul></li></ul></li><li>故障模式的描述要尽量精确，多使用量化的值来进行描述，避免泛化的方式。比如说慢，慢到3秒比说单纯的慢要好得多。</li></ul><h3 id="2-3-3-故障影响"><a href="#2-3-3-故障影响" class="headerlink" title="2.3.3 故障影响"></a>2.3.3 故障影响</h3><p>当发生故障模式中描述的故障时，功能点具体会受到什么影响。常见的影响有：</p><ul><li>功能点完全不可用</li><li>部分不可用</li><li>响应缓慢</li><li>功能出错</li></ul><p>故障影响也应该尽量准确描述，比如可能影响20%的用户之类的。</p><h3 id="2-3-4-严重程度"><a href="#2-3-4-严重程度" class="headerlink" title="2.3.4 严重程度"></a>2.3.4 严重程度</h3><p>站在业务的角度来看故障的影响程度，一般分为致命/ 高/ 中/ 低/ 无 五个档次。</p><p>严重程度 = 功能点重要程度 x 故障影响范围 x 功能点受损程度</p><h3 id="2-3-5-故障原因"><a href="#2-3-5-故障原因" class="headerlink" title="2.3.5 故障原因"></a>2.3.5 故障原因</h3><p>列出故障原因，是为了</p><ul><li>故障原因都具有不同的概率，这会影响我们的解决方案</li><li>不同故障原因检测手段不同</li><li>处理措施不同</li></ul><h3 id="2-3-6-故障概率"><a href="#2-3-6-故障概率" class="headerlink" title="2.3.6 故障概率"></a>2.3.6 故障概率</h3><ul><li>硬件</li><li>开源系统</li><li>自研系统</li></ul><h3 id="2-3-7-风险程度"><a href="#2-3-7-风险程度" class="headerlink" title="2.3.7 风险程度"></a>2.3.7 风险程度</h3><p>风险程度 = 严重程度 x 故障概率</p><h3 id="2-3-8-已有措施"><a href="#2-3-8-已有措施" class="headerlink" title="2.3.8 已有措施"></a>2.3.8 已有措施</h3><ul><li>检测告警<ul><li>检测故障，告警，人工干预</li></ul></li><li>容错<ul><li>系统通过备份手段来应对</li></ul></li><li>自恢复<ul><li>检测到故障以后，系统能够自动恢复。比如，Hadoop检测到某台机器故障之后，将存储在这台机器的副本重新分配到别的机器上。 </li></ul></li></ul><h3 id="2-3-9-规避措施"><a href="#2-3-9-规避措施" class="headerlink" title="2.3.9 规避措施"></a>2.3.9 规避措施</h3><ul><li>技术手段<ul><li>冗余备份等 </li></ul></li><li>管理手段<ul><li>硬件定期更新 </li></ul></li></ul><h3 id="2-3-10-解决措施"><a href="#2-3-10-解决措施" class="headerlink" title="2.3.10 解决措施"></a>2.3.10 解决措施</h3><p>为了能够解决问题而给出的方案，往往是技术手段</p><h3 id="2-3-11-后续规划"><a href="#2-3-11-后续规划" class="headerlink" title="2.3.11 后续规划"></a>2.3.11 后续规划</h3><p>综合前面的分析，就可以看出哪些故障我们目前还缺乏对应的措施，哪些已有措施还不够，针对这些不足的地方，再结合风险程度进行排序，给出后续的改进规划。这些规划既可以是技术手段，也可以是管理手段；可以是规避措施，也可以是解决措施。同时需要考虑资源的投入情况，优先将风险程度高的系统隐患解决。</p><h1 id="3-高可用存储架构"><a href="#3-高可用存储架构" class="headerlink" title="3. 高可用存储架构"></a>3. 高可用存储架构</h1><p>存储高可用方案 – 本质 – <strong><em>将数据复制到多个存储设备当中，通过数据冗余的方式来实现高可用</em></strong>， 其复杂性主要体现在如何应对复制延迟和中断导致的数据不一致的问题。因此，对任何一个高可用存储方案，我们需要考虑以下几个问题：</p><ul><li>数据如何复制的</li><li>各个节点的职责是什么</li><li>如何应对复制延迟</li><li>如何应对复制中断</li></ul><h2 id="3-1-双机架构"><a href="#3-1-双机架构" class="headerlink" title="3.1 双机架构"></a>3.1 双机架构</h2><h3 id="3-1-1-主备复制"><a href="#3-1-1-主备复制" class="headerlink" title="3.1.1 主备复制"></a>3.1.1 主备复制</h3><p><img src="https://i.loli.net/2020/02/04/CgcTbUFLiJDKE6u.jpg" alt="fig4.jpg"></p><p>主备架构的备机起到一个备份的作用，并不承担实际的业务读写操作，如果将备机改为主机，是需要进行人工操作的。</p><ul><li>优势<ul><li>足够简单</li><li>对于客户端来说，不需要感知备机的存在</li><li>对于主备之间，只需要进行数据复制，无须进行状态判断和主备切换这类复杂操作</li></ul></li><li>劣势<ul><li>备份无读写的流量，因此硬件成本上是有浪费的</li><li>故障之后需要人工干预，无法做自动恢复</li></ul></li></ul><h3 id="3-1-2-主从复制"><a href="#3-1-2-主从复制" class="headerlink" title="3.1.2 主从复制"></a>3.1.2 主从复制</h3><p><img src="https://i.loli.net/2020/02/04/JyKOIvYmc78Ut2Q.jpg" alt="fig5.jpg"></p><ul><li>优势<ul><li>主从复制在主机故障时，读操作相关的业务可以继续运行</li><li>主从复制架构的从机提供读操作，发挥了硬件的性能</li></ul></li><li>劣势<ul><li>主从复制当中，客户端需要感知主从关系，并将不同的操作发给不同的机器进行处理，复杂度比主备的要高</li><li>主从复制架构当中，从机提供读业务，如果主从复制延迟比较大，业务会因为数据不一致出现问题</li><li>故障时需要人工干预</li></ul></li></ul><h3 id="3-1-3-主备-主从切换"><a href="#3-1-3-主备-主从切换" class="headerlink" title="3.1.3 主备/ 主从切换"></a>3.1.3 主备/ 主从切换</h3><p>系统自动决定主机角色，并完成角色的切换。</p><p>以主备为例，需要考虑的问题有：</p><h4 id="3-1-3-1-主备间状态判断"><a href="#3-1-3-1-主备间状态判断" class="headerlink" title="3.1.3.1 主备间状态判断"></a>3.1.3.1 主备间状态判断</h4><ul><li>状态传递渠道<ul><li>相互之间的连接</li><li>第三方仲裁</li></ul></li><li>状态检测的内容<ul><li>机器是否掉电</li><li>进程是否存在</li><li>响应是否缓慢</li></ul></li></ul><h4 id="3-1-3-2-切换决策"><a href="#3-1-3-2-切换决策" class="headerlink" title="3.1.3.2 切换决策"></a>3.1.3.2 切换决策</h4><ul><li>切换时机</li><li>切换策略</li><li>自动程度</li></ul><h4 id="3-1-3-3-数据冲突解决"><a href="#3-1-3-3-数据冲突解决" class="headerlink" title="3.1.3.3 数据冲突解决"></a>3.1.3.3 数据冲突解决</h4><ul><li>需要做具体的应用场景的具体分析了</li></ul><h4 id="3-1-3-4-常见主备切换架构"><a href="#3-1-3-4-常见主备切换架构" class="headerlink" title="3.1.3.4 常见主备切换架构"></a>3.1.3.4 常见主备切换架构</h4><ul><li>互连式<ul><li>主备之间进行状态传递</li><li>缺点<ul><li>状态传递通道本身存在问题的话，备机也会自动升级为主机，造成有两个主机的结果</li></ul></li></ul></li><li>中介式<ul><li>引入第三方中介，主备间不直接连接，而是去连接中介，并且通过中介来传递状态信息</li><li>连接管理以及状态决策都更简单一些了</li></ul></li><li>模拟式<ul><li>主备之间不传递任何状态数据，而是备机模拟成一个客户端，向主机发起模拟的读写操作，根据读写操作的响应情况来判断主机的状态。 </li></ul></li></ul><h3 id="3-1-4-主主复制"><a href="#3-1-4-主主复制" class="headerlink" title="3.1.4 主主复制"></a>3.1.4 主主复制</h3><p><img src="https://i.loli.net/2020/02/04/o8ZKUvW4VEeY1nQ.png" alt="fig6.png"></p><ul><li>两台都是主机，不存在切换的概念</li><li>客户端无须区分不同角色的主机，随便讲读写操作发送给哪台主机都是可以的</li><li>双向复制本身的难以实现<ul><li>比如数据库同步，ID如何做更新等</li><li>一般适合于临时性，可丢失，可覆盖的数据场景</li></ul></li></ul><h2 id="3-2-集群和分区"><a href="#3-2-集群和分区" class="headerlink" title="3.2 集群和分区"></a>3.2 集群和分区</h2><h3 id="3-2-1-数据集群"><a href="#3-2-1-数据集群" class="headerlink" title="3.2.1 数据集群"></a>3.2.1 数据集群</h3><p>主备，主从，主主都有一个隐含的假设，主机能够存储所有数据。但是在实际场景当中，一台主机的存储和处理能力都是十分有限的，单台服务器一定是无法存储和处理的，我们必须使用多台服务器来存储数据，实现一个数据集群架构。</p><p>数据集群又可以分为数据集中集群，数据分散集群</p><h4 id="3-2-1-1-数据集中集群"><a href="#3-2-1-1-数据集中集群" class="headerlink" title="3.2.1.1 数据集中集群"></a>3.2.1.1 数据集中集群</h4><p><img src="https://i.loli.net/2020/02/04/93XQRrAHzuItK86.png" alt="fig7.png"></p><p> 客户端与主机进行交流，主机进行数据复制到各个备机上去。Zookeeper解决了大部分数据集中集群中会出现的问题。</p><ul><li>多条复制通道，会增大主机复制的压力，需要考虑如何降低主机复制压力</li><li>多条复制通道会导致多个备机之间数据不一致，我们需要对备机之间的数据一致性进行检查和修正</li><li>备机如何检查主机的状态，如何处理不同备机对主机状态的不同判断</li><li>主机故障以后，如何决定新的主机</li></ul><h4 id="3-2-1-2-数据分散集群"><a href="#3-2-1-2-数据分散集群" class="headerlink" title="3.2.1.2 数据分散集群"></a>3.2.1.2 数据分散集群</h4><ul><li><p>多个服务器组成一个集群，每台服务器都会负责存储一部分数据；同时为了提升硬件利用率，每台服务器又会备份一部分数据。</p></li><li><p>数据分配算法需要考虑到：</p><ul><li>均衡性 – 数据分区，数据容量基本上相同</li><li>容错性 – 当服务器故障时，算法需要将原来分配给故障服务器的数据分区分配给其他服务器</li><li>可伸缩性 – 集群容量不够，扩充了新的服务器之后，算法能够自动将部分数据分区迁移到新服务器上，并保证扩容后所有服务器的均衡性</li></ul></li><li><p>需要有一台机器来执行数据分配算法</p></li></ul><h3 id="3-2-2-数据分区"><a href="#3-2-2-数据分区" class="headerlink" title="3.2.2 数据分区"></a>3.2.2 数据分区</h3><p>针对于影响很大的事故或者灾难来说，有可能会使得所有硬件全部故障。数据分区指的是按照一定规则进行分区，分布到不同的地理位置上，每个分区存储一部分数据，通过这种方式来规避地理级别的故障所造成的的影响。</p><ul><li>数据分区的考虑因素<ul><li>数据量</li><li>分区规则</li><li>复制规则<ul><li>集中式<ul><li>总的备份中心，所有分区将数据备份到备份中心</li><li>设计简单，可互不影响</li><li>扩展容易</li><li>成本较高，需要建立一个独立的备份中心</li></ul></li><li>互备式<ul><li>每个分区备份另外一个分区的数据</li><li>复杂度高，相互之间强关联</li><li>成本低</li></ul></li><li>独立式<ul><li>每个分区都有自己的独立的备份中心</li><li>扩展容易，设计简单</li><li>成本很高</li></ul></li></ul></li></ul></li></ul><h1 id="4-计算高可用架构"><a href="#4-计算高可用架构" class="headerlink" title="4. 计算高可用架构"></a>4. 计算高可用架构</h1><p>当部分硬件损坏时，计算任务能够继续正常运行。因此计算高可用的本质是通过冗余来规避部分故障的风险。即通过增加更多的服务器来达到计算高可用。</p><p>设计复杂度主要体现在任务管理上，即当任务在某台服务器上执行失败以后，如何将任务重新分配到新的服务器进行执行。</p><h2 id="4-1-哪些服务器可以执行任务"><a href="#4-1-哪些服务器可以执行任务" class="headerlink" title="4.1 哪些服务器可以执行任务"></a>4.1 哪些服务器可以执行任务</h2><ul><li>特定服务器</li><li>每个服务器</li></ul><h2 id="4-2-任务如何重新执行"><a href="#4-2-任务如何重新执行" class="headerlink" title="4.2 任务如何重新执行"></a>4.2 任务如何重新执行</h2><ul><li>对已经分配的任务即使执行失败也不做任何处理，系统只需要保证新的任务能够分配到其他非故障的服务器上执行即可</li><li>设计一个任务管理器来管理需要执行的计算任务，服务器执行任务后，需要向任务管理器反馈任务执行的结果，任务管理器根据任务执行结果来决定是否需要将任务重新分配到另外的服务器上执行。</li></ul><h2 id="4-3-常见的计算高可用架构"><a href="#4-3-常见的计算高可用架构" class="headerlink" title="4.3 常见的计算高可用架构"></a>4.3 常见的计算高可用架构</h2><h3 id="4-3-1-主备"><a href="#4-3-1-主备" class="headerlink" title="4.3.1 主备"></a>4.3.1 主备</h3><p><img src="https://i.loli.net/2020/02/04/mGLY492oBbOqitu.png" alt="fig8.png"></p><ul><li>和存储高可用类似，不过更简单，因为不需要做数据复制的</li><li>主机执行所有计算任务</li><li>主机故障，任务分配器不会自动将计算任务发给备机，系统此时是不可用状态</li><li>如果主机恢复(人工或自动)，任务分配器继续将任务发送给主机</li><li>如果主机不能够恢复，则需要人工操作，将备机升为主机，然后让任务分配器将任务发送给新的主机</li></ul><h3 id="4-3-2-主从"><a href="#4-3-2-主从" class="headerlink" title="4.3.2 主从"></a>4.3.2 主从</h3><p><img src="https://i.loli.net/2020/02/04/Z4yh5EUqFCBPokT.png" alt="fig9.png"></p><ul><li>主机执行部分计算任务，备机也执行一部分</li><li>主机故障时，任务分配器还是会发给主机</li><li>不能恢复，人工操作，备机变主机，增加新的备机</li><li>好处是从机执行任务，发挥了硬件性能；缺点是需要将任务分类，任务分配器会复杂一些</li></ul><h3 id="4-3-3-集群"><a href="#4-3-3-集群" class="headerlink" title="4.3.3 集群"></a>4.3.3 集群</h3><p>系统需要能够自动完成切换操作，这是高可用集群方案。根据节点的角色，可以分成对称集群，集群内的每个服务器都有一样的角色，都可以执行所有的任务；另一类是非对称集群，集群中服务器分为多个不同角色，执行不同的任务。</p><h4 id="4-3-3-1-对称集群-负载均衡集群"><a href="#4-3-3-1-对称集群-负载均衡集群" class="headerlink" title="4.3.3.1 对称集群 - 负载均衡集群"></a>4.3.3.1 对称集群 - 负载均衡集群</h4><p><img src="https://i.loli.net/2020/02/04/hIbCsuAmKclkiqT.png" alt="fig10.png"></p><ul><li>任务分配器采取某种策略(随机、轮询等)将计算任务分配给集群当中的不同服务器</li><li>当集群中的某台服务器出现故障以后，任务分配器不再将任务分配给它，而是将任务分配给其他服务器执行</li><li>当故障的服务器恢复之后，任务分配器重新将任务分配给它执行</li></ul><ul><li>难点<ul><li>分配策略<ul><li>轮询</li><li>随机</li></ul></li><li>检测服务器状态<ul><li>服务器本身状态<ul><li>是否宕机</li><li>网络是否正常</li></ul></li><li>任务执行状态<ul><li>任务卡死</li><li>执行时间过长等</li></ul></li><li>一般来说是通过在任务分配器和服务器之间通过心跳来传递信息，包括服务器信息和任务信息，然后根据实际情况来确定状态，判断条件</li></ul></li></ul></li></ul><h4 id="4-3-3-2-非对称集群"><a href="#4-3-3-2-非对称集群" class="headerlink" title="4.3.3.2 非对称集群"></a>4.3.3.2 非对称集群</h4><ul><li>集群通过某种方式来区分不同的服务器角色<ul><li>ZAB 算法</li></ul></li><li>当指定类型的服务器故障时，需要重新分配角色 </li><li>比均衡负载更复杂<ul><li>任务分配策略更加复杂 - 需要将任务划分为不同类型并分配给不同角色的集群节点</li><li>角色分配策略实现更复杂      </li></ul></li></ul><h1 id="5-异地多活架构"><a href="#5-异地多活架构" class="headerlink" title="5. 异地多活架构"></a>5. 异地多活架构</h1><ul><li>异地 - 地理位置上的不同</li><li>多活 - 不同地理位置上的系统都能提供业务服务</li><li>异地多活标准<ul><li>用户无论访问哪一个地点的业务系统，都能够得到正确的业务服务</li><li>某个地方业务异常的时候，用户访问其他地方正常的业务系统，能够得到正确的业务服务</li></ul></li><li>异地多活实现代价非常高<ul><li>系统复杂度显著上升</li><li>成本上升</li></ul></li><li>需要异地多活的场景<ul><li>滴滴</li><li>微信</li><li>支付宝等</li></ul></li></ul><h2 id="5-1-架构模式"><a href="#5-1-架构模式" class="headerlink" title="5.1 架构模式"></a>5.1 架构模式</h2><h3 id="5-1-1-同城异区"><a href="#5-1-1-同城异区" class="headerlink" title="5.1.1 同城异区"></a>5.1.1 同城异区</h3><p>将业务部署在同一个城市不同区的多个机房当中。虽然还是无法在地震海啸等大灾害面前存活，但是同城异区通过光纤的设定，可以实现几乎和同一个机房相同的网络传输速度。这样尽管是多个机房，但我们可以将其作为一个机房来看待。</p><p>还是个看概率的问题，和地震海啸相比，机房火灾停电这种事情更有可能发生，对于此类故障，同城异区架构都可以很好地解决。</p><h3 id="5-1-2-跨城异地"><a href="#5-1-2-跨城异地" class="headerlink" title="5.1.2 跨城异地"></a>5.1.2 跨城异地</h3><p>将业务部署在不同城市的多个机房当中。距离要足够远，以应对极端灾难事件。但是与之相对的是，两个机房就几乎无法实现同步了。</p><p>正因为无法同步，所以对于十分敏感的数据，比如说账户余额这类，就不会使用跨城异地这种方式了。</p><h3 id="5-1-3-跨国异地"><a href="#5-1-3-跨国异地" class="headerlink" title="5.1.3 跨国异地"></a>5.1.3 跨国异地</h3><ul><li>主要为了为不同地区的用户提供服务</li><li>或者是只读类业务做多活</li></ul><h2 id="5-2-异地多活设计技巧"><a href="#5-2-异地多活设计技巧" class="headerlink" title="5.2 异地多活设计技巧"></a>5.2 异地多活设计技巧</h2><h3 id="5-2-1-保证核心业务的异地多活"><a href="#5-2-1-保证核心业务的异地多活" class="headerlink" title="5.2.1 保证核心业务的异地多活"></a>5.2.1 保证核心业务的异地多活</h3><p>因为保证所有业务的异地多活是不现实的，比如注册，登录，用户信息都要保持同步。注册不应该保持异地多活，因为一般都有单个手机号的限制，如果异地服务器，就无法检测是否已经注册过了，这是一个商业逻辑上的很大的悖论了，不可以这样做。</p><p>同理对于用户信息也是，根据更新时间的激活和识别也很可能会因为不同的机器时间的问题，而导致最终是不准确的，会带来很不好的用户体验。</p><p>登录才是最最需要保证异地多活的功能。</p><h3 id="5-2-2-保证核心数据最终一致性"><a href="#5-2-2-保证核心数据最终一致性" class="headerlink" title="5.2.2 保证核心数据最终一致性"></a>5.2.2 保证核心数据最终一致性</h3><p>异地多活本质上是通过异地的数据冗余，来保证在极端的异常情况下，业务也能正常提供给用户。即需要实现<strong>数据的快速同步</strong>。</p><ul><li>尽量减少异地多活机房的距离，搭建高速网络</li><li>尽量减少数据同步，只同步核心业务相关的数据</li><li>保证最终一致性，不保证实时的</li></ul><h2 id="5-3-如何应对接口级的故障"><a href="#5-3-如何应对接口级的故障" class="headerlink" title="5.3 如何应对接口级的故障"></a>5.3 如何应对接口级的故障</h2><p>接口级故障的典型表现就是系统并没有宕机，网络也没中断，但业务却出现了问题。例如：</p><ul><li>业务响应缓慢</li><li>访问大量超时</li><li>大量访问出现异常</li></ul><p>这类问题的主要原因在于系统压力太大，负载太高，导致无法快速处理业务请求，由此引发了更多的后续问题。常见的比如说数据库慢查询，将数据库的服务器资源耗尽了，导致读写超时，业务读写数据库要么超时，无法连接；从用户的角度来说，就是访问很慢，或者抛出异常。 </p><h3 id="5-3-1-接口级故障的原因"><a href="#5-3-1-接口级故障的原因" class="headerlink" title="5.3.1 接口级故障的原因"></a>5.3.1 接口级故障的原因</h3><ul><li>内部原因<ul><li>程序bug导致死循环</li><li>某个接口导致数据库慢查询</li><li>程序逻辑不完善导致耗尽内存</li></ul></li><li>外部原因<ul><li>黑客攻击</li><li>促销，抢购引入远超平时的用户</li><li>第三方系统大量请求</li><li>第三方系统响应缓慢</li></ul></li><li>解决的核心思想<ul><li>优先保证核心业务</li><li>优先保证绝大部分用户</li></ul></li></ul><h3 id="5-3-2-降级"><a href="#5-3-2-降级" class="headerlink" title="5.3.2 降级"></a>5.3.2 降级</h3><p>系统将某些业务或者接口的功能降低，只提供部分功能或者完全停掉所有功能</p><ul><li>系统后门降级<ul><li>比如提供一个降级URL，当访问这个URL的时候，就相当于提供了一个降级操作</li></ul></li><li>独立降级系统<ul><li>独立出系统，实现权限管理批量操作等功能。</li></ul></li></ul><h3 id="5-3-3-熔断"><a href="#5-3-3-熔断" class="headerlink" title="5.3.3 熔断"></a>5.3.3 熔断</h3><ul><li>和降级做对比<ul><li>降级是用来处理系统自身的故障</li><li>熔断是应对依赖的外部系统的故障的情况</li></ul></li><li>熔断机制的关键在于一个统一的API调用层，由API调用层来进行采样或者统计</li><li>另一个关键是阈值的设计，一般是根据分析确定阈值，然后上线观察效果，再进行调优</li></ul><h3 id="5-3-4-限流"><a href="#5-3-4-限流" class="headerlink" title="5.3.4 限流"></a>5.3.4 限流</h3><p>从用户访问压力的角度来考虑，只允许系统能够承载的访问量来访问，超出系统访问能力的请求将被丢弃。</p><ul><li>基于请求限流<ul><li>常用方式<ul><li>限制总量<ul><li>比如限制总用户的上限 </li></ul></li><li>限制时间量<ul><li>限制一段时间内某个指标的上限  比如请求tps</li></ul></li></ul></li><li>这种方式更多是英语业务功能比较简单的系统，因为很可能阈值需要不断调整的</li></ul></li><li>基于资源限流<ul><li>找到系统内部影响性能的关键资源，对其使用上限进行限制<ul><li>连接数</li><li>文件句柄</li><li>线程数</li><li>请求队列</li></ul></li></ul></li></ul><h3 id="5-3-5-排队"><a href="#5-3-5-排队" class="headerlink" title="5.3.5 排队"></a>5.3.5 排队</h3><ul><li>不直接扔掉请求，排队</li><li>排队模块<ul><li>将请求以先进先出的方式保存下来</li></ul></li><li>调度模块<ul><li>负责排队模块到服务模块的动态调度</li></ul></li><li>服务模块<ul><li>调用真正业务来处理服务，并返回处理结果，调用排队模块的接口回写处理结果。 </li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-CAP-原理&quot;&gt;&lt;a href=&quot;#1-CAP-原理&quot; class=&quot;headerlink&quot; title=&quot;1. CAP 原理&quot;&gt;&lt;/a&gt;1. CAP 原理&lt;/h1&gt;&lt;p&gt;CAP原理讨论得是对于数据的读写操作，并不是在讨论整个系统的各个方面的功能。并且讨论得是
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="架构" scheme="https://www.llchen60.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="CAP" scheme="https://www.llchen60.com/tags/CAP/"/>
    
  </entry>
  
  <entry>
    <title>架构学习-架构设计流程</title>
    <link href="https://www.llchen60.com/%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%B5%81%E7%A8%8B/"/>
    <id>https://www.llchen60.com/%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%B5%81%E7%A8%8B/</id>
    <published>2020-02-04T04:14:02.000Z</published>
    <updated>2020-02-04T04:14:25.557Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-识别复杂度"><a href="#1-识别复杂度" class="headerlink" title="1. 识别复杂度"></a>1. 识别复杂度</h1><p>具体情况需要具体分析，即这个系统的复杂度体现在哪一个方面。一个系统的复杂度主要来源于高性能，高可用，可扩展这几个方面。</p><p>正确的做法是将主要的复杂度问题列出来，然后根据业务、技术、团队等综合情况进行排序，优先解决当前面临的最主要的复杂问题。</p><p>多个系统之间的强耦合，可以通过信息队列来解耦。要注意从高可用，高性能，可扩展几个维度对其进行分析，看整个架构调整的复杂度在哪里，然后做针对性的提升。</p><p>平均TPS， QPS，峰值TPS (average x 3)，</p><h1 id="2-设计备选方案"><a href="#2-设计备选方案" class="headerlink" title="2. 设计备选方案"></a>2. 设计备选方案</h1><p>架构师需要对已经存在的技术非常熟悉，对已经经过验证的架构模式烂熟于心，然后根据自己对于业务的理解，挑选合适的架构模式进行组合，再对组合之后的方案进行修改和调整。</p><p>目前，只要明确了应用场景，复杂度上的限制因素，我们往往能找到相对成熟的技术来直接使用。例如</p><ul><li>高可用主备方案</li><li>集群方案</li><li>高性能负载均衡</li><li>多路复用</li><li>可拓展的分层</li><li>插件化技术</li></ul><p>设计备选方案的tips</p><ul><li>多设计几个备选方法，3-5个为宜</li><li>方案之间的差异要比较明显</li><li>备选方案的技术不要只局限于已经熟悉的技术</li><li>备选方案不需要太过于详细的，关注的是技术选型，而不是技术细节</li></ul><p>对于高性能写入</p><ul><li>集群</li><li>直接写入一台正常的服务器即可<br>高可用存储</li><li>已经写入的信息在单台服务器宕机的情况下不丢失</li><li>使用MySQL的主备复制功能<br>高可用读取</li><li>要求已经写入的消息在单台服务器宕机的情况下可以继续读取</li><li>服务器的主备方案</li></ul><h1 id="3-评估和选择备选方案"><a href="#3-评估和选择备选方案" class="headerlink" title="3. 评估和选择备选方案"></a>3. 评估和选择备选方案</h1><ul><li>多角度环评<ul><li>列出需要关注的质量属性点</li><li>分别从这些质量属性的维度去评估每个方案，再综合挑选适合当时情况的最优方案</li></ul></li><li>方案质量属性点<ul><li>性能</li><li>可用性</li><li>硬件成本</li><li>项目投入</li><li>复杂度</li><li>安全性</li><li>可拓展性</li></ul></li><li>对于需要评估未来业务发展的规模时，一般可以将当前的业务规模乘以2-4 即可。</li><li>将质量属性按照优先级排序</li></ul><h1 id="4-详细方案设计"><a href="#4-详细方案设计" class="headerlink" title="4. 详细方案设计"></a>4. 详细方案设计</h1><p>将方案涉及的关键技术细节给确定下来。</p><ul><li>假如我们确定使用 Elasticsearch 来做全文搜索，那么就需要确定 Elasticsearch 的索引是按照业务划分，还是一个大索引就可以了；副本数量是 2 个、3 个还是 4 个，集群节点数量是 3 个还是 6 个等。</li><li>假如我们确定使用 MySQL 分库分表，那么就需要确定哪些表要分库分表，按照什么维度来分库分表，分库分表后联合查询怎么处理等。</li><li>假如我们确定引入 Nginx 来做负载均衡，那么 Nginx 的主备怎么做，Nginx 的负载均衡策略用哪个（权重分配？轮询？ip_hash？）等。<ul><li>轮询</li><li>加权轮询 - 后端服务器性能不均</li><li>ip_hash - 每个方可固定访问同一个后端服务器，解决session的问题</li><li>fair - 按照响应时间来分配请求，响应时间短的优先分配，能够最大化平衡各后端服务器的压力，可以适用于后端服务器性能不均衡的情况</li><li>url_hash - 每个url定向到同一个后端服务器，适用于后端服务器能够将url的响应结果缓存的情况</li></ul></li></ul><ul><li>通过分步骤，分阶段，分系统等方式，尽量降低方案的复杂度。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-识别复杂度&quot;&gt;&lt;a href=&quot;#1-识别复杂度&quot; class=&quot;headerlink&quot; title=&quot;1. 识别复杂度&quot;&gt;&lt;/a&gt;1. 识别复杂度&lt;/h1&gt;&lt;p&gt;具体情况需要具体分析，即这个系统的复杂度体现在哪一个方面。一个系统的复杂度主要来源于高性能，高可
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="架构" scheme="https://www.llchen60.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>架构学习 - 架构设计文档模板</title>
    <link href="https://www.llchen60.com/%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3%E6%A8%A1%E6%9D%BF/"/>
    <id>https://www.llchen60.com/%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3%E6%A8%A1%E6%9D%BF/</id>
    <published>2020-02-04T04:12:55.000Z</published>
    <updated>2020-02-04T04:13:14.588Z</updated>
    
    <content type="html"><![CDATA[<p>整个流程应当是在刚开始的时候有几个方案，然后在经过讨论和分析以后整理出唯一可以的方案，然后再创建架构设计的详细文档，这个时候理论上应该</p><h1 id="1-备选方案模板"><a href="#1-备选方案模板" class="headerlink" title="1. 备选方案模板"></a>1. 备选方案模板</h1><h2 id="1-1-需求介绍"><a href="#1-1-需求介绍" class="headerlink" title="1.1 需求介绍"></a>1.1 需求介绍</h2><ul><li>需求的背景</li><li>需求的目标</li><li>需求的范围</li></ul><h2 id="1-2-需求分析"><a href="#1-2-需求分析" class="headerlink" title="1.2 需求分析"></a>1.2 需求分析</h2><h3 id="1-2-1-5W"><a href="#1-2-1-5W" class="headerlink" title="1.2.1 5W"></a>1.2.1 5W</h3><ul><li>Who 开发者 使用者 购买者 决策者等</li><li>When 需求使用时间，包括季节，时间，里程碑等</li><li>What 需求的产出是什么，包括系统，数据，文件，开发库，平台等</li><li>Where  需求的应用场景，包括国家，地点，环境等</li><li>Why  需求需要解决的问题，通常和需求背景相关</li></ul><h3 id="1-2-2-1H"><a href="#1-2-2-1H" class="headerlink" title="1.2.2 1H"></a>1.2.2 1H</h3><p>How指的是关键业务流程</p><h3 id="1-2-3-8C"><a href="#1-2-3-8C" class="headerlink" title="1.2.3 8C"></a>1.2.3 8C</h3><p>8个约束和限制，包括</p><ul><li>performance</li><li>cost</li><li>time</li><li>reliability</li><li>security</li><li>compliance</li><li>technology</li><li>compatibility</li></ul><h2 id="1-3-复杂度分析"><a href="#1-3-复杂度分析" class="headerlink" title="1.3 复杂度分析"></a>1.3 复杂度分析</h2><h3 id="1-3-1-高可用"><a href="#1-3-1-高可用" class="headerlink" title="1.3.1 高可用"></a>1.3.1 高可用</h3><h3 id="1-3-2-高性能"><a href="#1-3-2-高性能" class="headerlink" title="1.3.2 高性能"></a>1.3.2 高性能</h3><h3 id="1-3-3-可扩展"><a href="#1-3-3-可扩展" class="headerlink" title="1.3.3 可扩展"></a>1.3.3 可扩展</h3><h2 id="1-4-其他备选方案及评估"><a href="#1-4-其他备选方案及评估" class="headerlink" title="1.4 其他备选方案及评估"></a>1.4 其他备选方案及评估</h2><h1 id="2-架构设计模板"><a href="#2-架构设计模板" class="headerlink" title="2. 架构设计模板"></a>2. 架构设计模板</h1><h2 id="2-1-总体方案"><a href="#2-1-总体方案" class="headerlink" title="2.1 总体方案"></a>2.1 总体方案</h2><p>整体描述方案的结构，架构图，以及针对架构图的描述，包括模块或者子系统的职责描述，核心流程</p><h2 id="2-2-架构总览"><a href="#2-2-架构总览" class="headerlink" title="2.2 架构总览"></a>2.2 架构总览</h2><p>架构图以及架构的描述</p><h2 id="2-3-核心流程"><a href="#2-3-核心流程" class="headerlink" title="2.3 核心流程"></a>2.3 核心流程</h2><h2 id="2-4-详细设计"><a href="#2-4-详细设计" class="headerlink" title="2.4 详细设计"></a>2.4 详细设计</h2><h3 id="2-4-1-高可用设计"><a href="#2-4-1-高可用设计" class="headerlink" title="2.4.1 高可用设计"></a>2.4.1 高可用设计</h3><h3 id="2-4-2-高性能设计"><a href="#2-4-2-高性能设计" class="headerlink" title="2.4.2 高性能设计"></a>2.4.2 高性能设计</h3><h3 id="2-4-3-可扩展设计"><a href="#2-4-3-可扩展设计" class="headerlink" title="2.4.3 可扩展设计"></a>2.4.3 可扩展设计</h3><h3 id="2-4-4-安全设计"><a href="#2-4-4-安全设计" class="headerlink" title="2.4.4 安全设计"></a>2.4.4 安全设计</h3><h2 id="2-5-部署方案"><a href="#2-5-部署方案" class="headerlink" title="2.5 部署方案"></a>2.5 部署方案</h2><ul><li>硬件要求</li><li>服务器部署方式</li><li>组网方式</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;整个流程应当是在刚开始的时候有几个方案，然后在经过讨论和分析以后整理出唯一可以的方案，然后再创建架构设计的详细文档，这个时候理论上应该&lt;/p&gt;
&lt;h1 id=&quot;1-备选方案模板&quot;&gt;&lt;a href=&quot;#1-备选方案模板&quot; class=&quot;headerlink&quot; title=&quot;1
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="架构" scheme="https://www.llchen60.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>架构学习 - 实战</title>
    <link href="https://www.llchen60.com/%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0-%E5%AE%9E%E6%88%98/"/>
    <id>https://www.llchen60.com/%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0-%E5%AE%9E%E6%88%98/</id>
    <published>2020-02-04T04:10:07.000Z</published>
    <updated>2020-02-04T04:11:33.749Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-技术演进的动力-企业发展"><a href="#1-技术演进的动力-企业发展" class="headerlink" title="1. 技术演进的动力 - 企业发展"></a>1. 技术演进的动力 - 企业发展</h1><h2 id="1-1-业务和技术之间的关系"><a href="#1-1-业务和技术之间的关系" class="headerlink" title="1.1 业务和技术之间的关系"></a>1.1 业务和技术之间的关系</h2><ul><li>产品类<ul><li>技术创新推动业务发展 </li><li>用户选择产品的根本驱动力是功能</li></ul></li><li>服务类<ul><li>业务发展推动技术创新 </li><li>用户选择服务的根本驱动力是规模</li></ul></li></ul><h1 id="2-技术演进的模式-（复杂性，用户规模）"><a href="#2-技术演进的模式-（复杂性，用户规模）" class="headerlink" title="2. 技术演进的模式 （复杂性，用户规模）"></a>2. 技术演进的模式 （复杂性，用户规模）</h1><ul><li>业务时期分类<ul><li>初创期</li><li>发展期</li><li>竞争期</li><li>成熟期</li></ul></li></ul><h2 id="2-1-初创期"><a href="#2-1-初创期" class="headerlink" title="2.1 初创期"></a>2.1 初创期</h2><p>创新出新的理念，通过用户使用，快速迭代，不断完善。对于业务的要求就是快。</p><h2 id="2-2-发展期"><a href="#2-2-发展期" class="headerlink" title="2.2 发展期"></a>2.2 发展期</h2><p>大量加入功能，技术方面的核心工作就是快速实现各种需求。</p><ul><li>堆功能</li><li>优化 vs 重新架构</li><li>架构期 - 拆分</li></ul><h2 id="2-3-竞争期"><a href="#2-3-竞争期" class="headerlink" title="2.3 竞争期"></a>2.3 竞争期</h2><p>更迅速的发展，但是很容易出现重复造轮子，以及系统交互很乱等问题</p><p>因此一般都是做平台化以及服务化的操作。</p><ul><li>平台化<ul><li>存储平台化</li><li>数据库平台化</li><li>缓存平台化</li></ul></li></ul><h2 id="2-4-成熟期"><a href="#2-4-成熟期" class="headerlink" title="2.4 成熟期"></a>2.4 成熟期</h2><p>系统性的针对性优化</p><h1 id="3-General"><a href="#3-General" class="headerlink" title="3. General"></a>3. General</h1><p><img src="https://i.loli.net/2020/02/04/ViqLHs2aExQUAru.png" alt="fig1.png"></p><ul><li>纵向排列<ul><li>测试平台</li><li>运维平台</li><li>数据平台</li><li>管理平台</li></ul></li><li>横向<ul><li>业务层</li><li>用户层<ul><li>用户管理</li><li>消息推送</li><li>存储云</li><li>图片云</li></ul></li><li>网络层<ul><li>负载均衡</li><li>CDN</li></ul></li><li>服务层<ul><li>配置中心</li><li>服务中心</li><li>消息队列</li></ul></li><li>开发层<ul><li>开发框架</li><li>服务器</li><li>容器</li></ul></li><li>存储层<ul><li>SQL</li><li>NoSQL</li><li>小文件</li><li>大文件</li></ul></li></ul></li></ul><h1 id="4-存储层技术"><a href="#4-存储层技术" class="headerlink" title="4. 存储层技术"></a>4. 存储层技术</h1><h2 id="4-1-SQL"><a href="#4-1-SQL" class="headerlink" title="4.1 SQL"></a>4.1 SQL</h2><ul><li>NoSQL - Not only SQL </li><li>数据库拆分满足性能要求，但是会带来复杂度问题<ul><li>数据如何拆分</li><li>数据如何组合</li></ul></li><li>当业务发展到一定阶段之后，会将这部分功能独立成中间件</li><li>而后在SQL集群上构建SQL存储平台，以对业务透明的形式提供资源分配、数据备份、迁移、容灾、读写分离、分库分表等一系列服务</li></ul><h2 id="4-2-NoSQL"><a href="#4-2-NoSQL" class="headerlink" title="4.2 NoSQL"></a>4.2 NoSQL</h2><p>在NoSQL集群的基础上实现统一的存储平台，实现以下的功能：</p><ul><li>资源按需动态分配</li><li>资源自动化管理</li><li>故障自动化管理</li></ul><h2 id="4-3-小文件存储"><a href="#4-3-小文件存储" class="headerlink" title="4.3 小文件存储"></a>4.3 小文件存储</h2><p>展示性质的数据，比如商品图片，商品描述；特征是数据小，但数量巨大</p><h2 id="4-4-大文件存储"><a href="#4-4-大文件存储" class="headerlink" title="4.4 大文件存储"></a>4.4 大文件存储</h2><ul><li>业务上的大数据<ul><li>youtube的视频</li><li>电影</li></ul></li><li>海量日志数据<ul><li>访问日志</li><li>操作日志</li><li>用户轨迹日志</li></ul></li></ul><p>几个开源方案</p><ul><li>Hadoop</li><li>HBase</li><li>Storm</li><li>Hive</li></ul><h1 id="5-开发层技术"><a href="#5-开发层技术" class="headerlink" title="5. 开发层技术"></a>5. 开发层技术</h1><h2 id="5-1-开发框架"><a href="#5-1-开发框架" class="headerlink" title="5.1 开发框架"></a>5.1 开发框架</h2><p>整个公司使用同样的框架和技术可以解决组和组之间沟通的问题，大大提升组织和团队的开发效率。</p><p>对于框架，应该选择成熟的框架，避免盲目追逐新技术。</p><ul><li>java<ul><li>SSH</li><li>SpringMVC</li><li>Play </li></ul></li><li>Ruby<ul><li>Ruby on Rails</li></ul></li><li>PHP<ul><li>ThinkPHP</li></ul></li><li>Python <ul><li>Django </li></ul></li></ul><h2 id="5-2-Web服务器"><a href="#5-2-Web服务器" class="headerlink" title="5.2 Web服务器"></a>5.2 Web服务器</h2><ul><li>Java<ul><li>Tomcat</li><li>JBoss </li><li>Besin </li></ul></li><li>PHP/ Python <ul><li>Nginx</li></ul></li><li>Apache </li></ul><h2 id="5-3-容器"><a href="#5-3-容器" class="headerlink" title="5.3 容器"></a>5.3 容器</h2><p>Docker技术，不跨平台，但是启动快，几乎不占资源</p><p>可以基于Docker打造自动化运维</p><h1 id="6-服务层技术"><a href="#6-服务层技术" class="headerlink" title="6. 服务层技术"></a>6. 服务层技术</h1><p>服务层的主要目标就是降低系统间相互关联的复杂度。</p><h2 id="6-1-配置中心"><a href="#6-1-配置中心" class="headerlink" title="6.1 配置中心"></a>6.1 配置中心</h2><ul><li>集中管理各个系统的配置</li><li>各系统管理自己的配置会带来一些问题<ul><li>需要多个系统配合的时候，配置分散，则配置检查和沟通协调都会比较费时间</li><li>处理线上问题，需要查询多个配置文件，相互比较，很麻烦</li><li>各系统自己配置，往往用文本方式，没有自动的校验机制，就比较容易出现错误</li></ul></li><li>配置中心，做成通用系统，给所有系统来使用<ul><li>集中配置</li><li>程序化的规则检查，避免常见错误，可以用正则表达式来检查</li><li>备份了系统的配置，便于快速搭建系统和恢复业务</li></ul></li></ul><h2 id="6-2-服务中心"><a href="#6-2-服务中心" class="headerlink" title="6.2 服务中心"></a>6.2 服务中心</h2><p>服务中心是用来解决跨系统依赖的配置和调度问题的。</p><h3 id="6-2-1-服务名字系统-–-Service-Name-System"><a href="#6-2-1-服务名字系统-–-Service-Name-System" class="headerlink" title="6.2.1 服务名字系统 – Service Name System"></a>6.2.1 服务名字系统 – Service Name System</h3><p>将Service的名称解析为<code>host+port+接口名称</code></p><p><img src="https://i.loli.net/2020/02/04/HqVy9UlC35ceauY.png" alt="fig2.png"></p><h3 id="6-2-2-服务总线系统-–-Service-Bus-System"><a href="#6-2-2-服务总线系统-–-Service-Bus-System" class="headerlink" title="6.2.2 服务总线系统 – Service Bus System"></a>6.2.2 服务总线系统 – Service Bus System</h3><p>有总线系统完成调用，服务请求方不需要直接和服务提供方进行交互了。</p><p><img src="https://i.loli.net/2020/02/04/G2UmVfZCIBpcLSD.png" alt="fig3.png"></p><p><img src="https://i.loli.net/2020/02/04/D5QZEIuiFAWoN1s.png" alt="fig4.png"></p><h2 id="6-3-消息队列"><a href="#6-3-消息队列" class="headerlink" title="6.3 消息队列"></a>6.3 消息队列</h2><p>很多业务处理需要采用异步的方式，消息队列就是为了实现这种跨系统异步通知的中间件系统。</p><h1 id="7-网络层技术"><a href="#7-网络层技术" class="headerlink" title="7. 网络层技术"></a>7. 网络层技术</h1><h2 id="7-1-负载均衡"><a href="#7-1-负载均衡" class="headerlink" title="7.1 负载均衡"></a>7.1 负载均衡</h2><ul><li>DNS<ul><li>地理级别的负载均衡 </li></ul></li><li>Nginx, LVS, F5 <ul><li>同一个地点内机器级别的负载均衡</li></ul></li><li>CDN<h2 id="7-2-多机房-跨国多机房"><a href="#7-2-多机房-跨国多机房" class="headerlink" title="7.2 多机房 + 跨国多机房"></a>7.2 多机房 + 跨国多机房</h2><h2 id="7-3-多中心"><a href="#7-3-多中心" class="headerlink" title="7.3 多中心"></a>7.3 多中心</h2></li></ul><p>每个中心都可以对外提供服务，且业务可以自动在多中心之间切换。</p><h1 id="8-用户层技术"><a href="#8-用户层技术" class="headerlink" title="8. 用户层技术"></a>8. 用户层技术</h1><h2 id="8-1-用户管理"><a href="#8-1-用户管理" class="headerlink" title="8.1 用户管理"></a>8.1 用户管理</h2><ul><li>单点登录 (SSO) - 统一登录<ul><li>cookie</li><li>Json</li><li>token </li><li>CAS </li></ul></li></ul><p><img src="https://i.loli.net/2020/02/04/y9ScKCkWZvTomLY.png" alt="fig5.png"></p><ul><li>授权登录<ul><li>OAuth 2.0</li></ul></li></ul><h2 id="8-2-消息推送"><a href="#8-2-消息推送" class="headerlink" title="8.2 消息推送"></a>8.2 消息推送</h2><ul><li>根据途径<ul><li>短信</li><li>邮件</li><li>站内信</li><li>App推送</li></ul></li><li>消息推送的功能<ul><li>设备管理<ul><li>唯一标识</li><li>注册</li><li>注销</li></ul></li><li>连接管理</li><li>消息管理</li></ul></li></ul><p>技术上的挑战：</p><ul><li><p>海量设备和用户管理</p><ul><li>需要将用户和设备关联起来</li><li>提取用户特征对用户进行分类或者打标签</li></ul></li><li><p>连接保活</p><ul><li>想推送消息必须有连接通道</li><li>但是手机等终端都会限制后台应用的运行</li><li>应用找厂商拉白名单，hhhh</li></ul></li><li><p>消息管理</p><ul><li>根据用户的特征，选择一些用户进行消息推送</li><li>这部分的逻辑的设计必须十分灵活<h2 id="8-3-存储云，图片云"><a href="#8-3-存储云，图片云" class="headerlink" title="8.3 存储云，图片云"></a>8.3 存储云，图片云</h2></li></ul></li><li><p>小文件存储</p></li></ul><h1 id="9-业务层技术"><a href="#9-业务层技术" class="headerlink" title="9. 业务层技术"></a>9. 业务层技术</h1><p>主要是随着发展业务层变得越来越大了，需要做的最主要的就是拆分了，将整体复杂性分散到多个子业务或者子系统当中。</p><p>当子系统太多的时候，再做高内聚，低耦合的操作，即将职责关联比较强的子系统合成一个虚拟业务域，然后通过网关对外统一呈现。</p><h1 id="10-平台技术"><a href="#10-平台技术" class="headerlink" title="10. 平台技术"></a>10. 平台技术</h1><h2 id="10-1-运维平台"><a href="#10-1-运维平台" class="headerlink" title="10.1 运维平台"></a>10.1 运维平台</h2><ul><li>配置<ul><li>主要负责资源的管理<ul><li>机器管理</li><li>IP地址管理</li><li>虚拟机管理</li></ul></li></ul></li><li>部署<ul><li>主要负责将系统发布到线上<ul><li>包管理</li><li>灰度发布管理</li><li>回滚</li></ul></li></ul></li><li>监控<ul><li>主要负责收集系统上线运行之后的相关数据并进行监控，以便及时发现问题 </li></ul></li><li>应急<ul><li>主要负责系统出故障以后的处理<ul><li>停止程序</li><li>下线故障机器</li><li>切换IP</li></ul></li></ul></li></ul><h2 id="10-2-测试平台"><a href="#10-2-测试平台" class="headerlink" title="10.2 测试平台"></a>10.2 测试平台</h2><ul><li>单元测试</li><li>集成测试</li><li>接口测试</li><li>性能测试</li></ul><p>重点就是自动化测试，使测试用例能够重复执行，无须人工参与，以提高测试效率。</p><h3 id="10-2-1-用例管理"><a href="#10-2-1-用例管理" class="headerlink" title="10.2.1 用例管理"></a>10.2.1 用例管理</h3><p>测试自动化的主要手段就是通过脚本或者代码来进行测试，为了重复执行此类代码，测试平台需要将用例进行管理，管理的维度有业务、系统、测试类型、用例代码。例如网购业务的订单系统的接口测试用例。</p><h3 id="10-2-2-资源管理"><a href="#10-2-2-资源管理" class="headerlink" title="10.2.2 资源管理"></a>10.2.2 资源管理</h3><p>具体的运行环境的配置，包括</p><ul><li>硬件<ul><li>服务器</li><li>手机</li><li>平板</li></ul></li><li>软件<ul><li>操作系统</li><li>数据库</li><li>Java虚拟机</li></ul></li><li>业务系统</li></ul><h3 id="10-2-3-任务管理"><a href="#10-2-3-任务管理" class="headerlink" title="10.2.3 任务管理"></a>10.2.3 任务管理</h3><p>将测试用例分配到具体的资源上来执行，跟踪任务的执行情况。任务管理是测试平台设计的核心，其将测试平台的各个部分串联起来从而完成自动化测试</p><h3 id="10-2-4-数据管理"><a href="#10-2-4-数据管理" class="headerlink" title="10.2.4 数据管理"></a>10.2.4 数据管理</h3><p>记录各种相关的数据</p><ul><li>执行时间</li><li>执行结果</li><li>用例执行期间的CPU，内存占用情况</li></ul><h2 id="10-3-数据平台"><a href="#10-3-数据平台" class="headerlink" title="10.3 数据平台"></a>10.3 数据平台</h2><ul><li>数据管理<ul><li>数据采集<ul><li>日志</li><li>用户行为</li><li>业务数据</li></ul></li><li>数据存储<ul><li>将从业务系统采集的数据存储到数据平台，用于后续数据分析 </li></ul></li><li>数据访问<ul><li>负责对外提供各种协议用于读写数据 </li></ul></li><li>数据安全</li></ul></li><li>数据分析<ul><li>数据统计</li><li>数据挖掘</li><li>机器学习</li><li>深度学习</li></ul></li><li>数据应用</li></ul><h2 id="10-4-管理平台"><a href="#10-4-管理平台" class="headerlink" title="10.4 管理平台"></a>10.4 管理平台</h2><p>管理平台的核心职责就是权限管理，要做身份认证以及权限控制。</p><ul><li>身份认证<ul><li>确定当前的操作人员身份，防止非法人员进入系统</li></ul></li><li>权限控制<ul><li>根据身份确定权限 </li></ul></li></ul><h1 id="11-Some-tips"><a href="#11-Some-tips" class="headerlink" title="11. Some tips"></a>11. Some tips</h1><h2 id="11-1-如何选择开源项目"><a href="#11-1-如何选择开源项目" class="headerlink" title="11.1 如何选择开源项目"></a>11.1 如何选择开源项目</h2><ul><li>不要重复造轮子</li><li>但要找到合适的轮子</li></ul><h3 id="11-1-1-选择方法"><a href="#11-1-1-选择方法" class="headerlink" title="11.1.1 选择方法"></a>11.1.1 选择方法</h3><ul><li>聚焦于是否满足业务，而不是聚焦于开源项目本身是否足够优秀</li><li>聚焦于该项目是否足够成熟<ul><li>版本号</li><li>使用的公司数量</li><li>社区活跃程度</li></ul></li><li>聚焦于运维能力<ul><li>开源项目日志是否齐全</li><li>是否有命令行，管理控制台等维护工具</li><li>是否有故障检测和恢复的能力，例如告警，切换等</li></ul></li></ul><h3 id="11-1-2-如何深入了解一个开源项目"><a href="#11-1-2-如何深入了解一个开源项目" class="headerlink" title="11.1.2 如何深入了解一个开源项目"></a>11.1.2 如何深入了解一个开源项目</h3><ul><li>通读开源项目的设计文档，白皮书，了解其设计原理</li><li>核对每个配置项的作用和影响，识别出关键配置项</li><li>进行多种场景的性能测试</li><li>进行压力测试，观察CPU、内存、磁盘I/O等关键指标</li><li>进行故障测试</li></ul><h3 id="11-1-3-如何基于开源项目做二次开发"><a href="#11-1-3-如何基于开源项目做二次开发" class="headerlink" title="11.1.3 如何基于开源项目做二次开发"></a>11.1.3 如何基于开源项目做二次开发</h3><ul><li>不改动原系统，因为还要要能够合并，与原来的能够兼容就再好不过了</li><li>开发辅助系统<ul><li>监控</li><li>报警</li><li>负载均衡</li><li>管理</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-技术演进的动力-企业发展&quot;&gt;&lt;a href=&quot;#1-技术演进的动力-企业发展&quot; class=&quot;headerlink&quot; title=&quot;1. 技术演进的动力 - 企业发展&quot;&gt;&lt;/a&gt;1. 技术演进的动力 - 企业发展&lt;/h1&gt;&lt;h2 id=&quot;1-1-业务和技术之间
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="架构" scheme="https://www.llchen60.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>架构学习-复杂度来源</title>
    <link href="https://www.llchen60.com/%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0-%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%9D%A5%E6%BA%90/"/>
    <id>https://www.llchen60.com/%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0-%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%9D%A5%E6%BA%90/</id>
    <published>2020-02-04T04:09:13.000Z</published>
    <updated>2020-02-04T04:09:32.574Z</updated>
    
    <content type="html"><![CDATA[<p>架构设计的主要目的是为了解决软件系统复杂度带来的问题，那么复杂度的来源到底在哪里呢？ </p><h1 id="1-高性能"><a href="#1-高性能" class="headerlink" title="1. 高性能"></a>1. 高性能</h1><h2 id="1-1-单机复杂度"><a href="#1-1-单机复杂度" class="headerlink" title="1.1 单机复杂度"></a>1.1 单机复杂度</h2><p>操作系统 - 是将硬件性能充分发挥出来的关键。</p><ul><li>最初是只有输入计算以及输出功能</li><li>批处理 - 将要执行的指令预先写下来，形成一个指令清单，然后将任务交给计算机执行，读取任务中的指令清单并进行处理</li><li>进程 - 进程对应任务，都有自己的内存空间，进程间互不相关</li><li>进程间的通信<ul><li>管道</li><li>消息队列</li><li>信号量</li><li>共享存储</li></ul></li><li>线程<ul><li>进程内部的子任务，都共享同一份进程数据。为保证数据的正确性，有了互斥锁机制。有了多线程以后，操作系统调度的最小单位就变成了线程，而进程变成了操作系统分配资源的最小单位。</li></ul></li><li>多个CPU真正同时执行计算任务<ul><li>SMP symmetric multi processor </li><li>NUMA  Non uniform memory access </li><li>MPP  Massive Parallel Processing </li></ul></li></ul><h2 id="1-2-集群复杂度"><a href="#1-2-集群复杂度" class="headerlink" title="1.2 集群复杂度"></a>1.2 集群复杂度</h2><p>突然发现双十一峰值，支付宝能到每秒12万笔；红包能达到76万。通过大量机器来提升性能，并不仅仅是增加机器这么简单，让多台机器来配合达到高性能的目的，是一个复杂的任务，复杂在于：</p><ul><li>任务分配<ul><li>任务分配器<ul><li>硬件网络设备 交换机</li><li>软件网络设备  LVS</li><li>负载均衡软件  Nginix  HAProxy</li><li>分配算法<ul><li>轮询</li><li>按权重分配</li><li>按负载分配</li></ul></li></ul></li><li>任务分配器和业务服务器的连接<ul><li>选择合适的连接方式</li><li>管理连接<ul><li>连接建立，检测，中断后的处理 </li></ul></li></ul></li><li>继续拓展 -&gt; 任务分配器也要变成多台了<ul><li>此时需要将不同的用户分配到不同的任务分配器上<ul><li>DNS轮询，CDN， GSLB(Global Server Load Balance)</li></ul></li><li>任务分配器和业务服务器，多对多的网状结构</li></ul></li></ul></li><li>任务分解<ul><li>任务分配到不同的机器上带来的帮助会递减的，因为当业务越来越复杂，单台机器的性能不够用了，所以就需要进行任务分解来做优化</li><li>可以从逻辑上将各个子业务进行拆分，将一整个业务系统拆分成小而简单，但是需要多个系统配合的业务系统</li><li>为什么能提升性能？ 代码还是那些代码哇？<ul><li>简单的系统更容易分析出瓶颈，更容易做到高性能</li><li>可以针对单个任务进行拓展</li><li>当然不能划分的太细，因为网络的调用性能远比系统内的函数调用要低</li></ul></li></ul></li></ul><h1 id="2-高可用"><a href="#2-高可用" class="headerlink" title="2. 高可用"></a>2. 高可用</h1><blockquote><p>系统无中断地执行其功能的能力，代表系统的可用性程度</p></blockquote><blockquote><p>通过冗余来实现高可用，与高性能的区别在于，高性能增加机器的目的在于扩展处理性能；高可用增加机器的目的在于冗余处理单元</p></blockquote><h2 id="2-1-计算高可用"><a href="#2-1-计算高可用" class="headerlink" title="2.1 计算高可用"></a>2.1 计算高可用</h2><p>多台服务器时主备的选择，具体采用什么方式，主备分别的个数，结合实际业务需求来分析和判断。</p><h2 id="2-2-存储高可用"><a href="#2-2-存储高可用" class="headerlink" title="2.2 存储高可用"></a>2.2 存储高可用</h2><p>高可用设计的关键点就在于存储高可用了，区别在于将数据从一台机器搬到另一台机器，需要经过线路进行传输</p><p>无论是正常情况下的传输延迟，还是异常情况下的传输中断，都会导致系统的数据在某个时间点或者时间段是不一致的，而数据的不一致又会导致业务问题；存储高可用的难点不在于如何备份数据，而在于如何减少或者规避数据不一致对业务造成的影响。</p><p>分布式领域的CAP定理，存储高可用性不可能同时满足一致性，可用性，分区容错性，最多满足其中两个，这就要求我们在做架构设计的时候结合业务进行取舍。</p><h2 id="2-3-高可用状态决策"><a href="#2-3-高可用状态决策" class="headerlink" title="2.3 高可用状态决策"></a>2.3 高可用状态决策</h2><p>无论是计算高可用还是存储高可用，其基础都是状态决策，即系统需要能够判断当前的状态是正常还是异常的，如果出现异常就要采取行动来保证高可用。但一个矛盾点在于： </p><p><strong>通过冗余实现的高可用，状态决策本质上就不可能做到完全正确</strong></p><p>常见的决策方式：</p><ul><li>独裁式<ul><li>只有一个决策者</li><li>n个上报者</li><li>不会出现决策混乱，但是决策者本身故障的时候，系统就崩了</li></ul></li><li>协商式<ul><li>两个独立的个体通过交流信息，根据规则进行决策</li><li>主备决策</li><li>2台服务器启动时都是备机</li><li>建立连接</li><li>交换状态信息</li><li>某1台服务器做出决策，成为主机；另一台继续保持备机身份</li><li>协商式 当连接出问题的时候，采用哪个？ 两主？ 多连接？ 仍然存在问题的</li></ul></li><li>民主式<ul><li>多个独立个体通过投票的方式进行状态决策</li><li>ZooKeeper集群在选举leader时就采用这种方式</li><li>对于连接断开，可能出现多个leader的问题的解决<ul><li>投票节点数必须超过系统总结点数的一半的规则 </li></ul></li></ul></li></ul><h1 id="3-可拓展性"><a href="#3-可拓展性" class="headerlink" title="3. 可拓展性"></a>3. 可拓展性</h1><ul><li>可拓展性指系统为了应对将来的需求变化而提供的一种扩展能力，当有新的需求出现的时候，系统不需要或者仅仅需要少量修改就可以支持，无须整个系统的重构或者重建。</li><li>面向对象的思想以及设计模式的诞生与演化，都是在努力提升代码的可拓展性</li><li>设计具备良好可拓展性的系统的基本条件<ul><li>正确预测变化<ul><li>不能每个点都考虑可拓展性</li><li>不能完全不考虑可拓展性</li><li>所有的预测都存在出错的可能性</li></ul></li><li>完美封装变化<ul><li>一般来说会将变化封装在一个变化层，将不变的部分封装在一个独立的稳定层</li><li>或者提炼出一个抽象层和一个实现层</li></ul></li></ul></li></ul><h1 id="4-低成本，安全，规模"><a href="#4-低成本，安全，规模" class="headerlink" title="4. 低成本，安全，规模"></a>4. 低成本，安全，规模</h1><ul><li>低成本<ul><li>通过减少服务器的数量来达成低成本的目标</li><li>首先指定一个成本目标，当我们根据高性能、高可用的要求设计出方案时，评估一下方案能否满足成本目标，如果不行，就要重新设计架构</li><li>通过引入新技术来达到目标<ul><li>NoSQL 解决关系型数据库无法应对高并发情况下的访问压力的问题</li><li>全文搜索引擎是为了解决关系型数据库like搜索的低效的问题</li><li>Hadoop的出现是为了解决传统文件体统无法应对海量数据存储和计算的问题</li></ul></li></ul></li><li>安全<ul><li>功能安全<ul><li>XSS攻击</li><li>CSRF攻击</li><li>SQL注入</li><li>Windows漏洞</li><li>密码破解</li></ul></li><li>架构安全<ul><li>防火墙<ul><li>隔离网络</li><li>通过将网络划分成不同的区域，制定出不同区域之间的访问控制策略来控制不同信任程度区域间传送的数据流</li><li>太贵，很难实现</li></ul></li><li>一般还是靠运营商或者云服务商强大的带宽和流量清洗能力</li></ul></li></ul></li><li>规模<ul><li>规模带来的复杂度 - 量变带来的质变</li><li>功能越来越多，复杂度指数级增加</li><li>数据越来越多</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;架构设计的主要目的是为了解决软件系统复杂度带来的问题，那么复杂度的来源到底在哪里呢？ &lt;/p&gt;
&lt;h1 id=&quot;1-高性能&quot;&gt;&lt;a href=&quot;#1-高性能&quot; class=&quot;headerlink&quot; title=&quot;1. 高性能&quot;&gt;&lt;/a&gt;1. 高性能&lt;/h1&gt;&lt;h2 id=&quot;
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="架构" scheme="https://www.llchen60.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>架构学习-可扩展架构模式</title>
    <link href="https://www.llchen60.com/%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0-%E5%8F%AF%E6%89%A9%E5%B1%95%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.llchen60.com/%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0-%E5%8F%AF%E6%89%A9%E5%B1%95%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-02-04T04:05:31.000Z</published>
    <updated>2020-02-04T04:06:41.922Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-可扩展架构的基本思想和模式"><a href="#1-可扩展架构的基本思想和模式" class="headerlink" title="1. 可扩展架构的基本思想和模式"></a>1. 可扩展架构的基本思想和模式</h1><p>软件系统与硬件/建筑系统最大的差异在于软件是可扩展的，会不断更新，不断发展。如何避免扩展时改动范围太大，是软件架构可扩展性设计的主要思考点。</p><h2 id="1-1-基本思想-拆分"><a href="#1-1-基本思想-拆分" class="headerlink" title="1.1 基本思想 - 拆分"></a>1.1 基本思想 - 拆分</h2><p>将大系统细分为小系统，扩展时只是修改其中一部分即可，无须整个系统到处都改，通过这种方式来减少改动范围，降低改动风险。</p><p>不同的拆分方式，本质上决定了系统的扩展方式</p><h3 id="1-1-1-面向流程拆分-分层架构"><a href="#1-1-1-面向流程拆分-分层架构" class="headerlink" title="1.1.1 面向流程拆分 - 分层架构"></a>1.1.1 面向流程拆分 - 分层架构</h3><p>将整个业务流程分为几个阶段，每个阶段作为一部分</p><p>扩展时大部分情况只需要修改一层，或者相关联的两层，不会出现所有层都需要修改的情况的。</p><h3 id="1-1-2-面向服务拆分-SOA，微服务"><a href="#1-1-2-面向服务拆分-SOA，微服务" class="headerlink" title="1.1.2 面向服务拆分 - SOA，微服务"></a>1.1.2 面向服务拆分 - SOA，微服务</h3><p>将系统提供的服务拆分，每个服务作为一部分</p><p>扩展时只需要扩展相关服务即可。</p><h3 id="1-1-3-面向功能拆分-微内核架构"><a href="#1-1-3-面向功能拆分-微内核架构" class="headerlink" title="1.1.3 面向功能拆分 - 微内核架构"></a>1.1.3 面向功能拆分 - 微内核架构</h3><p>将系统提供的功能拆分，每个功能作为一部分</p><p>扩展时只需要扩展相关功能即可</p><h1 id="2-分层架构"><a href="#2-分层架构" class="headerlink" title="2. 分层架构"></a>2. 分层架构</h1><p>N层架构，逻辑上的分层</p><h2 id="2-1-C-S-B-S架构"><a href="#2-1-C-S-B-S架构" class="headerlink" title="2.1 C/S, B/S架构"></a>2.1 C/S, B/S架构</h2><p>划分的对象是整个业务系统，划分的维度是用户交互，将和用户交互的部分独立为一层，支撑用户交互的后台作为另外一层。 </p><h2 id="2-2-MVC-MVP架构"><a href="#2-2-MVC-MVP架构" class="headerlink" title="2.2 MVC, MVP架构"></a>2.2 MVC, MVP架构</h2><p>划分的对象是单个业务子系统，划分的维度是职责，将不同的职责划分到独立层，但各层的依赖关系会相对比较灵活。</p><h2 id="2-3-逻辑分层架构"><a href="#2-3-逻辑分层架构" class="headerlink" title="2.3 逻辑分层架构"></a>2.3 逻辑分层架构</h2><p>划分的对象可以是单个业务子系统，也可以是整个业务系统，划分的维度也是职责。虽然都是基于职责划分，但是不同点在于逻辑分层架构中的层是自顶向下依赖的。</p><h2 id="2-4-分层架构的核心"><a href="#2-4-分层架构的核心" class="headerlink" title="2.4 分层架构的核心"></a>2.4 分层架构的核心</h2><p>保证各层之间的差异足够清晰，边界足够明显，让人看到架构图之后就能看懂整个架构。</p><p>分层架构能够较好支撑系统扩展的本质在于<strong>隔离关注点</strong>，即每层的组件只会处理本层的逻辑，这样可以支撑系统在某层上快速扩展。</p><p>要保证层与层之间的依赖是稳定的。</p><p>分层结构的另外一个特点是层层传递，即一旦分层确定，整个业务流程就会按照层进行依次传递，不能在层之间进行跳跃。</p><h1 id="3-SOA-amp-微服务"><a href="#3-SOA-amp-微服务" class="headerlink" title="3. SOA &amp; 微服务"></a>3. SOA &amp; 微服务</h1><h2 id="3-1-SOA-Service-Oriented-Architecture-面向服务的架构"><a href="#3-1-SOA-Service-Oriented-Architecture-面向服务的架构" class="headerlink" title="3.1 SOA - Service Oriented Architecture - 面向服务的架构"></a>3.1 SOA - Service Oriented Architecture - 面向服务的架构</h2><p>提出的背景是企业内部的IT系统重复建设并且效率极低的问题，SOA提出了几个关键概念</p><h3 id="3-1-1-服务"><a href="#3-1-1-服务" class="headerlink" title="3.1.1 服务"></a>3.1.1 服务</h3><p>所有业务功能都是一项服务，意味着要对外提供开放的能力，当其他系统需要使用这项功能时，不需要做定制化开发。</p><h3 id="3-1-2-ESB"><a href="#3-1-2-ESB" class="headerlink" title="3.1.2 ESB"></a>3.1.2 ESB</h3><p>Enterprise Service Bus - 企业服务总线. 屏蔽异构系统对外提供各种不同的接口方式，以此达到服务间高效的互联互通。</p><p>ESB功能强大，但是现实中的协议种类很多，如JMS，WS，HTTP，RPC等，数据格式也多种多样，转换的过程是需要耗费大量计算性能的，当ESB承载的消息太多时，ESB本身会成为整个系统的性能瓶颈。</p><h3 id="3-1-3-松耦合"><a href="#3-1-3-松耦合" class="headerlink" title="3.1.3 松耦合"></a>3.1.3 松耦合</h3><p>减少各个服务间的依赖和互相影响。</p><h2 id="3-2-MicroService-微服务"><a href="#3-2-MicroService-微服务" class="headerlink" title="3.2 MicroService - 微服务"></a>3.2 MicroService - 微服务</h2><h3 id="3-2-1-微服务与SOA的关系"><a href="#3-2-1-微服务与SOA的关系" class="headerlink" title="3.2.1 微服务与SOA的关系"></a>3.2.1 微服务与SOA的关系</h3><p><img src="https://i.loli.net/2020/02/04/VgmIHRSsCUL2b6u.png" alt="fig1.png"></p><ul><li>微服务与SOA相似但是本质上并不相同<ul><li>是否有ESB<ul><li>微服务推荐使用同一的协议和格式<ul><li>例如RESTful协议， RPC协议 </li></ul></li></ul></li><li>服务的粒度<ul><li>微服务的服务粒度相对较细 </li></ul></li><li>服务交付<ul><li>微服务架构理念是快速交付，相应的就要求采取自动化测试，持续集成，自动化部署等敏捷开发相关的最佳实践。 </li></ul></li><li>应用场景<ul><li>SOA更适合于庞大、复杂、异构的企业化系统</li><li>微服务更适合于快速，轻量级，基于Web的互联网系统</li></ul></li></ul></li></ul><h3 id="3-2-2-微服务的陷阱"><a href="#3-2-2-微服务的陷阱" class="headerlink" title="3.2.2 微服务的陷阱"></a>3.2.2 微服务的陷阱</h3><ul><li>服务划分过细，服务间关系复杂</li><li>服务数量太多，团队效率急剧下降</li><li>调用链太长，性能下降<ul><li>一般线上的业务接口之间的调用，平均响应时间大约为50毫秒</li></ul></li><li>调用链太长，问题定位困难</li><li>需要自动化的支撑以实现快速交付</li></ul><h1 id="4-微服务架构最佳实践"><a href="#4-微服务架构最佳实践" class="headerlink" title="4. 微服务架构最佳实践"></a>4. 微服务架构最佳实践</h1><h2 id="4-1-方法论"><a href="#4-1-方法论" class="headerlink" title="4.1 方法论"></a>4.1 方法论</h2><h3 id="4-1-1-人员分配"><a href="#4-1-1-人员分配" class="headerlink" title="4.1.1 人员分配"></a>4.1.1 人员分配</h3><ul><li>3个人负责一个微服务</li></ul><h3 id="4-1-2-拆分逻辑的方法"><a href="#4-1-2-拆分逻辑的方法" class="headerlink" title="4.1.2 拆分逻辑的方法"></a>4.1.2 拆分逻辑的方法</h3><ul><li>基于业务逻辑拆分<ul><li>将业务模块按照职责范围识别出来，每个单独的业务模块拆分为一个独立的服务</li><li>拆分粒度的考虑 - 看人数最好 </li></ul></li><li>基于可扩展拆分<ul><li>将系统中的业务模块按照稳定性排序<ul><li>稳定服务</li><li>变动服务</li></ul></li><li>这样做的目的是为了提升项目快速迭代的效率，避免在开发的时候，不小心影响了已有的成熟功能导致线上的问题。</li></ul></li><li>基于可靠性拆分<ul><li>将业务模块按照优先级顺序排序，将可靠性要求高的核心服务和可靠性要求低的非核心服务拆分，然后重点保证核心服务的高可用</li></ul></li><li>基于性能拆分<ul><li>将性能要求高或者性能压力大的模块拆分出来，避免影响其他服务器<h2 id="4-2-基础设施"><a href="#4-2-基础设施" class="headerlink" title="4.2 基础设施"></a>4.2 基础设施</h2></li></ul></li></ul><p><img src="https://i.loli.net/2020/02/04/wVulTOvkeKRjpH4.jpg" alt="fig2.jpg"></p><ul><li>服务发现、服务路由、服务容错</li><li>接口框架、API网关</li><li>自动化部署、自动化测试、配置中心</li><li>服务监控、服务跟踪、服务安全</li></ul><h3 id="4-2-1-自动化测试"><a href="#4-2-1-自动化测试" class="headerlink" title="4.2.1 自动化测试"></a>4.2.1 自动化测试</h3><ul><li>代码级的单元测试</li><li>单个系统级的集成测试</li><li>系统间的接口测试</li></ul><h3 id="4-2-2-自动化部署"><a href="#4-2-2-自动化部署" class="headerlink" title="4.2.2 自动化部署"></a>4.2.2 自动化部署</h3><ul><li>版本管理</li><li>资源管理</li><li>部署操作</li><li>回退操作</li></ul><h3 id="4-2-3-配置中心"><a href="#4-2-3-配置中心" class="headerlink" title="4.2.3 配置中心"></a>4.2.3 配置中心</h3><ul><li>统一的配置中心来管理所有微服务节点的配置</li><li>配置中心包括<ul><li>版本管理</li><li>增删改查配置</li><li>结点管理</li><li>配置同步</li><li>配置推送</li></ul></li></ul><h3 id="4-2-4-接口框架"><a href="#4-2-4-接口框架" class="headerlink" title="4.2.4 接口框架"></a>4.2.4 接口框架</h3><p>除了统一接口协议，还要统一接口传递的数据格式</p><h3 id="4-2-5-API网关"><a href="#4-2-5-API网关" class="headerlink" title="4.2.5 API网关"></a>4.2.5 API网关</h3><p>内部微服务是相互连通的，相互访问都是点对点的。如果外部系统想调用系统的某个功能，也采取点对点的方式，那么外部系统会很崩，因为其无法理解这么多微服务的职责分工和边界，它只会关注其所需要的能力，而不会关注这个能力应该由哪个微服务提供。</p><p>====》 微服务需要一个统一的API网关，负责外部系统的访问操作</p><p>API网关是外部系统访问的接口，所有的外部系统接入系统都需要通过API网关，主要包括：</p><ul><li>接入鉴权 - 是否允许接入</li><li>权限控制 - 可以访问哪些功能</li><li>传输加密 </li><li>请求路由</li><li>流量控制</li></ul><h3 id="4-2-6-服务发现"><a href="#4-2-6-服务发现" class="headerlink" title="4.2.6 服务发现"></a>4.2.6 服务发现</h3><ul><li>自理式结构<ul><li>每个微服务自己完成服务发现</li></ul></li><li>代理式<ul><li>微服务之间有一个负载均衡系统，有负载均衡系统来完成微服务之间的服务发现 </li></ul></li></ul><p><img src="https://i.loli.net/2020/02/04/PWs5h1L2EFHizZn.png" alt="fig3.png"></p><p><img src="https://i.loli.net/2020/02/04/hmHp54yirJAWPgQ.png" alt="fig4.png"></p><h3 id="4-2-7-服务容错"><a href="#4-2-7-服务容错" class="headerlink" title="4.2.7 服务容错"></a>4.2.7 服务容错</h3><ul><li>请求重试</li><li>流量控制</li><li>服务隔离</li></ul><h3 id="4-2-8-服务监控"><a href="#4-2-8-服务监控" class="headerlink" title="4.2.8 服务监控"></a>4.2.8 服务监控</h3><ul><li>实时搜集信息并进行分析，避免故障后再来分析，减少了处理时间</li><li>在实时分析的基础上进行预警，在问题萌芽的阶段发觉并预警，降低问题的影响范围和影响时间</li></ul><h3 id="4-2-9-服务跟踪"><a href="#4-2-9-服务跟踪" class="headerlink" title="4.2.9 服务跟踪"></a>4.2.9 服务跟踪</h3><p>对于单个请求的完整跟踪，记录单个请求的发起时间，响应时间，响应错误码，请求参数，返回的JSON对象等信息。</p><h3 id="4-2-10-服务安全"><a href="#4-2-10-服务安全" class="headerlink" title="4.2.10 服务安全"></a>4.2.10 服务安全</h3><ul><li>接入安全</li><li>数据安全</li><li>传输安全</li></ul><h1 id="5-微内核架构"><a href="#5-微内核架构" class="headerlink" title="5. 微内核架构"></a>5. 微内核架构</h1><p>也被称为插件化架构(Plug-in Architecture), 是一种面向功能进行拆分的可扩展性架构。</p><h2 id="5-1-基本架构"><a href="#5-1-基本架构" class="headerlink" title="5.1 基本架构"></a>5.1 基本架构</h2><ul><li>核心系统<ul><li>负责和具体业务功能无关的通用功能，例如模块加载，模块间通信 </li></ul></li><li>插件模块<ul><li>负责实现具体的业务逻辑</li></ul></li></ul><p><img src="https://i.loli.net/2020/02/04/kz3Wg4ehDEc2xqv.png" alt="fig5.png"></p><p>微内核架构本质就是将变化的部分封装在插件里面，从而达到快速灵活扩展的目的，而又不会影响整体系统的稳定。</p><h2 id="5-2-设计关键点"><a href="#5-2-设计关键点" class="headerlink" title="5.2 设计关键点"></a>5.2 设计关键点</h2><h3 id="5-2-1-插件管理"><a href="#5-2-1-插件管理" class="headerlink" title="5.2.1 插件管理"></a>5.2.1 插件管理</h3><p>通过插件注册表，来知道当前有哪些插件，如何加载以及何时加载。插件注册表含有每个插件模块的信息，包括其名字，位置，加载时机等。</p><h3 id="5-2-2-插件连接"><a href="#5-2-2-插件连接" class="headerlink" title="5.2.2 插件连接"></a>5.2.2 插件连接</h3><p>插件是如何连接到核心系统的。</p><p>常见连接机制：</p><ul><li>OSGi </li><li>消息模式</li><li>依赖注入</li><li>分布式协议  RPC， HTTP</li></ul><h3 id="5-2-3-插件通信"><a href="#5-2-3-插件通信" class="headerlink" title="5.2.3 插件通信"></a>5.2.3 插件通信</h3><p>实际应用当中会出现某个业务流程需要多个插件协作，这就要求两个插件之间进行通信。由于插件之间没有直接的联系，通信必须通过核心系统，因此核心系统需要提供插件通信机制。</p><h2 id="5-3-OSGi框架"><a href="#5-3-OSGi框架" class="headerlink" title="5.3 OSGi框架"></a>5.3 OSGi框架</h2><p><img src="https://i.loli.net/2020/02/04/QBtP6Gqxea5bV1Z.png" alt="fig6.png"></p><p>该框架为通过网络向设备提供服务建立开发的标准。该框架的初始目标是构建一个在广域网和局域网或设备上展开业务的基础平台，但因为其的动态化，热拔插，高可复用性的特点，成为了首选的插件化标准。</p><h3 id="5-3-1-模块层-Module"><a href="#5-3-1-模块层-Module" class="headerlink" title="5.3.1 模块层 (Module)"></a>5.3.1 模块层 (Module)</h3><p>模块层实现插件管理功能，插件被称为Bundle，每个Bundle是一个Java的JAR文件。模块层里含有所有的插件。</p><h3 id="5-3-2-生命周期层-Lifecycle"><a href="#5-3-2-生命周期层-Lifecycle" class="headerlink" title="5.3.2 生命周期层 (Lifecycle)"></a>5.3.2 生命周期层 (Lifecycle)</h3><p>实现插件连接功能，提供了执行时的模块管理，模块对底层OSGi框架的访问。生命周期层精确定义了Bundle生命周期的操作(安装、更新、启动、停止、卸载)，Bundle必须按照规范实现各个操作。</p><h3 id="5-3-3-服务层-Service"><a href="#5-3-3-服务层-Service" class="headerlink" title="5.3.3 服务层 (Service)"></a>5.3.3 服务层 (Service)</h3><p>服务层实现插件通信的功能。OSGi提供了一个服务注册的功能，用于插件将自己能提供的服务注册到OSGi核心的服务注册中心当中，如果某个服务想用其他服务，则直接在服务注册中心搜索可用服务中心即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-可扩展架构的基本思想和模式&quot;&gt;&lt;a href=&quot;#1-可扩展架构的基本思想和模式&quot; class=&quot;headerlink&quot; title=&quot;1. 可扩展架构的基本思想和模式&quot;&gt;&lt;/a&gt;1. 可扩展架构的基本思想和模式&lt;/h1&gt;&lt;p&gt;软件系统与硬件/建筑系统最大的差
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="架构" scheme="https://www.llchen60.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>架构学习-原则</title>
    <link href="https://www.llchen60.com/%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0-%E5%8E%9F%E5%88%99/"/>
    <id>https://www.llchen60.com/%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0-%E5%8E%9F%E5%88%99/</id>
    <published>2020-02-04T04:04:42.000Z</published>
    <updated>2020-02-04T04:05:03.347Z</updated>
    
    <content type="html"><![CDATA[<p>程序员和架构师之间的区别：如何处理不确定性的。对于程序员来说，编程本身不能存在不确定性，执行结果需要是确定的。但是对于架构设计来说，本质上是不确定的，同样的一个系统，可能AB两家公司做出的架构差异很大，但是都能正确运转。<strong>架构设计常常面对多种可能性来进行选择</strong>。</p><p>太多的选择，需要一些框架来更好的做出决定。</p><h1 id="1-合适原则-合适优于业界领先"><a href="#1-合适原则-合适优于业界领先" class="headerlink" title="1. 合适原则 - 合适优于业界领先"></a>1. 合适原则 - 合适优于业界领先</h1><p>需不需要？有没有那么多人力？有没有足够的应用场景？ </p><h1 id="2-简单原则"><a href="#2-简单原则" class="headerlink" title="2. 简单原则"></a>2. 简单原则</h1><p>简单优于复杂的，复杂在软件工程领域“可能”意味着问题。因为我们需要持续在上面改进的。</p><ul><li>复杂性体现在<ul><li>结构的复杂性<ul><li>组件数量多</li><li>组件之间的关系更为复杂</li><li>某个组件的改动，会影响关联的所有组件</li><li>定位一个复杂系统当中的问题总是比简单系统的更加困难</li></ul></li><li>逻辑的复杂性<ul><li>一个组件承担太多功能会对开发维护都造成很大的困扰</li><li></li></ul></li></ul></li></ul><h1 id="3-演化原则"><a href="#3-演化原则" class="headerlink" title="3. 演化原则"></a>3. 演化原则</h1><p>演化优于一步到位，因为软件的更新，架构的变化非常快。软件的架构需要根据业务的发展不断变化。</p><ul><li>设计出来的架构要满足当时的业务需要</li><li>架构要不断地在实际应用过程当中迭代，保留优秀的设计，修复有缺陷的设计，逐渐完善架构</li><li>当业务发生变化的时候，架构要扩展，重构甚至重写</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;程序员和架构师之间的区别：如何处理不确定性的。对于程序员来说，编程本身不能存在不确定性，执行结果需要是确定的。但是对于架构设计来说，本质上是不确定的，同样的一个系统，可能AB两家公司做出的架构差异很大，但是都能正确运转。&lt;strong&gt;架构设计常常面对多种可能性来进行选择&lt;
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="架构" scheme="https://www.llchen60.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>架构学习-general</title>
    <link href="https://www.llchen60.com/%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0-general/"/>
    <id>https://www.llchen60.com/%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0-general/</id>
    <published>2020-02-04T03:58:33.000Z</published>
    <updated>2020-02-04T03:59:05.578Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-架构Intro"><a href="#1-架构Intro" class="headerlink" title="1. 架构Intro"></a>1. 架构Intro</h1><ul><li>架构设计的关键思维是<strong>判断和取舍</strong>，程序设计的关键思维是<strong>逻辑和实现</strong>。</li></ul><h2 id="1-1-架构世界的历史背景"><a href="#1-1-架构世界的历史背景" class="headerlink" title="1.1 架构世界的历史背景"></a>1.1 架构世界的历史背景</h2><ul><li>机器语言 <ul><li>01书写</li><li>难读，难写，难改</li></ul></li><li>汇编语言<ul><li>用地址符号或标号代替指令或操作数的地址</li><li>面向机器的语言，不够友好</li></ul></li><li>高级语言<ul><li>Fortran 公式翻译器</li><li>LISP 枚举处理器</li><li>Cobol 通用商业导向语言</li></ul></li></ul><h1 id="2-概念梳理"><a href="#2-概念梳理" class="headerlink" title="2. 概念梳理"></a>2. 概念梳理</h1><h2 id="2-1-系统与子系统"><a href="#2-1-系统与子系统" class="headerlink" title="2.1 系统与子系统"></a>2.1 系统与子系统</h2><blockquote><p>系统泛指由一群有关联的个体组成，根据某种规则运作，能完成个别元件不能单独完成的工作的群体</p></blockquote><ul><li>系统<ul><li>关联：相互之间有关联</li><li>规则：按照指定的规则运作</li><li>能力：产生了新的个体不具备的能力</li></ul></li><li>子系统<ul><li>更大系统的一部分</li></ul></li></ul><p>划分系统的时候一般是按照业务系统来划分的，可能一个子系统里面会有服务层，数据层，blabla. </p><h2 id="2-2-模块与组件"><a href="#2-2-模块与组件" class="headerlink" title="2.2 模块与组件"></a>2.2 模块与组件</h2><ul><li><p>模块</p><ul><li>互相有紧密关联的软件组织</li><li>程序和数据结构两部分</li><li>模块作为合成的单位</li><li>模块的接口表达了由该模块提供的功能和调用它所需的元素</li><li>模块是可以分开来编写的单位</li></ul></li><li><p>组件</p><ul><li>自包含的，可编程的，可重用的与语言无关的软件单元</li></ul></li><li><p>Summary</p><ul><li>模块和组件都是系统的组成部分，只是从不同角度来拆分了系统</li><li>逻辑角度拆分系统，得到的就是模块；划分模块的主要目的是职责分离</li><li>划分组件的主要目的是单元复用</li></ul></li><li><p>E.G</p><ul><li>一个信息管理系统，逻辑角度，可以划分成登录注册模块，个人信息模块，个人成绩模块</li><li>物理角度，Nginx，Web服务器，Mysql</li></ul></li></ul><h2 id="2-3-框架与架构"><a href="#2-3-框架与架构" class="headerlink" title="2.3 框架与架构"></a>2.3 框架与架构</h2><ul><li>框架<ul><li>为了实现某个业界标准或完成特定的基本任务的软件组件规范，也指为了实现某个软件组件规范时，提供规范锁要求的基础功能的软件产品</li><li>框架是组件规范 - MVC MVVM J2EE</li><li>提供基础功能的产品</li><li>面向编程或配置的半成品</li></ul></li></ul><blockquote><p>架构指软件系统的基础结构，创造这些基础结构的准则以及对这些结构的描述</p></blockquote><ul><li>软件架构指软件系统的顶层结构<ul><li>系统是一群关联个体组成，可以使子系统，模块，组件等</li><li>系统中的个体需要根据某种规则运作</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-架构Intro&quot;&gt;&lt;a href=&quot;#1-架构Intro&quot; class=&quot;headerlink&quot; title=&quot;1. 架构Intro&quot;&gt;&lt;/a&gt;1. 架构Intro&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;架构设计的关键思维是&lt;strong&gt;判断和取舍&lt;/strong&gt;，程
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="架构" scheme="https://www.llchen60.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>简单工厂模式</title>
    <link href="https://www.llchen60.com/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.llchen60.com/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-02-04T03:29:53.000Z</published>
    <updated>2020-02-04T03:30:42.723Z</updated>
    
    <content type="html"><![CDATA[<p>静态/简单工厂模式是工厂模式中最简单的一种实现，但是它实现了工厂模式的精髓，即将对象的创建和使用分离开，客户端通过调用工厂来创建具体的产品类。</p><h1 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h1><pre><code>class Chart {    private String type; //图表类型    public Chart(Object[][] data, String type) {        this.type = type;        if (type.equalsIgnoreCase(&quot;histogram&quot;)) {            //初始化柱状图        }        else if (type.equalsIgnoreCase(&quot;pie&quot;)) {            //初始化饼状图        }        else if (type.equalsIgnoreCase(&quot;line&quot;)) {            //初始化折线图        }    }    public void display() {        if (this.type.equalsIgnoreCase(&quot;histogram&quot;)) {            //显示柱状图        }        else if (this.type.equalsIgnoreCase(&quot;pie&quot;)) {            //显示饼状图        }        else if (this.type.equalsIgnoreCase(&quot;line&quot;)) {            //显示折线图        }        }}</code></pre><p>问题：</p><ol><li>冗长</li><li>职责太重</li><li>Constructor构建会非常耗时</li></ol><h1 id="2-简单工程模式概述"><a href="#2-简单工程模式概述" class="headerlink" title="2. 简单工程模式概述"></a>2. 简单工程模式概述</h1><h2 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h2><p>首先将需要创建的各种不同对象（例如各种不同的Chart对象）的相关代码封装到不同的类中，这些类称为具体产品类，而将它们公共的代码进行抽象和提取后封装在一个抽象产品类中，每一个具体产品类都是抽象产品类的子类；然后提供一个工厂类用于创建各种产品，在工厂类中提供一个创建产品的工厂方法，该方法可以根据所传入的参数不同创建不同的具体产品对象；客户端只需调用工厂类的工厂方法并传入相应的参数即可得到一个产品对象。</p><ul><li>具体产品类</li><li>抽象产品类</li><li>工厂类 - 创建产品，工厂方法</li><li>客户端 调用工厂类的工厂方法得到产品对象</li></ul><blockquote><p>简单工厂模式(Simple Factory Pattern)：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建实例的方法是<strong>静态(static)<em>方法</em></strong>，因此简单工厂模式又被称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。</p></blockquote><h2 id="2-2-结构"><a href="#2-2-结构" class="headerlink" title="2.2 结构"></a>2.2 结构</h2><p><img src="https://i.loli.net/2020/02/04/N5tmV9o1EPlgFLr.jpg" alt="sf1.jpeg"></p><ul><li>Factory</li></ul><p>工厂角色即工厂类，它是简单工厂模式的核心，负责实现创建所有产品实例的内部逻辑；工厂类可以被外界直接调用，创建所需的产品对象；在工厂类中提供了静态的工厂方法factoryMethod()，它的返回类型为抽象产品类型Product。</p><ul><li>Product 抽象产品</li></ul><p>它是工厂类所创建的所有对象的父类，封装了各种产品对象的公有方法，它的引入将提高系统的灵活性，使得在工厂类中只需定义一个通用的工厂方法，因为所有创建的具体产品对象都是其子类对象。</p><ul><li>ConcreteProduct 具体产品</li></ul><p>它是简单工厂模式的创建目标，所有被创建的对象都充当这个角色的某个具体类的实例。每一个具体产品角色都继承了抽象产品角色，需要实现在抽象产品中声明的抽象方法。</p><h1 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3 代码实现"></a>3 代码实现</h1><pre><code>abstract class Product {    //所有产品类的公共业务方法    public void methodSame() {        //公共方法的实现    }    //声明抽象业务方法    public abstract void methodDiff();}class ConcreteProduct extends Product {//实现业务方法    public void methodDiff() {    //业务方法的实现    }}class Factory {    //静态工厂方法    public static Product getProduct(String arg) {        Product product = null;        if (arg.equalsIgnoreCase(&quot;A&quot;)) {            product = new ConcreteProductA();            //初始化设置product        }        else if (arg.equalsIgnoreCase(&quot;B&quot;)) {            product = new ConcreteProductB();            //初始化设置product        }        return product;    }}//客户端代码，直接调用工厂类的工厂方法来得到产品对象class Client {    public static void main(String args[]) {        Product product;         product = Factory.getProduct(&quot;A&quot;); //通过工厂类创建产品对象        product.methodSame();        product.methodDiff();    }}</code></pre><h2 id="3-1-结构图"><a href="#3-1-结构图" class="headerlink" title="3.1 结构图"></a>3.1 结构图</h2><p><img src="https://i.loli.net/2020/02/04/FdsgZtQ27rE1NTU.jpg" alt="sf2.jpeg"></p><h2 id="3-2-完整方案"><a href="#3-2-完整方案" class="headerlink" title="3.2 完整方案"></a>3.2 完整方案</h2><pre><code>//抽象图表接口：抽象产品类interface Chart {    public void display();}//柱状图类：具体产品类class HistogramChart implements Chart {    public HistogramChart() {        System.out.println(&quot;创建柱状图！&quot;);    }    public void display() {        System.out.println(&quot;显示柱状图！&quot;);    }}//饼状图类：具体产品类class PieChart implements Chart {    public PieChart() {        System.out.println(&quot;创建饼状图！&quot;);    }    public void display() {        System.out.println(&quot;显示饼状图！&quot;);    }}//折线图类：具体产品类class LineChart implements Chart {    public LineChart() {        System.out.println(&quot;创建折线图！&quot;);    }    public void display() {        System.out.println(&quot;显示折线图！&quot;);    }}//图表工厂类：工厂类class ChartFactory {    //静态工厂方法    public static Chart getChart(String type) {        Chart chart = null;        if (type.equalsIgnoreCase(&quot;histogram&quot;)) {            chart = new HistogramChart();            System.out.println(&quot;初始化设置柱状图！&quot;);        }        else if (type.equalsIgnoreCase(&quot;pie&quot;)) {            chart = new PieChart();            System.out.println(&quot;初始化设置饼状图！&quot;);        }        else if (type.equalsIgnoreCase(&quot;line&quot;)) {            chart = new LineChart();            System.out.println(&quot;初始化设置折线图！&quot;);                    }        return chart;    }}</code></pre><h2 id="3-3-改进"><a href="#3-3-改进" class="headerlink" title="3.3 改进"></a>3.3 改进</h2><p>将选择具体的chart类的代码封装到xml文件里，然后写一个相应的方法去读取XML参数。</p><pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;&lt;config&gt;    &lt;chartType&gt;histogram&lt;/chartType&gt;&lt;/config&gt;</code></pre><p>写一个工具类，来获取XML文件里的参数</p><pre><code>import javax.xml.parsers.*;import org.w3c.dom.*;import org.xml.sax.SAXException;import java.io.*;public class XMLUtil {    //该方法用于从XML配置文件中提取图表类型，并返回类型名    public static String getChartType() {        try {            //创建文档对象            DocumentBuilderFactory dFactory = DocumentBuilderFactory.newInstance();            DocumentBuilder builder = dFactory.newDocumentBuilder();            Document doc;                                        doc = builder.parse(new File(&quot;config.xml&quot;));             //获取包含图表类型的文本节点            NodeList nl = doc.getElementsByTagName(&quot;chartType&quot;);            Node classNode = nl.item(0).getFirstChild();            String chartType = classNode.getNodeValue().trim();            return chartType;        }              catch(Exception e) {               e.printStackTrace();            return null;        }    }}</code></pre><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h1><p><img src="https://i.loli.net/2020/02/04/aSZD7Iv5A1wsN2C.jpg" alt="sf3.jpeg"></p><h2 id="4-1-优势"><a href="#4-1-优势" class="headerlink" title="4.1 优势"></a>4.1 优势</h2><ol><li>将对象的创建和使用分离</li><li>客户端不再直接创建产品对象，仅仅消费产品</li><li>配置文件，提高系统灵活性</li></ol><h2 id="4-2-缺陷"><a href="#4-2-缺陷" class="headerlink" title="4.2 缺陷"></a>4.2 缺陷</h2><ol><li>工厂类集中了所有的创建逻辑，职责太重。一旦不能正常工作，整个系统都要受影响。</li><li>势必增加类的个数，引入新的工厂类，增加了系统的复杂度和理解程度</li><li>系统扩展困难！！！一旦添加新产品就必须修改工厂逻辑</li><li>使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;静态/简单工厂模式是工厂模式中最简单的一种实现，但是它实现了工厂模式的精髓，即将对象的创建和使用分离开，客户端通过调用工厂来创建具体的产品类。&lt;/p&gt;
&lt;h1 id=&quot;1-问题描述&quot;&gt;&lt;a href=&quot;#1-问题描述&quot; class=&quot;headerlink&quot; title=&quot;1
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="Design Pattern" scheme="https://www.llchen60.com/tags/Design-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>抽象工厂模式</title>
    <link href="https://www.llchen60.com/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.llchen60.com/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-02-04T03:27:19.000Z</published>
    <updated>2020-02-04T03:29:24.992Z</updated>
    
    <content type="html"><![CDATA[<p>工厂方法模式通过引入工厂等级结构，解决了简单工厂模式中工厂类职责太重的问题，但是由于工厂方法模式中的每一个工厂只生产一类产品，可能会导致系统中存在大量的工厂类，势必会增加系统的开销。我们可以考虑<strong>将一些相关的产品组成一个产品族，由同一个工厂来统一生产</strong>。</p><h1 id="1-初始设计"><a href="#1-初始设计" class="headerlink" title="1. 初始设计"></a>1. 初始设计</h1><p>  Sunny软件公司欲开发一套界面皮肤库，可以对Java桌面软件进行界面美化。为了保护版权，该皮肤库源代码不打算公开，而只向用户提供已打包为jar文件的class字节码文件。用户在使用时可以通过菜单来选择皮肤，不同的皮肤将提供视觉效果不同的按钮、文本框、组合框等界面元素，<br><img src="https://i.loli.net/2020/02/04/RnYfcDpNqtkuCPj.jpg" alt="fm1.jpg"></p><p>  采用工厂模式进行系统设计的结构图如下：</p><p><img src="https://i.loli.net/2020/02/04/UAnaQOVXW4vZiSY.jpg" alt="fm2.jpg"></p><h2 id="1-1-存在的问题"><a href="#1-1-存在的问题" class="headerlink" title="1.1 存在的问题"></a>1.1 存在的问题</h2><ol><li>当需要增加新的皮肤时，虽然不要修改现有代码，但是需要增加大量类，针对每一个新增具体组件都需要增加一个具体工厂，<strong><em>类的个数成对增加，这无疑会导致系统越来越庞大，增加系统的维护成本和运行开销</em></strong>；</li><li>由于同一种风格的具体界面组件通常要一起显示，因此需要为每个组件都选择一个具体工厂，用户在使用时必须逐个进行设置，如果某个具体工厂选择失误将会导致界面显示混乱，虽然我们可以适当增加一些约束语句，但客户端代码和配置文件都较为复杂。</li></ol><h1 id="2-产品等级结构"><a href="#2-产品等级结构" class="headerlink" title="2. 产品等级结构"></a>2. 产品等级结构</h1><p>在工厂方法模式中具体工厂负责生产具体的产品，每一个<strong><em>具体工厂</em></strong>对应一种具体产品，工厂方法具有唯一性，一般情况下，一个具体工厂中只有一个或者一组重载的工厂方法。<strong><em>但是有时候我们希望一个工厂可以提供多个产品对象，而不是单一的产品对象</em></strong>，如一个电器工厂，它可以生产电视机、电冰箱、空调等多种电器，而不是只生产某一种电器。</p><h2 id="2-1-概念"><a href="#2-1-概念" class="headerlink" title="2.1 概念"></a>2.1 概念</h2><ol><li>产品等级结构</li></ol><p>即产品的继承结构</p><ol start="2"><li>产品族</li></ol><p>指由同一个工厂生产的，位于不同产品等级结构中的一组产品</p><p><img src="https://i.loli.net/2020/02/04/qJn7UsTMcC9tzw3.jpg" alt="fm3.jpg"></p><p><img src="https://i.loli.net/2020/02/04/n8ezWVCKOUSmN7p.jpg" alt="fm4.jpg"></p><p>当系统所提供的工厂生产的具体产品不是一个简单的对象，而是多个位于不同产品等级结构，属于不同类型的具体产品。</p><p>抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形式。抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式需要面对多个产品等级结构，一个工厂等级结构可以负责多个不同产品等级结构中的产品对象的创建。当一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象时，抽象工厂模式比工厂方法模式更为简单、更有效率。</p><h1 id="3-抽象工厂模式概述"><a href="#3-抽象工厂模式概述" class="headerlink" title="3. 抽象工厂模式概述"></a>3. 抽象工厂模式概述</h1><p>为创建一组对象提供了一种解决方案，与工厂方法模式相比，抽象工厂模式中的具体工厂不只是创建一种产品，它负责创建一族产品：</p><blockquote><p>抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，它是一种对象创建型模式。</p></blockquote><p> 在抽象工厂模式中，每一个具体工厂都提供了多个工厂方法用于产生多种不同类型的产品，这些产品构成了一个产品族</p><h2 id="3-1-包含的角色"><a href="#3-1-包含的角色" class="headerlink" title="3.1 包含的角色"></a>3.1 包含的角色</h2><ol><li>Abstract Factory 抽象工厂</li></ol><p>声明了一组用于创建一族产品的方法，每一个方法对应一种产品</p><ol start="2"><li>Concrete Factory 具体工厂</li></ol><p>实现了在抽象工厂中声明的创建产品的方法，生成一组具体的产品，这些产品构成了一个产品族</p><ol start="3"><li>Abstract Product 抽象产品</li></ol><p>为每种产品声明接口，在抽象产品中声明了产品所具有的业务方法</p><ol start="4"><li>Concrete Product 具体产品</li></ol><p>定义具体工厂产生的具体产品对象，实现抽象产品接口中声明的业务方法。</p><h2 id="3-2-具体实现"><a href="#3-2-具体实现" class="headerlink" title="3.2 具体实现"></a>3.2 具体实现</h2><p>在抽象工厂中声明了多个工厂方法，用于创建不同类型的产品，抽象工厂可以是接口，也可以是抽象类或者具体类，</p><pre><code>abstract class AbstractFactory {    public abstract AbstractProductA createProductA(); //工厂方法一    public abstract AbstractProductB createProductB(); //工厂方法二……}</code></pre><p>具体工厂实现了抽象工厂，每一个具体的工厂方法可以返回一个特定的产品对象，而同一个具体工厂所创建的产品对象构成了一个产品族。</p><pre><code>class ConcreteFactory1 extends AbstractFactory {    //工厂方法一    public AbstractProductA createProductA() {        return new ConcreteProductA1();    }    //工厂方法二    public AbstractProductB createProductB() {        return new ConcreteProductB1();    }……}</code></pre><h1 id="4-完整方案"><a href="#4-完整方案" class="headerlink" title="4. 完整方案"></a>4. 完整方案</h1><p><img src="https://i.loli.net/2020/02/04/628fTVDd9QaOrxm.jpg" alt="fm5.jpg"></p><p><img src="https://i.loli.net/2020/02/04/vJZSa3Ddi8olf6g.jpg" alt="fm6.jpg"></p><p>SkinFactory接口充当抽象工厂，其子类SpringSkinFactory和SummerSkinFactory充当具体工厂，接口Button、TextField和ComboBox充当抽象产品，其子类SpringButton、SpringTextField、SpringComboBox和SummerButton、SummerTextField、SummerComboBox充当具体产品。</p><p>//在本实例中我们对代码进行了大量简化，实际使用时，界面组件的初始化代码较为复杂，还需要使用JDK中一些已有类，为了突出核心代码，在此只提供框架代码和演示输出。<br>    //按钮接口：抽象产品<br>    interface Button {<br>        public void display();<br>    }</p><pre><code>//Spring按钮类：具体产品class SpringButton implements Button {    public void display() {        System.out.println(&quot;显示浅绿色按钮。&quot;);    }}//Summer按钮类：具体产品class SummerButton implements Button {    public void display() {        System.out.println(&quot;显示浅蓝色按钮。&quot;);    }    }//文本框接口：抽象产品interface TextField {    public void display();}//Spring文本框类：具体产品class SpringTextField implements TextField {    public void display() {        System.out.println(&quot;显示绿色边框文本框。&quot;);    }}//Summer文本框类：具体产品class SummerTextField implements TextField {    public void display() {        System.out.println(&quot;显示蓝色边框文本框。&quot;);    }    }//组合框接口：抽象产品interface ComboBox {    public void display();}//Spring组合框类：具体产品class SpringComboBox implements ComboBox {    public void display() {        System.out.println(&quot;显示绿色边框组合框。&quot;);    }}//Summer组合框类：具体产品class SummerComboBox implements ComboBox {    public void display() {        System.out.println(&quot;显示蓝色边框组合框。&quot;);    }    }//界面皮肤工厂接口：抽象工厂interface SkinFactory {    public Button createButton();    public TextField createTextField();    public ComboBox createComboBox();}//Spring皮肤工厂：具体工厂class SpringSkinFactory implements SkinFactory {    public Button createButton() {        return new SpringButton();    }    public TextField createTextField() {        return new SpringTextField();    }    public ComboBox createComboBox() {        return new SpringComboBox();    }}//Summer皮肤工厂：具体工厂class SummerSkinFactory implements SkinFactory {    public Button createButton() {        return new SummerButton();    }    public TextField createTextField() {        return new SummerTextField();    }    public ComboBox createComboBox() {        return new SummerComboBox();    }}</code></pre><p>引入工具类和配置文件，增强系统的灵活性和可扩展性</p><pre><code>import javax.xml.parsers.*;import org.w3c.dom.*;import org.xml.sax.SAXException;import java.io.*;public class XMLUtil {//该方法用于从XML配置文件中提取具体类类名，并返回一个实例对象    public static Object getBean() {        try {            //创建文档对象            DocumentBuilderFactory dFactory = DocumentBuilderFactory.newInstance();            DocumentBuilder builder = dFactory.newDocumentBuilder();            Document doc;                                        doc = builder.parse(new File(&quot;config.xml&quot;));             //获取包含类名的文本节点            NodeList nl = doc.getElementsByTagName(&quot;className&quot;);            Node classNode=nl.item(0).getFirstChild();            String cName=classNode.getNodeValue();            //通过类名生成实例对象并将其返回            Class c=Class.forName(cName);              Object obj=c.newInstance();            return obj;        }           catch(Exception e) {               e.printStackTrace();               return null;           }    }}</code></pre><p>配置文件config.xml中存储具体工厂类的类名</p><pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;&lt;config&gt;    &lt;className&gt;SpringSkinFactory&lt;/className&gt;&lt;/config&gt;</code></pre><h1 id="5-开闭原则的倾斜性"><a href="#5-开闭原则的倾斜性" class="headerlink" title="5. 开闭原则的倾斜性"></a>5. 开闭原则的倾斜性</h1><p>Sunny公司使用抽象工厂模式设计了界面皮肤库，该皮肤库可以较为方便地增加新的皮肤，但是现在遇到一个非常严重的问题：由于设计时考虑不全面，忘记为单选按钮(RadioButton)提供不同皮肤的风格化显示，导致无论选择哪种皮肤，单选按钮都显得那么“格格不入”。Sunny公司的设计人员决定向系统中增加单选按钮，但是发现原有系统居然不能够在符合“开闭原则”的前提下增加新的组件，原因是抽象工厂SkinFactory中根本没有提供创建单选按钮的方法，如果需要增加单选按钮，首先需要修改抽象工厂接口SkinFactory，在其中新增声明创建单选按钮的方法，然后逐个修改具体工厂类，增加相应方法以实现在不同的皮肤中创建单选按钮，此外还需要修改客户端，否则单选按钮无法应用于现有系统。</p><p>抽象工厂模式无法解决这个问题。在本模式中，增加新的产品族很方便，但是增加新的产品等级结构很麻烦。</p><ol><li>增加产品族</li></ol><p>对于增加新的产品族，抽象工厂模式很好地支持了“开闭原则”，只需要增加具体产品并对应增加一个新的具体工厂，对已有代码无须做任何修改。</p><ol start="2"><li>增加产品等级结构</li></ol><p>对于增加新的产品族，抽象工厂模式很好地支持了“开闭原则”，只需要增加具体产品并对应增加一个新的具体工厂，对已有代码无须做任何修改。</p><h1 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h1><h2 id="6-1-优势"><a href="#6-1-优势" class="headerlink" title="6.1 优势"></a>6.1 优势</h2><ol><li>隔离了具体类的生成，使得更换具体工厂变得容易。所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需要改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。</li><li>当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。</li></ol><h2 id="6-2-劣势"><a href="#6-2-劣势" class="headerlink" title="6.2 劣势"></a>6.2 劣势</h2><ol><li>增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不便，违背了“开闭原则”。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;工厂方法模式通过引入工厂等级结构，解决了简单工厂模式中工厂类职责太重的问题，但是由于工厂方法模式中的每一个工厂只生产一类产品，可能会导致系统中存在大量的工厂类，势必会增加系统的开销。我们可以考虑&lt;strong&gt;将一些相关的产品组成一个产品族，由同一个工厂来统一生产&lt;/str
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="Design Pattern" scheme="https://www.llchen60.com/tags/Design-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>微信红包高并发架构设计</title>
    <link href="https://www.llchen60.com/%E5%BE%AE%E4%BF%A1%E7%BA%A2%E5%8C%85%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    <id>https://www.llchen60.com/%E5%BE%AE%E4%BF%A1%E7%BA%A2%E5%8C%85%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</id>
    <published>2020-02-04T03:24:04.000Z</published>
    <updated>2020-02-04T03:24:25.902Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-微信红包业务特点以及技术难点"><a href="#1-微信红包业务特点以及技术难点" class="headerlink" title="1. 微信红包业务特点以及技术难点"></a>1. 微信红包业务特点以及技术难点</h1><h2 id="1-1-业务特点"><a href="#1-1-业务特点" class="headerlink" title="1.1 业务特点"></a>1.1 业务特点</h2><p>类似于线上的秒杀，海量的并发请求；更严格的安全级别，因为牵扯到资金交易，所以就不可以有像用秒杀活动当中的那种超卖的方式。</p><h2 id="1-2-流程"><a href="#1-2-流程" class="headerlink" title="1.2 流程"></a>1.2 流程</h2><ul><li><p>proxy</p><ul><li>处理请求接入 </li></ul></li><li><p>server</p><ul><li>主要业务逻辑 </li></ul></li><li><p>DB</p><ul><li>数据持久化 </li><li>事务级别的完成 - 完全执行或者完全不执行<ul><li>锁库存<ul><li>为了避免并发请求时出现超卖情况</li><li>技术难点，当大量用户同时做秒杀操作的时候，第一个到达DB的请求锁住了这行库存记录。在第一个事务完成提交之前这个锁一直被第一个请求占用。——&gt; 技术难点，并发请求抢锁</li></ul></li><li>插入秒杀记录</li><li>更新库存</li></ul></li></ul></li><li><p>Cache </p><ul><li>缓存库存数量 </li></ul></li></ul><h1 id="2-微信红包系统的高并发解决方案"><a href="#2-微信红包系统的高并发解决方案" class="headerlink" title="2. 微信红包系统的高并发解决方案"></a>2. 微信红包系统的高并发解决方案</h1><h2 id="2-1-高并发问题常用方案"><a href="#2-1-高并发问题常用方案" class="headerlink" title="2.1 高并发问题常用方案"></a>2.1 高并发问题常用方案</h2><h3 id="2-1-1-使用内存操作替代实时的DB事务操作"><a href="#2-1-1-使用内存操作替代实时的DB事务操作" class="headerlink" title="2.1.1 使用内存操作替代实时的DB事务操作"></a>2.1.1 使用内存操作替代实时的DB事务操作</h3><p>server 到内存Cache，做扣库存的操作，然后内存Cache异步持久化到数据库。但是如果内存Cache炸了，或者内存Cache更新，但是DDB没有更新，都会很崩。多个服务器之间的同步也会是一个不小的问题。</p><h3 id="2-1-2-使用乐观锁-instead-of-悲观锁"><a href="#2-1-2-使用乐观锁-instead-of-悲观锁" class="headerlink" title="2.1.2 使用乐观锁 instead of 悲观锁"></a>2.1.2 使用乐观锁 instead of 悲观锁</h3><ul><li>乐观锁<ul><li>假设多用户并发的事务处理时不会相互影响。在提交数据更新之前，每个事务会检查在该事务读取数据之后，有没有其他事务又修改了数据。如果其他事务用更新的话，正在提交的事务会进行回滚。</li></ul></li><li>悲观锁<ul><li>阻止一个事务以影响其他用户的方式来修改数据</li></ul></li></ul><p>对于微信红包的使用场景，即需要在DB里维护一个版本号，在更新库存的操作进行之前，先去DB获取当前版本号，然后在更新库存的事务提交的时候，检查是否被修改。</p><p>这么做的问题在于：</p><ul><li>乐观锁，多个用户同时抢红包，那势必只有一个成功，另外的都会显示失败 - 报错，这就用户体验很差劲了</li><li>而且会造成刚开始可能失败，后面因为并发小了，有成功的案例的可能性</li><li>大量无效请求，回滚，给DB带来很大压力</li></ul><h2 id="2-2-微信红包系统的解决方案"><a href="#2-2-微信红包系统的解决方案" class="headerlink" title="2.2 微信红包系统的解决方案"></a>2.2 微信红包系统的解决方案</h2><ul><li>系统垂直SET化<ul><li>生成ID作为红包的唯一标识</li><li>红包系统根据ID做垂直切分，一个垂直逻辑链条上的Server和DB们叫做一个SET</li><li>各个SET相互独立，且解耦，每个红包ID的所有请求都会在同一个SET当中来处理<ul><li>看起来像是需要主备两台服务器，备用服务器平常没有流量，完全用来在主服务器出问题的时候，直接转备用</li></ul></li></ul></li><li>逻辑Server层将请求排队，解决DB并发问题<ul><li>将拆红包的事务操作做串行处理，在Server层做FIFO的排队处理</li></ul></li><li>memcached控制并发<ul><li>利用CAS原子累增操作，控制同时进入DB拆红包的请求数，超过预定值就直接拒绝服务，通过这种方式来做DB负载过高时的降级体验</li></ul></li><li>双维度库存表设计<ul><li>TTL </li><li>冷热数据分离</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-微信红包业务特点以及技术难点&quot;&gt;&lt;a href=&quot;#1-微信红包业务特点以及技术难点&quot; class=&quot;headerlink&quot; title=&quot;1. 微信红包业务特点以及技术难点&quot;&gt;&lt;/a&gt;1. 微信红包业务特点以及技术难点&lt;/h1&gt;&lt;h2 id=&quot;1-1-业务特
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
  </entry>
  
  <entry>
    <title>建造者模式</title>
    <link href="https://www.llchen60.com/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.llchen60.com/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-02-04T03:20:11.000Z</published>
    <updated>2020-02-04T03:21:45.808Z</updated>
    
    <content type="html"><![CDATA[<p>建造者模式，又称为生成器模式，为客户端返回一个由多个部件组成的复杂产品。</p><h1 id="1-建造者模式概述"><a href="#1-建造者模式概述" class="headerlink" title="1. 建造者模式概述"></a>1. 建造者模式概述</h1><p>小例子，设计游戏角色病可以快速生成。对于各种角色来说，创建步骤相对比较类似，逐步创建其组成部分，再将各组成部分装配成一个完整的游戏角色。</p><p>建造者模式将客户端和包含各个组成部分的复杂对象的创建过程分离，客户端无须知道复杂对象的内部组成部分与装配方式，只需要知道所需建造者的类型即可。</p><blockquote><p>建造者模式，将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式是一种对象创建型模式。</p></blockquote><h2 id="1-1-建造者模式结构"><a href="#1-1-建造者模式结构" class="headerlink" title="1.1 建造者模式结构"></a>1.1 建造者模式结构</h2><p><img src="https://i.loli.net/2020/02/04/Tl4oLzhx16i9Uvq.gif" alt="1.gif"><br>建造者模式结构图</p><h2 id="1-2-建造者模式角色"><a href="#1-2-建造者模式角色" class="headerlink" title="1.2 建造者模式角色"></a>1.2 建造者模式角色</h2><ol><li>Builder(抽象建造者)</li></ol><p>为创建一个产品Product对象的各个部件指定抽象接口，包含两类方法。一是buildPart()， 二是getResult()方法</p><ol start="2"><li>ConcreteBuilder(具体建造者)</li></ol><p>实现了Builder接口，实现各个部件的具体构造和装配方法，定义并明确其所创建的复杂对象。</p><ol start="3"><li>Product(产品角色)</li></ol><p>是被构建的复杂对象，包含多个组成部件，具体建造者创建该产品，并定义其装配过程</p><ol start="4"><li>Director(指挥者)</li></ol><p>指挥者又称为导演类，它负责安排<strong>复杂对象的建造次序</strong>，指挥者与抽象建造者之间存在关联关系，可以在其construct()建造方法中调用建造者对象的部件构造与装配方法，完成复杂对象的建造。客户端一般只需要与指挥者进行交互，在客户端确定具体建造者的类型，并实例化具体建造者对象（也可以通过配置文件和反射机制），然后通过指挥者类的构造函数或者Setter方法将该对象传入指挥者类中。</p><p>在建造者模式的结构中还引入了一个指挥者类Director，该类主要有两个作用：一方面它隔离了客户与创建过程；另一方面它控制产品的创建过程，包括某个buildPartX()方法是否被调用以及多个buildPartX()方法调用的先后次序等。指挥者针对抽象建造者编程，客户端只需要知道具体建造者的类型，即可通过指挥者类调用建造者的相关方法，返回一个完整的产品对象。</p><h1 id="2-游戏角色创建解决方案"><a href="#2-游戏角色创建解决方案" class="headerlink" title="2. 游戏角色创建解决方案"></a>2. 游戏角色创建解决方案</h1><p><img src="https://i.loli.net/2020/02/04/R7D3qoj6ugxTIiQ.gif" alt="2.gif"><br>角色创建结构图</p><p>Actor角色类</p><pre><code>// import lombok@Dataclass Actor{    private String type;    private String sex;    private String face;    private String costume;    private String hairstyle;}</code></pre><p>角色建造起：抽象建造者</p><pre><code>abstract class ActorBuilder {    public void buildType() {        actor.setType(&quot;Charm&quot;);    }}</code></pre><p>指挥者类<br>    class ActorController {<br>        public Actor construct(ActorBuilder ab) {<br>            Actor actor;<br>            ab.buildType();<br>            ab.buildSex();<br>            …<br>            actor = ab.createActor();<br>            return actor;<br>        }<br>    }</p><h1 id="3-关于Director的讨论"><a href="#3-关于Director的讨论" class="headerlink" title="3. 关于Director的讨论"></a>3. 关于Director的讨论</h1><h2 id="3-1-省略Director"><a href="#3-1-省略Director" class="headerlink" title="3.1 省略Director"></a>3.1 省略Director</h2><p>将Director和抽象建造者Builder进行合并，在Builder中提供逐步构建复杂产品对象的construct()方法，控制调用的先后次序。</p><pre><code>abstract class ActorBuilder{       protected static Actor actor = new  Actor();       public  abstract void buildType();       public  abstract void buildSex();       public  abstract void buildFace();       public  abstract void buildCostume();       public  abstract void buildHairstyle();       public static Actor  construct(ActorBuilder ab)       {              ab.buildType();              ab.buildSex();              ab.buildFace();              ab.buildCostume();              ab.buildHairstyle();              return actor;       }}</code></pre><h2 id="3-2-设值钩子方法"><a href="#3-2-设值钩子方法" class="headerlink" title="3.2 设值钩子方法"></a>3.2 设值钩子方法</h2><p>来控制对BuilderPart的调用</p><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><h2 id="4-1-优点"><a href="#4-1-优点" class="headerlink" title="4.1 优点"></a>4.1 优点</h2><ol><li>产品本身与创建过程解耦</li><li>具体建造者之间相对独立</li></ol><h2 id="4-2-缺点"><a href="#4-2-缺点" class="headerlink" title="4.2 缺点"></a>4.2 缺点</h2><ol><li>同一个Builder建的很类似啊，需要产品本身相似程度比较高，否则会很受限</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;建造者模式，又称为生成器模式，为客户端返回一个由多个部件组成的复杂产品。&lt;/p&gt;
&lt;h1 id=&quot;1-建造者模式概述&quot;&gt;&lt;a href=&quot;#1-建造者模式概述&quot; class=&quot;headerlink&quot; title=&quot;1. 建造者模式概述&quot;&gt;&lt;/a&gt;1. 建造者模式概述&lt;/h1
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="Design Pattern" scheme="https://www.llchen60.com/tags/Design-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>工厂方法模式</title>
    <link href="https://www.llchen60.com/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.llchen60.com/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-02-02T23:06:53.000Z</published>
    <updated>2020-02-04T03:23:10.288Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>简单工厂模式虽然简单，但存在一个很严重的问题。当系统中需要引入新产品时，由于静态工厂方法通过所传入参数的不同来创建不同的产品，这必定要修改工厂类的源代码，将违背“开闭原则”，如何实现增加新产品而不影响已有代码？工厂方法模式应运而生，本文将介绍第二种工厂模式——工厂方法模式。</p></blockquote><h1 id="1-日志记录器的设计"><a href="#1-日志记录器的设计" class="headerlink" title="1. 日志记录器的设计"></a>1. 日志记录器的设计</h1><p>Sunny软件公司欲开发一个系统运行日志记录器(Logger)，该记录器可以通过多种途径保存系统的运行日志，如通过文件记录或数据库记录，用户可以通过修改配置文件灵活地更换日志记录方式。在设计各类日志记录器时，Sunny公司的开发人员发现需要对日志记录器进行一些初始化工作，初始化参数的设置过程较为复杂，而且某些参数的设置有严格的先后次序，否则可能会发生记录失败。如何封装记录器的初始化过程并保证多种记录器切换的灵活性是Sunny公司开发人员面临的一个难题。</p><h2 id="1-1-设计要点"><a href="#1-1-设计要点" class="headerlink" title="1.1 设计要点"></a>1.1 设计要点</h2><ol><li>需要封装日志记录器的初始化过程，这些初始化工作较为复杂，例如需要初始化其他相关的类，还有可能需要读取配置文件（例如连接数据库或创建文件），导致代码较长，如果将它们都写在构造函数中，会导致构造函数庞大，不利于代码的修改和维护</li><li>用户可能需要更换日志记录方式，在客户端代码中需要提供一种灵活的方式来选择日志记录器，尽量在不修改源代码的基础上更换或者增加日志记录方式。</li></ol><p><img src="https://i.loli.net/2020/02/03/7ArHEvCctiokB4U.jpg" alt="gc1.jpeg"></p><p>用简单工厂模式来做系统设计，LoggerFactory来创建具体的logger，抽象类logger被几个具体的logger类实现，客户端通过调用LoggerFactory来生成具体的logger对象。</p><pre><code>//日志记录器工厂class LoggerFactory {    //静态工厂方法    public static Logger createLogger(String args) {        if(args.equalsIgnoreCase(&quot;db&quot;)) {            //连接数据库，代码省略            //创建数据库日志记录器对象            Logger logger = new DatabaseLogger();             //初始化数据库日志记录器，代码省略            return logger;        }        else if(args.equalsIgnoreCase(&quot;file&quot;)) {            //创建日志文件            //创建文件日志记录器对象            Logger logger = new FileLogger();             //初始化文件日志记录器，代码省略            return logger;                    }        else {            return null;        }    }}</code></pre><p>通过这种模式，我们将日志记录器的创建和使用分离，客户端只需使用由工厂类创建的日志记录器对象即可。但仍存在一些问题：</p><ol><li>工厂类过于庞大，包含了大量的if…else…代码，导致维护和测试难度增大</li><li>系统扩展不灵活，如果增加新类型的日志记录器，必须修改静态工厂方法的业务逻辑，违反了“开闭原则”。</li></ol><h1 id="2-工厂方法模式概述"><a href="#2-工厂方法模式概述" class="headerlink" title="2. 工厂方法模式概述"></a>2. 工厂方法模式概述</h1><p>简单工厂模式只提供了一个工厂类，该工厂类处于对产品类进行实例化的中心位置，它需要知道每一个产品对象的创建细节，并决定何时实例化哪一个产品类。简单工厂模式最大的缺点是<strong>当有新产品要加入到系统中时，必须修改工厂类，需要在其中加入必要的业务逻辑，这违背了“开闭原则”</strong>。 此外，在简单工厂模式中，所有的产品都由同一个工厂创建，工厂类职责较重，业务逻辑较为复杂，具体产品与工厂类之间的耦合度高，严重影响了系统的灵活性和扩展性，而工厂方法模式则可以很好地解决这一问题。</p><h2 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h2><blockquote><p>工厂方法模式不再提供一个统一的工厂类来创建所有的产品对象，而是针对不同的产品提供不同的工厂，系统提供一个与产品等级结构对应的工厂等级结构。</p></blockquote><blockquote><p>工厂方法模式(Factory Method Pattern)：<strong><em>定义一个用于创建对象的接口，让子类决定将哪一个类实例化</em></strong>。工厂方法模式让一个类的实例化延迟到其子类。工厂方法模式又简称为工厂模式(Factory Pattern)，又可称作虚拟构造器模式(Virtual Constructor Pattern)或多态工厂模式(Polymorphic Factory Pattern)。工厂方法模式是一种类创建型模式。</p></blockquote><p><img src="https://i.loli.net/2020/02/03/lFQLbIy2eUzV8Nu.jpg" alt="gc2.jpeg"></p><h2 id="2-2-组成"><a href="#2-2-组成" class="headerlink" title="2.2 组成"></a>2.2 组成</h2><p>工厂方法模式包含以下几个组成部分：</p><ul><li>Product 抽象产品</li></ul><p>它是定义产品的接口，是工厂方法模式所创建对象的超类型，也就是产品对象的公共父类。</p><ul><li>Concrete Product 具体产品</li></ul><p>它实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，具体工厂和具体产品之间一一对应。</p><ul><li>Factory 抽象工厂</li></ul><p>在抽象工厂类中，声明了工厂方法(Factory Method)，用于返回一个产品。抽象工厂是工厂方法模式的核心，所有创建对象的工厂类都必须实现该接口。</p><ul><li>Concrete Factory 具体工厂</li></ul><p>它是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并可由客户端调用，返回一个具体产品类的实例。</p><h2 id="2-3-实现"><a href="#2-3-实现" class="headerlink" title="2.3 实现"></a>2.3 实现</h2><p>抽象工厂，可以使接口，或者是抽象类</p><pre><code>interface Factory {    public Product factoryMethod();}</code></pre><p>抽象工厂声明了工厂方法但是并未实现工厂方法，具体产品对象的创建由其子类负责，客户端针对抽象工厂编程，<strong><em>运行时再指定具体工厂类</em></strong>。不同的具体工厂可以创建不同的具体产品。</p><pre><code>class ConcreteFactory implements Factory {    public Product factoryMethod() {        return new ConcreteProduct();    }}</code></pre><p> 在实际使用时，具体工厂类在实现工厂方法时除了创建具体产品对象之外，还可以负责产品对象的初始化工作以及一些资源和环境配置工作，例如连接数据库、创建文件等。</p><p> 在客户端代码中，只需关注工厂类即可，不同的具体工厂可以创建不同的产品。</p><pre><code> ……Factory factory;factory = new ConcreteFactory(); //可通过配置文件实现Product product;product = factory.factoryMethod();……</code></pre><h2 id="2-4-完整解决方案"><a href="#2-4-完整解决方案" class="headerlink" title="2.4 完整解决方案"></a>2.4 完整解决方案</h2><p><img src="https://i.loli.net/2020/02/03/f6Stw3NPsXAiyC4.jpg" alt="gc3.jpeg"></p><p>Logger是抽象产品， 其子类FileLogger和DatabaseLogger充当具体产品，LoggerFactory接口充当抽象工厂，其子类FileLoggerFactory和DatabaseLoggerFactory充当具体工厂。</p><pre><code>//日志记录器接口：抽象产品interface Logger {    public void writeLog();}//数据库日志记录器：具体产品class DatabaseLogger implements Logger {    public void writeLog() {        System.out.println(&quot;数据库日志记录。&quot;);    }}//文件日志记录器：具体产品class FileLogger implements Logger {    public void writeLog() {        System.out.println(&quot;文件日志记录。&quot;);    }}//日志记录器工厂接口：抽象工厂interface LoggerFactory {    public Logger createLogger();}//数据库日志记录器工厂类：具体工厂class DatabaseLoggerFactory implements LoggerFactory {    public Logger createLogger() {            //连接数据库，代码省略            //创建数据库日志记录器对象            Logger logger = new DatabaseLogger();             //初始化数据库日志记录器，代码省略            return logger;    }    }//文件日志记录器工厂类：具体工厂class FileLoggerFactory implements LoggerFactory {    public Logger createLogger() {            //创建文件日志记录器对象            Logger logger = new FileLogger();             //创建文件，代码省略            return logger;    }    }</code></pre><p>客户端测试代码：</p><pre><code>class Client {    public static void main(String args[]) {        LoggerFactory factory;        Logger logger;        factory = new FileLoggerFactory(); //可引入配置文件实现        logger = factory.createLogger();        logger.writeLog();    }}</code></pre><h2 id="2-5-反射与配置文件"><a href="#2-5-反射与配置文件" class="headerlink" title="2.5 反射与配置文件"></a>2.5 反射与配置文件</h2><p><strong><em>如何在不修改任何客户端代码的基础上更新或增加新的日志记录方式？</em></strong></p><p>在客户端代码中将不再使用new关键字来创建工厂对象，而是将具体工厂类的类名存储在配置文件（如XML文件）中，<strong>通过读取配置文件获取类名字符串</strong>，再使用<strong>Java的反射机制</strong>，根据类名字符串生成对象。在整个实现过程中需要用到两个技术：Java反射机制与配置文件读取。</p><blockquote><p>Java反射机制</p></blockquote><p>是指在程序运行时获取已知名称的类或已有对象的相关信息的一种机制，包括类的方法、属性、父类等信息，还包括实例的创建和实例类型的判断等。在反射中使用最多的类是<strong>Class，Class类的实例表示正在运行的Java应用程序中的类和接口</strong>，其forName(String className)方法可以返回与带有给定字符串名的类或接口相关联的 Class对象，再通过Class对象的newInstance()方法创建此对象所表示的类的一个新实例，即通过一个类名字符串得到类的实例。</p><pre><code>   //通过类名生成实例对象并将其返回   Class c=Class.forName(&quot;String&quot;);   Object obj=c.newInstance();   return obj;</code></pre><p>而后使用XML格式的配置文件config.xml用于存储具体日志记录器工厂类类名：</p><pre><code>&lt;!— config.xml --&gt;&lt;?xml version=&quot;1.0&quot;?&gt;&lt;config&gt;    &lt;className&gt;FileLoggerFactory&lt;/className&gt;&lt;/config&gt;</code></pre><p>然后用一个名为XMLUtil的工具类来获取xml文件定义的类，<strong>并且生成实例对象</strong>。 </p><pre><code>//工具类XMLUtil.javaimport javax.xml.parsers.*;import org.w3c.dom.*;import org.xml.sax.SAXException;import java.io.*;public class XMLUtil {//该方法用于从XML配置文件中提取具体类类名，并返回一个实例对象    public static Object getBean() {        try {            //创建DOM文档对象            DocumentBuilderFactory dFactory = DocumentBuilderFactory.newInstance();            DocumentBuilder builder = dFactory.newDocumentBuilder();            Document doc;                                        doc = builder.parse(new File(&quot;config.xml&quot;));             //获取包含类名的文本节点            NodeList nl = doc.getElementsByTagName(&quot;className&quot;);            Node classNode=nl.item(0).getFirstChild();            String cName=classNode.getNodeValue();            //通过类名生成实例对象并将其返回            Class c=Class.forName(cName);              Object obj=c.newInstance();            return obj;        }           catch(Exception e) {               e.printStackTrace();               return null;         }    }}</code></pre><p>而后客户端不需要再使用new关键字来创建具体的工厂类了，可以将具体工厂类的类名存储在XML文件中，再通过XMLUtil类的静态工厂方法getBean()进行对象的实例化</p><pre><code>class Client {    public static void main(String args[]) {        LoggerFactory factory;        Logger logger;        factory = (LoggerFactory)XMLUtil.getBean(); //getBean()的返回类型为Object，需要进行强制类型转换        logger = factory.createLogger();        logger.writeLog();    }}</code></pre><p>引入了Util和XML配置文件之后，如果要增加新的日志记录方式，只需要：</p><ol><li>新的日志记录器需要继承抽象日志记录器Logger</li><li>对应增加一个新的具体日志记录器工厂，继承抽象日志记录器工厂LoggerFactory，并实现其中的工厂方法createLogger()，设置好初始化参数和环境变量，返回具体日志记录器对象；</li><li>修改配置文件config.xml，将新增的具体日志记录器工厂类的类名字符串替换原有工厂类类名字符串</li><li>编译新增的具体日志记录器类和具体日志记录器工厂类，运行客户端测试类即可使用新的日志记录方式，而原有类库代码无须做任何修改，完全符合“开闭原则”。</li></ol><h2 id="2-6-重载的工厂方法"><a href="#2-6-重载的工厂方法" class="headerlink" title="2.6 重载的工厂方法"></a>2.6 重载的工厂方法</h2><p>发现可以通过多种方式来初始化日志记录器，例如可以为各种日志记录器提供默认实现；还可以为数据库日志记录器提供数据库连接字符串，为文件日志记录器提供文件路径；也可以将参数封装在一个Object类型的对象中，通过Object对象将配置参数传入工厂类。此时，可以提供一组重载的工厂方法，以不同的方式对产品对象进行创建。当然，对于同一个具体工厂而言，无论使用哪个工厂方法，创建的产品类型均要相同。</p><p><img src="https://i.loli.net/2020/02/03/l8TdOYBKXeCmqbD.jpg" alt="gc4.jpeg"></p><p>引入重载方法后，抽象工厂LoggerFactory的代码修改如下：</p><pre><code>interface LoggerFactory {    public Logger createLogger();    public Logger createLogger(String args);    public Logger createLogger(Object obj);}</code></pre><p>具体工厂类DatabaseLoggerFactory代码修改如下：</p><pre><code>class DatabaseLoggerFactory implements LoggerFactory {    public Logger createLogger() {            //使用默认方式连接数据库，代码省略            Logger logger = new DatabaseLogger();             //初始化数据库日志记录器，代码省略            return logger;    }    public Logger createLogger(String args) {            //使用参数args作为连接字符串来连接数据库，代码省略            Logger logger = new DatabaseLogger();             //初始化数据库日志记录器，代码省略            return logger;    }        public Logger createLogger(Object obj) {            //使用封装在参数obj中的连接字符串来连接数据库，代码省略            Logger logger = new DatabaseLogger();             //使用封装在参数obj中的数据来初始化数据库日志记录器，代码省略            return logger;    }    }//其他具体工厂类代码省略</code></pre><p>在抽象工厂中定义多个重载的工厂方法，在具体工厂中实现了这些工厂方法，这些方法可以包含不同的业务逻辑，以满足对不同产品对象的需求。</p><h2 id="2-7-工厂方法的隐藏"><a href="#2-7-工厂方法的隐藏" class="headerlink" title="2.7 工厂方法的隐藏"></a>2.7 工厂方法的隐藏</h2><p> 有时候，为了进一步简化客户端的使用，还可以对客户端隐藏工厂方法，此时，在工厂类中将直接调用产品类的业务方法，客户端无须调用工厂方法创建产品，直接通过工厂即可使用所创建的对象中的业务方法。</p><p><img src="gc5.jpeg" alt="gc5.jpeg"></p><p>就是抽象工厂类从接口变成abstract类，并且在这个抽象类里面实现产品类的业务方法。</p><pre><code>//改为抽象类abstract class LoggerFactory {    //在工厂类中直接调用日志记录器类的业务方法writeLog()    public void writeLog() {        Logger logger = this.createLogger();        logger.writeLog();    }    public abstract Logger createLogger();    }</code></pre><p>客户端代码修改成：</p><pre><code>class Client {    public static void main(String args[]) {        LoggerFactory factory;        factory = (LoggerFactory)XMLUtil.getBean();        factory.writeLog(); //直接使用工厂对象来调用产品对象的业务方法    }}</code></pre><h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h1><h2 id="3-1-优势"><a href="#3-1-优势" class="headerlink" title="3.1 优势"></a>3.1 优势</h2><ol><li>工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，<strong>用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名</strong>。</li><li>基于工厂角色和产品角色的<strong>多态性设计</strong>是工厂方法模式的关键。它能够让工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，就正是因为所有的具体工厂类都具有同一抽象父类。</li><li>使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，<strong>而只要添加一个具体工厂和具体产品就可以了</strong>，这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。</li></ol><h2 id="3-2-劣势"><a href="#3-2-劣势" class="headerlink" title="3.2 劣势"></a>3.2 劣势</h2><ol><li>在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。</li><li>由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。</li></ol><h1 id="4-Reference"><a href="#4-Reference" class="headerlink" title="4. Reference"></a>4. Reference</h1><p><a href="https://blog.csdn.net/lovelion/article/details/9306457" target="_blank" rel="noopener">1. CSDN Liuwei</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;简单工厂模式虽然简单，但存在一个很严重的问题。当系统中需要引入新产品时，由于静态工厂方法通过所传入参数的不同来创建不同的产品，这必定要修改工厂类的源代码，将违背“开闭原则”，如何实现增加新产品而不影响已有代码？工厂方法模式应运而生，本文将介绍第二种
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="Design Pattern" scheme="https://www.llchen60.com/tags/Design-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>如何确定一个服务器的最大连接数</title>
    <link href="https://www.llchen60.com/%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E4%B8%80%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E8%BF%9E%E6%8E%A5%E6%95%B0/"/>
    <id>https://www.llchen60.com/%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E4%B8%80%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E8%BF%9E%E6%8E%A5%E6%95%B0/</id>
    <published>2020-02-02T23:05:38.000Z</published>
    <updated>2020-02-04T03:23:00.698Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-连接数定义"><a href="#1-连接数定义" class="headerlink" title="1. 连接数定义"></a>1. 连接数定义</h1><p>对于给定的一个服务器而言，在任意时刻能够同时处理的最大连接数。</p><h1 id="2-Tips"><a href="#2-Tips" class="headerlink" title="2. Tips"></a>2. Tips</h1><h2 id="2-1-如果超过了会怎么样"><a href="#2-1-如果超过了会怎么样" class="headerlink" title="2.1 如果超过了会怎么样"></a>2.1 如果超过了会怎么样</h2><ul><li>如果使用了Spillover的feature，额外的请求会被放置到队列里</li><li>如果没使用，那么HTTP 503会返回，对于TCP连接，会被重置掉</li></ul><h2 id="2-2-如果得出准确的允许的最大连接数？"><a href="#2-2-如果得出准确的允许的最大连接数？" class="headerlink" title="2.2 如果得出准确的允许的最大连接数？"></a>2.2 如果得出准确的允许的最大连接数？</h2><p>没有办法直接得出，因为运行的代码本身，机器本身都会对结果产生影响的，最好的方式依旧是做测试，即不停更改最大连接数，单独测试一个host在不同连接数的情况下的metrics，譬如延时问题，有没有fatals, etc. 以此来得到针对实际情况的正确地值。</p><h2 id="2-3-General-公式"><a href="#2-3-General-公式" class="headerlink" title="2.3 General 公式"></a>2.3 General 公式</h2><ul><li>需要使用的CPU时间 (local resource)</li><li>远端，网路延时 （remote latency）</li><li>CPU 核心数量</li></ul><p>参考公式</p><pre><code>maxConns = ((local + remote) / local) * cores</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-连接数定义&quot;&gt;&lt;a href=&quot;#1-连接数定义&quot; class=&quot;headerlink&quot; title=&quot;1. 连接数定义&quot;&gt;&lt;/a&gt;1. 连接数定义&lt;/h1&gt;&lt;p&gt;对于给定的一个服务器而言，在任意时刻能够同时处理的最大连接数。&lt;/p&gt;
&lt;h1 id=&quot;2-Ti
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
  </entry>
  
  <entry>
    <title>原型模式</title>
    <link href="https://www.llchen60.com/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.llchen60.com/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-02-02T23:02:53.000Z</published>
    <updated>2020-02-04T03:22:54.717Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-原型模式概述"><a href="#1-原型模式概述" class="headerlink" title="1. 原型模式概述"></a>1. 原型模式概述</h1><p>原型模式指：通过一个原型对象克隆出多个一模一样的对象。</p><p>在使用原型模式时，首先需要创建一个原型对象，再通过复制这个原型对象来创建更多同类型的对象。</p><blockquote><p>使用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。原型模式时一种对象创建型模式。</p></blockquote><h2 id="1-1-工作原理"><a href="#1-1-工作原理" class="headerlink" title="1.1 工作原理"></a>1.1 工作原理</h2><p>将一个原型对象传给要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝自己来实现创建过程。</p><p>通过克隆方法所创建的对象是全新的，在内存中有新的地址，对克隆对象所产生的对象进行修改不会对原型对象产生任何影响。</p><h2 id="1-2-包含角色"><a href="#1-2-包含角色" class="headerlink" title="1.2 包含角色"></a>1.2 包含角色</h2><p><img src="https://i.loli.net/2020/02/03/NSa3iLpPcvoCfIq.gif" alt="1.gif"></p><ul><li>Prototype (抽象原型类)</li></ul><p>是声明克隆方法的接口，是所有具体类型类的公共父类。抽象类/ 接口/ 具体实现类</p><ul><li>ConcretePrototype (具体原型类)</li></ul><p>实现了抽象原型类中声明的克隆方法，在克隆方法中返回一个自己的克隆对象</p><ul><li>Client</li></ul><p>让一个原型对象克隆自身，从而创建一个新的对象。客户类针对抽象原型类Prototype编程，因此用户可以根据需要选择具体原型类，扩展性加强了。</p><h1 id="2-原型模式的实现"><a href="#2-原型模式的实现" class="headerlink" title="2. 原型模式的实现"></a>2. 原型模式的实现</h1><h2 id="2-1-通用实现方法"><a href="#2-1-通用实现方法" class="headerlink" title="2.1 通用实现方法"></a>2.1 通用实现方法</h2><pre><code>class ConcretePrototype implements Prototype {    private String attr; //成员属性    public void setAttr(String attr) {        this.attr = attr;    }    public String getAttr() {        return this.attr;    }    public Prototype clone() //克隆方法    {        Prototype prototype = new ConcretePrototype(); //创建新对象        prototype.setAttr(this.attr);        return prototype;    }}</code></pre><h2 id="2-2-Java提供的clone-方法"><a href="#2-2-Java提供的clone-方法" class="headerlink" title="2.2 Java提供的clone()方法"></a>2.2 Java提供的clone()方法</h2><p>所有的Java类都继承自java.lang.Object。事实上，Object提供了clone()方法，可以将一个Java对象复制一份。可以直接使用这个方法来实现克隆的。</p><pre><code>class ConcretePrototype implements Cloneable {    public Prototype clone() {    　　Object object = null;    　　try {    　　　　　object = super.clone();    　　} catch (CloneNotSupportedException exception) {    　　　　　System.err.println(&quot;Not support cloneable&quot;);    　　}    　　return (Prototype )object;    }}</code></pre><p>Java中的clone()满足：</p><ol><li>对于任何对象，都有<code>x.clone() != x</code>，即克隆方法创建了新的对象</li><li>对于任何对象，都有<code>x.clone().getClass() == x.getClass()</code>，即克隆对象与原型对象的类型一样</li><li>派生类需要实现Cloneable接口</li></ol><h1 id="3-原型模式实现工作周报快速创建"><a href="#3-原型模式实现工作周报快速创建" class="headerlink" title="3. 原型模式实现工作周报快速创建"></a>3. 原型模式实现工作周报快速创建</h1><p><img src="https://i.loli.net/2020/02/03/Ci24JYEqs6z8GgX.gif" alt="2.gif"></p><p>快速创建周报结构图</p><p>//工作周报WeeklyLog：具体原型类，考虑到代码的可读性和易理解性，只列出部分与模式相关的核心代码</p><pre><code>class WeeklyLog implements Cloneable{    private String name;    private String date;    private String content;    public  void setName(String name) {        this.name  = name;    }    public  void setDate(String date) {        this.date  = date;    }    public  void setContent(String content) {        this.content  = content;    }    public  String getName() {        return  (this.name);    }    public  String getDate() {        return  (this.date);    }    public  String getContent() {        return  (this.content);    }     //克隆方法clone()，此处使用Java语言提供的克隆机制    public WeeklyLog clone()    {        Object obj = null;        try {        obj = super.clone();        return (WeeklyLog)obj;      } catch(CloneNotSupportedException e) {        System.out.println(&quot;不支持复制！&quot;);        return null;        }    }}</code></pre><p>测试代码:</p><pre><code>class Client{    public  static void main(String args[])    {              WeeklyLog log_previous = new WeeklyLog();  //创建原型对象              log_previous.setName(&quot;张无忌&quot;);              log_previous.setDate(&quot;第12周&quot;);              log_previous.setContent(&quot;这周工作很忙，每天加班！&quot;);              System.out.println(&quot;****周报****&quot;);              System.out.println(&quot;周次：&quot; +  log_previous.getDate());              System.out.println(&quot;姓名：&quot; +  log_previous.getName());              System.out.println(&quot;内容：&quot; +  log_previous.getContent());              System.out.println(&quot;--------------------------------&quot;);              WeeklyLog  log_new;              log_new  = log_previous.clone(); //调用克隆方法创建克隆对象              log_new.setDate(&quot;第13周&quot;);              System.out.println(&quot;****周报****&quot;);              System.out.println(&quot;周次：&quot; + log_new.getDate());              System.out.println(&quot;姓名：&quot; + log_new.getName());              System.out.println(&quot;内容：&quot; + log_new.getContent());       }}</code></pre><h1 id="4-浅克隆与深克隆"><a href="#4-浅克隆与深克隆" class="headerlink" title="4. 浅克隆与深克隆"></a>4. 浅克隆与深克隆</h1><p>在java中，数据类型分为值类型和引用类型，值类型包括int,double, byte, boolean, char等，引用类型包括类，接口，数组等。浅克隆与深克隆的区别在于是否支持引用类型的成员变量的复制。</p><h2 id="4-1-浅克隆"><a href="#4-1-浅克隆" class="headerlink" title="4.1 浅克隆"></a>4.1 浅克隆</h2><p><img src="https://i.loli.net/2020/02/03/xbMHXnZEd3NJlgh.gif" alt="3.gif"><br>浅克隆示意图</p><p>如果原型对象的成员变量是引用类型，则将引用对象的地址复制一份给克隆对象，也就是说二者的成员变量指向了相同的内存地址。<strong><em>在浅克隆中，当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制</em></strong>。</p><p><img src="https://i.loli.net/2020/02/03/KiLnFxBw2ODJvuI.gif" alt="4.gif"><br>带附件的周报结构图</p><p>附件类代码：</p><pre><code>//附件类class Attachment{    private String name; //附件名    public void setName(String name) {        this.name = name;    }    public String getName() {        return this.name;    }    public void download() {        System.out.println(&quot;下载附件，文件名为&quot; + name);    }}</code></pre><p>工作周报类代码</p><pre><code>//工作周报WeeklyLogclass WeeklyLog implements Cloneable{     //为了简化设计和实现，假设一份工作周报中只有一个附件对象，实际情况中可以包含多个附件，可以通过List等集合对象来实现       private Attachment attachment;       private String name;       private  String date;       private  String content;       public void setAttachment(Attachment  attachment) {              this.attachment = attachment;       }       public  void setName(String name) {              this.name  = name;       }       public  void setDate(String date) {              this.date  = date;       }       public  void setContent(String content) {              this.content  = content;       }       public Attachment  getAttachment(){              return (this.attachment);       }       public  String getName() {              return  (this.name);       }       public  String getDate() {              return  (this.date);       }       public  String getContent() {              return  (this.content);       }     //使用clone()方法实现浅克隆       public WeeklyLog clone()       {              Object obj = null;              try              {                     obj = super.clone();                     return (WeeklyLog)obj;              }              catch(CloneNotSupportedException  e)              {                System.out.println(&quot;不支持复制！&quot;);                     return null;              }       }}</code></pre><p>客户端代码：</p><pre><code>class Client{       public  static void main(String args[])       {              WeeklyLog  log_previous, log_new;              log_previous  = new WeeklyLog(); //创建原型对象              Attachment  attachment = new Attachment(); //创建附件对象              log_previous.setAttachment(attachment);  //将附件添加到周报中              log_new  = log_previous.clone(); //调用克隆方法创建克隆对象              //比较周报              System.out.println(&quot;周报是否相同？ &quot; + (log_previous ==  log_new));              //比较附件              System.out.println(&quot;附件是否相同？ &quot; +  (log_previous.getAttachment() == log_new.getAttachment()));       }}</code></pre><h2 id="4-2-深克隆"><a href="#4-2-深克隆" class="headerlink" title="4.2 深克隆"></a>4.2 深克隆</h2><p>无论原型对象的成员变量是值类型还是引用类型，都将复制一份给克隆对象。即深克隆中，除了对象本身被复制外，对象所包含的所有成员变量也将复制。</p><p><img src="https://i.loli.net/2020/02/03/6QblH4gmPvqx2FN.gif" alt="5.gif"><br>深克隆示意图</p><p>如果要实现深克隆，在Java中可以通过序列化Serialization等方式来实现。</p><p>序列化，将对象写到流里，通过序列化的拷贝不仅可以复制对象本身，也可以复制其引用的成员对象。因此通过序列化将对象写到一个流中，再从流里将其读出来，可以实现深克隆。需要注意的是能够实现序列化的对象其类必须实现<strong>Serializable接口</strong>，否则无法实现序列化操作。</p><p><img src="https://i.loli.net/2020/02/03/1vYLodkxTpSJ5q2.gif" alt="6.gif"><br>带附件的周报结构图</p><p>附件类：</p><p>import  java.io.*;</p><p>//附件类</p><pre><code>class  Attachment implements Serializable{       private  String name; //附件名       public  void setName(String name)       {              this.name  = name;       }       public  String getName()       {              return  this.name;       }     public void download()     {            System.out.println(&quot;下载附件，文件名为&quot; + name);     }}</code></pre><p>工作周报类代码实现：</p><pre><code>import  java.io.*;//工作周报类class  WeeklyLog implements Serializable{       private  Attachment attachment;       private  String name;       private  String date;       private  String content;       public  void setAttachment(Attachment attachment) {              this.attachment  = attachment;       }       public  void setName(String name) {              this.name  = name       }       public  void setDate(String date) {              this.date  = date;       }       public  void setContent(String content) {              this.content  = content;       }       public  Attachment getAttachment(){              return  (this.attachment);       }       public  String getName() {              return  (this.name);       }       public  String getDate() {              return  (this.date);       }       public  String getContent() {              return  (this.content);       }   //使用序列化技术实现深克隆       public WeeklyLog deepClone() throws  IOException, ClassNotFoundException, OptionalDataException       {              //将对象写入流中              ByteArrayOutputStream bao=new  ByteArrayOutputStream();              ObjectOutputStream oos=new  ObjectOutputStream(bao);              oos.writeObject(this);              //将对象从流中取出              ByteArrayInputStream bis=new  ByteArrayInputStream(bao.toByteArray());              ObjectInputStream ois=new  ObjectInputStream(bis);              return  (WeeklyLog)ois.readObject();       }}</code></pre><p>客户端代码：</p><pre><code>class Client{       public  static void main(String args[])       {              WeeklyLog  log_previous, log_new = null;              log_previous  = new WeeklyLog(); //创建原型对象              Attachment  attachment = new Attachment(); //创建附件对象              log_previous.setAttachment(attachment);  //将附件添加到周报中              try              {                     log_new =  log_previous.deepClone(); //调用深克隆方法创建克隆对象                                }              catch(Exception e)              {                  System.err.println(&quot;克隆失败！&quot;);              }              //比较周报              System.out.println(&quot;周报是否相同？ &quot; + (log_previous ==  log_new));              //比较附件              System.out.println(&quot;附件是否相同？ &quot; +  (log_previous.getAttachment() == log_new.getAttachment()));       }}</code></pre><blockquote><p>Tips: java中的Cloneable和Serializable接口的代码很简单，都是空接口，也成为标识接口，其中没有任何方法的定义，其作用是告诉JRE这些接口的实现类是否具有某个功能。</p></blockquote><h2 id="4-3-Java中实现深克隆的方法浅析"><a href="#4-3-Java中实现深克隆的方法浅析" class="headerlink" title="4.3 Java中实现深克隆的方法浅析"></a>4.3 Java中实现深克隆的方法浅析</h2><h3 id="4-3-1-Apache-Commons-Lang"><a href="#4-3-1-Apache-Commons-Lang" class="headerlink" title="4.3.1 Apache Commons Lang"></a>4.3.1 Apache Commons Lang</h3><p>SerializationUtils#clone, will perform a deep copy when all classes in the object graph implement the serializable interface. </p><h3 id="4-3-2-Json-Serialization-with-Gson"><a href="#4-3-2-Json-Serialization-with-Gson" class="headerlink" title="4.3.2 Json Serialization with Gson"></a>4.3.2 Json Serialization with Gson</h3><p>No need for Serializable interface</p><pre><code>gson.fromJson(gson.toJson(userA), User.class);</code></pre><h3 id="4-3-3-constructor"><a href="#4-3-3-constructor" class="headerlink" title="4.3.3 constructor"></a>4.3.3 constructor</h3><p>直接handmade, 用constructor生成一个新的想要的对象。</p><h1 id="5-原型管理器"><a href="#5-原型管理器" class="headerlink" title="5. 原型管理器"></a>5. 原型管理器</h1><p>原型管理器(Prototype Manager)是将多个原型对象存储在一个集合中供客户端使用，它是一个专门负责克隆对象的工厂，其中定义了一个集合用于存储原型对象，如果需要某个原型对象的一个克隆，可以通过复制集合中对应的原型对象来获得。在原型管理器中针对抽象原型类进行编程，以便扩展。</p><p><img src="https://i.loli.net/2020/02/03/9UmnSAyI7az4kjl.gif" alt="7.gif"><br>带原型管理器的原型模式图 </p><h2 id="5-1-实例-公文管理器"><a href="#5-1-实例-公文管理器" class="headerlink" title="5.1 实例-公文管理器"></a>5.1 实例-公文管理器</h2><p><img src="https://i.loli.net/2020/02/03/zE3ahLk6lvKfw4J.gif" alt="8.gif"><br>公文管理器结构图</p><p>代码实现： </p><pre><code>import java.util.*;//抽象公文接口，也可定义为抽象类，提供clone()方法的实现，将业务方法声明为抽象方法interface OfficialDocument extends  Cloneable{       public  OfficialDocument clone();       public  void display();}//可行性分析报告(Feasibility Analysis Report)类class FAR implements OfficialDocument{       public  OfficialDocument clone()      {              OfficialDocument  far = null;              try              {                     far  = (OfficialDocument)super.clone();              }              catch(CloneNotSupportedException  e)              {                  System.out.println(&quot;不支持复制！&quot;);              }              return  far;       }       public  void display()       {         System.out.println(&quot;《可行性分析报告》&quot;);       }}//软件需求规格说明书(Software Requirements Specification)类class SRS implements OfficialDocument{       public  OfficialDocument clone()       {              OfficialDocument  srs = null;              try              {                     srs  = (OfficialDocument)super.clone();              }              catch(CloneNotSupportedException  e)              {                 System.out.println(&quot;不支持复制！&quot;);              }              return  srs;       }       public  void display()       {             System.out.println(&quot;《软件需求规格说明书》&quot;);       }}//原型管理器（使用饿汉式单例实现）class  PrototypeManager{       //定义一个Hashtable，用于存储原型对象       private Hashtable ht=new Hashtable();       private static PrototypeManager pm =  new PrototypeManager();       //为Hashtable增加公文对象        private  PrototypeManager()     {              ht.put(&quot;far&quot;,new  FAR());              ht.put(&quot;srs&quot;,new  SRS());                    }     //增加新的公文对象       public void addOfficialDocument(String  key,OfficialDocument doc)       {              ht.put(key,doc);       }       //通过浅克隆获取新的公文对象       public OfficialDocument  getOfficialDocument(String key)       {              return  ((OfficialDocument)ht.get(key)).clone();       }       public static PrototypeManager  getPrototypeManager()       {              return pm;       }}</code></pre><p>客户端代码如下： </p><pre><code>class Client{       public  static void main(String args[])       {              //获取原型管理器对象              PrototypeManager pm =  PrototypeManager.getPrototypeManager();                OfficialDocument  doc1,doc2,doc3,doc4;              doc1  = pm.getOfficialDocument(&quot;far&quot;);              doc1.display();              doc2  = pm.getOfficialDocument(&quot;far&quot;);              doc2.display();              System.out.println(doc1  == doc2);              doc3  = pm.getOfficialDocument(&quot;srs&quot;);              doc3.display();              doc4  = pm.getOfficialDocument(&quot;srs&quot;);              doc4.display();              System.out.println(doc3  == doc4);       }}</code></pre><p> 在PrototypeManager中定义了一个Hashtable类型的集合对象，使用“键值对”来存储原型对象，客户端可以通过Key（如“far”或“srs”）来获取对应原型对象的克隆对象。PrototypeManager类提供了类似工厂方法的getOfficialDocument()方法用于返回一个克隆对象。</p><h1 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h1><h2 id="6-1-优点"><a href="#6-1-优点" class="headerlink" title="6.1 优点"></a>6.1 优点</h2><ol><li>简化对象的创建过程</li><li>客户端可以针对抽象原型类进行编程，具体原型类写在配置文件中</li><li>技工简化的创建结构</li></ol><h2 id="6-2-缺点"><a href="#6-2-缺点" class="headerlink" title="6.2 缺点"></a>6.2 缺点</h2><ol><li>每一个类有自己的克隆方法，且位于一个类的内部，对已有类进行改造的时候，需要修改源代码</li><li>深克隆复杂</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-原型模式概述&quot;&gt;&lt;a href=&quot;#1-原型模式概述&quot; class=&quot;headerlink&quot; title=&quot;1. 原型模式概述&quot;&gt;&lt;/a&gt;1. 原型模式概述&lt;/h1&gt;&lt;p&gt;原型模式指：通过一个原型对象克隆出多个一模一样的对象。&lt;/p&gt;
&lt;p&gt;在使用原型模式时，
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="Design Pattern" scheme="https://www.llchen60.com/tags/Design-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="https://www.llchen60.com/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.llchen60.com/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-02-02T23:00:48.000Z</published>
    <updated>2020-02-04T03:22:48.772Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-为什么需要单例模式"><a href="#1-为什么需要单例模式" class="headerlink" title="1. 为什么需要单例模式"></a>1. 为什么需要单例模式</h1><p>windows系统的任务管理器，只能有一个,唯一性的原因：</p><ol><li>如果能弹出多个窗口，且这些窗口的内容完全一致，全都是重复对象，那势必会浪费资源，尤其是任务管理器会需要进入内核态调取各种状态信息，会对性能造成一定的影响。</li><li>而且多个窗口之间需要保持一致性，绝对的同步，相互之间的同步也是资源的浪费。</li></ol><p>现实中的例子，就是为了节约系统资源，有时需要确保系统中某个类只有唯一一个实例，当这个实例创建成功以后，我们无法再创建一个同类型的其他对象，所有的操作都只能基于这个唯一的实例。</p><h1 id="2-单例模式概述"><a href="#2-单例模式概述" class="headerlink" title="2. 单例模式概述"></a>2. 单例模式概述</h1><h2 id="2-1-模拟任务管理类"><a href="#2-1-模拟任务管理类" class="headerlink" title="2.1 模拟任务管理类"></a>2.1 模拟任务管理类</h2><pre><code>class TaskManager{     public TaskManager() {...} //初始化窗口     public void displayProcesses()  {……} //显示进程     public void  displayServices() {……} //显示服务}</code></pre><p>对其进行重构，为了使其是单一实例的，那我们需要禁止类的外部直接使用new来创建对象  —–&gt;  将其构造函数的可见性变为private</p><pre><code>public TaskManager() {...}</code></pre><p>在类内部创建对象，保存这个唯一实例</p><pre><code>private static TaskManager tm = null;public static TaskManager getInstance() {    if (tm == null) {        tm = new TaskManager();    }    return tm;}</code></pre><p><code>getInstance()</code>定义成一个静态方法，这样可以直接通过类名来使用</p><h2 id="2-2-定义"><a href="#2-2-定义" class="headerlink" title="2.2 定义"></a>2.2 定义</h2><blockquote><p>单例模式(Singleton Pattern)：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式是一种对象创建型模式。</p></blockquote><ol><li>只有一个实例</li><li>必须自行创建这个实例</li><li>必须自行向整个系统提供这个实例</li></ol><p><img src="https://i.loli.net/2020/02/03/vKPVAeCrImYXq1U.gif" alt="s1.gif"></p><h2 id="2-3-负载均衡器的设计与实现"><a href="#2-3-负载均衡器的设计与实现" class="headerlink" title="2.3 负载均衡器的设计与实现"></a>2.3 负载均衡器的设计与实现</h2><p> Sunny软件公司承接了一个服务器负载均衡(Load Balance)软件的开发工作，该软件运行在一台负载均衡服务器上，可以将并发访问和数据流量分发到服务器集群中的多台设备上进行并发处理，提高系统的整体处理能力，缩短响应时间。由于集群中的服务器需要动态删减，且客户端请求需要统一分发，因此需要确保负载均衡器的唯一性，只能有一个负载均衡器来负责服务器的管理和请求的分发，否则将会带来服务器状态的不一致以及请求分配冲突等问题。如何确保负载均衡器的唯一性是该软件成功的关键。</p><p>使用单例模式来设计该负载均衡器： </p><p><img src="https://i.loli.net/2020/02/03/4vJzXqlRCITLUge.gif" alt="s2.gif"></p><pre><code>import java.util.*;//负载均衡器LoadBalancer：单例类，真实环境下该类将非常复杂，包括大量初始化的工作和业务方法，考虑到代码的可读性和易理解性，只列出部分与模式相关的核心代码class LoadBalancer {    //私有静态成员变量，存储唯一实例    private static LoadBalancer instance = null;    //服务器集合    private List serverList = null;    //私有构造函数    private LoadBalancer() {        serverList = new ArrayList();    }    //公有静态成员方法，返回唯一实例    public static LoadBalancer getLoadBalancer() {        if (instance == null) {            instance = new LoadBalancer();        }        return instance;    }    //增加服务器    public void addServer(String server) {        serverList.add(server);    }    //删除服务器    public void removeServer(String server) {        serverList.remove(server);    }    //使用Random类随机获取服务器    public String getServer() {        Random random = new Random();        int i = random.nextInt(serverList.size());        return (String)serverList.get(i);    }}</code></pre><h1 id="3-饿汉式单例模式和懒汉式单例模式"><a href="#3-饿汉式单例模式和懒汉式单例模式" class="headerlink" title="3. 饿汉式单例模式和懒汉式单例模式"></a>3. 饿汉式单例模式和懒汉式单例模式</h1><h2 id="3-1-饿汉式单例模式"><a href="#3-1-饿汉式单例模式" class="headerlink" title="3.1 饿汉式单例模式"></a>3.1 饿汉式单例模式</h2><p><img src="https://i.loli.net/2020/02/03/UAk8topvxWQTwfd.gif" alt="s3.gif"></p><pre><code>class EagerSingleton {     private static final EagerSingleton instance = new EagerSingleton();     private EagerSingleton() { }     public static EagerSingleton getInstance() {        return instance;     }   }</code></pre><p>在类加载的时候，静态变量instance就会被初始化，此时类的私有构造函数会被调用，然后单例类的唯一实例会在这个时候被创建出来。</p><h2 id="3-2-懒汉式单例模式"><a href="#3-2-懒汉式单例模式" class="headerlink" title="3.2 懒汉式单例模式"></a>3.2 懒汉式单例模式</h2><p><img src="https://i.loli.net/2020/02/03/bDLQtESdzF8Ugmq.gif" alt="s4.gif"></p><p>在第一个调用getInstance()方法的时候进行实例化。又叫做延迟加载技术——在需要的时候再加载实例，为了避免多个线程同时调用getInstance()方法，我们需要使用<strong><em>synchronized关键字</em></strong>：</p><pre><code>class LazySingleton {     private static LazySingleton instance = null;     private LazySingleton() { }     synchronized public static LazySingleton getInstance() {         if (instance == null) {            instance = new LazySingleton();         }        return instance;     }}</code></pre><p>这里实际上不需要多整个getInstance()方法要求synchronized， 只需要在new的时候，是不能并发的就可以了:</p><pre><code>public static LazySingleton getInstance() {     if (instance == null) {        synchronized (LazySingleton.class) {            instance = new LazySingleton();         }    }    return instance; }</code></pre><p>还是有可能存在不唯一的状态，即在第一个线程做实例化的时候，第二个线程已经完成了判断，在等待实例化了  所以需要做double check locking：</p><pre><code>class LazySingleton {     // volatile 保证在多线程可以被正确处理    private volatile static LazySingleton instance = null;     private LazySingleton() { }     public static LazySingleton getInstance() {         //第一重判断        if (instance == null) {            //锁定代码块            synchronized (LazySingleton.class) {                //第二重判断                if (instance == null) {                    instance = new LazySingleton(); //创建单例实例                }            }        }        return instance;     }}</code></pre><h1 id="4-Initialization-Demand-Holder-进行单例实现"><a href="#4-Initialization-Demand-Holder-进行单例实现" class="headerlink" title="4. Initialization Demand Holder 进行单例实现"></a>4. Initialization Demand Holder 进行单例实现</h1><p>结合饿汉模式和饱汉模式的优点，新的实例化方式： </p><pre><code>//Initialization on Demand Holderclass Singleton {    private Singleton() {    }    private static class HolderClass {            private final static Singleton instance = new Singleton();    }    public static Singleton getInstance() {        return HolderClass.instance;    }    public static void main(String args[]) {        Singleton s1, s2;             s1 = Singleton.getInstance();        s2 = Singleton.getInstance();        System.out.println(s1==s2);    }}</code></pre><p>在单例类中增加了一个静态内部类，在这个内部类中创建单例对象，再将这个单例对象通过getInstance()给外界使用。通过这种方式，我们实现了延迟加载，也保证了线程安全，不影响系统性能</p><h1 id="5-优缺点分析"><a href="#5-优缺点分析" class="headerlink" title="5. 优缺点分析"></a>5. 优缺点分析</h1><h2 id="5-1-优点"><a href="#5-1-优点" class="headerlink" title="5.1 优点"></a>5.1 优点</h2><ol><li>提供了对唯一实例的访问控制</li><li>因为内存中只存在一个对象，因此可以节约系统资源。尤其是对于一些需要频繁创建和销毁的对象，单例模式可以很大程度上提高系统性能</li></ol><h2 id="5-2-缺点"><a href="#5-2-缺点" class="headerlink" title="5.2 缺点"></a>5.2 缺点</h2><ol><li>扩展困难</li><li>职责相对比较重。因为单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身的功能融合到一起。</li><li>一些语言的垃圾自动回收技术，如果实例化的对象在一段时间内没有被使用，系统会认为它是垃圾，会自动销毁并回收资源。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-为什么需要单例模式&quot;&gt;&lt;a href=&quot;#1-为什么需要单例模式&quot; class=&quot;headerlink&quot; title=&quot;1. 为什么需要单例模式&quot;&gt;&lt;/a&gt;1. 为什么需要单例模式&lt;/h1&gt;&lt;p&gt;windows系统的任务管理器，只能有一个,唯一性的原因：&lt;/p
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="Design Pattern" scheme="https://www.llchen60.com/tags/Design-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>观察者模式</title>
    <link href="https://www.llchen60.com/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.llchen60.com/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-02-02T22:59:28.000Z</published>
    <updated>2020-02-04T03:23:25.771Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h1><p>观察者模式旨在描述如下行为：即一个对象的状态或者行为的变化将导致其他对象的状态或者行为也发生变化，他们之间将产生联动。为了更好地描述对象之间这种一对多(一对一)的联动，观察者模式应运而生，其定义了对象之间一种一对多的依赖关系，让一个对象的改变能够影响其他对象。</p><ul><li>Publish/ subscribe</li><li>Model/ View</li><li>Source/ Listener </li></ul><h1 id="2-概述"><a href="#2-概述" class="headerlink" title="2. 概述"></a>2. 概述</h1><p><img src="https://i.loli.net/2020/02/03/M6poTJ5PChWrReB.jpg" alt="fig1.jpg"></p><ul><li>subject<ul><li>被观察的对象</li><li>在subject当中定义了一个观察者的集合</li><li>一个观察目标可以接受任意数量的观察者来观察</li><li>定义了通知方法notify() </li></ul></li><li>concreteSubject <ul><li>具体目标，目标类的子类</li><li>通常包含<strong>经常发生改变的数据</strong>，当其状态发生改变的时候，向它的各个观察者发出通知；同时它还实现了在目标类当中定义的抽象业务逻辑方法。</li></ul></li><li>observer<ul><li>观察者将对观察目标的改变做出反应，观察者一般定义为接口，该接口声明了更新数据的方法update()</li></ul></li><li>concreteObserver<ul><li>在具体观察者中维护一个指向具体目标的对象的引用，存储具体观察者的有关状态。这些状态需要和具体目标的状态保持一致，实现了update()方法。</li></ul></li></ul><pre><code>import java.util.*;abstract class Subject {    //定义一个观察者集合用于存储所有观察者对象    protected ArrayList&lt;Observer&gt; observers= new ArrayList();    //注册方法，用于向观察者集合中增加一个观察者    public void attach(Observer observer) {        observers.add(observer);    }    //注销方法，用于在观察者集合中删除一个观察者    public void detach(Observer observer) {        observers.remove(observer);    }    //声明抽象通知方法    public abstract void notify();}class ConcreteSubject extends Subject {    //实现通知方法    public void notify() {        //遍历观察者集合，调用每一个观察者的响应方法        for(Object obs:observers) {            ((Observer)obs).update();        }    }    }interface Observer {    //声明响应方法    public void update();}class ConcreteObserver implements Observer {    //实现响应方法    public void update() {        //具体响应代码    }}</code></pre><h1 id="3-JDK对观察者模式的支持"><a href="#3-JDK对观察者模式的支持" class="headerlink" title="3. JDK对观察者模式的支持"></a>3. JDK对观察者模式的支持</h1><p><img src="https://i.loli.net/2020/02/03/tv5Zh68AQiSfIXC.jpg" alt="fig2.jpg"></p><ul><li>Observable 类<ul><li>定义了一个List来存储观察者对象</li><li>addObserver(Observer o)</li><li>deleteObserver(Observer o)</li><li>notifyObservers()</li><li>deleteObservers()</li><li>setChanged()</li><li>clearChanged()</li><li>hasChanged()</li><li>countObservers()</li></ul></li></ul><p>Observer接口还有Observable类可以直接作为观察者模式的抽象层，再自定义具体观察者类和具体的观察目标类。</p><h1 id="4-Review"><a href="#4-Review" class="headerlink" title="4. Review"></a>4. Review</h1><ul><li>优点<ul><li>实现表示层和数据逻辑层的分离，定义了稳定的消息更新传递机制，并抽象了更新接口</li><li>在观察目标和观察者之间建立一个抽象的耦合</li><li>观察目标只需要维持一个抽象观察者的集合，无须了解其具体的观察者</li></ul></li><li>缺陷<ul><li>太多观察者，都通知很耗时的</li></ul></li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://blog.csdn.net/lovelion/article/details/7720232" target="_blank" rel="noopener">https://blog.csdn.net/lovelion/article/details/7720232</a></li><li><a href="https://blog.csdn.net/LoveLion/article/details/7720490" target="_blank" rel="noopener">https://blog.csdn.net/LoveLion/article/details/7720490</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-定义&quot;&gt;&lt;a href=&quot;#1-定义&quot; class=&quot;headerlink&quot; title=&quot;1. 定义&quot;&gt;&lt;/a&gt;1. 定义&lt;/h1&gt;&lt;p&gt;观察者模式旨在描述如下行为：即一个对象的状态或者行为的变化将导致其他对象的状态或者行为也发生变化，他们之间将产生联动。为
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="Design Pattern" scheme="https://www.llchen60.com/tags/Design-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>设计模式概述</title>
    <link href="https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/"/>
    <id>https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/</id>
    <published>2020-02-02T22:58:10.000Z</published>
    <updated>2020-02-04T03:23:29.629Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-起源"><a href="#1-起源" class="headerlink" title="1. 起源"></a>1. 起源</h1><p>每个模式都描述了一个在我们的环境中不断出现的问题，然后描述了该问题的解决方案的核心，通过这种方式，我们可以无数次重用那些已有的成功的解决方案，无须再重复相同的工作。</p><p>软件模式(Software Patterns)是将模式的一般概念应用于软件开发领域，即软件开发的总体指导思路或参照样板。软件模式并非仅限于设计模式，还包括架构模式、分析模式和过程模式等，<strong><em>实际上，在软件开发生命周期的每一个阶段都存在着一些被认同的模式</em></strong>。</p><h1 id="2-软件模式的基础结构"><a href="#2-软件模式的基础结构" class="headerlink" title="2. 软件模式的基础结构"></a>2. 软件模式的基础结构</h1><ul><li>问题描述</li><li>前提条件</li><li>解法</li><li>效果</li></ul><h1 id="3-设计模式"><a href="#3-设计模式" class="headerlink" title="3. 设计模式"></a>3. 设计模式</h1><blockquote><p>设计模式(Design Pattern)是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结，使用设计模式是为了可重用代码、让代码更容易被他人理解并且保证代码可靠性。</p></blockquote><p>整个设计模式系列将会分以下几个部分：</p><ol><li><p>概述</p></li><li><p>面向对象设计原则</p><ul><li>单一职责</li><li>开闭原则</li><li>里氏代换</li><li>依赖倒转</li><li>接口隔离</li><li>合成复用</li><li>迪米特</li></ul></li><li><p>创建型模式（描述如何创建对象）</p><ul><li>简单工厂模式</li><li>工厂方法模式</li><li>抽象工厂模式</li><li>单例模式</li><li>原型模式</li><li>建造者模式</li></ul></li><li><p>结构型模式（如何实现类或对象的组合）</p><ul><li>适配器模式</li><li>桥接模式</li><li>组合模式</li><li>装饰模式</li><li>外观模式</li><li>享元模式</li><li>代理模式</li></ul></li><li><p>行为型模式（类或者对象怎样交互以及怎样分配职责）（类是对一类事物的描述，抽象出来的；而对象是具体的描述。类是一群具有相同属性的对象的集合体）</p><ul><li>职责链模式</li><li>命令模式</li><li>解释器模式</li><li>迭代器模式</li><li>中介者模式</li><li>备忘录模式</li><li>观察者模式</li><li>状态模式</li><li>策略模式</li><li>模板方法模式</li><li>访问者模式</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-起源&quot;&gt;&lt;a href=&quot;#1-起源&quot; class=&quot;headerlink&quot; title=&quot;1. 起源&quot;&gt;&lt;/a&gt;1. 起源&lt;/h1&gt;&lt;p&gt;每个模式都描述了一个在我们的环境中不断出现的问题，然后描述了该问题的解决方案的核心，通过这种方式，我们可以无数次重用那些
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="Design Pattern" scheme="https://www.llchen60.com/tags/Design-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>如何设计一个秒杀系统</title>
    <link href="https://www.llchen60.com/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/"/>
    <id>https://www.llchen60.com/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/</id>
    <published>2020-02-02T22:44:35.000Z</published>
    <updated>2020-02-04T03:23:06.520Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a>1. Overview</h1><h2 id="1-1-并发读写"><a href="#1-1-并发读写" class="headerlink" title="1.1 并发读写"></a>1.1 并发读写</h2><p>秒杀要解决的主要问题是：并发读与并发写。</p><p>并发读的优化理念是尽量减少用户到服务端来读数据，或者让他们读更少的数据；并发写的处理原则一样，要求我们在数据库层面独立出一个库，做特殊的处理。</p><p>其次，还需要针对秒杀系统做一些保护，针对意料之外的情况设计兜底方案，以防止最坏的情况发生。</p><h2 id="1-2-API设计原则"><a href="#1-2-API设计原则" class="headerlink" title="1.2 API设计原则"></a>1.2 API设计原则</h2><p>值得注意的地方是：如果想打造并维护一个超大流量并发读写、高性能、高可用的系统，在整个用户请求路径上从浏览器到服务端我们要遵循几个原则，就是保证<strong><em>用户请求的数据尽量少、请求数尽量少、路径尽量短、依赖尽量少，不要有单点</em></strong></p><h2 id="1-3-秒杀架构原则"><a href="#1-3-秒杀架构原则" class="headerlink" title="1.3 秒杀架构原则"></a>1.3 秒杀架构原则</h2><h3 id="1-3-1-高可用"><a href="#1-3-1-高可用" class="headerlink" title="1.3.1 高可用"></a>1.3.1 高可用</h3><p>整个系统架构需要满足高可用性，流量符合预期的时候肯定要稳定，就是超出预期也同样不能掉链子，保证秒杀产品顺利卖出。</p><h3 id="1-3-2-一致性"><a href="#1-3-2-一致性" class="headerlink" title="1.3.2 一致性"></a>1.3.2 一致性</h3><p>数据必须一致，即成交总量必须和设定的数量一致。</p><h3 id="1-3-3-高可用"><a href="#1-3-3-高可用" class="headerlink" title="1.3.3 高可用"></a>1.3.3 高可用</h3><p>系统的性能要足够强，支撑足够大的流量，不仅是服务端要做极致的性能优化，而且在整个请求链路上都要做协同的优化，每个地方都要快一点，整个系统就完美了。</p><p>本文将从这三个原则上来分别进行详细说明。</p><h1 id="2-架构原则"><a href="#2-架构原则" class="headerlink" title="2. 架构原则"></a>2. 架构原则</h1><p>秒杀系统本质上是一个满足大并发、高性能和高可用的分布式系统。</p><h2 id="2-1-数据尽量少"><a href="#2-1-数据尽量少" class="headerlink" title="2.1 数据尽量少"></a>2.1 数据尽量少</h2><p>用户请求的数据能少就少，请求的数据包括上传给系统的数据和系统返回给用户的数据。</p><p>因为这些数据在网络上传输需要时间，其次不管是请求数据还是返回数据都需要服务器处理，而服务器在写网络的时候通常都要做压缩和字符编码，这些都非常消耗CPU，所以减少传输的数据量可以显著减少CPU的使用。</p><p>同样，数据尽量少还要求系统依赖的数据能少就少，包括系统完成某些业务逻辑需要读取和保存的数据，这些数据一般是和后台服务以及数据库打交道的。调用其他服务会涉及数据的序列化和反序列化，这也是CPU的一大杀手，同样也会增加延时。而且数据库本身也很容易成为瓶颈，因此越少和数据库打交道越好。</p><h2 id="2-2-请求数尽量少"><a href="#2-2-请求数尽量少" class="headerlink" title="2.2 请求数尽量少"></a>2.2 请求数尽量少</h2><p>用户请求的页面返回后，浏览器渲染这个页面还要包含其他的额外请求，比如说，这个页面依赖的 CSS/JavaScript、图片，以及 Ajax 请求等等都定义为“额外请求”，这些额外请求应该尽量少。因为浏览器每发出一个请求都多少会有一些消耗，例如建立连接要做三次握手，有的时候有页面依赖或者连接数限制，一些请求（例如 JavaScript）还需要串行加载等。另外，如果不同请求的域名不一样的话，还涉及这些域名的 DNS 解析，可能会耗时更久。所以你要记住的是，减少请求数可以显著减少以上这些因素导致的资源消耗。</p><p>例如，减少请求数最常用的一个实践就是合并 CSS 和 JavaScript 文件，把多个 JavaScript 文件合并成一个文件，在 URL 中用逗号隔开（<code>https://g.xxx.com/tm/xx-b/4.0.94/mods/??module-preview/index.xtpl.js,module-jhs/index.xtpl.js,module-focus/index.xtpl.js</code>）。这种方式在服务端仍然是单个文件各自存放，只是服务端会有一个组件解析这个 URL，然后动态把这些文件合并起来一起返回。</p><h2 id="2-3-路径要尽量短"><a href="#2-3-路径要尽量短" class="headerlink" title="2.3 路径要尽量短"></a>2.3 路径要尽量短</h2><p>路径指的是用户发出请求到返回数据这个过程中需要经过的中间节点的数量。</p><p>通常，这些节点可以表示为一个系统或者一个新的 Socket 连接（比如代理服务器只是创建一个新的 Socket 连接来转发请求）。每经过一个节点，一般都会产生一个新的 Socket 连接。</p><p>然而，每增加一个连接都会增加新的不确定性。从概率统计上来说，假如一次请求经过 5 个节点，每个节点的可用性是 99.9% 的话，那么整个请求的可用性是：99.9% 的 5 次方，约等于 99.5%。</p><p>所以缩短请求路径不仅可以增加可用性，同样可以有效提升性能（减少中间节点可以减少数据的序列化与反序列化），并减少延时（可以减少网络传输耗时）。</p><p>要缩短访问路径可以将多个相互有强依赖的应用合并部署在一起，将远程过程调用变成JVM内部的方法调用。</p><h2 id="2-4-依赖要尽量少"><a href="#2-4-依赖要尽量少" class="headerlink" title="2.4 依赖要尽量少"></a>2.4 依赖要尽量少</h2><p>所谓依赖，指的是要完成一次用户请求必须依赖的系统或者服务。 </p><p>举个例子，比如说你要展示秒杀页面，而这个页面必须强依赖商品信息、用户信息，还有其他如优惠券、成交列表等这些对秒杀不是非要不可的信息（弱依赖），这些弱依赖在紧急情况下就可以去掉。</p><p>要减少依赖，我们可以给系统进行分级，比如 0 级系统、1 级系统、2 级系统、3 级系统，0 级系统如果是最重要的系统，那么 0 级系统强依赖的系统也同样是最重要的系统，以此类推。</p><p>注意，0 级系统要尽量减少对 1 级系统的强依赖，防止重要的系统被不重要的系统拖垮。例如支付系统是 0 级系统，而优惠券是 1 级系统的话，在极端情况下可以把优惠券给降级，防止支付系统被优惠券这个 1 级系统给拖垮。</p><h2 id="2-5-不要有单点"><a href="#2-5-不要有单点" class="headerlink" title="2.5 不要有单点"></a>2.5 不要有单点</h2><p>不能有单点，因为单点意味着没有备份，风险不可控，设计分布式系统的一个最重要的原则就是消除单点。</p><p>如何避免单点？ —-&gt; 避免将服务的状态和机器绑定，即把服务无状态化，这样服务就可以在机器中随意移动了。 </p><p>如何那把服务的状态和机器解耦呢？这里也有很多实现方式。例如把和机器相关的配置动态化，这些参数可以通过配置中心来动态推送，在服务启动时动态拉取下来，我们在这些配置中心设置一些规则来方便地改变这些映射关系。</p><p>应用无状态化是有效避免单点的一种方式，但是像存储服务本身很难无状态化，因为数据要存储在磁盘上，本身就要和机器绑定，那么这种场景一般要通过冗余多个备份的方式来解决单点问题。</p><h1 id="3-不同场景下的不同架构案例"><a href="#3-不同场景下的不同架构案例" class="headerlink" title="3. 不同场景下的不同架构案例"></a>3. 不同场景下的不同架构案例</h1><p>如果你想快速搭建一个简单的秒杀系统，只需要把你的商品购买页面增加一个“定时上架”功能，仅在秒杀开始时才让用户看到购买按钮，当商品的库存卖完了也就结束了。这就是当时第一个版本的秒杀系统实现方式。</p><p>但随着请求量的加大（比如从 1w/s 到了 10w/s 的量级），这个简单的架构很快就遇到了瓶颈，因此需要做架构改造来提升系统性能。这些架构改造包括：</p><ol><li>把秒杀系统独立出来单独打造一个系统，这样可以有针对性地做优化，例如这个独立出来的系统就减少了店铺装修的功能，减少了页面的复杂度；</li><li>在系统部署上也独立做一个机器集群，这样秒杀的大流量就不会影响到正常的商品购买集群的机器负载；</li><li>将热点数据（如库存数据）单独放到一个缓存系统中，以提高“读性能”；</li><li>增加秒杀答题，防止有秒杀器抢单。</li></ol><p>此时秒杀已经成为了一个独立的新系统，另外核心的一些数据放到了缓存当中，其他的关联系统也都以独立集群的方式进行部署。</p><p><img src="https://i.loli.net/2020/02/03/9RJsCGFtgbcyrhZ.jpg" alt="fig1.jpg"></p><p>但是这个架构仍然无法支持超过100w/s的请求量，因此为了进一步提高秒杀系统的性能，又对架构做了进一步的升级，比如：</p><ol><li>对页面进行彻底的动静分离，使得用户秒杀时不需要刷新整个页面，而只需要点击抢宝按钮，借此把页面刷新的数据降到最少；</li><li>在服务端对秒杀商品进行本地缓存，不需要再调用依赖系统的后台服务获取数据，甚至不需要去公共的缓存集群中查询数据，这样不仅可以减少系统调用，而且能够避免压垮公共缓存集群。</li><li>增加系统限流保护，防止最坏的情况发生</li></ol><p>此时整个系统架构变成了这个样子，已经对页面进行了进一步的静态化，秒杀过程当中就不需要刷新整个页面了，只需要向服务端请求很少的动态数据。而且最关键的详情和交易系统都增加了本地缓存，来提前缓存秒杀商品的信息，热点数据库也做了独立部署。</p><p><img src="https://i.loli.net/2020/02/03/46cK3CdURO8Yngp.jpg" alt="fig2.jpg"></p><p>从前面的几次升级来看，其实越到后面需要定制的地方越多，也就是越“不通用”。例如，把秒杀商品缓存在每台机器的内存中，这种方式显然不适合太多的商品同时进行秒杀的情况，因为单机的内存始终有限。所以要取得极致的性能，就要在其他地方（比如，通用性、易用性、成本等方面）有所牺牲。</p><h1 id="4-动静分离的方案"><a href="#4-动静分离的方案" class="headerlink" title="4. 动静分离的方案"></a>4. 动静分离的方案</h1><p>秒杀系统需要让请求效率足够高 - 提高单次请求的效率，减少没必要的请求。</p><h2 id="4-1-何为动静数据"><a href="#4-1-何为动静数据" class="headerlink" title="4.1 何为动静数据"></a>4.1 何为动静数据</h2><p>将用户请求的数据（如HTML）划分为动态数据和静态数据。而动态静态数据的划分，在于看页面中输出的数据是否和URL，浏览者，时间，地域相关，以及是否含有Cookie等私密数据。</p><ol><li>对很多媒体类的网站来说，无论谁来看文章，展示的数据都是一样的，那么哪怕这是个动态页面，它仍然是个典型的静态数据。</li><li>访问淘宝的首页，每个人看到的页面可能都是不一样的，其中包含了很多根据访问者个人信息进行的推荐，这些个性化的数据就称为动态数据。</li></ol><p>这里再强调一下，我们所说的静态数据，不能仅仅理解为传统意义上完全存在磁盘上的 HTML 页面，它也可能是经过 Java 系统产生的页面，但是它输出的页面本身不包含上面所说的那些因素。也就是所谓“动态”还是“静态”，并不是说数据本身是否动静，而是数据中是否含有和访问者相关的个性化数据。</p><p>这样做动静分离的时候，我们就可以对分离出来的静态数据做缓存，有了缓存以后，静态数据的访问效率肯定就提高了。</p><h2 id="4-2-如何对静态数据做缓存？"><a href="#4-2-如何对静态数据做缓存？" class="headerlink" title="4.2 如何对静态数据做缓存？"></a>4.2 如何对静态数据做缓存？</h2><h3 id="4-2-1-距离用户最近"><a href="#4-2-1-距离用户最近" class="headerlink" title="4.2.1 距离用户最近"></a>4.2.1 距离用户最近</h3><p>将静态数据缓存到离用户最近的地方。静态数据就是那些相对不会变化的数据，因此可以做缓存。常见的，我们可以缓存在：</p><ol><li>用户浏览器</li><li>CDN上</li><li>服务端的Cache中</li></ol><h3 id="4-2-2-静态化改造要直接缓存HTTP连接"><a href="#4-2-2-静态化改造要直接缓存HTTP连接" class="headerlink" title="4.2.2 静态化改造要直接缓存HTTP连接"></a>4.2.2 静态化改造要直接缓存HTTP连接</h3><p>系统的静态化改造是直接缓存HTTP连接而不仅仅是数据了。如下图所示，Web代理服务器根据请求URL直接去除对应的HTTP响应头和响应体然后直接返回，这个响应过程连HTTP协议都不用重新组装，甚至连HTTP请求头也不需要解析。</p><p><img src="https://i.loli.net/2020/02/03/ydBbWKCeip8jGm5.jpg" alt="fig3.jpg"></p><h3 id="4-2-3-缓存语言"><a href="#4-2-3-缓存语言" class="headerlink" title="4.2.3 缓存语言"></a>4.2.3 缓存语言</h3><p>不同语言写的cache软件处理缓存数据的效率也各不相同。以Java为例，Java不擅长处理大量连接请求，每个连接消耗的内存会比较多，Servlet容器解析HTTP协议比较慢。所以可以不在Java层做缓存，而是直接在Web服务器层上做，这样就可以屏蔽Java的一些弱点；而相比起来，Web服务器(Nginx, Apache, Varnish)会更加擅长处理大并发的静态文件请求。</p><h2 id="4-3-静态数据处理方案"><a href="#4-3-静态数据处理方案" class="headerlink" title="4.3 静态数据处理方案"></a>4.3 静态数据处理方案</h2><p>以商品详情页为例：</p><h3 id="4-3-1-URL唯一化"><a href="#4-3-1-URL唯一化" class="headerlink" title="4.3.1 URL唯一化"></a>4.3.1 URL唯一化</h3><p>要缓存整个HTTP连接，以URL作为缓存的key</p><h3 id="4-3-2-分离浏览者相关的因素"><a href="#4-3-2-分离浏览者相关的因素" class="headerlink" title="4.3.2 分离浏览者相关的因素"></a>4.3.2 分离浏览者相关的因素</h3><p>分离用户的相关信息，是否登录以及登录身份等等。</p><h3 id="4-3-3-分离时间因素"><a href="#4-3-3-分离时间因素" class="headerlink" title="4.3.3 分离时间因素"></a>4.3.3 分离时间因素</h3><p>服务端输出的是哪也通过动态请求获取</p><h3 id="4-3-4-异步化地域因素"><a href="#4-3-4-异步化地域因素" class="headerlink" title="4.3.4 异步化地域因素"></a>4.3.4 异步化地域因素</h3><p>详情页面上与地域相关的因素做成异步获取的方式</p><h3 id="4-3-5-去掉Cookie"><a href="#4-3-5-去掉Cookie" class="headerlink" title="4.3.5 去掉Cookie"></a>4.3.5 去掉Cookie</h3><p>服务端输出的页面包含的 Cookie 可以通过代码软件来删除，如 Web 服务器 Varnish 可以通过 unset req.http.cookie 命令去掉 Cookie。注意，这里说的去掉 Cookie 并不是用户端收到的页面就不含 Cookie 了，而是说，在缓存的静态数据中不含有 Cookie。</p><h2 id="4-4-动态数据处理方案"><a href="#4-4-动态数据处理方案" class="headerlink" title="4.4 动态数据处理方案"></a>4.4 动态数据处理方案</h2><h3 id="4-4-1-ESI-Edge-Side-Includes"><a href="#4-4-1-ESI-Edge-Side-Includes" class="headerlink" title="4.4.1 ESI (Edge Side Includes)"></a>4.4.1 ESI (Edge Side Includes)</h3><p>在Web代理服务器上做动态内容请求，并将请求插入到静态页面中，当用户拿到页面时已经是一个完整的页面了。对服务端性能有影响，但是用户体验会比较好</p><h3 id="4-4-2-CSI-Client-Side-Include"><a href="#4-4-2-CSI-Client-Side-Include" class="headerlink" title="4.4.2 CSI (Client Side Include)"></a>4.4.2 CSI (Client Side Include)</h3><p>单独发出异步Javascript请求，向服务端获取动态内容。这种方式服务端性能更好，但是用户端可能会有延时，体验会差一些</p><h2 id="4-5-动静分离架构方案"><a href="#4-5-动静分离架构方案" class="headerlink" title="4.5 动静分离架构方案"></a>4.5 动静分离架构方案</h2><h3 id="4-5-1-实体机单机部署"><a href="#4-5-1-实体机单机部署" class="headerlink" title="4.5.1 实体机单机部署"></a>4.5.1 实体机单机部署</h3><p>这种方案是将虚拟机改为实体机，以增大 Cache 的容量，并且采用了一致性 Hash 分组的方式来提升命中率。这里将 Cache 分成若干组，是希望能达到命中率和访问热点的平衡。Hash 分组越少，缓存的命中率肯定就会越高，但短板是也会使单个商品集中在一个分组中，容易导致 Cache 被击穿，所以我们应该适当增加多个相同的分组，来平衡访问热点和命中率的问题。</p><p>Nginx+Cache+Java结构实体机单机部署<br><img src="https://i.loli.net/2020/02/03/m6GuWRPxrk4hvK8.jpg" alt="fig4.jpg"></p><p>这种部署方式有以下几个优点：</p><ol><li>没有网络瓶颈，而且能使用大内存；</li><li>既能提升命中率，又能减少 Gzip 压缩；</li><li>减少 Cache 失效压力，因为采用定时失效方式，例如只缓存 3 秒钟，过期即自动失效。</li></ol><p>这个方案中，虽然把通常只需要虚拟机或者容器运行的 Java 应用换成实体机，优势很明显，它会增加单机的内存容量，但是一定程度上也造成了 CPU 的浪费，因为单个的 Java 进程很难用完整个实体机的 CPU。</p><p>另外就是，一个实体机上部署了 Java 应用又作为 Cache 来使用，这造成了运维上的高复杂度，所以这是一个折中的方案。如果你的公司里，没有更多的系统有类似需求，那么这样做也比较合适，如果你们有多个业务系统都有静态化改造的需求，那还是建议把 Cache 层单独抽出来公用比较合理，如下面的方案 2 所示。</p><h3 id="4-5-2-统一Cache层"><a href="#4-5-2-统一Cache层" class="headerlink" title="4.5.2 统一Cache层"></a>4.5.2 统一Cache层</h3><p>所谓统一 Cache 层，就是将单机的 Cache 统一分离出来，形成一个单独的 Cache 集群。统一 Cache 层是个更理想的可推广方案，该方案的结构图如下：</p><p><img src="https://i.loli.net/2020/02/03/oJjRUqAkN8PVGaM.jpg" alt="fig5.jpg"></p><p>统一Cache层，可以减少运维成本，也方便接入其他静态化系统，还有以下优点：</p><ol><li>单独一个 Cache 层，可以减少多个应用接入时使用 Cache 的成本。这样接入的应用只要维护自己的 Java 系统就好，不需要单独维护 Cache，而只关心如何使用即可。</li><li>统一 Cache 的方案更易于维护，如后面加强监控、配置的自动化，只需要一套解决方案就行，统一起来维护升级也比较方便。</li><li>可以共享内存，最大化利用内存，不同系统之间的内存可以动态切换，从而能够有效应对各种攻击。</li></ol><p>这种方案也会带来一些问题。比如：</p><ol><li>Cache 层内部交换网络成为瓶颈；</li><li>缓存服务器的网卡也会是瓶颈；</li><li>机器少风险较大，挂掉一台就会影响很大一部分缓存数据。</li></ol><p>要解决上面这些问题，可以再对 Cache 做 Hash 分组，即一组 Cache 缓存的内容相同，这样能够避免热点数据过度集中导致新的瓶颈产生。</p><h3 id="4-5-3-使用CDN"><a href="#4-5-3-使用CDN" class="headerlink" title="4.5.3 使用CDN"></a>4.5.3 使用CDN</h3><p>在将整个系统做动静分离后，我们自然会想到更进一步的方案，就是将 Cache 进一步前移到 CDN 上，因为 CDN 离用户最近，效果会更好。</p><p>有几个问题需要解决： </p><ol><li>失效问题</li></ol><p>前面我们也有提到过缓存时效的问题，不知道你有没有理解，我再来解释一下。谈到静态数据时，我说过一个关键词叫“相对不变”，它的言外之意是“可能会变化”。比如一篇文章，现在不变，但如果你发现个错别字，是不是就会变化了？如果你的缓存时效很长，那用户端在很长一段时间内看到的都是错的。所以，这个方案中也是，我们需要保证 CDN 可以在秒级时间内，让分布在全国各地的 Cache 同时失效，这对 CDN 的失效系统要求很高。</p><ol start="2"><li>命中率问题</li></ol><p>Cache 最重要的一个衡量指标就是“高命中率”，不然 Cache 的存在就失去了意义。同样，如果将数据全部放到全国的 CDN 上，必然导致 Cache 分散，而 Cache 分散又会导致访问请求命中同一个 Cache 的可能性降低，那么命中率就成为一个问题。</p><ol start="3"><li>发布更新问题</li></ol><p>如果一个业务系统每周都有日常业务需要发布，那么发布系统必须足够简洁高效，而且你还要考虑有问题时快速回滚和排查问题的简便性。</p><p>从前面的分析来看，将商品详情系统放到全国的所有 CDN 节点上是不太现实的，因为存在失效问题、命中率问题以及系统的发布更新问题。那么是否可以选择若干个节点来尝试实施呢？答案是“可以”，但是这样的节点需要满足几个条件：</p><ol><li>靠近访问量比较集中的地区</li><li>离主站相对较远</li><li>节点到主站间的网络比较好，比较稳定</li><li>节点容量大，不会占用其他CDN太多的资源</li></ol><p>基于上面几个因素，选择 CDN 的二级 Cache 比较合适，因为二级 Cache 数量偏少，容量也更大，让用户的请求先回源的 CDN 的二级 Cache 中，如果没命中再回源站获取数据，部署方式如下图所示：</p><p><img src="https://i.loli.net/2020/02/03/Eu5q7bATK4xFkSW.jpg" alt="fig6.jpg"></p><p>使用 CDN 的二级 Cache 作为缓存，可以达到和当前服务端静态化 Cache 类似的命中率，因为节点数不多，Cache 不是很分散，访问量也比较集中，这样也就解决了命中率问题，同时能够给用户最好的访问体验，是当前比较理想的一种 CDN 化方案。</p><h1 id="5-如何处理热点数据"><a href="#5-如何处理热点数据" class="headerlink" title="5. 如何处理热点数据"></a>5. 如何处理热点数据</h1><p>有一部分数据是会被大量用户访问的热卖商品，这部分商品是需要特殊关注的，因为其会对系统产生一系列的影响。</p><p>首先，热点请求会大量占用服务器处理资源，虽然这个热点可能占总量的很小的一部分，然而却可能抢占90%以上的服务器资源，如果这个热点请求还是没有价值的无效请求，那么对系统资源来说完全是浪费。</p><h2 id="5-1-什么是热点"><a href="#5-1-什么是热点" class="headerlink" title="5.1 什么是热点"></a>5.1 什么是热点</h2><h3 id="5-1-1-热点操作"><a href="#5-1-1-热点操作" class="headerlink" title="5.1.1 热点操作"></a>5.1.1 热点操作</h3><p>例如大量的刷新页面，大量添加购物车，零点大量的下单等。这些操作可以抽象为“读请求”和“写请求”，这两种请求的处理方式大相径庭，读请求的优化空间比较大，而写请求的瓶颈一般都在存储层，优化的思路就是根据CAP理论做平衡。</p><h3 id="5-1-2-热点数据"><a href="#5-1-2-热点数据" class="headerlink" title="5.1.2 热点数据"></a>5.1.2 热点数据</h3><p>热点数据就是用户的热点请求对应的数据，又可以分为静态热点数据和动态热点数据。</p><p>静态热点数据，就是能够提前预测的热点数据。动态热点数据，就是不能被提前预测到的，系统在运行过程中临时产生的热点。</p><h2 id="5-2-发现热点数据"><a href="#5-2-发现热点数据" class="headerlink" title="5.2 发现热点数据"></a>5.2 发现热点数据</h2><h3 id="5-2-1-发现静态热点数据"><a href="#5-2-1-发现静态热点数据" class="headerlink" title="5.2.1 发现静态热点数据"></a>5.2.1 发现静态热点数据</h3><p>如前面讲的，静态热点数据可以通过商业手段，例如强制让卖家通过报名参加的方式提前把热点商品筛选出来，实现方式是通过一个运营系统，把参加活动的商品数据进行打标，然后通过一个后台系统对这些热点商品进行预处理，如提前进行缓存。但是这种通过报名提前筛选的方式也会带来新的问题，即增加卖家的使用成本，而且实时性较差，也不太灵活。</p><p>不过，除了提前报名筛选这种方式，你还可以通过技术手段提前预测，例如对买家每天访问的商品进行大数据计算，然后统计出 TOP N 的商品，我们可以认为这些 TOP N 的商品就是热点商品。</p><h3 id="5-2-2-发现动态热点数据"><a href="#5-2-2-发现动态热点数据" class="headerlink" title="5.2.2 发现动态热点数据"></a>5.2.2 发现动态热点数据</h3><p>具体实现</p><ol><li>构建异步系统，用来收集交易链路上各个环节中的中间件产品的热点Key，例如Nginx、缓存、RPC服务框架</li><li>建立一个热点上报和可以按照需求订阅的热点服务的下发规范。因为交易链路上各个系统(包括详情，购物车，交易，优惠，库存等等)会有访问上的时间差，需要将上游已经发现的热点透传给下游系统，提前做好保护。例如，对于大促高峰期，详情系统是最早知道的。</li><li>将上游系统收集的热点数据发送到热点服务台，让下游系统提前知道信息，做热电保护</li></ol><p><img src="https://i.loli.net/2020/02/03/hGd5HWVLaEKAwZS.jpg" alt="fig7.jpg"></p><p>我们通过部署在每台机器上的 Agent 把日志汇总到聚合和分析集群中，然后把符合一定规则的热点数据，通过订阅分发系统再推送到相应的系统中。你可以是把热点数据填充到 Cache 中，或者直接推送到应用服务器的内存中，还可以对这些数据进行拦截，总之下游系统可以订阅这些数据，然后根据自己的需求决定如何处理这些数据。</p><p>Tips:</p><ol><li>热点服务的后台抓取热点数据日志的方式最好采用异步的方式；可以保证通过性，不会影响业务系统和中间件产品的主流程。</li><li>热点服务和中间件自身需要有热电保护模块，每个中间件和应用和需要保护自己</li><li>热点发现需要接近实时，因为只有接近实时才有意义，能及时对下游系统提供保护</li></ol><h2 id="5-3-如何处理热点数据"><a href="#5-3-如何处理热点数据" class="headerlink" title="5.3 如何处理热点数据"></a>5.3 如何处理热点数据</h2><h3 id="5-3-1-优化"><a href="#5-3-1-优化" class="headerlink" title="5.3.1 优化"></a>5.3.1 优化</h3><p>缓存热点数据，如果热点数据做了动静分离，那么可以长期缓存静态数据。</p><h3 id="5-3-2-限制"><a href="#5-3-2-限制" class="headerlink" title="5.3.2 限制"></a>5.3.2 限制</h3><p>保护机制，比如对商品的ASIN做一致性hash，然后根据hash做分桶，每个分桶处置一个处理队列，通过这种方式将热点商品限制在一个请求队列当中，防止因为某些热点商品占用太多的服务器资源，而使得其他请求始终得不到服务器的处理资源。 </p><h3 id="5-3-3-隔离"><a href="#5-3-3-隔离" class="headerlink" title="5.3.3 隔离"></a>5.3.3 隔离</h3><p>将热点数据隔离出来，针对热点数据可以再做优化</p><ol><li>业务隔离 - 商业逻辑上运行上的隔离</li><li>系统隔离 - 运行时的隔离</li><li>数据隔离 - 单独数据库 Cache集群</li></ol><h1 id="6-流量削峰"><a href="#6-流量削峰" class="headerlink" title="6. 流量削峰"></a>6. 流量削峰</h1><p>秒杀请求在时间上是高度集中于某一特定的时间点的，这样一来会有一个特别高的流量峰值，它对资源的消耗是瞬时的。</p><p>但是对于秒杀这个场景来说，最终能够抢到的商品的人数是固定的，并发读越高，无效请求也就越多了。</p><p>从业务角度上来说，秒杀希望更多的人能够参与进来，更多的人来刷新页面，但是真正开始下单的时候，秒杀请求就不是越多越好了，可以设计一些规则，让并发的请求更多的延缓，甚至我们可以过滤掉一些无效请求。</p><h2 id="6-1-削峰的原因"><a href="#6-1-削峰的原因" class="headerlink" title="6.1 削峰的原因"></a>6.1 削峰的原因</h2><p>我们知道服务器的处理资源是恒定的，你用或者不用它的处理能力都是一样的，所以出现峰值的话，很容易导致忙到处理不过来，闲的时候却又没有什么要处理。但是由于要保证服务质量，我们的很多处理资源只能按照忙的时候来预估，而这会导致资源的一个浪费。</p><p>削峰主要是为了能够让服务端处理变得更加平稳，也为了能够节省服务器的资源成本。从秒杀这个场景来说，就是更多延缓用户请求的发出，以便减少或者过滤掉一些无效请求，遵从请求数要尽量少的原则。</p><h2 id="6-2-无损削峰方式"><a href="#6-2-无损削峰方式" class="headerlink" title="6.2 无损削峰方式"></a>6.2 无损削峰方式</h2><h3 id="6-2-1-排队"><a href="#6-2-1-排队" class="headerlink" title="6.2.1 排队"></a>6.2.1 排队</h3><p>用消息队列缓冲瞬时流量，将同步的直接调用转换成异步的间接推送，中间通过一个队列在一端承接瞬时的流量洪峰，在另外一端平滑地将信息推送出去。</p><p><img src="https://i.loli.net/2020/02/03/dyp5UfOgsSHC3hi.jpg" alt="fig8.jpg"></p><p>但是如果流量峰值持续一段时间，超过了消息队列的处理上限，还是会被压垮的。</p><p>其他常见的排队方式有：</p><ol><li>利用线程池加锁等待</li><li>先进先出、先进后出等常用的内存排队算法的实现</li><li>将请求序列化到文件当中，然后再顺序读文件</li></ol><h3 id="6-2-2-答题"><a href="#6-2-2-答题" class="headerlink" title="6.2.2 答题"></a>6.2.2 答题</h3><p>第一个目的是防止部分买家使用秒杀器在参加秒杀时作弊。2011 年秒杀非常火的时候，秒杀器也比较猖獗，因而没有达到全民参与和营销的目的，所以系统增加了答题来限制秒杀器。增加答题后，下单的时间基本控制在 2s 后，秒杀器的下单比例也大大下降。</p><p>第二个目的其实就是延缓请求，起到对请求流量进行削峰的作用，从而让系统能够更好地支持瞬时的流量高峰。这个重要的功能就是把峰值的下单请求拉长，从以前的 1s 之内延长到 2s~10s。这样一来，请求峰值基于时间分片了。这个时间的分片对服务端处理并发非常重要，会大大减轻压力。而且，由于请求具有先后顺序，靠后的请求到来时自然也就没有库存了，因此根本到不了最后的下单步骤，所以真正的并发写就非常有限了。这种设计思路目前用得非常普遍，如当年支付宝的“咻一咻”、微信的“摇一摇”都是类似的方式。</p><h3 id="6-2-3-分层过滤"><a href="#6-2-3-分层过滤" class="headerlink" title="6.2.3 分层过滤"></a>6.2.3 分层过滤</h3><p>采用漏斗式的设计</p><p><img src="https://i.loli.net/2020/02/03/GCXLQ2UsIqElavZ.jpg" alt="fig9.jpg"></p><p>假如请求分别经过 CDN、前台读系统（如商品详情系统）、后台系统（如交易系统）和数据库这几层，那么：</p><ul><li>大部分数据和流量在用户浏览器或者 CDN 上获取，这一层可以拦截大部分数据的读取</li><li>经过第二层（即前台系统）时数据（包括强一致性的数据）尽量得走 Cache，过滤一些无效的请求</li><li>再到第三层后台系统，主要做数据的二次检验，对系统做好保护和限流，这样数据量和请求就进一步减少</li><li>最后在数据层完成数据的强一致性校验</li></ul><p>分层过滤的核心思想是：在不同的层次尽可能地过滤掉无效请求，让漏斗最末端的才是有效的请求。而达到这种效果，我们就必须对数据做分层的校验。</p><p>分层校验的基本原则有：</p><ol><li>将动态请求的读数据缓存在Web端，过滤掉无效的数据读</li><li>对读数据不做强一致性校验，减少因为一致性校验产生的瓶颈问题</li><li>对写数据进行基于时间的合理分片，过滤掉过期的失效请求</li><li>对写请求做限流保护，将超出系统承载能力的请求过滤掉</li><li>对写数据进行强一致性校验，只保留最后有效的数据</li></ol><p>分层校验的目的是：在读系统中，尽量减少由于一致性校验带来的系统瓶颈，但是尽量将不影响性能的检查条件提前，如用户是否具有秒杀资格、商品状态是否正常、用户答题是否正确、秒杀是否已经结束、是否非法请求、营销等价物是否充足等；在写数据系统中，主要对写的数据（如“库存”）做一致性检查，最后在数据库层保证数据的最终准确性（如“库存”不能减为负数）。</p><h1 id="7-影响性能的因素"><a href="#7-影响性能的因素" class="headerlink" title="7. 影响性能的因素"></a>7. 影响性能的因素</h1><h2 id="7-1-性能的定义"><a href="#7-1-性能的定义" class="headerlink" title="7.1 性能的定义"></a>7.1 性能的定义</h2><p>服务设备的不同对于性能的定义也是不一样的，例如CPU主要看主频，磁盘主要看IOPS(Input/ output Operations Per Second, 即每秒进行读写操作的次数)。</p><p>关于秒杀，我们主要讨论系统服务端的性能，一般使用QPS来衡量，还有一个影响和QPS息息相关，即响应时间(Response Time, RT)，可以理解为服务器处理响应的耗时。</p><p>正常情况下响应时间越短，一秒钟处理的请求数就会越多，这在单线程处理的情况下看起来是线性关系，即我们只要把每个请求的响应时间降到最低，那么性能就会最高。而在多线程当中，总QPS = （1000ms/ 响应时间）x 线程数，从这个角度上来看，性能和两个因素相关，一个是一次响应的服务端的耗时，一个是处理请求的线程数。</p><h3 id="7-1-1-响应时间"><a href="#7-1-1-响应时间" class="headerlink" title="7.1.1 响应时间"></a>7.1.1 响应时间</h3><p>对于大部分的Web系统而言，响应时间一般是由CPU执行时间和线程等待时间组成的，即服务器在处理一个请求时，一部分是CPU本身在做运算，还有一部分是各种等待。</p><p>理解了服务器处理请求的逻辑，估计你会说为什么我们不去减少这种等待时间。很遗憾，根据我们实际的测试发现，减少线程等待时间对提升性能的影响没有我们想象得那么大，它并不是线性的提升关系，这点在很多代理服务器（Proxy）上可以做验证。</p><p>如果代理服务器本身没有CPU消耗，我们在每次给代理服务器代理的请求加个延时，即增加响应时间，但是这对代理服务器本身的吞吐量并没有多大的影响，因为代理服务器本身的资源并没有被消耗，可以通过增加代理服务器的处理线程数，来弥补响应时间对代理服务器的 QPS 的影响。</p><p>其实，真正对性能有影响的是 CPU 的执行时间。这也很好理解，因为 CPU 的执行真正消耗了服务器的资源。经过实际的测试，如果减少 CPU 一半的执行时间，就可以增加一倍的 QPS。</p><h3 id="7-1-2-线程数"><a href="#7-1-2-线程数" class="headerlink" title="7.1.2 线程数"></a>7.1.2 线程数</h3><p>并不是线程数越多越好，总QPS就会越大，因为线程本身也消耗资源，会受到其他因素的制约。例如，线程越多系统的线程切换成本就会越高，而且每个线程都会耗费一定的内存。</p><p>默认的配置一般为：</p><blockquote><p>线程数 = 2 x CPU核数 + 1</p></blockquote><p>还有一个根据最佳实践得出来的公式为：</p><blockquote><p>线程数 = [(线程等待时间 + 线程CPU时间) / 线程CPU时间] x CPU数量</p></blockquote><p>因此要提升性能，我们就要减少CPU的执行时间，另外就是要设置一个合理的并发线程数量，通过这两方面来显著提升服务器的性能。</p><h2 id="7-2-如何发现瓶颈"><a href="#7-2-如何发现瓶颈" class="headerlink" title="7.2 如何发现瓶颈"></a>7.2 如何发现瓶颈</h2><p>服务器会出现瓶颈的地方很多，例如CPU， 内存， 磁盘以及网络等可能都会导致瓶颈。另外不同的系统对于瓶颈的关注度不一样，例如对缓存系统来说，制约的是内存，而对存储型的系统来说I/O 更容易出现瓶颈。</p><p>而对于秒杀，瓶颈更容易发生在CPU上。</p><p>那么，如何发现 CPU 的瓶颈呢？其实有很多 CPU 诊断工具可以发现 CPU 的消耗，最常用的就是 JProfiler 和 Yourkit 这两个工具，它们可以列出整个请求中每个函数的 CPU 执行时间，可以发现哪个函数消耗的 CPU 时间最多，以便你有针对性地做优化。</p><p>当然还有一些办法也可以近似地统计 CPU 的耗时，例如通过 jstack 定时地打印调用栈，如果某些函数调用频繁或者耗时较多，那么那些函数就会多次出现在系统调用栈里，这样相当于采样的方式也能够发现耗时较多的函数。</p><p>虽说秒杀系统的瓶颈大部分在 CPU，但这并不表示其他方面就一定不出现瓶颈。例如，如果海量请求涌过来，你的页面又比较大，那么网络就有可能出现瓶颈。</p><p>怎样简单地判断 CPU 是不是瓶颈呢？一个办法就是看当 QPS 达到极限时，你的服务器的 CPU 使用率是不是超过了 95%，如果没有超过，那么表示 CPU 还有提升的空间，要么是有锁限制，要么是有过多的本地 I/O 等待发生。</p><h2 id="7-3-如何优化系统"><a href="#7-3-如何优化系统" class="headerlink" title="7.3 如何优化系统"></a>7.3 如何优化系统</h2><p>针对Java来说的：</p><h3 id="7-3-1-减少编码"><a href="#7-3-1-减少编码" class="headerlink" title="7.3.1 减少编码"></a>7.3.1 减少编码</h3><p>Java的编码运行比较慢，在很多场景下，只要涉及字符串的操作都会比较消耗CPU资源，不管是磁盘IO还是网络IO，因为都需要将字符转换成字节，这个转换必须编码。</p><p>每个字符的编码都需要查表，而这种查表的操作非常耗资源，所以减少字符到字节或者相反的转换、减少字符编码会非常有成效。减少编码就可以大大提升性能。</p><p>那么如何才能减少编码呢？例如，网页输出是可以直接进行流输出的，即用 resp.getOutputStream() 函数写数据，把一些静态的数据提前转化成字节，等到真正往外写的时候再直接用 OutputStream() 函数写，就可以减少静态数据的编码转换。</p><h3 id="7-3-2-减少序列化"><a href="#7-3-2-减少序列化" class="headerlink" title="7.3.2 减少序列化"></a>7.3.2 减少序列化</h3><p>序列化也是Java性能的一大天敌，减少Java当中的序列化操作也能大大提升性能。又因为序列化往往是和编码同时发生的，所以减少序列化也就减少了编码。</p><p>序列化大部分是在 RPC 中发生的，因此避免或者减少 RPC 就可以减少序列化，当然当前的序列化协议也已经做了很多优化来提升性能。有一种新的方案，就是可以将多个关联性比较强的应用进行“合并部署”，而减少不同应用之间的 RPC 也可以减少序列化的消耗。</p><p>所谓“合并部署”，就是把两个原本在不同机器上的不同应用合并部署到一台机器上，当然不仅仅是部署在一台机器上，还要在同一个 Tomcat 容器中，且不能走本机的 Socket，这样才能避免序列化的产生。</p><h3 id="7-3-3-Java-秒杀场景的针对性优化"><a href="#7-3-3-Java-秒杀场景的针对性优化" class="headerlink" title="7.3.3 Java 秒杀场景的针对性优化"></a>7.3.3 Java 秒杀场景的针对性优化</h3><p>Java 和通用的 Web 服务器（如 Nginx 或 Apache 服务器）相比，在处理大并发的 HTTP 请求时要弱一点，所以一般我们都会对大流量的 Web 系统做静态化改造，让大部分请求和数据直接在 Nginx 服务器或者 Web 代理服务器（如 Varnish、Squid 等）上直接返回（这样可以减少数据的序列化与反序列化），而 Java 层只需处理少量数据的动态请求。针对这些请求，我们可以使用以下手段进行优化：</p><ul><li>直接使用 Servlet 处理请求。避免使用传统的 MVC 框架，这样可以绕过一大堆复杂且用处不大的处理逻辑，节省 1ms 时间（具体取决于你对 MVC 框架的依赖程度）。</li><li>直接输出流数据。使用 resp.getOutputStream() 而不是 resp.getWriter() 函数，可以省掉一些不变字符数据的编码，从而提升性能；数据输出时推荐使用 JSON 而不是模板引擎（一般都是解释执行）来输出页面。</li></ul><h3 id="7-3-4-并发读优化"><a href="#7-3-4-并发读优化" class="headerlink" title="7.3.4 并发读优化"></a>7.3.4 并发读优化</h3><p>也许有读者会觉得这个问题很容易解决，无非就是放到 Tair 缓存里面。集中式缓存为了保证命中率一般都会采用一致性 Hash，所以同一个 key 会落到同一台机器上。虽然单台缓存机器也能支撑 30w/s 的请求，但还是远不足以应对像“大秒”这种级别的热点商品。那么，该如何彻底解决单点的瓶颈呢？</p><p>答案是采用应用层的 LocalCache，即在秒杀系统的单机上缓存商品相关的数据。</p><p>那么，又如何缓存（Cache）数据呢？你需要划分成动态数据和静态数据分别进行处理：</p><ul><li>像商品中的“标题”和“描述”这些本身不变的数据，会在秒杀开始之前全量推送到秒杀机器上，并一直缓存到秒杀结束；</li><li>像库存这类动态数据，会采用“被动失效”的方式缓存一定时间（一般是数秒），失效后再去缓存拉取最新的数据。</li></ul><p>还有关于一致性的问题，因为库存是在不断更新的，这就要用到前面介绍的读数据的分层校验原则了，读的场景可以允许一定的脏数据，因为这里的误判只会导致少量原本无库存的下单请求被误认为有库存，可以等到真正写数据时再保证最终的一致性，通过在数据的高可用性和一致性之间的平衡，来解决高并发的数据读取问题。</p><h1 id="8-减库存设计的核心逻辑"><a href="#8-减库存设计的核心逻辑" class="headerlink" title="8. 减库存设计的核心逻辑"></a>8. 减库存设计的核心逻辑</h1><p>不超卖是秒杀系统的前提。减库存到底应该是在下单阶段还是付款阶段呢？ </p><h2 id="8-1-减库存的方式"><a href="#8-1-减库存的方式" class="headerlink" title="8.1 减库存的方式"></a>8.1 减库存的方式</h2><h3 id="8-1-1-下单减库存"><a href="#8-1-1-下单减库存" class="headerlink" title="8.1.1 下单减库存"></a>8.1.1 下单减库存</h3><p>即当买家下单之后，在商品的总库存中减去买家购买的数量。这种方式控制最精确，下单时直接通过数据库的事务机制控制商品库存，这样一定不会出现超卖的现象。但是有些人下完单以后并不会付款。</p><h3 id="8-1-2-付款减库存"><a href="#8-1-2-付款减库存" class="headerlink" title="8.1.2 付款减库存"></a>8.1.2 付款减库存</h3><p>即买家下单后，并不立即减库存，而是等到有用户付款后才真正减库存，否则库存一直保留给其他买家。但因为付款时才减库存，如果并发比较高，有可能出现买家下单后付不了款的情况，因为可能商品已经被其他人买走了。</p><h3 id="8-1-3-预扣库存"><a href="#8-1-3-预扣库存" class="headerlink" title="8.1.3 预扣库存"></a>8.1.3 预扣库存</h3><p>这种方式相对复杂一些，买家下单后，库存为其保留一定的时间（如 10 分钟），超过这个时间，库存将会自动释放，释放后其他买家就可以继续购买。在买家付款前，系统会校验该订单的库存是否还有保留：如果没有保留，则再次尝试预扣；如果库存不足（也就是预扣失败）则不允许继续付款；如果预扣成功，则完成付款并实际地减去库存。</p><h2 id="8-2-可能存在的问题"><a href="#8-2-可能存在的问题" class="headerlink" title="8.2 可能存在的问题"></a>8.2 可能存在的问题</h2><p>假如我们采用“下单减库存”的方式，即用户下单后就减去库存，正常情况下，买家下单后付款的概率会很高，所以不会有太大问题。但是有一种场景例外，就是当卖家参加某个活动时，此时活动的有效时间是商品的黄金售卖时间，如果有竞争对手通过恶意下单的方式将该卖家的商品全部下单，让这款商品的库存减为零，那么这款商品就不能正常售卖了。要知道，这些恶意下单的人是不会真正付款的，这正是“下单减库存”方式的不足之处。</p><p>既然“下单减库存”可能导致恶意下单，从而影响卖家的商品销售，那么有没有办法解决呢？你可能会想，采用“付款减库存”的方式是不是就可以了？的确可以。但是，“付款减库存”又会导致另外一个问题：库存超卖。</p><p>假如有 100 件商品，就可能出现 300 人下单成功的情况，因为下单时不会减库存，所以也就可能出现下单成功数远远超过真正库存数的情况，这尤其会发生在做活动的热门商品上。这样一来，就会导致很多买家下单成功但是付不了款，买家的购物体验自然比较差。</p><p>那么，既然“下单减库存”和“付款减库存”都有缺点，我们能否把两者相结合，将两次操作进行前后关联起来，下单时先预扣，在规定时间内不付款再释放库存，即采用“预扣库存”这种方式呢？</p><p>这种方案确实可以在一定程度上缓解上面的问题。但是否就彻底解决了呢？其实没有！针对恶意下单这种情况，虽然把有效的付款时间设置为 10 分钟，但是恶意买家完全可以在 10 分钟后再次下单，或者采用一次下单很多件的方式把库存减完。针对这种情况，解决办法还是要结合安全和反作弊的措施来制止。</p><p>例如，给经常下单不付款的买家进行识别打标（可以在被打标的买家下单时不减库存）、给某些类目设置最大购买件数（例如，参加活动的商品一人最多只能买 3 件），以及对重复下单不付款的操作进行次数限制等。</p><p>针对“库存超卖”这种情况，在 10 分钟时间内下单的数量仍然有可能超过库存数量，遇到这种情况我们只能区别对待：对普通的商品下单数量超过库存数量的情况，可以通过补货来解决；但是有些卖家完全不允许库存为负数的情况，那只能在买家付款时提示库存不足。</p><h2 id="8-3-大型秒杀中如何减库存"><a href="#8-3-大型秒杀中如何减库存" class="headerlink" title="8.3 大型秒杀中如何减库存"></a>8.3 大型秒杀中如何减库存</h2><p>对于一般业务系统而言，一般是预扣库存的方案，超出有效付款时间订单就会自动释放。而对于秒杀场景，一般采用下单减库存。</p><p>“下单减库存”在数据一致性上，主要就是保证大并发请求时库存数据不能为负数，也就是要保证数据库中的库存字段值不能为负数，一般我们有多种解决方案：一种是在应用程序中通过事务来判断，即保证减后库存不能为负数，否则就回滚；另一种办法是直接设置数据库的字段数据为无符号整数，这样减后库存字段值小于零时会直接执行 SQL 语句来报错；再有一种就是使用 CASE WHEN 判断语句，例如这样的 SQL 语句：</p><pre><code>UPDATE item SET inventory = CASE WHEN inventory &gt;= xxx THEN inventory-xxx ELSE inventory END</code></pre><p>秒杀商品和普通商品的减库存还是有些差异的，例如商品数量比较少，交易时间段也比较短，因此这里有一个大胆的假设，即能否把秒杀商品减库存直接放到缓存系统中实现，也就是直接在缓存中减库存或者在一个带有持久化功能的缓存系统（如 Redis）中完成呢？</p><p>如果你的秒杀商品的减库存逻辑非常单一，比如没有复杂的 SKU 库存和总库存这种联动关系的话，我觉得完全可以。但是如果有比较复杂的减库存逻辑，或者需要使用事务，你还是必须在数据库中完成减库存。</p><p>由于 MySQL 存储数据的特点，同一数据在数据库里肯定是一行存储（MySQL），因此会有大量线程来竞争 InnoDB 行锁，而并发度越高时等待线程会越多，TPS（Transaction Per Second，即每秒处理的消息数）会下降，响应时间（RT）会上升，数据库的吞吐量就会严重受影响。</p><p>这就可能引发一个问题，就是单个热点商品会影响整个数据库的性能， 导致 0.01% 的商品影响 99.99% 的商品的售卖，这是我们不愿意看到的情况。一个解决思路是遵循前面介绍的原则进行隔离，把热点商品放到单独的热点库中。但是这无疑会带来维护上的麻烦，比如要做热点数据的动态迁移以及单独的数据库等。</p><p>而分离热点商品到单独的数据库还是没有解决并发锁的问题，我们应该怎么办呢？要解决并发锁的问题，有两种办法：</p><ol><li>应用层排队</li></ol><p>按照商品维度设置队列顺序执行，这样能减少同一台机器对数据库同一行记录进行操作的并发度，同时也能控制单个商品占用数据库连接的数量，防止热点商品占用太多的数据库连接。</p><ol start="2"><li>数据库排队</li></ol><p>应用层只能做到单机的排队，但是应用机器数本身很多，这种排队方式控制并发的能力仍然有限，所以如果能在数据库层做全局排队是最理想的。阿里的数据库团队开发了针对这种 MySQL 的 InnoDB 层上的补丁程序（patch），可以在数据库层上对单行记录做到并发排队。</p><h1 id="9-如何设计兜底方案？"><a href="#9-如何设计兜底方案？" class="headerlink" title="9. 如何设计兜底方案？"></a>9. 如何设计兜底方案？</h1><h2 id="9-1-高可用建设应该从哪里着手？"><a href="#9-1-高可用建设应该从哪里着手？" class="headerlink" title="9.1 高可用建设应该从哪里着手？"></a>9.1 高可用建设应该从哪里着手？</h2><p><img src="https://i.loli.net/2020/02/03/pJX2oIyCGUVY7H5.jpg" alt="fig10.jpg"></p><ol><li>架构阶段 - 考虑系统的可扩展性和容错性，要避免出现单点问题。例如多机房单元化部署，即使某个城市的某个机房出现整体故障，仍然不会影响整体网站的运转。</li><li>编码阶段 - 保证代码的健壮性，例如涉及到远程调用的问题的时候，要设置合理的超时退出机制，防止被其他系统拖垮，也要对调用的返回结果集有预期，防止返回的结果超出程序处理的范围。即对错误异常进行捕获，对无法预料的错误要有默认处理结果。</li><li>测试阶段 - 测试主要是保证测试用例的覆盖度，保证最坏情况发生的时候，我们也有相应的处理流程。</li><li>发布阶段 - 要有紧急的回滚机制</li><li>运行阶段 - 运行态是常态，重要的是对系统的监控要准确及时，发现问题能够准确报警并且报警数据要准确详细，以便于排查问题。</li><li>故障发生 - 及时止损，例如由于程序问题导致商品价格错误，就要及时下架商品或者关闭购买链接，防止造成重大资产损失。</li></ol><p>为什么系统的高可用建设要放到整个生命周期中全面考虑？因为我们在每个环节中都可能犯错，而有些环节犯的错，你在后面是无法弥补的。例如在架构阶段，你没有消除单点问题，那么系统上线后，遇到突发流量把单点给挂了，你就只能干瞪眼，有时候想加机器都加不进去。所以高可用建设是一个系统工程，必须在每个环节都做好。</p><p>那么针对秒杀系统，我们重点介绍在遇到大流量时，应该从哪些方面来保障系统的稳定运行，所以更多的是看如何针对运行阶段进行处理，这就引出了接下来的内容：降级、限流和拒绝服务。</p><h2 id="9-2-降级"><a href="#9-2-降级" class="headerlink" title="9.2 降级"></a>9.2 降级</h2><p>所谓“降级”，就是当系统的容量达到一定程度时，限制或者关闭系统的某些非核心功能，从而把有限的资源保留给更核心的业务。它是一个有目的、有计划的执行过程，所以对降级我们一般需要有一套预案来配合执行。如果我们把它系统化，就可以通过预案系统和开关系统来实现降级。</p><p>降级方案可以这样设计：当秒杀流量达到 5w/s 时，把成交记录的获取从展示 20 条降级到只展示 5 条。“从 20 改到 5”这个操作由一个开关来实现，也就是设置一个能够从开关系统动态获取的系统参数。</p><p>这里，我给出开关系统的示意图。它分为两部分，一部分是开关控制台，它保存了开关的具体配置信息，以及具体执行开关所对应的机器列表；另一部分是执行下发开关数据的 Agent，主要任务就是保证开关被正确执行，即使系统重启后也会生效。</p><p><img src="https://i.loli.net/2020/02/03/MsuI54DXOFAKU7G.jpg" alt="fig11.jpg"></p><h2 id="9-3-限流"><a href="#9-3-限流" class="headerlink" title="9.3 限流"></a>9.3 限流</h2><p>如果说降级是牺牲了一部分次要的功能和用户的体验效果，那么限流就是更极端的一种保护措施了。限流就是当系统容量达到瓶颈时，我们需要通过限制一部分流量来保护系统，并做到既可以人工执行开关，也支持自动化保护的措施。</p><p>这里，我同样给出了限流系统的示意图。总体来说，限流既可以是在客户端限流，也可以是在服务端限流。此外，限流的实现方式既要支持 URL 以及方法级别的限流，也要支持基于 QPS 和线程的限流。</p><ul><li>客户端限流</li></ul><p>好处可以限制请求的发出，通过减少发出无用请求从而减少对系统的消耗。缺点就是当客户端比较分散时，没法设置合理的限流阈值：如果阈值设的太小，会导致服务端没有达到瓶颈时客户端已经被限制；而如果设的太大，则起不到限制的作用。</p><ul><li>服务端限流</li></ul><p>好处是可以根据服务端的性能设置合理的阈值，而缺点就是被限制的请求都是无效的请求，处理这些无效的请求本身也会消耗服务器资源。</p><p><img src="https://i.loli.net/2020/02/03/zm8P6fRyoUsclSj.jpg" alt="fig12.jpg"></p><p>在限流的实现手段上来讲，基于 QPS 和线程数的限流应用最多，最大 QPS 很容易通过压测提前获取，例如我们的系统最高支持 1w QPS 时，可以设置 8000 来进行限流保护。线程数限流在客户端比较有效，例如在远程调用时我们设置连接池的线程数，超出这个并发线程请求，就将线程进行排队或者直接超时丢弃。</p><p>限流无疑会影响用户的正常请求，所以必然会导致一部分用户请求失败，因此在系统处理这种异常时一定要设置超时时间，防止因被限流的请求不能 fast fail（快速失败）而拖垮系统。</p><h2 id="9-4-拒绝服务"><a href="#9-4-拒绝服务" class="headerlink" title="9.4 拒绝服务"></a>9.4 拒绝服务</h2><p>当系统负载达到一定阈值时，例如 CPU 使用率达到 90% 或者系统 load 值达到 2*CPU 核数时，系统直接拒绝所有请求，这种方式是最暴力但也最有效的系统保护方式。例如秒杀系统，我们在如下几个环节设计过载保护：</p><p>在最前端的 Nginx 上设置过载保护，当机器负载达到某个值时直接拒绝 HTTP 请求并返回 503 错误码，在 Java 层同样也可以设计过载保护。</p><p>拒绝服务可以说是一种不得已的兜底方案，用以防止最坏情况发生，防止因把服务器压跨而长时间彻底无法提供服务。像这种系统过载保护虽然在过载时无法提供服务，但是系统仍然可以运作，当负载下降时又很容易恢复，所以每个系统和每个环节都应该设置这个兜底方案，对系统做最坏情况下的保护。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Overview&quot;&gt;&lt;a href=&quot;#1-Overview&quot; class=&quot;headerlink&quot; title=&quot;1. Overview&quot;&gt;&lt;/a&gt;1. Overview&lt;/h1&gt;&lt;h2 id=&quot;1-1-并发读写&quot;&gt;&lt;a href=&quot;#1-1-并发读写&quot; c
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="秒杀" scheme="https://www.llchen60.com/tags/%E7%A7%92%E6%9D%80/"/>
    
  </entry>
  
</feed>
