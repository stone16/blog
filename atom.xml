<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Leilei&#39;s Blog | 磊磊的博客</title>
  
  <subtitle>Because it&#39;s there</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.llchen60.com/"/>
  <updated>2020-03-21T03:25:05.413Z</updated>
  <id>https://www.llchen60.com/</id>
  
  <author>
    <name>Leilei Chen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>KISS and YAGNI原则</title>
    <link href="https://www.llchen60.com/KISS-and-YAGNI%E5%8E%9F%E5%88%99/"/>
    <id>https://www.llchen60.com/KISS-and-YAGNI%E5%8E%9F%E5%88%99/</id>
    <published>2020-03-21T03:24:37.000Z</published>
    <updated>2020-03-21T03:25:05.413Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-KISS"><a href="#1-KISS" class="headerlink" title="1. KISS"></a>1. KISS</h1><p>Keep it simple and stupid. </p><p>这个原则相对比较范范，其实着重在说的还是从代码的可读性和可维护性两个角度来衡量代码的质量。</p><pre><code>// 第一种实现方式: 使用正则表达式public boolean isValidIpAddressV1(String ipAddress) {  if (StringUtils.isBlank(ipAddress)) return false;  String regex = &quot;^(1\\d{2}|2[0-4]\\d|25[0-5]|[1-9]\\d|[1-9])\\.&quot;          + &quot;(1\\d{2}|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)\\.&quot;          + &quot;(1\\d{2}|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)\\.&quot;          + &quot;(1\\d{2}|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)$&quot;;  return ipAddress.matches(regex);}// 第二种实现方式: 使用现成的工具类public boolean isValidIpAddressV2(String ipAddress) {  if (StringUtils.isBlank(ipAddress)) return false;  String[] ipUnits = StringUtils.split(ipAddress, &#39;.&#39;);  if (ipUnits.length != 4) {    return false;  }  for (int i = 0; i &lt; 4; ++i) {    int ipUnitIntValue;    try {      ipUnitIntValue = Integer.parseInt(ipUnits[i]);    } catch (NumberFormatException e) {      return false;    }    if (ipUnitIntValue &lt; 0 || ipUnitIntValue &gt; 255) {      return false;    }    if (i == 0 &amp;&amp; ipUnitIntValue == 0) {      return false;    }  }  return true;}// 第三种实现方式: 不使用任何工具类public boolean isValidIpAddressV3(String ipAddress) {  char[] ipChars = ipAddress.toCharArray();  int length = ipChars.length;  int ipUnitIntValue = -1;  boolean isFirstUnit = true;  int unitsCount = 0;  for (int i = 0; i &lt; length; ++i) {    char c = ipChars[i];    if (c == &#39;.&#39;) {      if (ipUnitIntValue &lt; 0 || ipUnitIntValue &gt; 255) return false;      if (isFirstUnit &amp;&amp; ipUnitIntValue == 0) return false;      if (isFirstUnit) isFirstUnit = false;      ipUnitIntValue = -1;      unitsCount++;      continue;    }    if (c &lt; &#39;0&#39; || c &gt; &#39;9&#39;) {      return false;    }    if (ipUnitIntValue == -1) ipUnitIntValue = 0;    ipUnitIntValue = ipUnitIntValue * 10 + (c - &#39;0&#39;);  }  if (ipUnitIntValue &lt; 0 || ipUnitIntValue &gt; 255) return false;  if (unitsCount != 3) return false;  return true;}</code></pre><p>相对来说，第二种实现方式会更好一些，因为细节被封装在工具类当中，可读性相对强很多；方法一直接使用正则表达式，可读性会差很多；第三种自己来处理底层的逻辑，虽然执行起来相对会快一些，但是很容易出错。</p><h1 id="2-YAGNI"><a href="#2-YAGNI" class="headerlink" title="2. YAGNI"></a>2. YAGNI</h1><p>You ain’t gonna need it. </p><p>你不会需要它。深有感触，很多时候我们想写很优雅的代码，会疯狂向后考虑，比如对于不常用的功能，有的时候哪怕就一个方法，也想搞个接口供后面的扩展来使用。过度设计，反而增加了代码的阅读成本和维护成本。</p><p>我们不应当去设计当前用不到的功能，也不应该编写现在用不到的代码。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-KISS&quot;&gt;&lt;a href=&quot;#1-KISS&quot; class=&quot;headerlink&quot; title=&quot;1. KISS&quot;&gt;&lt;/a&gt;1. KISS&lt;/h1&gt;&lt;p&gt;Keep it simple and stupid. &lt;/p&gt;
&lt;p&gt;这个原则相对比较范范，其实着重在说
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
  </entry>
  
  <entry>
    <title>SOLID - 依赖反转原则</title>
    <link href="https://www.llchen60.com/SOLID-%E4%BE%9D%E8%B5%96%E5%8F%8D%E8%BD%AC%E5%8E%9F%E5%88%99/"/>
    <id>https://www.llchen60.com/SOLID-%E4%BE%9D%E8%B5%96%E5%8F%8D%E8%BD%AC%E5%8E%9F%E5%88%99/</id>
    <published>2020-03-19T03:53:05.000Z</published>
    <updated>2020-03-19T03:53:34.823Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-控制反转-IOC-Inversion-of-Control"><a href="#1-控制反转-IOC-Inversion-of-Control" class="headerlink" title="1. 控制反转 IOC Inversion of Control"></a>1. 控制反转 IOC Inversion of Control</h1><pre><code>public class UserServiceTest {  public static boolean doTest() {    // ...   }  public static void main(String[] args) {//这部分逻辑可以放到框架中    if (doTest()) {      System.out.println(&quot;Test succeed.&quot;);    } else {      System.out.println(&quot;Test failed.&quot;);    }  }}</code></pre><p>上述代码程序员在自己控制整个代码的运行顺序和执行,可以看到如果我想增加test的话，就要在main函数里面添加，同时在UserServiceTest当中添加实例。而使用框架的话，代码就可以变成如下：</p><pre><code>public abstract class TestCase {  public void run() {    if (doTest()) {      System.out.println(&quot;Test succeed.&quot;);    } else {      System.out.println(&quot;Test failed.&quot;);    }  }  public abstract boolean doTest();}public class JunitApplication {  private static final List&lt;TestCase&gt; testCases = new ArrayList&lt;&gt;();  public static void register(TestCase testCase) {    testCases.add(testCase);  }  public static final void main(String[] args) {    for (TestCase case: testCases) {      case.run();    }  }</code></pre><p>上面的代码我们将测试的注册和运行都交给了JunitApplication了，然后我们要写新test，就让我们的concrete class extends TestCase类，来填充我们需要做的各种测试。</p><p>通过这种方式，我们实现了使用框架来控制整个代码的运转，我们使用框架来<strong>组装对象，管理整个执行流程</strong>。程序员利用框架进行开发的时候，只需要往预留的扩展点上，添加跟自己业务相关的代码，然后利用框架来驱动整个程序流程的执行。</p><p>控制反转是一种思想，有很多的具体的实现方式</p><h1 id="2-控制反转-–-依赖注入"><a href="#2-控制反转-–-依赖注入" class="headerlink" title="2. 控制反转 – 依赖注入"></a>2. 控制反转 – 依赖注入</h1><p>是控制反转的一种具体实现的方式，他的实际操作的指南是 – 不通过new（）的方式在类内部创建依赖类的对象，而是将依赖的类对象在外部创建好以后，通过构造函数，函数参数的方式传递进来给类使用。</p><pre><code>// 非依赖注入实现方式public class Notification {  private MessageSender messageSender;  public Notification() {    this.messageSender = new MessageSender(); //此处有点像hardcode  }  public void sendMessage(String cellphone, String message) {    //...省略校验逻辑等...    this.messageSender.send(cellphone, message);  }}public class MessageSender {  public void send(String cellphone, String message) {    //....  }}// 使用NotificationNotification notification = new Notification();// 依赖注入的实现方式public class Notification {  private MessageSender messageSender;  // 通过构造函数将messageSender传递进来  public Notification(MessageSender messageSender) {    this.messageSender = messageSender;  }  public void sendMessage(String cellphone, String message) {    //...省略校验逻辑等...    this.messageSender.send(cellphone, message);  }}//使用NotificationMessageSender messageSender = new MessageSender();Notification notification = new Notification(messageSender);</code></pre><p>使用依赖注入的最大好处就是，我们不需要在具体的类当中实例化其他的类，这样就实现了解耦，即他的具体实现我们可以在外部做其他方式的实例，这个时候多态也可以派上用场。可以想成我在类的内部占了个座，至于这个座具体要给谁坐，怎么坐，得等到节目要开始之前再来安排，这样我就可以举办不同的活动了。</p><pre><code>public class Notification {  private MessageSender messageSender;  public Notification(MessageSender messageSender) {    this.messageSender = messageSender;  }  public void sendMessage(String cellphone, String message) {    this.messageSender.send(cellphone, message);  }}public interface MessageSender {  void send(String cellphone, String message);}// 短信发送类public class SmsSender implements MessageSender {  @Override  public void send(String cellphone, String message) {    //....  }}// 站内信发送类public class InboxSender implements MessageSender {  @Override  public void send(String cellphone, String message) {    //....  }}//使用NotificationMessageSender messageSender = new SmsSender();Notification notification = new Notification(messageSender);</code></pre><h1 id="3-依赖反转原则"><a href="#3-依赖反转原则" class="headerlink" title="3. 依赖反转原则"></a>3. 依赖反转原则</h1><p>依赖反转 – Dependency Inversion Principle </p><blockquote><p>High-level modules shouldn’t depend on low-level modules. Both modules should depend on abstractions. In addition, abstractions shouldn’t depend on details. Details depend on abstractions.</p></blockquote><p>高层模块（high-level modules）不要依赖低层模块（low-level）。高层模块和低层模块应该通过抽象（abstractions）来互相依赖。除此之外，抽象（abstractions）不要依赖具体实现细节（details），具体实现细节（details）依赖抽象（abstractions）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-控制反转-IOC-Inversion-of-Control&quot;&gt;&lt;a href=&quot;#1-控制反转-IOC-Inversion-of-Control&quot; class=&quot;headerlink&quot; title=&quot;1. 控制反转 IOC Inversion of Contr
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="SOLID" scheme="https://www.llchen60.com/tags/SOLID/"/>
    
  </entry>
  
  <entry>
    <title>SOLID - 接口隔离原则</title>
    <link href="https://www.llchen60.com/SOLID-%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99/"/>
    <id>https://www.llchen60.com/SOLID-%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99/</id>
    <published>2020-03-17T01:26:08.000Z</published>
    <updated>2020-03-17T01:26:41.608Z</updated>
    
    <content type="html"><![CDATA[<p>接口隔离原则 – interface segregation principle </p><p>客户端不应该强迫依赖它不需要的接口。</p><h1 id="1-将接口视为一组API接口的集合"><a href="#1-将接口视为一组API接口的集合" class="headerlink" title="1. 将接口视为一组API接口的集合"></a>1. 将接口视为一组API接口的集合</h1><pre><code>public interface UserService {  boolean register(String cellphone, String password);  boolean login(String cellphone, String password);  UserInfo getUserInfoById(long id);  UserInfo getUserInfoByCellphone(String cellphone);}public class UserServiceImpl implements UserService {  //...}</code></pre><p>当我们要实现删除操作的时候，最好不要直接在UserService里面加上这个方法，因为用户服务实质上不应该被默认直接具有删除的权限，相对应的，我们应该去创建一个新的接口，里面实现有删除相关的方法，实现接口的隔离。</p><pre><code>public interface UserService {  boolean register(String cellphone, String password);  boolean login(String cellphone, String password);  UserInfo getUserInfoById(long id);  UserInfo getUserInfoByCellphone(String cellphone);}public interface RestrictedUserService {  boolean deleteUserByCellphone(String cellphone);  boolean deleteUserById(long id);}public class UserServiceImpl implements UserService, RestrictedUserService {  // ...省略实现代码...}</code></pre><h1 id="2-将接口理解为单个API接口或者函数"><a href="#2-将接口理解为单个API接口或者函数" class="headerlink" title="2. 将接口理解为单个API接口或者函数"></a>2. 将接口理解为单个API接口或者函数</h1><p>函数的设计需要功能单一，不要将多个不同的功能逻辑放在一个函数当中实现。</p><pre><code>public class Statistics {  private Long max;  private Long min;  private Long average;  private Long sum;  private Long percentile99;  private Long percentile999;  //...省略constructor/getter/setter等方法...}public Statistics count(Collection&lt;Long&gt; dataSet) {  Statistics statistics = new Statistics();  //...省略计算逻辑...  return statistics;}</code></pre><p>count方法算了太多不同的指标，应该将其分割开的。</p><pre><code>public Long max(Collection&lt;Long&gt; dataSet) { //... }public Long min(Collection&lt;Long&gt; dataSet) { //... } public Long average(Colletion&lt;Long&gt; dataSet) { //... }// ...省略其他统计函数...</code></pre><h1 id="3-将接口理解为OOP中的接口的概念"><a href="#3-将接口理解为OOP中的接口的概念" class="headerlink" title="3. 将接口理解为OOP中的接口的概念"></a>3. 将接口理解为OOP中的接口的概念</h1><p>即在设计接口的时候尽量减少大而全的接口的设计，每个接口都只做一件事情，这样子类在implement interface的时候，我们通过接口名也可以很清晰的知道在做什么，会有什么功能，也很大程度上提升了代码的复用性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;接口隔离原则 – interface segregation principle &lt;/p&gt;
&lt;p&gt;客户端不应该强迫依赖它不需要的接口。&lt;/p&gt;
&lt;h1 id=&quot;1-将接口视为一组API接口的集合&quot;&gt;&lt;a href=&quot;#1-将接口视为一组API接口的集合&quot; class=&quot;he
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="SOLID" scheme="https://www.llchen60.com/tags/SOLID/"/>
    
  </entry>
  
  <entry>
    <title>SOLID - 里氏替换原则</title>
    <link href="https://www.llchen60.com/SOLID-%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99/"/>
    <id>https://www.llchen60.com/SOLID-%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99/</id>
    <published>2020-03-14T04:33:36.000Z</published>
    <updated>2020-03-14T04:34:42.521Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Intro"><a href="#1-Intro" class="headerlink" title="1. Intro"></a>1. Intro</h1><p>里氏替代原则 - Liskov Substitution Principle </p><p>讲述的是子类对象需要能够替换程序当中父类对象出现的任何地方，并且保证原来程序的逻辑性为不变以及正确性不被破坏。</p><pre><code>public class Transporter {  private HttpClient httpClient;  public Transporter(HttpClient httpClient) {    this.httpClient = httpClient;  }  public Response sendRequest(Request request) {    // ...use httpClient to send request  }}public class SecurityTransporter extends Transporter {  private String appId;  private String appToken;  public SecurityTransporter(HttpClient httpClient, String appId, String appToken) {    super(httpClient);    this.appId = appId;    this.appToken = appToken;  }  @Override  public Response sendRequest(Request request) {    if (StringUtils.isNotBlank(appId) &amp;&amp; StringUtils.isNotBlank(appToken)) {      request.addPayload(&quot;app-id&quot;, appId);      request.addPayload(&quot;app-token&quot;, appToken);    }    return super.sendRequest(request);  }}public class Demo {      public void demoFunction(Transporter transporter) {        Reuqest request = new Request();    //...省略设置request中数据值的代码...    Response response = transporter.sendRequest(request);    //...省略其他逻辑...  }}// 里式替换原则Demo demo = new Demo();demo.demofunction(new SecurityTransporter(/*省略参数*/););</code></pre><h1 id="2-里氏替代原则-–-按照协议进行设计"><a href="#2-里氏替代原则-–-按照协议进行设计" class="headerlink" title="2. 里氏替代原则 – 按照协议进行设计"></a>2. 里氏替代原则 – 按照协议进行设计</h1><p>子类在设计的时候，应当遵守父类的行为约定。父类定义了函数的行为约定，那么子类可以改变函数的内部实现逻辑，但不能改变函数原有的行为约定。  </p><p>这里的行为约定指的是函数声明的要实现的功能；对于输入输出以及异常的约定</p><p>定义当中父类和子类之间的关系，也是可以替换成接口和实现类之间的关系的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Intro&quot;&gt;&lt;a href=&quot;#1-Intro&quot; class=&quot;headerlink&quot; title=&quot;1. Intro&quot;&gt;&lt;/a&gt;1. Intro&lt;/h1&gt;&lt;p&gt;里氏替代原则 - Liskov Substitution Principle &lt;/p&gt;
&lt;p&gt;讲
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="SOLID" scheme="https://www.llchen60.com/tags/SOLID/"/>
    
  </entry>
  
  <entry>
    <title>SOLID - 开闭原则</title>
    <link href="https://www.llchen60.com/SOLID-%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/"/>
    <id>https://www.llchen60.com/SOLID-%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/</id>
    <published>2020-03-11T03:52:23.000Z</published>
    <updated>2020-03-14T04:34:35.038Z</updated>
    
    <content type="html"><![CDATA[<p>开闭原则说的是对扩展开放，对修改关闭。我们希望做到的是使得代码有着比较好的扩展性，但是同时也不会影响到他的可读性。</p><h1 id="1-如何理解-对扩展开放，对修改关闭？"><a href="#1-如何理解-对扩展开放，对修改关闭？" class="headerlink" title="1. 如何理解 对扩展开放，对修改关闭？"></a>1. 如何理解 对扩展开放，对修改关闭？</h1><p>Open closed principle, Software entities (modules, classes, functions, etc) should be open for extension, but closed for modification. </p><p>添加一个新的功能应该是在已有代码基础上扩展代码，而非修改已有的代码。</p><h1 id="2-实例解释"><a href="#2-实例解释" class="headerlink" title="2. 实例解释"></a>2. 实例解释</h1><p>代码实现的功能就是当TPS超过某个预设的最大值的时候，或者是错误的数量超过允许的最大值，那么就会触发警报<br>    public class Alert {<br>      private AlertRule rule;<br>      private Notification notification;</p><pre><code>  public Alert(AlertRule rule, Notification notification) {    this.rule = rule;    this.notification = notification;  }  public void check(String api, long requestCount, long errorCount, long durationOfSeconds) {    long tps = requestCount / durationOfSeconds;    if (tps &gt; rule.getMatchedRule(api).getMaxTps()) {      notification.notify(NotificationEmergencyLevel.URGENCY, &quot;...&quot;);    }    if (errorCount &gt; rule.getMatchedRule(api).getMaxErrorCount()) {      notification.notify(NotificationEmergencyLevel.SEVERE, &quot;...&quot;);    }  }}</code></pre><p>现在我们需要添加一个功能，当每秒钟请求数量超过某个阈值的时候，我们也要触发警告，发送通知。</p><p>如果直接在上述代码中进行修改的话，我们主要是需要在check函数当中，添加一个新的输入参数，timeoutCount，表示超时的请求数量，然后再check函数里面加上对应的逻辑</p><pre><code>public class Alert {  // ...省略AlertRule/Notification属性和构造函数...  // 改动一：添加参数timeoutCount  public void check(String api, long requestCount, long errorCount, long timeoutCount, long durationOfSeconds) {    long tps = requestCount / durationOfSeconds;    if (tps &gt; rule.getMatchedRule(api).getMaxTps()) {      notification.notify(NotificationEmergencyLevel.URGENCY, &quot;...&quot;);    }    if (errorCount &gt; rule.getMatchedRule(api).getMaxErrorCount()) {      notification.notify(NotificationEmergencyLevel.SEVERE, &quot;...&quot;);    }    // 改动二：添加接口超时处理逻辑    long timeoutTps = timeoutCount / durationOfSeconds;    if (timeoutTps &gt; rule.getMatchedRule(api).getMaxTimeoutTps()) {      notification.notify(NotificationEmergencyLevel.URGENCY, &quot;...&quot;);    }  }}</code></pre><p>这样的改动是有不少问题的，比如我们对于传入参数做了改动，那所有调用这个函数的地方都需要进行修改，这就是个不小的问题了；而且在修改了check函数以后，所有的单元测试都需要进行修改，会很麻烦的。</p><p>为了提高这整个类的拓展性，我们可以做以下的重构操作：</p><ul><li>将check函数的多个入参封装成ApiStatInfo类</li><li>引入handler的概念，将if判断逻辑分散到各个handler当中</li></ul><pre><code>public class Alert {  private List&lt;AlertHandler&gt; alertHandlers = new ArrayList&lt;&gt;();  public void addAlertHandler(AlertHandler alertHandler) {    this.alertHandlers.add(alertHandler);  }  public void check(ApiStatInfo apiStatInfo) {    for (AlertHandler handler : alertHandlers) {      handler.check(apiStatInfo);    }  }}public class ApiStatInfo {//省略constructor/getter/setter方法  private String api;  private long requestCount;  private long errorCount;  private long durationOfSeconds;}public abstract class AlertHandler {  protected AlertRule rule;  protected Notification notification;  public AlertHandler(AlertRule rule, Notification notification) {    this.rule = rule;    this.notification = notification;  }  public abstract void check(ApiStatInfo apiStatInfo);}public class TpsAlertHandler extends AlertHandler {  public TpsAlertHandler(AlertRule rule, Notification notification) {    super(rule, notification);  }  @Override  public void check(ApiStatInfo apiStatInfo) {    long tps = apiStatInfo.getRequestCount()/ apiStatInfo.getDurationOfSeconds();    if (tps &gt; rule.getMatchedRule(apiStatInfo.getApi()).getMaxTps()) {      notification.notify(NotificationEmergencyLevel.URGENCY, &quot;...&quot;);    }  }}public class ErrorAlertHandler extends AlertHandler {  public ErrorAlertHandler(AlertRule rule, Notification notification){    super(rule, notification);  }  @Override  public void check(ApiStatInfo apiStatInfo) {    if (apiStatInfo.getErrorCount() &gt; rule.getMatchedRule(apiStatInfo.getApi()).getMaxErrorCount()) {      notification.notify(NotificationEmergencyLevel.SEVERE, &quot;...&quot;);    }  }}</code></pre><p>在使用的时候，如下：</p><pre><code>public class ApplicationContext {  private AlertRule alertRule;  private Notification notification;  private Alert alert;  public void initializeBeans() {    alertRule = new AlertRule(/*.省略参数.*/); //省略一些初始化代码    notification = new Notification(/*.省略参数.*/); //省略一些初始化代码    alert = new Alert();    alert.addAlertHandler(new TpsAlertHandler(alertRule, notification));    alert.addAlertHandler(new ErrorAlertHandler(alertRule, notification));  }  public Alert getAlert() { return alert; }  // 饿汉式单例  private static final ApplicationContext instance = new ApplicationContext();  private ApplicationContext() {    instance.initializeBeans();  }  public static ApplicationContext getInstance() {    return instance;  }}public class Demo {  public static void main(String[] args) {    ApiStatInfo apiStatInfo = new ApiStatInfo();    // ...省略设置apiStatInfo数据值的代码    ApplicationContext.getInstance().getAlert().check(apiStatInfo);  }}</code></pre><p>需要修改的地方：</p><pre><code>public class Alert { // 代码未改动... }public class ApiStatInfo {//省略constructor/getter/setter方法  private String api;  private long requestCount;  private long errorCount;  private long durationOfSeconds;  private long timeoutCount; // 改动一：添加新字段}public abstract class AlertHandler { //代码未改动... }public class TpsAlertHandler extends AlertHandler {//代码未改动...}public class ErrorAlertHandler extends AlertHandler {//代码未改动...}// 改动二：添加新的handlerpublic class TimeoutAlertHandler extends AlertHandler {//省略代码...}public class ApplicationContext {  private AlertRule alertRule;  private Notification notification;  private Alert alert;  public void initializeBeans() {    alertRule = new AlertRule(/*.省略参数.*/); //省略一些初始化代码    notification = new Notification(/*.省略参数.*/); //省略一些初始化代码    alert = new Alert();    alert.addAlertHandler(new TpsAlertHandler(alertRule, notification));    alert.addAlertHandler(new ErrorAlertHandler(alertRule, notification));    // 改动三：注册handler    alert.addAlertHandler(new TimeoutAlertHandler(alertRule, notification));  }  //...省略其他未改动代码...}public class Demo {  public static void main(String[] args) {    ApiStatInfo apiStatInfo = new ApiStatInfo();    // ...省略apiStatInfo的set字段代码    apiStatInfo.setTimeoutCount(289); // 改动四：设置tiemoutCount值    ApplicationContext.getInstance().getAlert().check(apiStatInfo);}</code></pre><h1 id="3-一些思考"><a href="#3-一些思考" class="headerlink" title="3. 一些思考"></a>3. 一些思考</h1><ul><li><p>写代码的时候就需要想想有可能会有哪些需求上的变更，如何设计代码的结构，留好扩展点。</p></li><li><p>在识别出可变部分之后，要将可变部分封装起来，隔离变化，提供抽象化的不可变接口，给上层系统来使用。当具体的实现发生变化的时候，我们只需要基于相同的抽象接口，扩展一个新的实现，这样子上游的代码就几乎不需要修改了</p></li><li><p>基于接口而非实现的编程， 对扩展开放，对修改关闭</p><p>  // 这一部分体现了抽象意识<br>  public interface MessageQueue { //… }<br>  public class KafkaMessageQueue implements MessageQueue { //… }<br>  public class RocketMQMessageQueue implements MessageQueue {//…}</p><p>  public interface MessageFormatter { //… }<br>  public class JsonMessageFormatter implements MessageFormatter {//…}<br>  public class MessageFormatter implements MessageFormatter {//…}</p><p>  public class Demo {</p><pre><code>private MessageQueue msgQueue; // 基于接口而非实现编程public Demo(MessageQueue msgQueue) { // 依赖注入  this.msgQueue = msgQueue;}// msgFormatter：多态、依赖注入public void sendNotification(Notification notification, MessageFormatter msgFormatter) {  //...    }</code></pre><p>  }</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;开闭原则说的是对扩展开放，对修改关闭。我们希望做到的是使得代码有着比较好的扩展性，但是同时也不会影响到他的可读性。&lt;/p&gt;
&lt;h1 id=&quot;1-如何理解-对扩展开放，对修改关闭？&quot;&gt;&lt;a href=&quot;#1-如何理解-对扩展开放，对修改关闭？&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="SOLID" scheme="https://www.llchen60.com/tags/SOLID/"/>
    
  </entry>
  
  <entry>
    <title>SOLID - 单一职责原则</title>
    <link href="https://www.llchen60.com/SOLID-%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99/"/>
    <id>https://www.llchen60.com/SOLID-%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99/</id>
    <published>2020-03-10T03:49:07.000Z</published>
    <updated>2020-03-10T03:50:07.853Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Intro"><a href="#1-Intro" class="headerlink" title="1. Intro"></a>1. Intro</h1><ul><li>Single Responsibility Principle - 单一职责原则<ul><li>我们希望对于一个类或者模块来说，他们都是只有一个职责的，即只完成一个功能</li><li>这个职责说的其实就是，不要设计大而全的类，应当设计粒度小，功能单一的类。</li><li>在同一个类当中的方法功能，应该是在同一个业务方向当中的</li></ul></li></ul><h1 id="2-如何判断类的职责是否单一"><a href="#2-如何判断类的职责是否单一" class="headerlink" title="2. 如何判断类的职责是否单一"></a>2. 如何判断类的职责是否单一</h1><ul><li><p>E.G</p><ul><li>如果一个类，既要处理和其他微服务的交互，又要到数据库query，那么这就是两个职责，我们就应该将这个类分割开，划分到两个不同的类当中去 </li></ul></li><li><p>E.G2</p></li></ul><pre><code>public class UserInfo {  private long userId;  private String username;  private String email;  private String telephone;  private long createTime;  private long lastLoginTime;  private String avatarUrl;  private String provinceOfAddress; // 省  private String cityOfAddress; // 市  private String regionOfAddress; // 区   private String detailedAddress; // 详细地址  // ...省略其他属性和方法...}</code></pre><p>对于上述UserInfo类来说，里面全是User的一些属性，但是其中有将近半数是关于地址的，我们有理由将其细分为UserAddress类以及UserInfo类，但是在实际应用场景当中，我们需要考虑我们到底是准备如何使用这些数据的。</p><p>如果应用场景就是拿出用户相关的信息，那放在一起无伤大雅，但是如果是要做物流，电商的场景，那么我们单独想拿出地址相关信息的场景就会比较多了，这种情况最好就分成两个不同的类了。</p><p>实际开发当中，实际上一般情况下都是先写一个粗粒度的类，以满足业务的需求，随着业务的发展，如果粗粒度的类越来越庞大，我们就可以将这个粗粒度的类拆分成几个更细粒度的类，即–持续重构。</p><h1 id="3-判断是否满足单一职责原则的判断准则"><a href="#3-判断是否满足单一职责原则的判断准则" class="headerlink" title="3. 判断是否满足单一职责原则的判断准则"></a>3. 判断是否满足单一职责原则的判断准则</h1><ul><li>类中代码的行数，函数或者属性过多，会影响代码的可读性和可维护性，需要考虑对类进行拆分了</li><li>类依赖的其他类过多，或者依赖类的其他类过多，不符合高内聚，低耦合的设计思想，我们需要对其考虑进行拆分</li><li>私有方法过多，我们需要考虑是否应该将私有方法独立到新的类当中，设置为public方法，供更多的类使用，从而提高代码的复用性</li><li>如果对于一个类，比较难取名字，只能用相对泛泛的名字，那很可能意味着这个类的职责有点过多了</li><li>类中的大量方法都是集中操作类中的某几个属性，那么就可以考虑将这几个属性和对应的方法拆分出来</li></ul><p>需要注意的一点是： 我们使用这些准则，亦或者是设计模式，最终的目的还是提高代码的可读性，可扩展性，复用性，可维护性等。这才应当是我们判断是否要采用SOLID准则，以及其他的原则的最终标准。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Intro&quot;&gt;&lt;a href=&quot;#1-Intro&quot; class=&quot;headerlink&quot; title=&quot;1. Intro&quot;&gt;&lt;/a&gt;1. Intro&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Single Responsibility Principle - 单一职责原则&lt;u
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="SOLID" scheme="https://www.llchen60.com/tags/SOLID/"/>
    
  </entry>
  
  <entry>
    <title>基于充血模型的DDD开发模型</title>
    <link href="https://www.llchen60.com/%E5%9F%BA%E4%BA%8E%E5%85%85%E8%A1%80%E6%A8%A1%E5%9E%8B%E7%9A%84DDD%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B/"/>
    <id>https://www.llchen60.com/%E5%9F%BA%E4%BA%8E%E5%85%85%E8%A1%80%E6%A8%A1%E5%9E%8B%E7%9A%84DDD%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B/</id>
    <published>2020-03-06T00:49:16.000Z</published>
    <updated>2020-03-08T17:05:14.373Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-传统基于MVC的开发模式"><a href="#1-传统基于MVC的开发模式" class="headerlink" title="1. 传统基于MVC的开发模式"></a>1. 传统基于MVC的开发模式</h1><p>MVC三层结构中的M表示Model，V表示View，C表示Controller。通过这三层将整个项目分为了三大部分，展示层，逻辑层，数据层</p><p>而贫血模型 - Anemic Domain Model，指的是我们将数据和操作分离，有专门的POJO类，即只包含数据的类，这实质上会破坏面向对象的封装特性，是一种面向过程的编程风格。</p><h1 id="2-基于充血模型的DDD开发模式"><a href="#2-基于充血模型的DDD开发模式" class="headerlink" title="2. 基于充血模型的DDD开发模式"></a>2. 基于充血模型的DDD开发模式</h1><p>充血模型 - rich domain model，旨在将数据和对应的业务逻辑封装在同一个类当中。</p><h1 id="3-实战-DDD-开发虚拟钱包系统"><a href="#3-实战-DDD-开发虚拟钱包系统" class="headerlink" title="3. 实战  DDD 开发虚拟钱包系统"></a>3. 实战  DDD 开发虚拟钱包系统</h1><h2 id="3-1-钱包业务背景介绍"><a href="#3-1-钱包业务背景介绍" class="headerlink" title="3.1 钱包业务背景介绍"></a>3.1 钱包业务背景介绍</h2><p>需要创建一个系统内的虚拟钱包账户，来支持用户的充值，提现，支付，冻结，透支，转赠，查询账户余额，查询交易流水等操作。</p><p>在这里，我们假定要去实现一个具备充值，提现, 支付，查询余额，还有查询交易流水五个功能的钱包。</p><p>其业务流程分别为：</p><ul><li>充值 <ul><li>用户通过第三方支付渠道，将自己银行卡里面的钱充值到虚拟钱包账号当中</li><li>操作流程<ul><li>从用户银行卡到应用的公共银行卡</li><li>用户虚拟钱包增加金额</li><li>记录刚刚这笔交易流水</li></ul></li></ul></li><li>支付<ul><li>实际上是一个转账的过程，从用户的虚拟钱包账户划钱到商家的虚拟钱包账户当中</li><li>记录流水信息</li></ul></li><li>提现<ul><li>用户虚拟钱包  减去对应的钱数</li><li>应用的公共银行卡 打钱 到用户的银行卡</li><li>记录交易</li></ul></li><li>查询余额<ul><li>看虚拟钱包的余额数字</li></ul></li><li>查询交易流水<ul><li>查询充值，支付，提现三种操作</li></ul></li></ul><h2 id="3-2-设计思路"><a href="#3-2-设计思路" class="headerlink" title="3.2 设计思路"></a>3.2 设计思路</h2><p>首先我们需要对系统进行解耦，即用相似特征和特性的功能放到同一个子系统当中。根据特性，我们可以分为虚拟钱包系统和三方支付系统两个部分。</p><ul><li>虚拟钱包<ul><li>用户虚拟钱包</li><li>商家虚拟钱包</li></ul></li><li>三方支付<ul><li>用户银行卡</li><li>商家银行卡</li><li>应用公共银行卡</li></ul></li></ul><p>虚拟钱包需要支持的操作基本上就是对于余额的加减，充值，提现，查询三种操作都是只涉及到一个账户的余额的加减操作；而支付功能涉及到两个账户的余额的加减操作。</p><p>而对于交易记录，应当记录的信息有：</p><ul><li>交易流水ID</li><li>交易时间</li><li>交易金额</li><li>交易类型<ul><li>充值</li><li>提现</li><li>支付</li></ul></li><li>入账钱包账号</li><li>出账钱包账号</li></ul><p>这么设计是有点浪费存储空间的，因为对于充值提现这种交易类型来说，我们只要记录一个钱包账户信息就好了。</p><p>另外一种方式就是在交易类型处，设计成支付和被支付两种类型，这样在对待转账的情况的时候，数据库写两条数据，来记录整个transaction。能够省空间，但是会有一些问题：</p><p>最重要的难点还是在数据的一致性方面，当我们在做转账操作的时候，我们必须保证加减两个操作要么都成功，要么都失败。如果一个成功，一个失败，那会完蛋的。关于钱的事情，发生一点错误就会对公司造成非常大的影响。</p><p>对于转账及类似的操作，合理的做法是在操作两个钱包的账户余额之前，先记录交易流水，并且标记为待执行，当两个钱包的加减金额都完成了之后，我们再回头将交易记录的状态标记为失败。然后我们通过后台的补漏job，拉取状态为失败或者长时间处于待执行状态的交易记录，重新执行或者人工介入处理。</p><p>另外一个点在我们会构建一个钱包系统，然后分出两个子系统，虚拟钱包还有第三方交易平台，那么我们的商业逻辑都应该放到钱包系统这一个层级上，我们希望我们的虚拟钱包还有交易平台尽量和我们的商业逻辑脱钩，更多的是事务上方法上的更泛化的东西。这样做的好处是我们的商业逻辑会经常发生变化，但是我们希望虚拟钱包，还有第三方交易平台两个模块不需要经常性的变动。这也是去做两个子系统的初衷之一。</p><h2 id="3-3-基于贫血模式的传统开发模式"><a href="#3-3-基于贫血模式的传统开发模式" class="headerlink" title="3.3 基于贫血模式的传统开发模式"></a>3.3 基于贫血模式的传统开发模式</h2><pre><code>public class VirtualWalletController {  // 通过构造函数或者IOC框架注入  private VirtualWalletService virtualWalletService;  public BigDecimal getBalance(Long walletId) { ... } //查询余额  public void debit(Long walletId, BigDecimal amount) { ... } //出账  public void credit(Long walletId, BigDecimal amount) { ... } //入账  public void transfer(Long fromWalletId, Long toWalletId, BigDecimal amount) { ...} //转账}public class VirtualWalletBo {//省略getter/setter/constructor方法  private Long id;  private Long createTime;  private BigDecimal balance;}public class VirtualWalletService {  // 通过构造函数或者IOC框架注入  private VirtualWalletRepository walletRepo;  private VirtualWalletTransactionRepository transactionRepo;  public VirtualWalletBo getVirtualWallet(Long walletId) {    VirtualWalletEntity walletEntity = walletRepo.getWalletEntity(walletId);    VirtualWalletBo walletBo = convert(walletEntity);    return walletBo;  }  public BigDecimal getBalance(Long walletId) {    return walletRepo.getBalance(walletId);  }  public void debit(Long walletId, BigDecimal amount) {    VirtualWalletEntity walletEntity = walletRepo.getWalletEntity(walletId);    BigDecimal balance = walletEntity.getBalance();    if (balance.compareTo(amount) &lt; 0) {      throw new NoSufficientBalanceException(...);    }    walletRepo.updateBalance(walletId, balance.subtract(amount));  }  public void credit(Long walletId, BigDecimal amount) {    VirtualWalletEntity walletEntity = walletRepo.getWalletEntity(walletId);    BigDecimal balance = walletEntity.getBalance();    walletRepo.updateBalance(walletId, balance.add(amount));  }  public void transfer(Long fromWalletId, Long toWalletId, BigDecimal amount) {    VirtualWalletTransactionEntity transactionEntity = new VirtualWalletTransactionEntity();    transactionEntity.setAmount(amount);    transactionEntity.setCreateTime(System.currentTimeMillis());    transactionEntity.setFromWalletId(fromWalletId);    transactionEntity.setToWalletId(toWalletId);    transactionEntity.setStatus(Status.TO_BE_EXECUTED);    Long transactionId = transactionRepo.saveTransaction(transactionEntity);    try {      debit(fromWalletId, amount);      credit(toWalletId, amount);    } catch (InsufficientBalanceException e) {      transactionRepo.updateStatus(transactionId, Status.CLOSED);      ...rethrow exception e...    } catch (Exception e) {      transactionRepo.updateStatus(transactionId, Status.FAILED);      ...rethrow exception e...    }    transactionRepo.updateStatus(transactionId, Status.EXECUTED);  }}</code></pre><h2 id="3-4-基于充血模式的DDD开发模式"><a href="#3-4-基于充血模式的DDD开发模式" class="headerlink" title="3.4 基于充血模式的DDD开发模式"></a>3.4 基于充血模式的DDD开发模式</h2><pre><code>public class VirtualWallet { // Domain领域模型(充血模型)  private Long id;  private Long createTime = System.currentTimeMillis();;  private BigDecimal balance = BigDecimal.ZERO;  public VirtualWallet(Long preAllocatedId) {    this.id = preAllocatedId;  }  public BigDecimal balance() {    return this.balance;  }  public void debit(BigDecimal amount) {    if (this.balance.compareTo(amount) &lt; 0) {      throw new InsufficientBalanceException(...);    }    this.balance.subtract(amount);  }  public void credit(BigDecimal amount) {    if (amount.compareTo(BigDecimal.ZERO) &lt; 0) {      throw new InvalidAmountException(...);    }    this.balance.add(amount);  }}public class VirtualWalletService {  // 通过构造函数或者IOC框架注入  private VirtualWalletRepository walletRepo;  private VirtualWalletTransactionRepository transactionRepo;  public VirtualWallet getVirtualWallet(Long walletId) {    VirtualWalletEntity walletEntity = walletRepo.getWalletEntity(walletId);    VirtualWallet wallet = convert(walletEntity);    return wallet;  }  public BigDecimal getBalance(Long walletId) {    return walletRepo.getBalance(walletId);  }  public void debit(Long walletId, BigDecimal amount) {    VirtualWalletEntity walletEntity = walletRepo.getWalletEntity(walletId);    VirtualWallet wallet = convert(walletEntity);    wallet.debit(amount);    walletRepo.updateBalance(walletId, wallet.balance());  }  public void credit(Long walletId, BigDecimal amount) {    VirtualWalletEntity walletEntity = walletRepo.getWalletEntity(walletId);    VirtualWallet wallet = convert(walletEntity);    wallet.credit(amount);    walletRepo.updateBalance(walletId, wallet.balance());  }  public void transfer(Long fromWalletId, Long toWalletId, BigDecimal amount) {    //...跟基于贫血模型的传统开发模式的代码一样...  }}</code></pre><p>一些思考： </p><ul><li>领域模型 希望其尽可能的独立，不包含任何其它层的代码，将流程性的代码逻辑和领域模型的业务逻辑解耦，让领域模型更加可以复用</li><li>Service类负责一些非功能性的和与第三方交互的工作 <ul><li>信息传送</li><li>metrics</li><li>日志</li></ul></li></ul><h1 id="4-实战-接口鉴权"><a href="#4-实战-接口鉴权" class="headerlink" title="4. 实战 - 接口鉴权"></a>4. 实战 - 接口鉴权</h1><p>目的是熟悉在拿到相对笼统的开发需求的时候，需要如何做需求分析，如何做职责划分，看需要定义哪些类，每个类应该具有哪些属性，方法；定义类和类的交互</p><h2 id="4-1-需求"><a href="#4-1-需求" class="headerlink" title="4.1 需求"></a>4.1 需求</h2><p>微服务系统，通过HTTP协议暴露接口给其他系统调用。需要实现一个接口鉴权系统，只有经过认证的系统才能调用我们的接口</p><ul><li>需求分析<ul><li>基础分析<ul><li>通过用户名加密码来做认证</li><li>每个允许访问的调用发都有应用ID还有秘钥，在做接口请求的时候，需要传进来应用ID和秘钥，然后我们在自己的服务器来进行验证比对。如果一致，说明认证成功，允许接口调用了否则，就拒绝</li></ul></li><li>二轮分析<ul><li>这种方式，明文传输，容易被拦截，并不安全</li><li>借助加密算法，对密码进行加密再传递到微服务端验证，同样不安全。因为还是可以被拦截，被拦截以后黑客可以直接拿着这个加密的密码加ID来假装是调用者向服务端发出请求</li><li>OAuth方式<ul><li>调用方生成token (id + appId + pwd)</li><li>调用方生成新的URL (id + appId + token)</li><li>Server解析出URL, appId, token</li><li>Server从数据库根据appId拿出pwd</li><li>Server利用Url，appId， pwd生成server端token</li><li>比较是否一致</li></ul></li></ul></li><li>三轮分析<ul><li>上述方式还是可能存在重放攻击，被拦截，然后来伪装成认证系统，调用这个URL对应的接口。</li><li>token生成过程加入时间戳，然后传递到微服务器端</li><li>微服务器收到这些数据之后，会验证当前时间戳跟传递过来的时间戳，是否在一定的时间窗口内。超过时间窗口，也会决绝请求</li></ul></li><li>四轮分析<ul><li>基本就是到这个程度，因为我们还要考虑性能方面的东西。这种方式对于性能的影响比较小，也考量到了安全性。</li><li>如何在微服务端存储每个授权调用方的appId和密码<ul><li>开发鉴权这种非业务功能，最好不要与具体的第三方系统有过度的耦合</li><li>最好能够支持多种不同的存储方式<ul><li>ZooKeeper</li><li>本地配置文件</li><li>自研配置中心</li><li>MySQL</li><li>Redis等</li></ul></li></ul></li></ul></li><li>最终需求的确定<ul><li>调用方进行接口请求的时候，将 URL、AppID、密码、时间戳拼接在一起，通过加密算法生成 token，并且将 token、AppID、时间戳拼接在 URL 中，一并发送到微服务端。</li><li>微服务端在接收到调用方的接口请求之后，从请求中拆解出 token、AppID、时间戳。</li><li>微服务端首先检查传递过来的时间戳跟当前时间，是否在 token 失效时间窗口内。如果已经超过失效时间，那就算接口调用鉴权失败，拒绝接口调用请求。</li><li>如果 token 验证没有过期失效，微服务端再从自己的存储中，取出 AppID 对应的密码，通过同样的 token 生成算法，生成另外一个 token，与调用方传递过来的 token 进行匹配；如果一致，则鉴权成功，允许接口调用，否则就拒绝接口调用。 </li></ul></li></ul></li></ul><h2 id="4-2-面向对象设计"><a href="#4-2-面向对象设计" class="headerlink" title="4.2 面向对象设计"></a>4.2 面向对象设计</h2><ul><li>进行职责划分，进而识别出都有哪些类<ul><li>将需求描述中的名词罗列出来，作为可能的候选类，然后进行筛选</li><li>或者根据需求描述，将其中涉及的功能点，一个一个罗列出来，然后再看哪些功能点职责相近，操作同样的属性，能否归到同一个类当中</li></ul></li><li>定义类，及其属性和方法</li><li>定义类和类之间的交互关系</li><li>将类组装起来并提供执行入口 </li></ul><ul><li>功能点列表<ul><li>把 URL、AppID、密码、时间戳拼接为一个字符串；</li><li>对字符串通过加密算法加密生成 token；</li><li>将 token、AppID、时间戳拼接到 URL 中，形成新的 URL；</li><li>解析 URL，得到 token、AppID、时间戳等信息；</li><li>从存储中取出 AppID 和对应的密码；</li><li>根据时间戳判断 token 是否过期失效；</li><li>验证两个 token 是否匹配； </li></ul></li></ul><p>从上面的功能列表中，我们发现，1、2、6、7 都是跟 token 有关，负责 token 的生成、验证；3、4 都是在处理 URL，负责 URL 的拼接、解析；5 是操作 AppID 和密码，负责从存储中读取 AppID 和密码。所以，我们可以粗略地得到三个核心的类：AuthToken、Url、CredentialStorage。AuthToken 负责实现 1、2、6、7 这四个操作；Url 负责 3、4 两个操作；CredentialStorage 负责 5 这个操作。</p><pre><code>// AuthToken类的实现private static final long DEFAULT_EXPIRED_TIME_INTERVAL = 1 * 60 * 1000;private String token;private long createTime;private long expiredTimeInterval = DEFAULT_EXPIRED_TIME_INTERVAL;public AuthToken(String token, long createTime);public AuthToken(String token, long createTime, long expredTImeInterval);public static AuthToken create(String baseUrl, long createTime, Map&lt;String, String&gt; params);public String getToken();public boolean isExpired();public boolean match(AuthToken authToken)</code></pre><ul><li>Tips<ul><li>并不是所有的需要的名词类的属性都会作为类的属性，有可能会作为方法的参数。选择的基准还是这个属性到底属不属于这个类，从这个角度来看的</li><li>我们有可能需要去挖掘一下在功能需求里面并没有体现的一些属性  还是需要从业务模型的角度上来看究竟需要怎么做才比较好</li></ul></li></ul><pre><code>public interface ApiAuthenticator {  void auth(String url);  void auth(ApiRequest apiRequest);}public class DefaultApiAuthenticatorImpl implements ApiAuthenticator {  private CredentialStorage credentialStorage;  public DefaultApiAuthenticator() {    this.credentialStorage = new MysqlCredentialStorage();  }  public DefaultApiAuthenticator(CredentialStorage credentialStorage) {    this.credentialStorage = credentialStorage;  }  @Override  public void auth(String url) {    ApiRequest apiRequest = ApiRequest.buildFromUrl(url);    auth(apiRequest);  }  @Override  public void auth(ApiRequest apiRequest) {    String appId = apiRequest.getAppId();    String token = apiRequest.getToken();    long timestamp = apiRequest.getTimestamp();    String originalUrl = apiRequest.getOriginalUrl();    AuthToken clientAuthToken = new AuthToken(token, timestamp);    if (clientAuthToken.isExpired()) {      throw new RuntimeException(&quot;Token is expired.&quot;);    }    String password = credentialStorage.getPasswordByAppId(appId);    AuthToken serverAuthToken = AuthToken.generate(originalUrl, appId, password, timestamp);    if (!serverAuthToken.match(clientAuthToken)) {      throw new RuntimeException(&quot;Token verfication failed.&quot;);    }  }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-传统基于MVC的开发模式&quot;&gt;&lt;a href=&quot;#1-传统基于MVC的开发模式&quot; class=&quot;headerlink&quot; title=&quot;1. 传统基于MVC的开发模式&quot;&gt;&lt;/a&gt;1. 传统基于MVC的开发模式&lt;/h1&gt;&lt;p&gt;MVC三层结构中的M表示Model，V表
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="DDD" scheme="https://www.llchen60.com/tags/DDD/"/>
    
  </entry>
  
  <entry>
    <title>组合 vs 继承</title>
    <link href="https://www.llchen60.com/%E7%BB%84%E5%90%88-vs-%E7%BB%A7%E6%89%BF/"/>
    <id>https://www.llchen60.com/%E7%BB%84%E5%90%88-vs-%E7%BB%A7%E6%89%BF/</id>
    <published>2020-03-04T04:21:56.000Z</published>
    <updated>2020-03-04T04:22:54.643Z</updated>
    
    <content type="html"><![CDATA[<p>组合还有继承都是面向对象的很重要的特性，但是有一条非常重要的设计原则说 – 组合优于继承，想在这篇博文当中分析一下为什么认为组合优于继承，以及什么情况下我们仍然应该使用继承。</p><p>继承可以表示类之间的is-a的关系，可以一定程度上解决代码复用性的问题，但是继承层次过深，也会影响到代码的可维护性。</p><h1 id="1-继承的劣势"><a href="#1-继承的劣势" class="headerlink" title="1. 继承的劣势"></a>1. 继承的劣势</h1><p>譬如 我们现在要实现一个关于哺乳动物的类，我们首先需要将哺乳动物定义为一个抽象的类</p><pre><code>public class Mammal {    public void breathWithLung() {    }}</code></pre><p>此时我们就可以实例化Monkey，Whale等一系列哺乳动物了。但是对于哺乳动物来说，他的属，科，目门类很多，海陆空都有，假设我们按照他们的行为来进行分类的话。可以分成会飞的，会游的，还有会跑的。所以就可以写如下的代码：</p><pre><code>public class flyableMammal extends Mammal {    public void fly() {    }}public class underwaterMammal extends Mammal {    public void swim() {    }}public class onLandMammal extends Mammal {    public void run() {    }}</code></pre><p>这个时候我们已经有两层的继承了，而后我们可以实例化一些哺乳动物，譬如鲸鱼，海豚，狮子等等来创建真的对象。然后问题来了，我们现在想探究会飞的动物当中，夜行的类目，那就意味着我们需要再创建一个新的层级来进行研究了。</p><p>长此以往，整个层级就会变得很深。而深度的层级意味着每当我们想真真切切去研究到底这个类做了什么的时候，我们需要去他的父类，去他的父类的父类，追本溯源，一个一个看其中定义的属性和方法，才能完全理解他做了什么。</p><p>这样子来做，首先造成了代码的可读性变得非常差，而对于类本身而言，破坏了其封装特性，将父类的实现细节暴露给了子类。在这种情况下，一旦父类代码修改，就会影响所有子类的逻辑。</p><h1 id="2-组合的优势"><a href="#2-组合的优势" class="headerlink" title="2. 组合的优势"></a>2. 组合的优势</h1><p>对于上述的场景，我们完全可以用组合的方式来实现。通过设立多个功能接口，来表示当前类的属性，譬如flyable, runnable, swimmable, etc. 通过这种方式，我们让concrete class直接implements对应的接口，并override写出自己的实现。这样子就能够解决这个问题了。</p><p>除了使用接口之外，我们也可以使用委托的方式，即仍然定于对应的接口，但是还定义了实现了接口方法的实现类，在实际使用的时候，调用实现类的方法直接使用，例子如下</p><pre><code>public interface Flyable {  void fly()；}public class FlyAbility implements Flyable {  @Override  public void fly() { //... }}//省略Tweetable/TweetAbility/EggLayable/EggLayAbilitypublic class Ostrich implements Tweetable, EggLayable {//鸵鸟  private TweetAbility tweetAbility = new TweetAbility(); //组合  private EggLayAbility eggLayAbility = new EggLayAbility(); //组合  //... 省略其他属性和方法...  @Override  public void tweet() {    tweetAbility.tweet(); // 委托  }  @Override  public void layEgg() {    eggLayAbility.layEgg(); // 委托  }}</code></pre><h1 id="3-如何判断该使用继承还是组合？"><a href="#3-如何判断该使用继承还是组合？" class="headerlink" title="3. 如何判断该使用继承还是组合？"></a>3. 如何判断该使用继承还是组合？</h1><p>组合也并不完美，组合需要对类做更细度的拆分，要定义更多的类和接口，因此在实际开发的过程当中，我们还是要根据具体的情况，来具体选择该使用继承还是组合。</p><p>如果类之间的继承结构稳定 – 不会轻易改变，继承关系比较浅 – 譬如两层到三层的继承关系，那么我们可以直接使用继承。反之，对于系统不够稳定，继承层次会很深，且关系复杂的，我们就应该尽量使用组合来替代继承了。</p><p>或者当我们想要使用多态的特性的时候，我们就需要使用继承了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;组合还有继承都是面向对象的很重要的特性，但是有一条非常重要的设计原则说 – 组合优于继承，想在这篇博文当中分析一下为什么认为组合优于继承，以及什么情况下我们仍然应该使用继承。&lt;/p&gt;
&lt;p&gt;继承可以表示类之间的is-a的关系，可以一定程度上解决代码复用性的问题，但是继承层次
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
      <category term="Composition" scheme="https://www.llchen60.com/tags/Composition/"/>
    
      <category term="Inheritance" scheme="https://www.llchen60.com/tags/Inheritance/"/>
    
  </entry>
  
  <entry>
    <title>Java 理解多态</title>
    <link href="https://www.llchen60.com/Java-%E7%90%86%E8%A7%A3%E5%A4%9A%E6%80%81/"/>
    <id>https://www.llchen60.com/Java-%E7%90%86%E8%A7%A3%E5%A4%9A%E6%80%81/</id>
    <published>2020-02-29T16:34:38.000Z</published>
    <updated>2020-02-29T16:35:36.929Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-什么是多态？"><a href="#1-什么是多态？" class="headerlink" title="1. 什么是多态？"></a>1. 什么是多态？</h1><p>多态目的是为了分离做什么和怎么做，从而实现接口和实现的分离。通过多态，可以改善代码的组织结构和可读性，最重要的是能够创建可扩展的程序。</p><p>有继承关系的类，子类重写父类的方法，然后父类的引用指向子类。通过这种方式，就可以对于父类的声明指向子类的实际对象，</p><h1 id="2-为什么需要多态？"><a href="#2-为什么需要多态？" class="headerlink" title="2. 为什么需要多态？"></a>2. 为什么需要多态？</h1><p>多态的好处很多，令代码可扩展，解耦接口与实现，让代码对于改动封闭，对于扩展开放, etc. 如果直接从代码的角度来看，我们可以比较直观的看到他的优势</p><pre><code>public class Animal {    public void move() {        System.out.println(&quot;Animal move&quot;);    }}public class Cat extends Animal {    @Override    public void move() {        System.out.println(&quot;cat climb&quot;);    }}public calss Dog entends Animal {    @Override    public void move() {        System.out.println(&quot;dog run&quot;);    }}public static void main(String [] args) {    Animal animal = new Cat();    animal.move();    // output: cat climb}</code></pre><p>通过这种方式可以实现接口与实现的解耦。</p><h1 id="3-多态和继承的关系"><a href="#3-多态和继承的关系" class="headerlink" title="3. 多态和继承的关系"></a>3. 多态和继承的关系</h1><p>继承指在子类当中使用父类的数据和方法</p><p>多态指在子类当中改变父类的行为。</p><h1 id="4-构造器内部的多态方法的行为"><a href="#4-构造器内部的多态方法的行为" class="headerlink" title="4. 构造器内部的多态方法的行为"></a>4. 构造器内部的多态方法的行为</h1><p>如果在一个构造器的内部调用正在构造的对象的某个动态绑定的方法，会出现一些不可知的错误。</p><p>因为构造器内部的动态绑定意味着要用到方法被覆盖以后的定义，而这意味着被覆盖的方法在对象被完全构造之前就会被调用了，</p><pre><code>class Graph {    void draw() {        print(&quot;Graph draw()&quot;);    }    Graph() {        print(&quot;Graph() before draw()&quot;);        draw();        print(&quot;Graph() after draw()&quot;);    }}class RoundGraph extends Graph {    private int radius = 1;    RoundGraph(int r) {        radius = r;        print(&quot;RoundGraph.RoundGraph(), radius = &quot; + radius);    }    void draw() {        print(&quot;RoundGraph.draw(), radius = &quot; + radius);    }}public class PolyConstructors {    public static void main(String[] args) {        new RoundGraph(5);    }}// All output Graph() before draw()RoundGraph.draw(), radius = 0Graph() after draw()ROundGraph,RoundGraph(), radius = 5</code></pre><p>有这样的输出的原因是当我们实例化R欧尼的Graph的时候，会调用基类的构造器，在Graph类的构造器当中调用了draw()方法，这个时候动态绑定，是要去调用RoundGraph类的draw方法的，但是这个时候还在构建Graph 的实例，RoundGraph还没有构建好，所以就出现了返回的Radius刚开始值为0的问题了</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li>Thinking in Java Ch.8 </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-什么是多态？&quot;&gt;&lt;a href=&quot;#1-什么是多态？&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是多态？&quot;&gt;&lt;/a&gt;1. 什么是多态？&lt;/h1&gt;&lt;p&gt;多态目的是为了分离做什么和怎么做，从而实现接口和实现的分离。通过多态，可以改善代码的组织
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
      <category term="Polymorphism" scheme="https://www.llchen60.com/tags/Polymorphism/"/>
    
  </entry>
  
  <entry>
    <title>理解面向对象</title>
    <link href="https://www.llchen60.com/%E7%90%86%E8%A7%A3%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>https://www.llchen60.com/%E7%90%86%E8%A7%A3%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</id>
    <published>2020-02-25T05:20:52.000Z</published>
    <updated>2020-03-04T01:43:08.660Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博文主要想说面向对象的几大特性：封装，抽象，继承，多态，以及我们究竟如何去使用。</p><h1 id="1-面向对象概述"><a href="#1-面向对象概述" class="headerlink" title="1. 面向对象概述"></a>1. 面向对象概述</h1><h2 id="1-1-面向对象编程"><a href="#1-1-面向对象编程" class="headerlink" title="1.1 面向对象编程"></a>1.1 面向对象编程</h2><p>一种编程范式/风格，以类或对象作为组织代码的基本单元，并将封装，抽象，继承，多态四个特性作为代码设计和实现的基石。</p><p>整个编程的过程：</p><ul><li>Object Oriented Analysis</li><li>Object Oriented Design</li><li>Object Oriented Programming </li></ul><h2 id="1-2-面向对象编程的四大特征"><a href="#1-2-面向对象编程的四大特征" class="headerlink" title="1.2 面向对象编程的四大特征"></a>1.2 面向对象编程的四大特征</h2><h3 id="1-2-1-封装-Encapsulation"><a href="#1-2-1-封装-Encapsulation" class="headerlink" title="1.2.1 封装 Encapsulation"></a>1.2.1 封装 Encapsulation</h3><pre><code>public class Wallet {  private String id;  private long createTime;  private BigDecimal balance;  private long balanceLastModifiedTime;  // ...省略其他属性...  public Wallet() {     this.id = IdGenerator.getInstance().generate();     this.createTime = System.currentTimeMillis();     this.balance = BigDecimal.ZERO;     this.balanceLastModifiedTime = System.currentTimeMillis();  }  // 注意：下面对get方法做了代码折叠，是为了减少代码所占文章的篇幅  public String getId() { return this.id; }  public long getCreateTime() { return this.createTime; }  public BigDecimal getBalance() { return this.balance; }  public long getBalanceLastModifiedTime() { return this.balanceLastModifiedTime;  }  public void increaseBalance(BigDecimal increasedAmount) {    if (increasedAmount.compareTo(BigDecimal.ZERO) &lt; 0) {      throw new InvalidAmountException(&quot;...&quot;);    }    this.balance.add(increasedAmount);    this.balanceLastModifiedTime = System.currentTimeMillis();  }  public void decreaseBalance(BigDecimal decreasedAmount) {    if (decreasedAmount.compareTo(BigDecimal.ZERO) &lt; 0) {      throw new InvalidAmountException(&quot;...&quot;);    }    if (decreasedAmount.compareTo(this.balance) &gt; 0) {      throw new InsufficientAmountException(&quot;...&quot;);    }    this.balance.subtract(decreasedAmount);    this.balanceLastModifiedTime = System.currentTimeMillis();  }}</code></pre><p>虚拟钱包，对于自身变量，用private来标注，然后通过对应的getter，setter方法允许外界来访问一部分变量，允许进行一定的修改。</p><p>没有封装则意味着不可控，即任何代码都可以被任何人访问，修改的代码可以遍布在包的任何角落，会影响代码的可读性，以及可维护性。只暴露出有限多的接口，供外界来使用。</p><p>总结： 封装是为了隐藏信息，保护数据</p><h3 id="1-2-2-继承-Inheritance"><a href="#1-2-2-继承-Inheritance" class="headerlink" title="1.2.2 继承 Inheritance"></a>1.2.2 继承 Inheritance</h3><p>用来表述is a的关系，java支持单继承。</p><p>继承最大的好处就是代码复用，比如两个子类的共同代码抽取到父类当中，然后父类来共同使用。</p><p>但是过度使用的话会容易导致层级数量太多，反而降低代码的可读性。</p><h3 id="1-2-3-多态-Polymorphism"><a href="#1-2-3-多态-Polymorphism" class="headerlink" title="1.2.3 多态 Polymorphism"></a>1.2.3 多态 Polymorphism</h3><ul><li>继承加方法重写实现</li></ul><pre><code>public class DynamicArray {  private static final int DEFAULT_CAPACITY = 10;  protected int size = 0;  protected int capacity = DEFAULT_CAPACITY;  protected Integer[] elements = new Integer[DEFAULT_CAPACITY];  public int size() { return this.size; }  public Integer get(int index) { return elements[index];}  //...省略n多方法...  public void add(Integer e) {    ensureCapacity();    elements[size++] = e;  }  protected void ensureCapacity() {    //...如果数组满了就扩容...代码省略...  }}public class SortedDynamicArray extends DynamicArray {  @Override  public void add(Integer e) {    ensureCapacity();    int i;    for (i = size-1; i&gt;=0; --i) { //保证数组中的数据有序      if (elements[i] &gt; e) {        elements[i+1] = elements[i];      } else {        break;      }    }    elements[i+1] = e;    ++size;  }}public class Example {  public static void test(DynamicArray dynamicArray) {    dynamicArray.add(5);    dynamicArray.add(1);    dynamicArray.add(3);    for (int i = 0; i &lt; dynamicArray.size(); ++i) {      System.out.println(dynamicArray.get(i));    }  }  public static void main(String args[]) {    DynamicArray dynamicArray = new SortedDynamicArray();    test(dynamicArray); // 打印结果：1、3、5  }}</code></pre><ul><li>利用接口类实现多态特性</li></ul><pre><code>public interface Iterator {  String hasNext();  String next();  String remove();}public class Array implements Iterator {  private String[] data;  public String hasNext() { ... }  public String next() { ... }  public String remove() { ... }  //...省略其他方法...}public class LinkedList implements Iterator {  private LinkedListNode head;  public String hasNext() { ... }  public String next() { ... }  public String remove() { ... }  //...省略其他方法... }public class Demo {  private static void print(Iterator iterator) {    while (iterator.hasNext()) {      System.out.println(iterator.next());    }  }  public static void main(String[] args) {    Iterator arrayIterator = new Array();    print(arrayIterator);    Iterator linkedListIterator = new LinkedList();    print(linkedListIterator);  }}</code></pre><p>多态可以很大程度上提高代码的可扩展性和复用性</p><h3 id="1-2-4-抽象-Abstraction"><a href="#1-2-4-抽象-Abstraction" class="headerlink" title="1.2.4 抽象 Abstraction"></a>1.2.4 抽象 Abstraction</h3><p>抽象，主要是为了隐藏方法的具体实现，让调用者只需要关心方法提供了哪些功能，并不需要知道这些方法具体是如何实现的。</p><pre><code>public interface IPictureStorage {  void savePicture(Picture picture);  Image getPicture(String pictureId);  void deletePicture(String pictureId);  void modifyMetaInfo(String pictureId, PictureMetaInfo metaInfo);}public class PictureStorage implements IPictureStorage {  // ...省略其他属性...  @Override  public void savePicture(Picture picture) { ... }  @Override  public Image getPicture(String pictureId) { ... }  @Override  public void deletePicture(String pictureId) { ... }  @Override  public void modifyMetaInfo(String pictureId, PictureMetaInfo metaInfo) { ... }}</code></pre><p>使用接口或者abstract class，然后调用者就只需要知道需要传入什么参数，传出什么参数，就可以试用了。</p><h1 id="2-面向对象-vs-面向过程"><a href="#2-面向对象-vs-面向过程" class="headerlink" title="2. 面向对象 vs 面向过程"></a>2. 面向对象 vs 面向过程</h1><p>需要对这两个概念有更深的理解，很多时候，我们是在用面向对象的语言写面向过程的代码，对于到底什么是面向对象，如何写真的面向对象的代码，我们还是有很多无法确定的地方。</p><p>面向过程的编程是一种编程范式，以过程(方法，函数，操作)作为组织代码的基本单元，以数据(可以理解为成员变量，属性)与方法相分离为最主要的特点。面向过程风格是一种流程化的编程风格，通过拼接一组顺序执行的方法来操作数据完成一项功能。</p><h2 id="2-1-面向对象编程的优势"><a href="#2-1-面向对象编程的优势" class="headerlink" title="2.1 面向对象编程的优势"></a>2.1 面向对象编程的优势</h2><h3 id="2-1-1-更能够应对大规模复杂程序的开发"><a href="#2-1-1-更能够应对大规模复杂程序的开发" class="headerlink" title="2.1.1 更能够应对大规模复杂程序的开发"></a>2.1.1 更能够应对大规模复杂程序的开发</h3><p>因为对于面向过程的编程风格来说，整个程序的处理流程会偏向于线性，流程化，但是实际应用场景中，关系错综复杂，会很难将程序拆解为一组顺序执行的方法。而面向对象的方式就可以比较好的解决这个问题了。</p><h3 id="2-1-2-更易复用，扩展和维护"><a href="#2-1-2-更易复用，扩展和维护" class="headerlink" title="2.1.2 更易复用，扩展和维护"></a>2.1.2 更易复用，扩展和维护</h3><p>面向对象通过类这种组织方式能够将数据和方法绑定在一起，通过访问权限控制，只允许外部调用者通过类暴露的有限方法访问数据，而不会像面向过程编程那样，数据可以被任意方法的随意修改</p><p>我们通过使用多态的特性，可以在需要修改一个功能实现的时候，通过实现一个新的子类的方式，在子类当中重写原来的功能逻辑，用子类替代父类。 —- 对修改关闭，对扩展开放。</p><h2 id="2-2-Warning-Bad-Smell-看似面向对象的面向过程的代码"><a href="#2-2-Warning-Bad-Smell-看似面向对象的面向过程的代码" class="headerlink" title="2.2 Warning/ Bad Smell - 看似面向对象的面向过程的代码"></a>2.2 Warning/ Bad Smell - 看似面向对象的面向过程的代码</h2><p>首先值得注意的是，这里提及的都是我们需要注意的地方，但并不是说我们完全不能这样子写。譬如util class，很多时候我们是需要的，因为确实可以不带数据的，只在input，output传递所有信息就够了。</p><h3 id="2-2-1-getter-setter方法的问题"><a href="#2-2-1-getter-setter方法的问题" class="headerlink" title="2.2.1 getter setter方法的问题"></a>2.2.1 getter setter方法的问题</h3><p>当我们习惯性的给所有的属性都加上getter， setter方法的时候，其实是破坏了Java的封装的特性的，我们使用private 标注属性，再适当的设置setter，getter方法是因为我们不想将对于代码/数据的控制权交给他人，而疯狂的getter，setter方法会让Java的封装优势荡然无存，只是从原来的直接访问属性变成通过getter，setter方法来访问。没有起到任何保障安全的作用。</p><p>注意如果是集合容器的话，要防范集合内部的数据被修改的危险。另外，setter方法的使用需要谨慎些，只有在必需的时候再用。</p><h3 id="2-2-2-全局变量和全局方法"><a href="#2-2-2-全局变量和全局方法" class="headerlink" title="2.2.2 全局变量和全局方法"></a>2.2.2 全局变量和全局方法</h3><p>常见的全局变量有：</p><ul><li>单例类对象</li><li>静态成员变量</li><li>常量</li></ul><p>常见的全局方法有：</p><ul><li>静态方法</li></ul><p>Constants类往往会越加越大，而且会很难维护。而且如果我们开发的其他项目需要复用这些constants，哪怕我们只使用一个，那么最终也会不得不将整个文件加载进去，没有必要，而且会变得非常的慢。我们可以将Constants类拆分为功能更加单一的多个类，或者直接将这些常量定义到对应的class当中。这也是个很好的选择。</p><h2 id="3-1-什么是接口？-什么是抽象类？"><a href="#3-1-什么是接口？-什么是抽象类？" class="headerlink" title="3.1 什么是接口？ 什么是抽象类？"></a>3.1 什么是接口？ 什么是抽象类？</h2><h3 id="3-1-1-抽象类定义"><a href="#3-1-1-抽象类定义" class="headerlink" title="3.1.1 抽象类定义"></a>3.1.1 抽象类定义</h3><p>下面是一个模板设计的实例，Logger被用来记录日志，FileLogger和MessageQueueLogger继承Logger，分别实现两种不同的日志记录方式</p><pre><code>// 抽象类public abstract class Logger {  private String name;  private boolean enabled;  private Level minPermittedLevel;  public Logger(String name, boolean enabled, Level minPermittedLevel) {    this.name = name;    this.enabled = enabled;    this.minPermittedLevel = minPermittedLevel;  }  public void log(Level level, String message) {    boolean loggable = enabled &amp;&amp; (minPermittedLevel.intValue() &lt;= level.intValue());    if (!loggable) return;    doLog(level, message);  }  protected abstract void doLog(Level level, String message);}// 抽象类的子类：输出日志到文件public class FileLogger extends Logger {  private Writer fileWriter;  public FileLogger(String name, boolean enabled,    Level minPermittedLevel, String filepath) {    super(name, enabled, minPermittedLevel);    this.fileWriter = new FileWriter(filepath);   }  @Override  public void doLog(Level level, String mesage) {    // 格式化level和message,输出到日志文件    fileWriter.write(...);  }}// 抽象类的子类: 输出日志到消息中间件(比如kafka)public class MessageQueueLogger extends Logger {  private MessageQueueClient msgQueueClient;  public MessageQueueLogger(String name, boolean enabled,    Level minPermittedLevel, MessageQueueClient msgQueueClient) {    super(name, enabled, minPermittedLevel);    this.msgQueueClient = msgQueueClient;  }  @Override  protected void doLog(Level level, String mesage) {    // 格式化level和message,输出到消息中间件    msgQueueClient.send(...);  }}</code></pre><p>抽象类的特性：</p><ul><li>抽象类不允许被实例化，只能被继承  </li><li>抽象类可以包含属性与方法，方法可以包含代码实现，也可以不包含，设计成抽象方法</li><li>子类继承抽象类，必须实现抽象类当中的所有抽象方法</li></ul><h3 id="3-1-2-接口定义"><a href="#3-1-2-接口定义" class="headerlink" title="3.1.2 接口定义"></a>3.1.2 接口定义</h3><pre><code>// 接口public interface Filter {  void doFilter(RpcRequest req) throws RpcException;}// 接口实现类：鉴权过滤器public class AuthencationFilter implements Filter {  @Override  public void doFilter(RpcRequest req) throws RpcException {    //...鉴权逻辑..  }}// 接口实现类：限流过滤器public class RateLimitFilter implements Filter {  @Override  public void doFilter(RpcRequest req) throws RpcException {    //...限流逻辑...  }}// 过滤器使用demopublic class Application {  // filters.add(new AuthencationFilter());  // filters.add(new RateLimitFilter());  private List&lt;Filter&gt; filters = new ArrayList&lt;&gt;();  public void handleRpcRequest(RpcRequest req) {    try {      for (Filter filter : fitlers) {        filter.doFilter(req);      }    } catch(RpcException e) {      // ...处理过滤结果...    }    // ...省略其他处理逻辑...  }}</code></pre><p>使用interface关键字实现一个Filter接口，AuthencationFilter和RatelimiterFilter分别实现对于RPC请求的鉴权和限流的过滤功能。</p><ul><li>接口不能包含属性</li><li>接口只能声明方法，方法不能包含代码实现</li><li>类实现接口的时候，必须实现接口当中声明的所有方法</li></ul><p>抽象类和继承类似，其实表征的是一种is-a的关系；而接口表征的是一种has-a的关系/ 协议，表示具有某些功能 </p><h2 id="3-2-区别-都能解决什么样的编程问题？"><a href="#3-2-区别-都能解决什么样的编程问题？" class="headerlink" title="3.2 区别/ 都能解决什么样的编程问题？"></a>3.2 区别/ 都能解决什么样的编程问题？</h2><h3 id="3-2-1-抽象类-存在的意义"><a href="#3-2-1-抽象类-存在的意义" class="headerlink" title="3.2.1 抽象类 存在的意义"></a>3.2.1 抽象类 存在的意义</h3><p>抽象类不能实例化，只能被继承。主要是用来解决代码复用的问题的。多个子类可以继承抽象类当中定义的属性和方法，避免在子类当中，重复编写相同的代码。</p><p>为什么必须是抽象类来做代码复用呢？ </p><ul><li>因为可以利用多态来做了</li><li>减少父类代码被错误的直接使用的风险</li><li>也可以增加代码的可读性</li></ul><h3 id="3-2-2-接口的存在意义"><a href="#3-2-2-接口的存在意义" class="headerlink" title="3.2.2 接口的存在意义"></a>3.2.2 接口的存在意义</h3><p>接口更侧重于解耦，接口是对行为的一种抽象，相当于一组协议或者契约。这样调用者只需要关注抽象的接口，不需要了解具体的实现</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://github.com/gdhucoder/Algorithms4/blob/master/designpattern/pic/umlcheatsheet.jpg" target="_blank" rel="noopener">https://github.com/gdhucoder/Algorithms4/blob/master/designpattern/pic/umlcheatsheet.jpg</a> </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这篇博文主要想说面向对象的几大特性：封装，抽象，继承，多态，以及我们究竟如何去使用。&lt;/p&gt;
&lt;h1 id=&quot;1-面向对象概述&quot;&gt;&lt;a href=&quot;#1-面向对象概述&quot; class=&quot;headerlink&quot; title=&quot;1. 面向对象概述&quot;&gt;&lt;/a&gt;1. 面向对象概述&lt;/
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="OOP" scheme="https://www.llchen60.com/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>设计模式概述</title>
    <link href="https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/"/>
    <id>https://www.llchen60.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/</id>
    <published>2020-02-21T22:58:10.000Z</published>
    <updated>2020-02-23T17:10:22.625Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-起源"><a href="#1-起源" class="headerlink" title="1. 起源"></a>1. 起源</h1><p>每个模式都描述了一个在我们的环境中不断出现的问题，然后描述了该问题的解决方案的核心，通过这种方式，我们可以无数次重用那些已有的成功的解决方案，无须再重复相同的工作。</p><p>软件模式(Software Patterns)是将模式的一般概念应用于软件开发领域，即软件开发的总体指导思路或参照样板。软件模式并非仅限于设计模式，还包括架构模式、分析模式和过程模式等，<strong><em>实际上，在软件开发生命周期的每一个阶段都存在着一些被认同的模式</em></strong>。</p><p>想要学习设计模式的原因，是因为感到自己的代码能力还是有点捉急，可以写出能用的代码，但很难写出好看的代码，如果每次写代码的时候都要一行一行的来构建，而没有一个组件一个组件的意识的话，那写好代码恐怕只能是天方夜谭了。我想设计模式对我来说，就是抽象，构建框架的过程，是真真切切能够在日常工作当中帮助到自己的。不仅仅在于代码质量，也在于组件化以后的开发速度，以及对于更加复杂的商业上的实际场景得以提供出更加匹配的解决方式的能力。</p><p>另外一个点是当前我的能力范畴还是仅仅在于根据需求写出代码，即停留在写业务代码的阶段，在这个阶段当中，自己并不需要具有很强的代码设计能力，理解业务就可以写出代码了。但是如果想要成长，还是需要具备写出<strong>和业务并不直接相关的更加通用的功能模块</strong>的能力的。</p><h1 id="2-软件模式的基础结构"><a href="#2-软件模式的基础结构" class="headerlink" title="2. 软件模式的基础结构"></a>2. 软件模式的基础结构</h1><ul><li>问题描述</li><li>前提条件</li><li>解法</li><li>效果</li></ul><h2 id="2-1-评价代码的一些维度"><a href="#2-1-评价代码的一些维度" class="headerlink" title="2.1 评价代码的一些维度"></a>2.1 评价代码的一些维度</h2><p>关于如何判断一段代码写的好坏，众说纷纭，每个人其实都有自己主观上的某些看法。但是在更高维度上来说，会有一些相对能达成共识的标准，是我们可以在平常写代码的时候更多的注意一下的。</p><h3 id="2-1-1-可维护性-maintainability"><a href="#2-1-1-可维护性-maintainability" class="headerlink" title="2.1.1 可维护性 maintainability"></a>2.1.1 可维护性 maintainability</h3><ul><li>在不破坏原有代码的设计，不引入新的bug的情况下，能够快速地修改或者添加代码</li><li>细拆分其实就有很多因素的协同作用了<ul><li>代码的可读性，简洁</li><li>代码分层清晰程度，模块化，高内聚低耦合</li><li>基于接口而非实现编程</li></ul></li></ul><h3 id="2-1-2-可读性-readability"><a href="#2-1-2-可读性-readability" class="headerlink" title="2.1.2 可读性 readability"></a>2.1.2 可读性 readability</h3><ul><li>命名</li><li>注释</li><li>函数的长短</li><li>模块的划分</li></ul><h3 id="2-1-3-可扩展性-extensibility"><a href="#2-1-3-可扩展性-extensibility" class="headerlink" title="2.1.3 可扩展性  extensibility"></a>2.1.3 可扩展性  extensibility</h3><p>表征的是我们的代码对未来需求变化进行应对的能力。</p><p>即代码预留了一些功能的扩展点，我们可以将新功能代码直接插入到扩展点上，而不需要因为添加一个功能而大动干戈，改动大量的原始代码。</p><h3 id="2-1-4-灵活性-flexibility"><a href="#2-1-4-灵活性-flexibility" class="headerlink" title="2.1.4 灵活性  flexibility"></a>2.1.4 灵活性  flexibility</h3><ul><li>比如预留好了扩展点给新的功能代码来使用</li><li>代码已经抽象出了很多底层可以复用的模块，类</li></ul><h3 id="2-1-5-简洁性-simplicity"><a href="#2-1-5-简洁性-simplicity" class="headerlink" title="2.1.5 简洁性   simplicity"></a>2.1.5 简洁性   simplicity</h3><p>Keep it simple, stupid. </p><h3 id="2-1-6-可复用性-reusability"><a href="#2-1-6-可复用性-reusability" class="headerlink" title="2.1.6 可复用性  reusability"></a>2.1.6 可复用性  reusability</h3><p>尽量减少重复代码的编写，复用已有的代码</p><h3 id="2-1-7-可测试性-testability"><a href="#2-1-7-可测试性-testability" class="headerlink" title="2.1.7 可测试性  testability"></a>2.1.7 可测试性  testability</h3><p>比较难写的单元测试往往意味着代码的设计是有问题的。</p><p>如果说上面的细节实在是太多，并不能一下子很快的掌握，个人感觉，去看别人的设计，别人的代码，和自己的比较，会是非常快的成长方式。除此以外，肯定还是要经过看山是山，不是山，还是山的阶段的。希望自己的代码最终能像一个故事一样，将一段逻辑讲述完整。</p><h1 id="3-设计模式"><a href="#3-设计模式" class="headerlink" title="3. 设计模式"></a>3. 设计模式</h1><blockquote><p>设计模式(Design Pattern)是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结，使用设计模式是为了可重用代码、让代码更容易被他人理解并且保证代码可靠性。</p></blockquote><p>整个设计模式系列将会分以下几个部分：</p><ol><li><p>概述</p></li><li><p>面向对象设计原则</p><ul><li>单一职责</li><li>开闭原则</li><li>里氏代换</li><li>依赖倒转</li><li>接口隔离</li><li>合成复用</li><li>迪米特</li></ul></li><li><p>创建型模式（描述如何创建对象）</p><ul><li>简单工厂模式</li><li>工厂方法模式</li><li>抽象工厂模式</li><li>单例模式</li><li>原型模式</li><li>建造者模式</li></ul></li><li><p>结构型模式（如何实现类或对象的组合）</p><ul><li>适配器模式</li><li>桥接模式</li><li>组合模式</li><li>装饰模式</li><li>外观模式</li><li>享元模式</li><li>代理模式</li></ul></li><li><p>行为型模式（类或者对象怎样交互以及怎样分配职责）（类是对一类事物的描述，抽象出来的；而对象是具体的描述。类是一群具有相同属性的对象的集合体）</p><ul><li>职责链模式</li><li>命令模式</li><li>解释器模式</li><li>迭代器模式</li><li>中介者模式</li><li>备忘录模式</li><li>观察者模式</li><li>状态模式</li><li>策略模式</li><li>模板方法模式</li><li>访问者模式</li></ul></li></ol><h1 id="4-面向对象，设计原则，设计模式，编程规范，代码重构"><a href="#4-面向对象，设计原则，设计模式，编程规范，代码重构" class="headerlink" title="4. 面向对象，设计原则，设计模式，编程规范，代码重构"></a>4. 面向对象，设计原则，设计模式，编程规范，代码重构</h1><h2 id="4-1-面向对象"><a href="#4-1-面向对象" class="headerlink" title="4.1 面向对象"></a>4.1 面向对象</h2><p>主流的编程范式有：</p><ul><li>面向过程</li><li>面向对象</li><li>函数式编程</li></ul><p>面向对象因为其具有的丰富的特性 - 封装，继承，抽象，多态。可以实现很多复杂的设计思路，是很多设计原则，设计模式的实现基础。</p><ul><li>知识点<ul><li>封装 继承 抽象 多态</li><li>面向对象与面向过程编程的区别与联系</li><li>面向对象的分析设计和编程</li><li>接口和抽象类的区别以及各自的应用场景</li><li>基于接口而非实现的编程设计思想</li><li>多用组合少用继承的设计思想</li><li>面向过程的贫血模型和面向对象的充血模型<h2 id="4-2-设计原则"><a href="#4-2-设计原则" class="headerlink" title="4.2 设计原则"></a>4.2 设计原则</h2></li></ul></li><li>设计原则<ul><li>单一职责原则</li><li>开闭原则</li><li>里氏替换原则</li><li>接口隔离原则</li><li>依赖导致原则</li><li>DRY</li><li>KISS</li><li>YAGNI</li><li>LOD</li></ul></li></ul><h2 id="4-3-设计模式"><a href="#4-3-设计模式" class="headerlink" title="4.3 设计模式"></a>4.3 设计模式</h2><ul><li>设计模式<ul><li>为了解决代码的可扩展性问题</li><li>需要掌握他们都解决了哪些问题，典型的应用场景，并且不能也不应该过度使用</li><li>创建型<ul><li>单例模式</li><li>工厂模式</li><li>建造者模式</li></ul></li><li>结构型<ul><li>代理模式</li><li>桥接模式</li><li>装饰者模式</li><li>适配器模式</li></ul></li><li>行为型<ul><li>观察者模式</li><li>模板模式</li><li>策略模式</li><li>职责链模式</li><li>迭代器模式</li><li>状态模式</li></ul></li></ul></li></ul><h2 id="4-4-编程规范"><a href="#4-4-编程规范" class="headerlink" title="4.4 编程规范"></a>4.4 编程规范</h2><p>主要为了解决代码的可读性问题，这些规范主要是记忆，熟悉，然后尽量多的去使用。书籍的话可以去看重构，代码大全，代码整洁之道这几本书。</p><h2 id="4-5-代码重构"><a href="#4-5-代码重构" class="headerlink" title="4.5 代码重构"></a>4.5 代码重构</h2><p>业务发展，规模扩大，原先的设计很可能无法支持现在的体量的应用场景，这种情况下就需要持续重构了。而是用的工具就是我们前面说的设计模式，编程规范等等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-起源&quot;&gt;&lt;a href=&quot;#1-起源&quot; class=&quot;headerlink&quot; title=&quot;1. 起源&quot;&gt;&lt;/a&gt;1. 起源&lt;/h1&gt;&lt;p&gt;每个模式都描述了一个在我们的环境中不断出现的问题，然后描述了该问题的解决方案的核心，通过这种方式，我们可以无数次重用那些
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="Design Pattern" scheme="https://www.llchen60.com/tags/Design-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>PowerMock with EasyMock toturial</title>
    <link href="https://www.llchen60.com/Powermock-with-EasyMock-toturial/"/>
    <id>https://www.llchen60.com/Powermock-with-EasyMock-toturial/</id>
    <published>2020-02-21T05:11:10.000Z</published>
    <updated>2020-02-21T05:11:57.519Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Intro-with-an-example"><a href="#1-Intro-with-an-example" class="headerlink" title="1. Intro with an example"></a>1. Intro with an example</h1><p>We often find we need to do unit tests for final class, static method, which are not supported by Easymock, Mockito currently. Under such situation, we could use Powermock to help us mock the corresponding classes. </p><p>For detail introduction about powermock, refer to <a href="https://github.com/powermock/powermock" target="_blank" rel="noopener">PowerMock Github</a></p><p>Use example as followed to show how to integrate PowerMock with EasyMock: </p><pre><code>public final class FinalClassExample {    public String static doNothingStatic() {        return &quot;test&quot;;    }}@PowerMockIgnore(&quot;javax.management.*&quot;) // only need when see warning related with jmx or mbeans@RunWith(PowerMockRunner.class)  // necessary for powermock @PrepareForTest(FinalClassExample.class)  // necessary for powermock public class FinalClassExampleTest {    private IMocksControl control;    @Before    public void init() {        // do some initialization here         control = EasyMock.createControl();    }    @Test    public void test_example() {        PowerMock.mockStatic(FinalClassExample.class);        expect(FinalClassExample.doNothingStatic()).andReturn(&quot;test&quot;);        PowerMock.replay(FinalClassExample.class);        runYourTest();        PowerMock.verify(FinalClassExample.class);        // do some assertions here    }}</code></pre><h1 id="2-Other-APIs"><a href="#2-Other-APIs" class="headerlink" title="2. Other APIs"></a>2. Other APIs</h1><ul><li>mock final classes or methods <ul><li><code>@RunWith(PowerMockRunner.class)</code></li><li><code>@PrepareForTest(ClassWithFinal.class)</code></li><li><code>PowerMock.createMock(ClassWithFinal.class);</code></li><li><code>PowerMock.replay(mockObject)</code></li><li><code>PowerMock.verify(mockObject)</code></li></ul></li><li>mock private methods <ul><li><code>@RunWith(PowerMockRunner.class)</code></li><li><code>@PrepareForTest(ClassWithPrivateMethod.class)</code></li><li><code>PowerMock.createPartialMock(ClassWithPrivateMethod.class, &quot;nameOfTheMethodToMock&quot;)</code></li><li>Use <code>PowerMock.expectPrivate(mockObject, &quot;nameOfTheMethodToMock&quot;, argument1, argument2)</code> to expect the method call to <code>nameOfTheMethodToMock</code> with arguments <code>argument1</code> and <code>argument2</code></li><li><code>PowerMock.replay(mockObject)</code></li><li><code>PowerMock.verify(mockObject)</code></li></ul></li><li>mock construction of new objects <ul><li><code>@RunWith(PowerMockRunner.class)</code></li><li><code>@PrepareForTest(ClassThatCreatesTheNewInstance.class)</code> </li><li><code>PowerMock.createMock(NewInstanceClass.class)</code></li><li><code>PowerMock.expectNew(NewInstanceClass.class).andReturn(mockObject)</code></li><li><code>PowerMock.replay(mockObject, NewInstanceClass.class)</code></li><li><code>PowerMock.verify(mockObject, NewInstanceClass.class)</code></li></ul></li><li>mock partial <ul><li><code>@RunWith(PowerMockRunner.class)</code></li><li><code>@PrepareForTest(ClassToPartiallyMock.class)</code></li><li><code>PowerMock.createPartialMock(ClassToPartiallyMock.class, &quot;nameOfTheFirstMethodToMock&quot;, &quot;nameOfTheSecondMethodToMock&quot;)</code></li><li><code>PowerMock.replay(mockObject)</code></li><li><code>PowerMock.verify(mockObject)</code></li></ul></li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://github.com/powermock/powermock" target="_blank" rel="noopener">https://github.com/powermock/powermock</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Intro-with-an-example&quot;&gt;&lt;a href=&quot;#1-Intro-with-an-example&quot; class=&quot;headerlink&quot; title=&quot;1. Intro with an example&quot;&gt;&lt;/a&gt;1. Intro with an
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
      <category term="Unit Test" scheme="https://www.llchen60.com/tags/Unit-Test/"/>
    
      <category term="PowerMock" scheme="https://www.llchen60.com/tags/PowerMock/"/>
    
  </entry>
  
  <entry>
    <title>工程师需要知道的latency 数字 </title>
    <link href="https://www.llchen60.com/%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84latency-%E6%95%B0%E5%AD%97/"/>
    <id>https://www.llchen60.com/%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84latency-%E6%95%B0%E5%AD%97/</id>
    <published>2020-02-21T05:08:38.000Z</published>
    <updated>2020-02-21T05:10:12.077Z</updated>
    
    <content type="html"><![CDATA[<p>看到一篇博客，叙述了当前内存对于数据的处理速度对于开发的影响，推而广之，找到了一些我们在做系统设计的时候需要熟知的一些数据。</p><p>首先处理器的处理速度和内存的处理速度是差距很大的，处理器的处理速度的增长速度要比内存的快很多。</p><p><img src="https://i.loli.net/2020/02/21/s8h6GTfi1PSYwpe.png" alt="处理器与内存的性能表现.png"></p><p>我们需要探究的是CPU从内存中随机提取数据以及获取连续数据的速度，这是很粗略的估计，只是希望能够有一个数量级上的感知。</p><pre><code>Latency Comparison Numbers (~2012)----------------------------------L1 cache reference                           0.5 nsBranch mispredict                            5   nsL2 cache reference                           7   ns                      14x L1 cacheMutex lock/unlock                           25   nsMain memory reference                      100   ns                      20x L2 cache, 200x L1 cacheCompress 1K bytes with Zippy             3,000   ns        3 usSend 1K bytes over 1 Gbps network       10,000   ns       10 usRead 4K randomly from SSD*             150,000   ns      150 us          ~1GB/sec SSDRead 1 MB sequentially from memory     250,000   ns      250 usRound trip within same datacenter      500,000   ns      500 usRead 1 MB sequentially from SSD*     1,000,000   ns    1,000 us    1 ms  ~1GB/sec SSD, 4X memoryDisk seek                           10,000,000   ns   10,000 us   10 ms  20x datacenter roundtripRead 1 MB sequentially from disk    20,000,000   ns   20,000 us   20 ms  80x memory, 20X SSDSend packet CA-&gt;Netherlands-&gt;CA    150,000,000   ns  150,000 us  150 ms</code></pre><p>根据2020年StackOverflow上的回答，我们可以看到Core i7 Xeon 5500 的benchmark数据如下</p><pre><code>Core i7 Xeon 5500 Series Data Source Latency (approximate)               [Pg. 22]local  L1 CACHE hit,                              ~4 cycles (   2.1 -  1.2 ns )local  L2 CACHE hit,                             ~10 cycles (   5.3 -  3.0 ns )local  L3 CACHE hit, line unshared               ~40 cycles (  21.4 - 12.0 ns )local  L3 CACHE hit, shared line in another core ~65 cycles (  34.8 - 19.5 ns )local  L3 CACHE hit, modified in another core    ~75 cycles (  40.2 - 22.5 ns )remote L3 CACHE (Ref: Fig.1 [Pg. 5])        ~100-300 cycles ( 160.7 - 30.0 ns )local  DRAM                                                   ~60 nsremote DRAM                                                  ~100 ns</code></pre><p>而现在的cache的大小，根据wikiChip上的数据，对于Core i7-8700K</p><pre><code>Memory Bandwidth: 39.74 gigabytes per secondL1 cache: 192 kilobytes (32 KB per core)L2 cache: 1.5 megabytes (256 KB per core)L3 cache: 12 megabytes  (shared; 2 MB per core)</code></pre><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://www.forrestthewoods.com/blog/memory-bandwidth-napkin-math/" target="_blank" rel="noopener">https://www.forrestthewoods.com/blog/memory-bandwidth-napkin-math/</a>?</li><li><a href="https://stackoverflow.com/questions/4087280/approximate-cost-to-access-various-caches-and-main-memory" target="_blank" rel="noopener">https://stackoverflow.com/questions/4087280/approximate-cost-to-access-various-caches-and-main-memory</a></li><li><a href="https://en.wikichip.org/wiki/intel/core_i7/i7-8700k" target="_blank" rel="noopener">https://en.wikichip.org/wiki/intel/core_i7/i7-8700k</a></li><li><a href="https://gist.github.com/jboner/2841832" target="_blank" rel="noopener">https://gist.github.com/jboner/2841832</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;看到一篇博客，叙述了当前内存对于数据的处理速度对于开发的影响，推而广之，找到了一些我们在做系统设计的时候需要熟知的一些数据。&lt;/p&gt;
&lt;p&gt;首先处理器的处理速度和内存的处理速度是差距很大的，处理器的处理速度的增长速度要比内存的快很多。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;ht
      
    
    </summary>
    
    
      <category term="SystemDesign" scheme="https://www.llchen60.com/categories/SystemDesign/"/>
    
    
      <category term="latency" scheme="https://www.llchen60.com/tags/latency/"/>
    
      <category term="system design" scheme="https://www.llchen60.com/tags/system-design/"/>
    
  </entry>
  
  <entry>
    <title>Java8 Date Time API </title>
    <link href="https://www.llchen60.com/Java8-Date-Time-API/"/>
    <id>https://www.llchen60.com/Java8-Date-Time-API/</id>
    <published>2020-02-20T03:08:47.000Z</published>
    <updated>2020-02-20T03:09:12.256Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-为什么需要新的Date-API"><a href="#1-为什么需要新的Date-API" class="headerlink" title="1. 为什么需要新的Date API"></a>1. 为什么需要新的Date API</h1><p>Java8 的一大更新在于终于将Date Time一致化，这解决了在Java8以前我们观察到的非常多的问题：</p><p>譬如：</p><ul><li>Java Date Time类定义在不同的地方，比如在java.util &amp; java.sql里面都有，而样式和格式转化的类都定义在java.text的包里，比较混乱</li><li>java.util.Date包括date和time类，而java.sql.Date只包含date</li><li>并没有清晰定义的类用于处理time, timestamp, formatting, parsing </li><li>所有的Date类都是可变的，并不是线程安全的</li><li>Date类不支持全球化，没有时区的支持，在java8之前，为了显示当地时间，就得使用java.util.Calendar 还有 java.util.TimeZone,整个变得比较麻烦</li></ul><h1 id="2-Java8-Date-Time-API-详解"><a href="#2-Java8-Date-Time-API-详解" class="headerlink" title="2. Java8 Date Time API 详解"></a>2. Java8 Date Time API 详解</h1><h2 id="2-1-Packages"><a href="#2-1-Packages" class="headerlink" title="2.1 Packages"></a>2.1 Packages</h2><ul><li>java.time Package <ul><li>这是新的Date Time API的基础包，一些主要的基本类都在这里面，譬如LocalDate, LocalTime, LocalDateTime, Instant, Period, Duration  </li></ul></li><li>java.time.chrono <ul><li>定义了抽象的API接口，针对于非ISO标准的calendar 系统，我们可以通过extend AbstractChronology类来创建我们自己的calendar系统</li></ul></li><li>java.time.format <ul><li>包含用来Formatting还有parsing date time对象的类</li></ul></li><li>java.time.temporal <ul><li>包含一些时间对象，比如找到月份的第一天， 最后一天之类的</li></ul></li><li>java.time.zone<ul><li>支持不同的时区 </li></ul></li></ul><h2 id="2-2-LocalDate"><a href="#2-2-LocalDate" class="headerlink" title="2.2 LocalDate"></a>2.2 LocalDate</h2><ul><li>Immutable class </li><li>默认样式为 yyyy-MM-dd</li><li>我们可以使用<code>now()</code>方法来获得当前的日期</li><li>也可以通过提供年月日来创建localDate对象</li><li>我们同时也可以传入ZoneId来得到在特定的时区的日期</li></ul><pre><code>package com.journaldev.java8.time;import java.time.LocalDate;import java.time.Month;import java.time.ZoneId;/** * LocalDate Examples * @author pankaj * */public class LocalDateExample {    public static void main(String[] args) {        //Current Date        LocalDate today = LocalDate.now();        System.out.println(&quot;Current Date=&quot;+today);        //Creating LocalDate by providing input arguments        LocalDate firstDay_2014 = LocalDate.of(2014, Month.JANUARY, 1);        System.out.println(&quot;Specific Date=&quot;+firstDay_2014);        //Try creating date by providing invalid inputs        //LocalDate feb29_2014 = LocalDate.of(2014, Month.FEBRUARY, 29);        //Exception in thread &quot;main&quot; java.time.DateTimeException:         //Invalid date &#39;February 29&#39; as &#39;2014&#39; is not a leap year        //Current date in &quot;Asia/Kolkata&quot;, you can get it from ZoneId javadoc        LocalDate todayKolkata = LocalDate.now(ZoneId.of(&quot;Asia/Kolkata&quot;));        System.out.println(&quot;Current Date in IST=&quot;+todayKolkata);        //java.time.zone.ZoneRulesException: Unknown time-zone ID: IST        //LocalDate todayIST = LocalDate.now(ZoneId.of(&quot;IST&quot;));        //Getting date from the base date i.e 01/01/1970        LocalDate dateFromBase = LocalDate.ofEpochDay(365);        System.out.println(&quot;365th day from base date= &quot;+dateFromBase);        LocalDate hundredDay2014 = LocalDate.ofYearDay(2014, 100);        System.out.println(&quot;100th day of 2014=&quot;+hundredDay2014);    }}// output Current Date=2014-04-28Specific Date=2014-01-01Current Date in IST=2014-04-29365th day from base date= 1971-01-01100th day of 2014=2014-04-10</code></pre><h2 id="2-3-LocalTime"><a href="#2-3-LocalTime" class="headerlink" title="2.3 LocalTime"></a>2.3 LocalTime</h2><ul><li>Immutable Class </li><li>表示一个可读的时间 (vs Instant 基本不可读)</li><li>默认样式为 hh:mm:ss:zz</li><li>和LocalDate基本一致的用法，可以传入参数生成实例，支持时区</li></ul><pre><code>package com.journaldev.java8.time;import java.time.LocalTime;import java.time.ZoneId;/** * LocalTime Examples * @author pankaj * */public class LocalTimeExample {    public static void main(String[] args) {        //Current Time        LocalTime time = LocalTime.now();        System.out.println(&quot;Current Time=&quot;+time);        //Creating LocalTime by providing input arguments        LocalTime specificTime = LocalTime.of(12,20,25,40);        System.out.println(&quot;Specific Time of Day=&quot;+specificTime);        //Try creating time by providing invalid inputs        //LocalTime invalidTime = LocalTime.of(25,20);        //Exception in thread &quot;main&quot; java.time.DateTimeException:         //Invalid value for HourOfDay (valid values 0 - 23): 25        //Current date in &quot;Asia/Kolkata&quot;, you can get it from ZoneId javadoc        LocalTime timeKolkata = LocalTime.now(ZoneId.of(&quot;Asia/Kolkata&quot;));        System.out.println(&quot;Current Time in IST=&quot;+timeKolkata);        //java.time.zone.ZoneRulesException: Unknown time-zone ID: IST        //LocalTime todayIST = LocalTime.now(ZoneId.of(&quot;IST&quot;));        //Getting date from the base date i.e 01/01/1970        LocalTime specificSecondTime = LocalTime.ofSecondOfDay(10000);        System.out.println(&quot;10000th second time= &quot;+specificSecondTime);    }}// Output Current Time=15:51:45.240Specific Time of Day=12:20:25.000000040Current Time in IST=04:21:45.27610000th second time= 02:46:40</code></pre><h2 id="2-4-LocalDateTime"><a href="#2-4-LocalDateTime" class="headerlink" title="2.4 LocalDateTime"></a>2.4 LocalDateTime</h2><ul><li>Immutable date-time object </li><li>represent both date and time </li><li>default format at yyyy-MM-dd-HH-mm-ss.zzz </li><li>用工厂方法来拿到LocalDate和LocalTime的input 然后来创建LocalDateTime的实例</li></ul><pre><code>package com.journaldev.java8.time;import java.time.LocalDate;import java.time.LocalDateTime;import java.time.LocalTime;import java.time.Month;import java.time.ZoneId;import java.time.ZoneOffset;public class LocalDateTimeExample {    public static void main(String[] args) {        //Current Date        LocalDateTime today = LocalDateTime.now();        System.out.println(&quot;Current DateTime=&quot;+today);        //Current Date using LocalDate and LocalTime        today = LocalDateTime.of(LocalDate.now(), LocalTime.now());        System.out.println(&quot;Current DateTime=&quot;+today);        //Creating LocalDateTime by providing input arguments        LocalDateTime specificDate = LocalDateTime.of(2014, Month.JANUARY, 1, 10, 10, 30);        System.out.println(&quot;Specific Date=&quot;+specificDate);        //Try creating date by providing invalid inputs        //LocalDateTime feb29_2014 = LocalDateTime.of(2014, Month.FEBRUARY, 28, 25,1,1);        //Exception in thread &quot;main&quot; java.time.DateTimeException:         //Invalid value for HourOfDay (valid values 0 - 23): 25        //Current date in &quot;Asia/Kolkata&quot;, you can get it from ZoneId javadoc        LocalDateTime todayKolkata = LocalDateTime.now(ZoneId.of(&quot;Asia/Kolkata&quot;));        System.out.println(&quot;Current Date in IST=&quot;+todayKolkata);        //java.time.zone.ZoneRulesException: Unknown time-zone ID: IST        //LocalDateTime todayIST = LocalDateTime.now(ZoneId.of(&quot;IST&quot;));        //Getting date from the base date i.e 01/01/1970        LocalDateTime dateFromBase = LocalDateTime.ofEpochSecond(10000, 0, ZoneOffset.UTC);        System.out.println(&quot;10000th second time from 01/01/1970= &quot;+dateFromBase);    }}// OutputCurrent DateTime=2014-04-28T16:00:49.455Current DateTime=2014-04-28T16:00:49.493Specific Date=2014-01-01T10:10:30Current Date in IST=2014-04-29T04:30:49.49310000th second time from 01/01/1970= 1970-01-01T02:46:40</code></pre><h2 id="2-5-Instant"><a href="#2-5-Instant" class="headerlink" title="2.5 Instant"></a>2.5 Instant</h2><p>是为了生成机器阅读的时间格式，它会使用unix的时间戳来存储日期和时间</p><pre><code>package com.journaldev.java8.time;import java.time.Duration;import java.time.Instant;public class InstantExample {    public static void main(String[] args) {        //Current timestamp        Instant timestamp = Instant.now();        System.out.println(&quot;Current Timestamp = &quot;+timestamp);        //Instant from timestamp        Instant specificTime = Instant.ofEpochMilli(timestamp.toEpochMilli());        System.out.println(&quot;Specific Time = &quot;+specificTime);        //Duration example        Duration thirtyDay = Duration.ofDays(30);        System.out.println(thirtyDay);    }}// Output Current Timestamp = 2014-04-28T23:20:08.489ZSpecific Time = 2014-04-28T23:20:08.489ZPT720H</code></pre><h2 id="2-6-常用API"><a href="#2-6-常用API" class="headerlink" title="2.6 常用API"></a>2.6 常用API</h2><pre><code>package com.journaldev.java8.time;import java.time.LocalDate;import java.time.LocalTime;import java.time.Period;import java.time.temporal.TemporalAdjusters;public class DateAPIUtilities {    public static void main(String[] args) {        LocalDate today = LocalDate.now();        //得到年份，看是否为闰年        System.out.println(&quot;Year &quot;+today.getYear()+&quot; is Leap Year? &quot;+today.isLeapYear());        //比较两个时间的先后        System.out.println(&quot;Today is before 01/01/2015? &quot;+today.isBefore(LocalDate.of(2015,1,1)));        //从LocalDate创建LocalDateTime        System.out.println(&quot;Current Time=&quot;+today.atTime(LocalTime.now()));        //加减时间的操作        System.out.println(&quot;10 days after today will be &quot;+today.plusDays(10));        System.out.println(&quot;3 weeks after today will be &quot;+today.plusWeeks(3));        System.out.println(&quot;20 months after today will be &quot;+today.plusMonths(20));        System.out.println(&quot;10 days before today will be &quot;+today.minusDays(10));        System.out.println(&quot;3 weeks before today will be &quot;+today.minusWeeks(3));        System.out.println(&quot;20 months before today will be &quot;+today.minusMonths(20));        //时间上的加减        System.out.println(&quot;First date of this month= &quot;+today.with(TemporalAdjusters.firstDayOfMonth()));        LocalDate lastDayOfYear = today.with(TemporalAdjusters.lastDayOfYear());        System.out.println(&quot;Last date of this year= &quot;+lastDayOfYear);        Period period = today.until(lastDayOfYear);        System.out.println(&quot;Period Format= &quot;+period);        System.out.println(&quot;Months remaining in the year= &quot;+period.getMonths());            }}Year 2014 is Leap Year? falseToday is before 01/01/2015? trueCurrent Time=2014-04-28T16:23:53.15410 days after today will be 2014-05-083 weeks after today will be 2014-05-1920 months after today will be 2015-12-2810 days before today will be 2014-04-183 weeks before today will be 2014-04-0720 months before today will be 2012-08-28First date of this month= 2014-04-01Last date of this year= 2014-12-31Period Format= P8M3DMonths remaining in the year= 8</code></pre><h2 id="2-7-时间的Parsing-和-Formatting"><a href="#2-7-时间的Parsing-和-Formatting" class="headerlink" title="2.7 时间的Parsing 和 Formatting"></a>2.7 时间的Parsing 和 Formatting</h2><pre><code>package com.journaldev.java8.time;import java.time.Instant;import java.time.LocalDate;import java.time.LocalDateTime;import java.time.format.DateTimeFormatter;public class DateParseFormatExample {    public static void main(String[] args) {        //Format examples        LocalDate date = LocalDate.now();        //default format        System.out.println(&quot;Default format of LocalDate=&quot;+date);        //使用特定的Formatter        System.out.println(date.format(DateTimeFormatter.ofPattern(&quot;d::MMM::uuuu&quot;)));        System.out.println(date.format(DateTimeFormatter.BASIC_ISO_DATE));        LocalDateTime dateTime = LocalDateTime.now();        //default format        System.out.println(&quot;Default format of LocalDateTime=&quot;+dateTime);        //specific format        System.out.println(dateTime.format(DateTimeFormatter.ofPattern(&quot;d::MMM::uuuu HH::mm::ss&quot;)));        System.out.println(dateTime.format(DateTimeFormatter.BASIC_ISO_DATE));        Instant timestamp = Instant.now();        //default format        System.out.println(&quot;Default format of Instant=&quot;+timestamp);        //Parse examples        LocalDateTime dt = LocalDateTime.parse(&quot;27::Apr::2014 21::39::48&quot;,                DateTimeFormatter.ofPattern(&quot;d::MMM::uuuu HH::mm::ss&quot;));        System.out.println(&quot;Default format after parsing = &quot;+dt);    }}// OutputDefault format of LocalDate=2014-04-2828::Apr::201420140428Default format of LocalDateTime=2014-04-28T16:25:49.34128::Apr::2014 16::25::4920140428Default format of Instant=2014-04-28T23:25:49.342ZDefault format after parsing = 2014-04-27T21:39:48</code></pre><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://www.journaldev.com/2800/java-8-date-localdate-localdatetime-instant" target="_blank" rel="noopener">https://www.journaldev.com/2800/java-8-date-localdate-localdatetime-instant</a> </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-为什么需要新的Date-API&quot;&gt;&lt;a href=&quot;#1-为什么需要新的Date-API&quot; class=&quot;headerlink&quot; title=&quot;1. 为什么需要新的Date API&quot;&gt;&lt;/a&gt;1. 为什么需要新的Date API&lt;/h1&gt;&lt;p&gt;Java8 的一
      
    
    </summary>
    
    
      <category term="BackEnd" scheme="https://www.llchen60.com/categories/BackEnd/"/>
    
    
      <category term="Java" scheme="https://www.llchen60.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法(17)-红黑树</title>
    <link href="https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-17-%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <id>https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-17-%E7%BA%A2%E9%BB%91%E6%A0%91/</id>
    <published>2020-02-11T04:16:00.000Z</published>
    <updated>2020-02-11T04:16:29.377Z</updated>
    
    <content type="html"><![CDATA[<p>首先对于我们前面看到的二叉查找树，在相对理想的情况下，它的时间负责度为O(logn).但是在频繁的动态更新的过程中，可能会出现树的高度远远大于log2(n)的情况，导致各项操作的效率下降.</p><p>在极端情况下，二叉查找树会退化为一个链表，时间复杂度会退化到O(n).为了解决这个复杂度退化的问题，我们需要设计一种平衡二叉查找树</p><h1 id="1-什么是平衡二叉查找树？"><a href="#1-什么是平衡二叉查找树？" class="headerlink" title="1. 什么是平衡二叉查找树？"></a>1. 什么是平衡二叉查找树？</h1><blockquote><p>平衡二叉查找树定义  二叉树中任意一个节点的左右子树的高度相差不能大于1.</p></blockquote><p>平衡二叉查找树的初衷是解决普通二叉查找树在频繁的插入\删除等动态更新的情况下，出现时间复杂度退化的问题</p><p>平衡二叉查找树中平衡的意思就是让整棵树看起来比较对称，不要出现左子树很高，右子树很矮的情况。这样就能让整棵树的高度相对来说低一些。</p><h1 id="2-如何定义一棵红黑树-Red-Black-Tree"><a href="#2-如何定义一棵红黑树-Red-Black-Tree" class="headerlink" title="2. 如何定义一棵红黑树 Red Black Tree"></a>2. 如何定义一棵红黑树 Red Black Tree</h1><p>是一种不严格的平衡二叉查找树。红黑树当中的节点，一类被标记为黑色，一类被标记为红色。</p><ul><li>根节点是黑色的</li><li>每个叶子节点都是黑色的空节点(NIL)，即叶子节点不存储数据</li><li>任何相邻的节点都不能同时为红色，即红色节点是被黑色节点分割开的</li><li>每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点</li></ul><p>二叉查找树的很多操作的性能都跟树的高度成正比，因此为了证明红黑树近似平衡，我们需要分析的问题可以转化为其高度是否能比较稳定的趋近log2(n)</p><p>AVL是高度平衡的二叉树，查找效率非常高，但是每次插入删除都要对应做调整，所以会比较复杂耗时。红黑树只是做到近似平衡，在维护平衡的成本上，要比AVL要低。</p><h1 id="3-如何实现一个红黑树"><a href="#3-如何实现一个红黑树" class="headerlink" title="3. 如何实现一个红黑树"></a>3. 如何实现一个红黑树</h1><p>红黑树的平衡过程就是<strong>根据节点排布的特征来，遇到什么样的节点排布，我们就对应的去进行调整</strong>。 </p><ul><li>重要操作<ul><li>左旋 rotate left<ul><li>将基准点的右子树绕x做逆时针旋转，是的x的右子树成为x的父亲，同时修改相关节点的引用。旋转之后，二叉查找树的特性仍然能够得到满足 </li></ul></li><li>右旋 rotate right <ul><li>将x的左子树绕x顺时针旋转，使得x的左子树成为x的父亲，同时修改相关节点的引用。旋转之后，二叉查找树的属性仍然能够满足 </li></ul></li></ul></li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://www.cnblogs.com/carpenterlee/p/5503882.html" target="_blank" rel="noopener">https://www.cnblogs.com/carpenterlee/p/5503882.html</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先对于我们前面看到的二叉查找树，在相对理想的情况下，它的时间负责度为O(logn).但是在频繁的动态更新的过程中，可能会出现树的高度远远大于log2(n)的情况，导致各项操作的效率下降.&lt;/p&gt;
&lt;p&gt;在极端情况下，二叉查找树会退化为一个链表，时间复杂度会退化到O(n).
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://www.llchen60.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="红黑树" scheme="https://www.llchen60.com/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法(16)-二叉树</title>
    <link href="https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-16-%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-16-%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2020-02-09T18:31:37.000Z</published>
    <updated>2020-02-09T18:32:28.203Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-树"><a href="#1-树" class="headerlink" title="1. 树"></a>1. 树</h1><ul><li>父节点<ul><li>上层的节点 </li></ul></li><li>兄弟节点<ul><li>父节点是同一个节点 </li></ul></li><li>叶节点<ul><li>没有子节点的节点</li></ul></li><li>高度<ul><li>节点到叶子节点的最长路径 </li></ul></li><li>深度<ul><li>根节点到这个节点所经历的边的个数 </li></ul></li><li>层<ul><li>节点的深度 + 1 </li></ul></li></ul><h1 id="2-二叉树"><a href="#2-二叉树" class="headerlink" title="2. 二叉树"></a>2. 二叉树</h1><p>每个节点最多有两个分叉的树，即最多有两个子节点</p><p><img src="https://i.loli.net/2020/02/10/r72vjaPlpfsHmuE.jpg" alt="fig1.jpg"><br>2 显示的是满二叉树，特点是叶子节点都在最底层，出了叶子节点之外，每个节点都有左右两个子节点</p><p>3 叶子节点都在最底下两层，并且出了最后一层，其他的层的节点数量都要达到最大，并且最后一层的节点都是靠左排列的，这种二叉树叫做完全二叉树。</p><h2 id="2-1-如何表示-存储一棵二叉树？"><a href="#2-1-如何表示-存储一棵二叉树？" class="headerlink" title="2.1 如何表示/ 存储一棵二叉树？"></a>2.1 如何表示/ 存储一棵二叉树？</h2><h3 id="2-1-1-基于指针或者引用的二叉链式存储法"><a href="#2-1-1-基于指针或者引用的二叉链式存储法" class="headerlink" title="2.1.1 基于指针或者引用的二叉链式存储法"></a>2.1.1 基于指针或者引用的二叉链式存储法</h3><p><img src="https://i.loli.net/2020/02/10/M1I6FkWJodTq3fX.jpg" alt="fig2.jpg"></p><p>每个节点都有三个字段，其中一个存储数据，另外两个指向左右子节点的指针。因此通过根节点，我们就可以通过左右子节点的指针将整棵树都串起来了。</p><h3 id="2-1-2-基于数组的顺序存储法"><a href="#2-1-2-基于数组的顺序存储法" class="headerlink" title="2.1.2 基于数组的顺序存储法"></a>2.1.2 基于数组的顺序存储法</h3><p><img src="https://i.loli.net/2020/02/10/P62NlH8EbY3LBXv.jpg" alt="fig3.jpg"><br>如果节点X存储在数组中下标为i的位置，下标为2<em>i的位置存储的是左子节点，下标为2</em>i + 1的位置存储的就是右子节点。下标为i/2的位置存储的就是它的父节点了。通过这种方式，我们只要知道根节点存储的位置，就可以通过下标计算，把整棵树都串起来。 不过对于一棵非完全二叉树而言，会浪费比较多的数组存储空间的。</p><h2 id="2-2-二叉树的遍历"><a href="#2-2-二叉树的遍历" class="headerlink" title="2.2 二叉树的遍历"></a>2.2 二叉树的遍历</h2><h3 id="2-2-0-递归公式"><a href="#2-2-0-递归公式" class="headerlink" title="2.2.0 递归公式"></a>2.2.0 递归公式</h3><p><img src="https://i.loli.net/2020/02/10/o1TLXDnalmgBzAQ.jpg" alt="fig4.jpg"></p><p>二叉树的遍历整体就是一个递归的过程</p><p>写递归代码的关键，就是看能不能写出一个递推公式。而递推公式的关键，就是如果要解决问题A，就假设子问题B,C都已经解决，然后再来看如何利用B，C来解决A</p><pre><code>前序遍历的递推公式：preOrder(r) = print r-&gt;preOrder(r-&gt;left)-&gt;preOrder(r-&gt;right)中序遍历的递推公式：inOrder(r) = inOrder(r-&gt;left)-&gt;print r-&gt;inOrder(r-&gt;right)后序遍历的递推公式：postOrder(r) = postOrder(r-&gt;left)-&gt;postOrder(r-&gt;right)-&gt;print r// 前序遍历void preOrder(Node* root) {  if (root == null) return;  print root // 此处为伪代码，表示打印root节点  preOrder(root-&gt;left);  preOrder(root-&gt;right);}// 中序遍历void inOrder(Node* root) {  if (root == null) return;  inOrder(root-&gt;left);  print root // 此处为伪代码，表示打印root节点  inOrder(root-&gt;right);}// 后序遍历void postOrder(Node* root) {  if (root == null) return;  postOrder(root-&gt;left);  postOrder(root-&gt;right);  print root // 此处为伪代码，表示打印root节点}</code></pre><h3 id="2-2-1-前序遍历"><a href="#2-2-1-前序遍历" class="headerlink" title="2.2.1 前序遍历"></a>2.2.1 前序遍历</h3><p>对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。</p><h3 id="2-2-2-中序遍历"><a href="#2-2-2-中序遍历" class="headerlink" title="2.2.2 中序遍历"></a>2.2.2 中序遍历</h3><p>对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树</p><h3 id="2-2-3-后序遍历"><a href="#2-2-3-后序遍历" class="headerlink" title="2.2.3 后序遍历"></a>2.2.3 后序遍历</h3><p>对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身</p><h1 id="3-二叉查找树"><a href="#3-二叉查找树" class="headerlink" title="3. 二叉查找树"></a>3. 二叉查找树</h1><p>支持动态数据集合的快速插入、删除、查找操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-树&quot;&gt;&lt;a href=&quot;#1-树&quot; class=&quot;headerlink&quot; title=&quot;1. 树&quot;&gt;&lt;/a&gt;1. 树&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;父节点&lt;ul&gt;
&lt;li&gt;上层的节点 &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;兄弟节点&lt;ul&gt;
&lt;li&gt;父节点是同
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://www.llchen60.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://www.llchen60.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法(15)-哈希算法</title>
    <link href="https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-15-%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/"/>
    <id>https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-15-%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/</id>
    <published>2020-02-09T18:30:23.000Z</published>
    <updated>2020-02-09T18:30:43.320Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-什么是哈希算法"><a href="#1-什么是哈希算法" class="headerlink" title="1. 什么是哈希算法"></a>1. 什么是哈希算法</h1><blockquote><p>将任意长度的二进制串映射为固定长度的二进制串，这个映射的规则就是哈希算法，而通过原始数据映射之后得到的二进制串就是哈希值</p></blockquote><ul><li>哈希算法的要求<ul><li>从哈希值无法反向推导出原始数据</li><li>对输入数据非常敏感，哪怕原始数据只修改一个bit，最后得到的哈希值也会大不相同</li><li>散列冲突的概率很小，对于不同的原始数据，哈希值相同的概率非常小</li><li>哈希算法的效率要足够高，针对较长文本，也能快速计算出哈希值</li></ul></li></ul><h1 id="2-哈希算法的应用"><a href="#2-哈希算法的应用" class="headerlink" title="2. 哈希算法的应用"></a>2. 哈希算法的应用</h1><h2 id="2-1-安全加密"><a href="#2-1-安全加密" class="headerlink" title="2.1 安全加密"></a>2.1 安全加密</h2><ul><li>常用de加密算法<ul><li>MD5<ul><li>MD5 Message-Digest Algorithm </li><li>MD5信息摘要算法</li></ul></li><li>SHA <ul><li>Secure Hash Algorithm 安全散列算法</li></ul></li><li>DES <ul><li>Data Encryption Standard 数据加密标准</li></ul></li><li>AES <ul><li>Advanced Encryption Standard 高级加密标准</li></ul></li></ul></li></ul><h2 id="2-2-唯一标识"><a href="#2-2-唯一标识" class="headerlink" title="2.2 唯一标识"></a>2.2 唯一标识</h2><p>图片的标识，从图片的二进制串码的前中后各取出100字节，通过哈希算法得到一个哈希字符串，用它作为图片的唯一标识。然后通过这个唯一标识来判定图片是否在图库当中，通过这种方式来减少工作量。</p><h2 id="2-3-数据校验"><a href="#2-3-数据校验" class="headerlink" title="2.3 数据校验"></a>2.3 数据校验</h2><p>BT协议的数据校验，对每个文件块取哈希值，保存在种子文件当中。当文件块下载完成之后，我们通过相同的哈希算法，对下载好的文件块逐一求哈希值，然后跟种子文件中保存的哈希值进行比对。如果不同，就说明这个文件块不完整或者被篡改了，需要再重新从其他宿主机器上下载这个文件块。</p><h2 id="2-4-散列函数"><a href="#2-4-散列函数" class="headerlink" title="2.4 散列函数"></a>2.4 散列函数</h2><p>哈希表的散列函数，关注的是在做完哈希以后，是否能够平均的分布。一组数据能否均匀散列在各个槽中。 </p><p>另外一个点是其执行速度，散列函数对执行速度的要求会比较高一些。</p><h2 id="2-5-负载均衡"><a href="#2-5-负载均衡" class="headerlink" title="2.5 负载均衡"></a>2.5 负载均衡</h2><p>分布式系统当中需要解决的问题</p><ul><li>负载均衡的算法<ul><li>轮询</li><li>随机</li><li>加权轮询</li></ul></li></ul><p>但是我们需要实现一个会话粘滞的负载均衡算法(session sticky)。即我们需要在一个客户端上，在一次会话上的所有请求都路由到同一个服务器上。</p><p>通过哈希算法，对客户端IP地址或者会话的ID计算哈希值，将取得的哈希值与服务器列表的大小进行取模运算，最终得到的值就是应该被路由到的服务器的编号。</p><h2 id="2-6-数据分片"><a href="#2-6-数据分片" class="headerlink" title="2.6 数据分片"></a>2.6 数据分片</h2><h3 id="2-6-1-如何统计关键词搜索的次数"><a href="#2-6-1-如何统计关键词搜索的次数" class="headerlink" title="2.6.1 如何统计关键词搜索的次数"></a>2.6.1 如何统计关键词搜索的次数</h3><p>假设我们有1T的日志文件，里面记录了用户的关键词，我们想快速统计出来每个关键词被搜索的次数，该怎么做呢？ </p><ol><li>数据量太大的问题</li><li>处理时间太长的问题</li></ol><p>对数据进行分片，然后多台机器进行处理。用哈希算法，将哈希值相同的搜索关键词放到同一台机器上。然后最后做汇总</p><h3 id="2-6-2-如何快速判断图片是否在图库当中"><a href="#2-6-2-如何快速判断图片是否在图库当中" class="headerlink" title="2.6.2 如何快速判断图片是否在图库当中"></a>2.6.2 如何快速判断图片是否在图库当中</h3><p>为每个图片取唯一标识，然后构建散列表，但是当图片量很大的时候，在单台机器上构建散列表是行不通的。</p><p>因为在存储的时候，我们还是需要根据哈希算法取模来进行存储，然后在进行判断的时候，也是用同样的哈希算法，然后与机器个数n求余取模。然后根据得到的值到对应的机器上去进行查找。</p><h2 id="2-7-分布式存储"><a href="#2-7-分布式存储" class="headerlink" title="2.7 分布式存储"></a>2.7 分布式存储</h2><p>分布式存储需要解决的问题是，当我们已经在各个host上按照哈希算法保存了数据以后，再增减host的时候，我们不希望还需要对原先的host里面的数据做迁移。如果说缓存当中的数据会一下子全都失效的话，那么所有数据请求都要从数据库走，直接就压垮数据库了。</p><p>因此在分布式存储当中，我们需要采用<strong><em>一致性哈希算法</em></strong></p><p>假设我们有 k 个机器，数据的哈希值的范围是[0, MAX]。我们将整个范围划分成 m 个小区间（m 远大于 k），每个机器负责 m/k 个小区间。当有新机器加入的时候，我们就将某几个小区间的数据，从原来的机器中搬移到新的机器中。这样，既不用全部重新哈希、搬移数据，也保持了各个机器上数据数量的均衡。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-什么是哈希算法&quot;&gt;&lt;a href=&quot;#1-什么是哈希算法&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是哈希算法&quot;&gt;&lt;/a&gt;1. 什么是哈希算法&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;将任意长度的二进制串映射为固定长度的二进制串，这个映射
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://www.llchen60.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="哈希算法" scheme="https://www.llchen60.com/tags/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法(14)-散列表</title>
    <link href="https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-14-%E6%95%A3%E5%88%97%E8%A1%A8/"/>
    <id>https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-14-%E6%95%A3%E5%88%97%E8%A1%A8/</id>
    <published>2020-02-09T18:21:54.000Z</published>
    <updated>2020-02-09T18:24:07.894Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Intro"><a href="#1-Intro" class="headerlink" title="1. Intro"></a>1. Intro</h1><p>散列表 - Hash Table, 又被称为哈希表或者Hash表。散列表用的是数组支持按照下标来随机访问数据的特性，因此散列表实际上是数组的一种扩展，由数组演化而来。</p><p>散列的思想就是对于key值，通过hash function，对应到table上来进行存储</p><p><img src="https://i.loli.net/2020/02/10/pnWdbkoVjUE7aTw.jpg" alt="fig1.jpg"></p><h1 id="2-散列函数"><a href="#2-散列函数" class="headerlink" title="2. 散列函数"></a>2. 散列函数</h1><p>散列函数就是实现输入到存储的对应的函数，因为最终是要存储到数组当中，故而其基本要求有：</p><ol><li>散列函数计算得到的散列值是一个非负整数</li><li>如果Key1 = Key2,那么hash(key1) == hash(key2)</li><li>如果key1 != key2, 那么hash(key1) != hash(key2)</li></ol><p>条件3 即如何应对散列冲突的问题，首先本身是必须的，而且客观是存在散列冲突的情况的，针对于散列冲突，我们一般会使用开放寻址法和链表法。</p><h1 id="3-如何解决散列冲突"><a href="#3-如何解决散列冲突" class="headerlink" title="3. 如何解决散列冲突"></a>3. 如何解决散列冲突</h1><h2 id="3-1-开放寻址法"><a href="#3-1-开放寻址法" class="headerlink" title="3.1 开放寻址法"></a>3.1 开放寻址法</h2><ul><li>核心思想<ul><li>出现了散列冲突，就重新探测一个空闲位置，将其插入</li></ul></li><li>探测方法<ul><li>线性探测</li><li>二次探测<ul><li>探测步长为二次方的增长 </li></ul></li><li>双重散列<ul><li>使用第一个散列函数进行尝试</li><li>如果计算得到的存储位置已经被占用，再用第二个散列函数，依次类推直到找到空闲的存储位置</li></ul></li></ul></li><li>装载因子<ul><li>引入装在引资的概念来表示空位的多少</li><li><code>装载因子 = 填入表中的元素个数/散列表的长度</code></li></ul></li></ul><h2 id="3-2-链表法"><a href="#3-2-链表法" class="headerlink" title="3.2 链表法"></a>3.2 链表法</h2><p><img src="https://i.loli.net/2020/02/10/VAUezcR2phPlYjT.jpg" alt="fig2.jpg"></p><p>链表法是一种更加常用的散列冲突解决办法，相比开放寻址法，它要简单很多。我们来看这个图，在散列表中，每个“桶（bucket）”或者“槽（slot）”会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中。</p><h1 id="4-工程上使用的散列表"><a href="#4-工程上使用的散列表" class="headerlink" title="4. 工程上使用的散列表"></a>4. 工程上使用的散列表</h1><p>首先我们需要思考下实际应用场景当中的散列表，虽然我们说散列表的查询效率是O(1), 实质上他的真实数据时和散列函数，装载因子，散列冲突都有关系的。如果散列函数设计的不好，或者装载因子过高，都可能导致散列冲突发生的概率升高，从而导致查询的效率下降。</p><p>因此对于在工程上使用的散列表，首先要考虑的就是需要能够应对各种异常情况，来避免散列冲突的情况下散列表性能的急剧下降，并且需要能够抵抗散列碰撞攻击。</p><h2 id="4-1-如何设计散列函数"><a href="#4-1-如何设计散列函数" class="headerlink" title="4.1 如何设计散列函数"></a>4.1 如何设计散列函数</h2><ul><li>需求<ul><li>散列函数的设计不能太复杂 <ul><li>会消耗很多计算时间</li><li>即会影响到散列表的性能</li></ul></li><li>散列函数生成的值需要尽可能随机并且均匀分布</li></ul></li><li>如何解决装载因子过大的问题<ul><li>针对散列表，当装载因子过大的时候，我们也可以进行动态扩容，重新申请一个更大的散列表，将数据搬移到这个新的散列表当中。</li><li>同时也有装载因子太小的情况下，我们可以做动态缩容的工作</li></ul></li><li>如何避免低效扩容<ul><li>所谓低效的扩容指的是如果我们在装载因子超过阈值的时候一下子进行扩容，即数据的搬运和最终的新数据的插入，那针对这一个数据，其时间复杂度变成了O(n).</li><li>为了解决这个问题，我们在需要进行扩容的时候，将扩容的操作穿插在插入操作的过程当中，分批次来完成。当装载因子触达阈值的时候，只申请新空间，但是没有将老的数据搬移到新的散列表当中。</li><li>当有新数据插入的时候，就将新数据放到新的散列表当中，并且从老的散列表当中拿一个数据放到新的散列表当中</li><li>而查询操作，为了兼顾，我们会先从新的散列表当中查找，如果没有找到，再去老的散列表当中查找</li></ul></li></ul><h2 id="4-2-如何解决冲突？"><a href="#4-2-如何解决冲突？" class="headerlink" title="4.2 如何解决冲突？"></a>4.2 如何解决冲突？</h2><h3 id="4-2-1-开放寻址法"><a href="#4-2-1-开放寻址法" class="headerlink" title="4.2.1 开放寻址法"></a>4.2.1 开放寻址法</h3><ul><li>优势<ul><li>数据都存储在数组当中，可以有效利用CPU缓存加快查询速度</li><li>序列化比较简单</li></ul></li><li>缺陷<ul><li>删除数据比较麻烦，需要特殊标记已经删除的数据</li><li>冲突代价高，导致装载因子的上限不能太大</li></ul></li></ul><blockquote><p>当数据量比较小，装载因子小的时候，适合使用开放寻址法。</p></blockquote><h3 id="4-2-2-链表法"><a href="#4-2-2-链表法" class="headerlink" title="4.2.2 链表法"></a>4.2.2 链表法</h3><ul><li>优势<ul><li>对内存的利用率相对比较高，因为链表结点可以在需要的时候再创建，不需要提前申请好</li><li>可以允许很高的装载因子</li></ul></li><li>劣势<ul><li>因为要存储指针，对于小的对象的存储，是更加耗内存的</li><li>因为结点零散分布在内存当中，不是连续的，所以对CPU缓存不友好，对执行效率会造成一定的影响</li></ul></li></ul><h2 id="4-3-Java-HashMap举例"><a href="#4-3-Java-HashMap举例" class="headerlink" title="4.3 Java HashMap举例"></a>4.3 Java HashMap举例</h2><ul><li>初始大小 - 16<ul><li>如果大概知道数据量的大小，可以修改默认，来减少动态扩容的次数</li></ul></li><li>装载因子和动态扩容<ul><li>默认 load factor 0.75 </li><li>每次扩容大小变为两倍</li></ul></li><li>散列冲突解决方法<ul><li>采用链表法</li><li>1.8以后当链表长度超过8以后，链表就会自动转化为红黑树</li></ul></li><li>散列函数</li></ul><pre><code>int hash(Object key) {    int h = key.hashCode()；    return (h ^ (h &gt;&gt;&gt; 16)) &amp; (capicity -1); //capicity表示散列表的大小} </code></pre><p><code>&amp;(capacity - 1)</code> means <code>% capacity</code></p><p>因为hashcode本身是个32位的整型值，获得其hash值以后，将高16位移到低16位，就相当于拿到了高16位和低16位的feature。用自己的高半区和低半区做异或，为的是加大低位的随机性。这样子哪怕是高位的变化也可以反映到低位当中，保证了最终进bin的随机性</p><h1 id="5-散列表实际应用"><a href="#5-散列表实际应用" class="headerlink" title="5. 散列表实际应用"></a>5. 散列表实际应用</h1><p>散列表和链表经常是共同使用的,这一部分会walk through一些常用的场景，看看是如何来共同使用的。</p><h2 id="5-1-LRU缓存淘汰算法"><a href="#5-1-LRU缓存淘汰算法" class="headerlink" title="5.1 LRU缓存淘汰算法"></a>5.1 LRU缓存淘汰算法</h2><p>最基础的LRU实现，我们可以通过链表来做.维护一个按照访问时间从大到小有序排列的链表结构，因为缓存大小有限，当缓存空间不够，需要淘汰一个数据的时候，我们就直接将链表头部的结点删除。</p><p>我们可以选择使用散列表和双向链表一起来实现LRU cache。要实现的操作有：</p><ul><li>往缓存中加入数据</li><li>从缓存中删除数据</li><li>在缓存中查找数据</li></ul><p><img src="https://i.loli.net/2020/02/10/LIB2nkbZYudrq37.jpg" alt="fig3.jpg"></p><p>如图所示，我们相当于在维护两条链表，一条是在哈希表的每个entry上的链，在这上面的链是为了解决哈希冲突的；另外一个点，我们在使用的是维护LRU cache的链表。</p><p>链表当中的每个结点保存了：</p><ul><li>prev</li><li>next</li><li>data</li><li>hnext<ul><li>散列表上碰撞问题的解决的 </li></ul></li></ul><h2 id="5-2-Java-LinkedHashMap"><a href="#5-2-Java-LinkedHashMap" class="headerlink" title="5.2 Java LinkedHashMap"></a>5.2 Java LinkedHashMap</h2><p>LinkedHashMap能够实现按照数据的插入顺序来进行打印，是因为他也是通过散列表和链表组合在一起的方式实现的。它支持按照插入顺序遍历数据，还支持按照访问顺序来遍历数据</p><pre><code>// 10是初始大小，0.75是装载因子，true是表示按照访问时间排序HashMap&lt;Integer, Integer&gt; m = new LinkedHashMap&lt;&gt;(10, 0.75f, true);m.put(3, 11);m.put(1, 12);m.put(5, 23);m.put(2, 22);m.put(3, 26);m.get(5);for (Map.Entry e : m.entrySet()) {  System.out.println(e.getKey());}// print out: 1, 2, 3, 5</code></pre><p><img src="https://i.loli.net/2020/02/10/wxy1tumrZO3DXQz.jpg" alt="fig4.jpg"></p><p><img src="https://i.loli.net/2020/02/10/9phoBuRSI5gsJC4.jpg" alt="fig5.jpg"></p><p><img src="https://i.loli.net/2020/02/10/3KGVI15LDp4PSAZ.jpg" alt="fig6.jpg"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Intro&quot;&gt;&lt;a href=&quot;#1-Intro&quot; class=&quot;headerlink&quot; title=&quot;1. Intro&quot;&gt;&lt;/a&gt;1. Intro&lt;/h1&gt;&lt;p&gt;散列表 - Hash Table, 又被称为哈希表或者Hash表。散列表用的是数组支持按照下标来
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://www.llchen60.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="散列表" scheme="https://www.llchen60.com/tags/%E6%95%A3%E5%88%97%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法(13)-跳表</title>
    <link href="https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-13-%E8%B7%B3%E8%A1%A8/"/>
    <id>https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-13-%E8%B7%B3%E8%A1%A8/</id>
    <published>2020-02-09T18:11:25.000Z</published>
    <updated>2020-02-09T18:12:09.716Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h1><ul><li>跳表<ul><li>动态数据结构</li><li>可以支持快速的插入，删除，查找操作</li><li>写起来也不会很复杂</li></ul></li></ul><p>Redis当中的有序集合就是用跳表来实现的。</p><h1 id="2-如何理解跳表"><a href="#2-如何理解跳表" class="headerlink" title="2. 如何理解跳表"></a>2. 如何理解跳表</h1><p>对于一个单链表来说，即便链表当中存储的数据是有序的，如果我们想要从中查找某个数据，也只能从头到尾遍历链表，这样查找效率就会非常低，时间复杂度比较高，O(n)</p><p>为了解决这个问题，我们可以对链表建立一级索引，每几个结点就提取一个结点到上一级当中，抽出来的那一级我们就可以将其叫做索引或者索引层了。</p><p>通过增加索引的层级，来加快寻找节点的速度，这就是跳表 – 链表加上多级索引的结构</p><ul><li>时间复杂度非常理想 O(logn)</li><li>但是相对来说会更需要内存一些  空间复杂度为O(n)</li></ul><h1 id="3-高效的动态插入和删除操作"><a href="#3-高效的动态插入和删除操作" class="headerlink" title="3. 高效的动态插入和删除操作"></a>3. 高效的动态插入和删除操作</h1><p>其动态的插入和删除操作的时间复杂度为O(logn)</p><p><img src="https://i.loli.net/2020/02/10/f4vdSyzCEs2KWFY.jpg" alt="fig1.jpg"></p><p>删除操作，还是需要拿到删除节点的前驱节点，然后通过指针操作完成删除。</p><h2 id="4-跳表索引动态更新"><a href="#4-跳表索引动态更新" class="headerlink" title="4. 跳表索引动态更新"></a>4. 跳表索引动态更新</h2><p><img src="https://i.loli.net/2020/02/10/J5QxpXFgAeTCa2j.jpg" alt="fig2.jpg"></p><p>跳表是需要不断更新的，因为当我们不断向跳表里面插入数据的时候，如果我们不更新索引，就有可能出现两个索引节点之间数据非常多的情况。极端情况下，跳表就会退化成单链表。</p><ul><li>我们需要某种方式来维护索引与原始链表大小之间的平衡<ul><li>跳表是通过随机函数来维护平衡性的</li><li>当我们往跳表里面插入数据的时候，可以选择同时将这个数据插入到部分索引层当中。</li><li>根据随机函数来决定这个结点插入到哪几级索引当中。</li></ul></li></ul><p><img src="https://i.loli.net/2020/02/10/64FQnKPZ8uWlTCb.jpg" alt="fig3.jpg"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-概念&quot;&gt;&lt;a href=&quot;#1-概念&quot; class=&quot;headerlink&quot; title=&quot;1. 概念&quot;&gt;&lt;/a&gt;1. 概念&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;跳表&lt;ul&gt;
&lt;li&gt;动态数据结构&lt;/li&gt;
&lt;li&gt;可以支持快速的插入，删除，查找操作&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://www.llchen60.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="跳表" scheme="https://www.llchen60.com/tags/%E8%B7%B3%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法(12)-二分查找</title>
    <link href="https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-12-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <id>https://www.llchen60.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-12-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</id>
    <published>2020-02-09T18:07:07.000Z</published>
    <updated>2020-02-09T18:07:27.910Z</updated>
    
    <content type="html"><![CDATA[<p>二分查找是一种针对于有序数据集合的查找算法，也叫折半查找算法。类似分治的思想，每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为0. 查找速度为O(logn)</p><p>思考题：1000万个整数数据，每个数据8字节，</p><h1 id="1-二分查找的基本实现"><a href="#1-二分查找的基本实现" class="headerlink" title="1. 二分查找的基本实现"></a>1. 二分查找的基本实现</h1><pre><code>public int bsearch(int[] a, int n, int value) {// 定基准点  int low = 0;  int high = n - 1;// 停止条件  while (low &lt;= high) {    // 定二分点    int mid = (low + high) / 2;    if (a[mid] == value) {      return mid;    } else if (a[mid] &lt; value) {     // 保证是活循环..       low = mid + 1;    } else {      high = mid - 1;    }  }  return -1;}// 二分查找的递归实现public int bsearch(int[] a, int n, int val) {  return bsearchInternally(a, 0, n - 1, val);}private int bsearchInternally(int[] a, int low, int high, int value) {  if (low &gt; high) return -1;  int mid =  low + ((high - low) &gt;&gt; 1);  if (a[mid] == value) {    return mid;  } else if (a[mid] &lt; value) {    return bsearchInternally(a, mid+1, high, value);  } else {    return bsearchInternally(a, low, mid-1, value);  }}</code></pre><ul><li>循环退出条件<ul><li>low &lt;= high </li></ul></li><li>mid取值<ul><li>mid = low + (high - low)/2</li><li>因为如果值太大的话，会溢出的</li></ul></li><li>low high的更新<ul><li>low = mid + 1</li><li>high = mid - 1 </li></ul></li></ul><h1 id="2-二分查找的应用场景局限性"><a href="#2-二分查找的应用场景局限性" class="headerlink" title="2. 二分查找的应用场景局限性"></a>2. 二分查找的应用场景局限性</h1><ul><li>二分查找以来的是顺序表结构  – 数组<ul><li>因为二分查找需要按照下标来随机访问元素</li></ul></li><li>针对的是有序数据 – 静态数据集<ul><li>更适用在插入，删除不频繁，一次排序多次查找的场景当中</li><li>针对动态变化的数据集合，二分查找就不再适用了</li></ul></li><li>数据量太小不需要适用二分查找</li><li>如果数据之间的比较非常耗时，我们需要尽力减少比较的次数，那么二分查找就是很好的方式了</li></ul><h1 id="3-二分查找的实际应用与变体"><a href="#3-二分查找的实际应用与变体" class="headerlink" title="3. 二分查找的实际应用与变体"></a>3. 二分查找的实际应用与变体</h1><h2 id="3-1-查找第一个值等于给定值的元素"><a href="#3-1-查找第一个值等于给定值的元素" class="headerlink" title="3.1 查找第一个值等于给定值的元素"></a>3.1 查找第一个值等于给定值的元素</h2><pre><code>public int bsearch(int[] a, int n, int value) {  int low = 0;  int high = n - 1;  while (low &lt;= high) {    int mid =  low + ((high - low) &gt;&gt; 1);    if (a[mid] &gt; value) {      high = mid - 1;    } else if (a[mid] &lt; value) {      low = mid + 1;    } else {      // 注意这里的判断，中止条件时mid为0 或者左一个的值和现在的值不相等       if ((mid == 0) || (a[mid - 1] != value)) return mid;      else high = mid - 1;    }  }  return -1;}</code></pre><ul><li>写二分相关的算法要注意的点有<ul><li>终止条件</li><li>区间上下界的更新方法</li><li>返回值的选择</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;二分查找是一种针对于有序数据集合的查找算法，也叫折半查找算法。类似分治的思想，每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为0. 查找速度为O(logn)&lt;/p&gt;
&lt;p&gt;思考题：1000万个整数数据，每个数据8字节，&lt;
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://www.llchen60.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="二分查找" scheme="https://www.llchen60.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
</feed>
