<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>React初探</title>
      <link href="/React%E5%88%9D%E6%8E%A2/"/>
      <url>/React%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<p>初探React,很喜欢Component这种方式，很大程度提高了复用性，如果抛除C/S的区别，感觉有点像mason，毕竟刚刚弃掉mason的坑，很有意思的React。</p><h1 id="1-Hello-World"><a href="#1-Hello-World" class="headerlink" title="1. Hello World"></a>1. Hello World</h1><p>React.Component   A component takes in parameters, called props and returns a hierarchy of views to display via the render method. </p><p>To collect data from multiple children, or to have two child components communicate with each other, you need to declare the shared state in their parent component instead. <strong>The parent component can pass the state back down to the children by using props; this keeps the child components in sync with each other and with the parent component.</strong> </p><pre><code>ReactDOM.render(    &lt;h1&gt;Hello, world!&lt;/h1&gt;,    document.getElementById(&apos;root&apos;));</code></pre><h1 id="2-JSX"><a href="#2-JSX" class="headerlink" title="2. JSX"></a>2. JSX</h1><p>jsx, 一种JavaScript的语法扩展。用来声明React当中的元素。可以任意在<strong>大括号{}</strong>里面使用<strong>JS表达式</strong>.</p><h2 id="2-1-JS表达式"><a href="#2-1-JS表达式" class="headerlink" title="2.1 JS表达式"></a>2.1 JS表达式</h2><blockquote><p>Any valid unit of code that resolves to a value. </p></blockquote><h3 id="2-1-1-分类"><a href="#2-1-1-分类" class="headerlink" title="2.1.1 分类"></a>2.1.1 分类</h3><ul><li><p>Arithmetic</p></li><li><p>String </p></li><li><p>Logical</p></li><li><p>Primary Expressions</p></li></ul><p>Basic keywords and general expressions in JS.</p><ol><li><p>this: refer to the current object.</p></li><li><p>grouping operator() : controls the precedence of evaluation in expressions. </p></li><li><p>new: to create an instance of a user-defined object type </p></li><li><p>super: call functions on an object’s parent.</p></li><li><p>spread operator: allow an expression to be expanded in places where multiple arguments or multiple elements are expected. </p><pre><code> function f(x, y, z) { }var args = [0, 1, 2];f(...args);</code></pre></li></ol><ul><li>Left hand side expressions</li></ul><h2 id="2-2-JSX-属性"><a href="#2-2-JSX-属性" class="headerlink" title="2.2 JSX 属性"></a>2.2 JSX 属性</h2><p>编译之后，会被转化为普通的JS对象。这意味着可以在if 或者for语句里使用JSX，将其赋值给变量，当做参数传入或者作为返回值都可以。</p><pre><code>// 使用引号定义以字符串为值得属性const element = &lt;div tabIndex=&quot;0&quot;&gt;&lt;/div&gt;;// 使用大括号来定义以js表达式为值得属性const element = &lt;img src={user.avatarUrl}&gt;&lt;/img&gt;;</code></pre><p>JSX代表Objects, Babel转译器会把JSX转换成一个名为React.createEliment()的方法来调用</p><h2 id="2-3-嵌套与防注入攻击"><a href="#2-3-嵌套与防注入攻击" class="headerlink" title="2.3 嵌套与防注入攻击"></a>2.3 嵌套与防注入攻击</h2><pre><code>const element = (  &lt;div&gt;    &lt;h1&gt;Hello!&lt;/h1&gt;    &lt;h2&gt;Good to see you here.&lt;/h2&gt;  &lt;/div&gt;);React DOM在渲染之前会过滤所有传入的值，可以确保应用不会被注入攻击，因为所有内容渲染之前都已经被转化为了字符串，有效防止XSS。 </code></pre><h1 id="3-元素渲染"><a href="#3-元素渲染" class="headerlink" title="3. 元素渲染"></a>3. 元素渲染</h1><p>React中的元素实际上是普通的对象，React DOM可以确保浏览器DOM的数据内容与React元素保持一致。<br>寻找React 根节点，渲染在根节点上</p><pre><code>const element = &lt;h1&gt;Hello, world&lt;/h1&gt;;ReactDOM.render(element, document.getElementById(&apos;root&apos;));</code></pre><h2 id="3-1-更新元素渲染"><a href="#3-1-更新元素渲染" class="headerlink" title="3.1 更新元素渲染"></a>3.1 更新元素渲染</h2><p>React 元素都是immutable的，更新界面的方式就是创建一个新的元素，然后将其传入<code>ReactDOM.render()</code> </p><p>React DOM 会比较元素的内容的先后的不同，而在渲染过程中只会更新改变了的部分。</p><h1 id="4-组件-amp-props"><a href="#4-组件-amp-props" class="headerlink" title="4. 组件 &amp; props"></a>4. 组件 &amp; props</h1><p>组件将UI切分成一些独立的，可复用的部件，这样就可以专注于构建每一个单独的部件。概念上像<strong>函数</strong>一样，可以接受任意的输入值(props)，并返回一个在页面上展示的React元素。</p><h2 id="4-1-函数定义组件"><a href="#4-1-函数定义组件" class="headerlink" title="4.1 函数定义组件"></a>4.1 函数定义组件</h2><pre><code>function Welcome(props) {    return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;;}</code></pre><h2 id="4-2-ES6-class-定义组件"><a href="#4-2-ES6-class-定义组件" class="headerlink" title="4.2 ES6 class 定义组件"></a>4.2 ES6 class 定义组件</h2><pre><code>class Welcome extends React.Component {    render() {        return &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;    }}</code></pre><h2 id="4-3-组件渲染"><a href="#4-3-组件渲染" class="headerlink" title="4.3 组件渲染"></a>4.3 组件渲染</h2><pre><code>// React 元素可以使用户自定义的组件const element = &lt;Welcome name=&quot;Sara&quot; /&gt;;</code></pre><p><strong>当React遇到的元素是用户自定义的组件，它会将JSX属性作为单个对象传递给该组件，这个对象被称为”props”</strong></p><blockquote><p>组件名称必须大写</p></blockquote><h2 id="4-4-组合组件"><a href="#4-4-组合组件" class="headerlink" title="4.4 组合组件"></a>4.4 组合组件</h2><p>组件可以在它的输出中引用其他组件，这样我们就可以用同一组件来抽象出任意层次的细节。</p><blockquote><p>一个新的React应用程序的顶部是一个App组件。但是，如果要将React集成到现有应用程序中，则可以从下而上使用像Button这样的小组件作为开始，并逐渐运用到视图层的顶部。</p></blockquote><blockquote><p>组件的返回值只能有一个根元素。这也是我们要用一个<div>来包裹所有<Welcome />元素的原因。</p></blockquote><h2 id="4-5-提取组件"><a href="#4-5-提取组件" class="headerlink" title="4.5 提取组件"></a>4.5 提取组件</h2><p>分割组件，</p><h2 id="4-6-Props的只读性"><a href="#4-6-Props的只读性" class="headerlink" title="4.6 Props的只读性"></a>4.6 Props的只读性</h2><p>所有的React组件必须像纯函数那样使用它们的props</p><h1 id="5-State-amp-生命周期"><a href="#5-State-amp-生命周期" class="headerlink" title="5. State &amp; 生命周期"></a>5. State &amp; 生命周期</h1><p>更新UI的方法： <code>ReactDOM.render()</code></p><p>还可以通过更新状态来更新UI，<strong>状态是私有的，完全受控于当前组件</strong></p><h2 id="5-1-将函数转换为类"><a href="#5-1-将函数转换为类" class="headerlink" title="5.1 将函数转换为类"></a>5.1 将函数转换为类</h2><p>定义为类的组件有状态这个特性，还有生命周期钩子。</p><p>函数转换为类的步骤： </p><ol><li>创建一个名称扩展为<code>React.Component</code>的类</li><li>创建一个<code>render()</code>空方法</li><li>将函数体移动到render()方法中</li><li>在render()方法中，使用this.props替换props</li><li>删除剩余的空函数声明</li></ol><h2 id="5-2-为类添加局部状态"><a href="#5-2-为类添加局部状态" class="headerlink" title="5.2 为类添加局部状态"></a>5.2 为类添加局部状态</h2><pre><code>Class Clock extends React.Component {    constructor(props) {        super(props);        this.state = {date: new Date()};    }    render() {        return (            &lt;div&gt;                &lt;h1&gt;Hello, world!&lt;/h1&gt;                &lt;h2&gt;It is {this.state.date.toLocaleTimeString()}.&lt;/h2&gt;            &lt;/div&gt;        );    }}ReactDOM.render(    &lt;Clock/&gt;    document.getElementById(&apos;root&apos;));</code></pre><h2 id="5-3-添加生命周期方法到类中"><a href="#5-3-添加生命周期方法到类中" class="headerlink" title="5.3 添加生命周期方法到类中"></a>5.3 添加生命周期方法到类中</h2><p>当组件第一次加载到DOM中时，生成定时器，挂载</p><pre><code>componentDidMount() {}</code></pre><p>当Clock生成的这个DOM被移除时，清除定时器，卸载</p><pre><code>componentWillUnmount() {}</code></pre><p>一个完整的Clock的例子： </p><pre><code>class Clock extends React.Component {    constructor(props) {        super(props);        this.state = {date: new Date()};    }    // 3. Called when Clock&apos;s output is injected into DOM     componentDidMount() {        this.timerID = setInterval(            () =&gt; this.tick(),                1000        );    }    componentWillUnmount() {        clearInterval(this.timerID);    }    // 4. when setState() is being called, render() is called     tick() {        this.setState({            date: new Date()        });    }    // 2. Call render(), react know what need to be shown on screen. Update DOM     render() {        return (          &lt;div&gt;            &lt;h1&gt;Hello, world!&lt;/h1&gt;            &lt;h2&gt;It is {this.state.date.toLocaleTimeString()}.&lt;/h2&gt;          &lt;/div&gt;        );    }}ReactDOM.render(// 1. call Clock&apos;s constructor  &lt;Clock /&gt;,  document.getElementById(&apos;root&apos;));</code></pre><h2 id="5-4-如何使用状态"><a href="#5-4-如何使用状态" class="headerlink" title="5.4 如何使用状态"></a>5.4 如何使用状态</h2><ol><li><p>不要直接更新状态</p><p> use: this.setState({comment: ‘hi’});</p></li></ol><blockquote><p>构造函数是唯一能够初始化this.state的地方</p></blockquote><ol start="2"><li>状态更新可能是异步的</li></ol><p>React可以将多个<code>setState()</code>调用合并成一个来提高性能</p><pre><code>// Wrongthis.setState({  counter: this.state.counter + this.props.increment,});// Correctthis.setState((prevState, props) =&gt; ({  counter: prevState.counter + props.increment}));// Correctthis.setState(function(prevState, props) {  return {    counter: prevState.counter + props.increment  };});</code></pre><ol start="3"><li>当调用<code>setState()</code>的时候，React会将你提供的对象合并到当前状态。可以只提供state的一部分。</li></ol><h2 id="5-5-数据流动方向：-自顶向下"><a href="#5-5-数据流动方向：-自顶向下" class="headerlink" title="5.5 数据流动方向： 自顶向下"></a>5.5 数据流动方向： 自顶向下</h2><p>父组件或子组件都不知道某个组件是否有状态，组件可以选择将其状态作为属性传递给其子组件。</p><h1 id="6-事件处理"><a href="#6-事件处理" class="headerlink" title="6. 事件处理"></a>6. 事件处理</h1><p>React事件绑定属性的命名采用驼峰式写法</p><p>采用jsx的语法你需要传入一个函数作为事件处理函数，而不是一个字符串。</p><pre><code>&lt;button onClick={activateLasers}&gt;    Activate Lasers&lt;/button&gt;</code></pre><h2 id="6-1-Toggle"><a href="#6-1-Toggle" class="headerlink" title="6.1 Toggle"></a>6.1 Toggle</h2><pre><code>class Toggle extends React.Component {    constructor(props) {    super(props);    this.state = {isToggleOn: true};    // This binding is necessary to make `this` work in the callback    this.handleClick = this.handleClick.bind(this);    }    handleClick() {        this.setState(prevState =&gt; ({            isToggleOn: !prevState.isToggleOn        }));    }    render() {        return (        // &lt;button onClick={(e) =&gt; this.handleClick(e)}&gt;         // 问题L每次渲染的时候都会创建一个不同的回调函数            &lt;button onClick={this.handleClick}&gt;                {this.state.isToggleOn ? &apos;ON&apos; : &apos;OFF&apos;}            &lt;/button&gt;        );    }}ReactDOM.render(    &lt;Toggle /&gt;,    document.getElementById(&apos;root&apos;));</code></pre><p>必须谨慎对待JSX回调函数中的this，类的方法默认不会绑定this的。如果你忘记绑定 <code>this.handleClick</code> 并把它传入 <code>onClick</code>, 当你调用这个函数的时候 <code>this</code> 的值会是 <code>undefined</code>。</p><h2 id="6-2-Todolist"><a href="#6-2-Todolist" class="headerlink" title="6.2 Todolist"></a>6.2 Todolist</h2><pre><code>class TodoApp extends React.Component {    constructor(props) {        super(props);        this.state = { items: [], text: &apos;&apos; };        this.handleChange = this.handleChange.bind(this);        this.handleSubmit = this.handleSubmit.bind(this);    }    render() {        return (            &lt;div&gt;                &lt;h3&gt;TODO&lt;/h3&gt;                &lt;TodoList items={this.state.items} /&gt;                &lt;form onSubmit={this.handleSubmit}&gt;                  &lt;input                    onChange={this.handleChange}                    value={this.state.text}                  /&gt;                  &lt;button&gt;                    Add #{this.state.items.length + 1}                  &lt;/button&gt;                &lt;/form&gt;            &lt;/div&gt;        );    }    handleChange(e) {        this.setState({ text: e.target.value });    }    handleSubmit(e) {        e.preventDefault();        if (!this.state.text.length) {            return;        }        const newItem = {            text: this.state.text,            id: Date.now()        };        this.setState(prevState =&gt; ({            items: prevState.items.concat(newItem),            text: &apos;&apos;        }));    }}class TodoList extends React.Component {    render() {        return (            &lt;ul&gt;                {this.props.items.map(item =&gt; (                  &lt;li key={item.id}&gt;{item.text}&lt;/li&gt;                ))}            &lt;/ul&gt;        );    }}ReactDOM.render(&lt;TodoApp /&gt;, mountNode);</code></pre><h2 id="6-3-向事件处理程序传递参数"><a href="#6-3-向事件处理程序传递参数" class="headerlink" title="6.3 向事件处理程序传递参数"></a>6.3 向事件处理程序传递参数</h2><pre><code>&lt;button onClick={(e) =&gt; this.deleteRow(id, e)}&gt;Delete Row&lt;/button&gt;&lt;button onClick={this.deleteRow.bind(this, id)}&gt;Delete Row&lt;/button&gt;</code></pre><p>参数 e 作为 React 事件对象将会被作为第二个参数进行传递。通过箭头函数的方式，事件对象必须显式的进行传递，但是通过 bind 的方式，事件对象以及更多的参数将会被隐式的进行传递。</p><h2 id="6-4-bind-向监听函数传参，-事件对象e需要放在最后"><a href="#6-4-bind-向监听函数传参，-事件对象e需要放在最后" class="headerlink" title="6.4 bind 向监听函数传参， 事件对象e需要放在最后"></a>6.4 bind 向监听函数传参， 事件对象e需要放在最后</h2><pre><code>class Popper extends React.Component{    constructor(){        super();        this.state = {name:&apos;Hello world!&apos;};    }    preventPop(name, e){    //事件对象e要放在最后        e.preventDefault();        alert(name);    }    render(){        return (            &lt;div&gt;                &lt;p&gt;hello&lt;/p&gt;                {/* Pass params via bind() method. */}                &lt;a href=&quot;https://reactjs.org&quot; onClick={this.preventPop.bind(this,this.state.name)}&gt;Click&lt;/a&gt;            &lt;/div&gt;        );    }}</code></pre><h1 id="7-条件渲染"><a href="#7-条件渲染" class="headerlink" title="7. 条件渲染"></a>7. 条件渲染</h1><p>可以创建不同的组件来封装各种你需要的行为。然后根据应用的状态变化只渲染其中的一部分。(if)</p><pre><code>function Greeting(props) {    const isLoggedIn = props.isLoggedIn;    if (isLoggedIn) {        return &lt;UserGreeting /&gt;;    }    return &lt;GuestGreeting /&gt;;}ReactDOM.render(  // Try changing to isLoggedIn={true}:  &lt;Greeting isLoggedIn={false} /&gt;,  document.getElementById(&apos;root&apos;));</code></pre><h2 id="7-1-与运算符-amp-amp"><a href="#7-1-与运算符-amp-amp" class="headerlink" title="7.1 与运算符 &amp;&amp;"></a>7.1 与运算符 &amp;&amp;</h2><pre><code>function Mailbox(props) {    const unreadMessages = props.unreadMessages;    return (        &lt;div&gt;          &lt;h1&gt;Hello!&lt;/h1&gt;          {unreadMessages.length &gt; 0 &amp;&amp;            &lt;h2&gt;              You have {unreadMessages.length} unread messages.            &lt;/h2&gt;          }        &lt;/div&gt;    );}const messages = [&apos;React&apos;, &apos;Re: React&apos;, &apos;Re:Re: React&apos;];ReactDOM.render(  &lt;Mailbox unreadMessages={messages} /&gt;,  document.getElementById(&apos;root&apos;));</code></pre><p><strong>在 JavaScript 中，true &amp;&amp; expression 总是返回 expression，而 false &amp;&amp; expression 总是返回 false。</strong></p><h2 id="7-2-阻止组件渲染"><a href="#7-2-阻止组件渲染" class="headerlink" title="7.2 阻止组件渲染"></a>7.2 阻止组件渲染</h2><pre><code>function WarningBanner(props) {    if (!props.warn) {        return null;    }    return (        &lt;div className=&quot;warning&quot;&gt;            Warning!        &lt;/div&gt;    );}class Page extends React.Component {    constructor(props) {        super(props);        this.state = {showWarning: true}        this.handleToggleClick = this.handleToggleClick.bind(this);    }    handleToggleClick() {        this.setState(prevState =&gt; ({            showWarning: !prevState.showWarning        }));    }    render() {        return (            &lt;div&gt;                &lt;WarningBanner warn={this.state.showWarning} /&gt;                &lt;button onClick={this.handleToggleClick}&gt;                {this.state.showWarning ? &apos;Hide&apos; : &apos;Show&apos;}                &lt;/button&gt;            &lt;/div&gt;        );    }}ReactDOM.render(  &lt;Page /&gt;,  document.getElementById(&apos;root&apos;));</code></pre><h1 id="8-列表-amp-Keys"><a href="#8-列表-amp-Keys" class="headerlink" title="8. 列表 &amp; Keys"></a>8. 列表 &amp; Keys</h1><h2 id="8-1-渲染多个组件"><a href="#8-1-渲染多个组件" class="headerlink" title="8.1 渲染多个组件"></a>8.1 渲染多个组件</h2><pre><code>const numbers = [1, 2, 3, 4, 5];const listItems = numbers.map(    (number) =&gt; &lt;li&gt;{number}&lt;/li&gt;);ReactDOM.render(    &lt;ul&gt;{listItems}&lt;/ul&gt;    documnet.getElementById(&apos;root&apos;));</code></pre><h2 id="8-2-基础列表组件"><a href="#8-2-基础列表组件" class="headerlink" title="8.2 基础列表组件"></a>8.2 基础列表组件</h2><pre><code>function NumberList(props) {    const numbers = props.numbers;    const listItems = numbers.map((number) =&gt;        &lt;li key={number.toString()}&gt;            {number}        &lt;/li&gt;    );    return (        &lt;ul&gt;{listItems}&lt;/ul&gt;    );}const numbers = [1, 2, 3, 4, 5];ReactDOM.render(  &lt;NumberList numbers={numbers} /&gt;,  document.getElementById(&apos;root&apos;));</code></pre><h2 id="8-3-Keys"><a href="#8-3-Keys" class="headerlink" title="8.3 Keys"></a>8.3 Keys</h2><p>Keys可以在DOM中的某些元素被增加或删除的时候帮助React识别哪些元素发生了变化。最好是该元素在列表中拥有的独一无二的字符串。使用来自数据的id作为元素的key</p><p>元素的key只有在它和它的兄弟节点对比时才有意义。</p><h1 id="9-表单"><a href="#9-表单" class="headerlink" title="9.表单"></a>9.表单</h1><p>HTML 表单元素与React中其他DOM元素有所不同，因为表单元素本来就保留一些内部状态了。会构造一个处理提交表单并可访问用户输入表单数据的函数。标准方法是使用受控组件。</p><h2 id="9-1-受控组件"><a href="#9-1-受控组件" class="headerlink" title="9.1 受控组件"></a>9.1 受控组件</h2><p>在HTML当中，像<code>&lt;input&gt;,&lt;textarea&gt;, 和 &lt;select&gt;</code>这类表单元素会维持自身状态，并根据用户输入进行更新。但在React中，可变的状态通常保存在组件的状态属性中，并且只能用 setState() 方法进行更新。</p><pre><code>class NameForm extends React.Component {    constructor(props) {        super(props);        this.state = {value: &apos;&apos;};        this.handleChange = this.handleChange.bind(this);        this.handleSubmit = this.handleSubmit.bind(this);    }    handleChange(event) {        this.setState({value: event.target.value});    }    handleSubmit(event) {        alert(&apos;A name was submitted: &apos; + this.state.value);        event.preventDefault();    }    render() {        return (            &lt;form onSubmit={this.handleSubmit}&gt;                &lt;label&gt;                  Name:                  &lt;input type=&quot;text&quot; value={this.state.value} onChange={this.handleChange} /&gt;                &lt;/label&gt;                &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;            &lt;/form&gt;        );    }}</code></pre><h2 id="9-2-textarea标签"><a href="#9-2-textarea标签" class="headerlink" title="9.2 textarea标签"></a>9.2 textarea标签</h2><pre><code>class EssayForm extends React.Component {    constructor(props) {        super(props);        this.state = {          value: &apos;Please write an essay about your favorite DOM element.&apos;        };        this.handleChange = this.handleChange.bind(this);        this.handleSubmit = this.handleSubmit.bind(this);    }    handleChange(event) {        this.setState({value: event.target.value});    }    handleSubmit(event) {        alert(&apos;An essay was submitted: &apos; + this.state.value);        event.preventDefault();    }    render() {        return (            &lt;form onSubmit={this.handleSubmit}&gt;                &lt;label&gt;                Name:                &lt;textarea value={this.state.value} onChange={this.handleChange} /&gt;                &lt;/label&gt;                &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;            &lt;/form&gt;        );    }}</code></pre><h2 id="9-3-select标签"><a href="#9-3-select标签" class="headerlink" title="9.3 select标签"></a>9.3 select标签</h2><p>React中，不适用selected属性表明选中项，而是在根select标签上用value属性来表示选中项。这在受控组件中更方便，因为只需要在一个地方更新组件。</p><pre><code>class FlavorForm extends React.Component {    constructor(props) {    super(props);    this.state = {value: &apos;coconut&apos;};    this.handleChange = this.handleChange.bind(this);    this.handleSubmit = this.handleSubmit.bind(this);}handleChange(event) {    this.setState({value: event.target.value});}handleSubmit(event) {    alert(&apos;Your favorite flavor is: &apos; + this.state.value);    event.preventDefault();}    render() {        return (            &lt;form onSubmit={this.handleSubmit}&gt;                &lt;label&gt;                    Pick your favorite La Croix flavor:                    &lt;select value={this.state.value} onChange={this.handleChange}&gt;                    &lt;option value=&quot;grapefruit&quot;&gt;Grapefruit&lt;/option&gt;                    &lt;option value=&quot;lime&quot;&gt;Lime&lt;/option&gt;                    &lt;option value=&quot;coconut&quot;&gt;Coconut&lt;/option&gt;                    &lt;option value=&quot;mango&quot;&gt;Mango&lt;/option&gt;                    &lt;/select&gt;                &lt;/label&gt;                &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;            &lt;/form&gt;        );    }}</code></pre><h2 id="9-4-多个输入的解决方法"><a href="#9-4-多个输入的解决方法" class="headerlink" title="9.4 多个输入的解决方法"></a>9.4 多个输入的解决方法</h2><p>通过给每个元素添加一个name属性，来让处理函数根据event.target.name的值来选择做什么</p><pre><code>class Reservation extends React.Component {    constructor(props) {        super(props);        this.state = {            isGoing: true,            numberOfGuests: 2        };        this.handleInputChange = this.handleInputChange.bind(this);    }    handleInputChange(event) {        const target = event.target;        const value = target.type === &apos;checkbox&apos; ? target.checked : target.value;        const name = target.name;        this.setState({            [name]: value        });    }    render() {        return (            &lt;form&gt;                &lt;label&gt;                    Is going:                    &lt;input                        name=&quot;isGoing&quot;                        type=&quot;checkbox&quot;                        checked={this.state.isGoing}                        onChange={this.handleInputChange} /&gt;                &lt;/label&gt;                &lt;br /&gt;                &lt;label&gt;                    Number of guests:                    &lt;input                        name=&quot;numberOfGuests&quot;                        type=&quot;number&quot;                        value={this.state.numberOfGuests}                        onChange={this.handleInputChange} /&gt;                &lt;/label&gt;            &lt;/form&gt;        );    }}</code></pre><h1 id="10-状态提升"><a href="#10-状态提升" class="headerlink" title="10. 状态提升"></a>10. 状态提升</h1><h2 id="10-1-摄氏度华氏度的例子"><a href="#10-1-摄氏度华氏度的例子" class="headerlink" title="10.1 摄氏度华氏度的例子"></a>10.1 摄氏度华氏度的例子</h2><p>状态分享是通过将state数据提升至离需要这些数据的组件最近的父组件来完成的</p><pre><code>class Calculator extends React.Component {    constructor(props) {        super(props);        this.handleCelsiusChange = this.handleCelsiusChange.bind(this);        this.handleFahrenheitChange = this.handleFahrenheitChange.bind(this);        this.state = {temperature: &apos;&apos;, scale: &apos;c&apos;};    }    handleCelsiusChange(temperature) {        this.setState({scale: &apos;c&apos;, temperature});    }    handleFahrenheitChange(temperature) {        this.setState({scale: &apos;f&apos;, temperature});    }    render() {        const scale = this.state.scale;        const temperature = this.state.temperature;        const celsius = scale === &apos;f&apos; ? tryConvert(temperature, toCelsius) : temperature;        const fahrenheit = scale === &apos;c&apos; ? tryConvert(temperature, toFahrenheit) : temperature;        return (          &lt;div&gt;            &lt;TemperatureInput              scale=&quot;c&quot;              temperature={celsius}              onTemperatureChange={this.handleCelsiusChange} /&gt;            &lt;TemperatureInput              scale=&quot;f&quot;              temperature={fahrenheit}              onTemperatureChange={this.handleFahrenheitChange} /&gt;            &lt;BoilingVerdict              celsius={parseFloat(celsius)} /&gt;          &lt;/div&gt;        );    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> FrontEnd </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -React -FrontEnd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二战时间线</title>
      <link href="/%E4%BA%8C%E6%88%98%E6%97%B6%E9%97%B4%E7%BA%BF/"/>
      <url>/%E4%BA%8C%E6%88%98%E6%97%B6%E9%97%B4%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<!--toc--><blockquote><p>对二战很感兴趣，依旧在不断了解中。未了解前完全没想到在不到80年前，我们这个世界因为战争在短短十多年间死去了7000万人。中间有太多的泯灭人性，亦有很多人性的光辉。不知道列宁格勒，如今的圣彼得堡的居民，在两年半的被围城中是如何活下来的，每个人，都真的是挺直了腰背，这一刻，尊严比命重要。有太多的细节可以探寻，也有很多微妙的节点，好多次盟军的胜利是因为一些不期而遇的变化，小人物的选择，天气的突然放晴。每每读到这种时候，心里总会长舒一口气，庆幸啊。（PS: 有部美剧，就特地开了脑洞，讲二战轴心国胜利以后的世界的样子… 一个真的敢拍，一个真的敢播，hhh ）Anyway，铭记历史~ </p></blockquote><h1 id="时间线（欧洲战场-and-太平洋战场）"><a href="#时间线（欧洲战场-and-太平洋战场）" class="headerlink" title="时间线（欧洲战场 and 太平洋战场）"></a>时间线（欧洲战场 and 太平洋战场）</h1><p>二战整个过程，德国东征波兰，北伐北欧、西吞法国、南并巴尔干，在欧洲大陆上大杀四方，无人可挡。但到了第二阶段，苏联以强大的力量阻遏了德国的闪电攻势，而年底日本对美国的偷袭更将可怕的敌人拉入了战争。在第三阶段，同盟国在太平洋战场、北非战场、东线战场相继赢得转折点性质的胜利。在第四阶段，扫清了北非的盟军开始进攻西欧大陆，苏联在东面的战场大举反攻。到第五阶段，轴心国崩溃，德国、日本相继投降（意大利早在上一阶段就已投降），战争结束。</p><h2 id="1939-1940"><a href="#1939-1940" class="headerlink" title="1939 - 1940"></a>1939 - 1940</h2><ul><li>1939.9 </li></ul><p>德国进攻波兰，闪电战，波兰迅速崩溃。波兰盟友英法向德国宣战，却没有采取大规模行动，形成了西线无战事的奇怪的战争。与德国签订有《德苏互不侵犯条约》的苏联更是趁机从东面入侵了波兰，一个月，战争结束，波兰被德苏两国瓜分。</p><ul><li>1930.11</li></ul><p>苏联入侵芬兰，在芬兰人的抵抗下，苏联损失惨重。两方面原因，芬兰人英勇抵抗，苏联在大清洗中洗掉了大量的优秀军官。最终苏联惨胜，签订《莫斯科和平协定》。</p><ul><li>1940.5 </li></ul><p>德国德国兵锋西指，几天内就攻陷了荷兰和比利时，驻守在<strong><em>马其诺防线</em></strong>北侧的英军、法军北上迎击，这落入了曼施坦因的圈套，德军出其不意地从<strong>阿登山区</strong>突入，“闪击战之父”古德里安率领坦克部队果断前进，切入到盟军侧背，形成围歼之势。盟军被迫在敦刻尔克乘英国的大小船只撤退到英国，这就是代号为“发电机行动”的敦刻尔克大撤退。无力抵抗的法国在德军的继续进攻下被迫投降，一部分国土被德国和意大利占领，另一部分国土则由贝当的“维希法国”管理。戴高乐在伦敦发表演说，不承认维希法国的合法性，组织自由法国继续抗争。几乎与此同时，苏联吞并了位于波罗的海的三个国家——爱沙尼亚、拉脱维亚和立陶宛。</p><ul><li>1940.8</li></ul><p>攻占法国后，希特勒开始着眼于英国，制定了“海狮计划”准备登陆英国。为了争夺登陆作战的制空权，德国空军从8月份开始对英国的空中攻势，英国军民在丘吉尔的领导下奋勇抵抗 —— 不列颠空战。1941年不列颠空战中，英国取得了最终胜利。</p><ul><li>1940.9</li></ul><p>利比亚的意大利军队入侵埃及，而后被英军击败并在12月反推至利比亚。10月，意大利入侵希腊，却迅速失败反而被希腊军队反推到阿尔巴尼亚。德国被迫卷入战争，入侵南斯拉夫和希腊。经过一系列战役后，巴尔干半岛上的战争最终以轴心国的胜利结束，整个巴尔干半岛都落入了轴心国的掌控之内。希特勒在次年又将隆美尔派往北非营救意大利。隆美尔取得了一系列胜利，赢得了“沙漠之狐”的美誉。轴心国在地中海、北非战场取得了一定进展，但德军因此推迟了入侵苏联的时间，希特勒后来为之懊恼不已。</p><h2 id="1941"><a href="#1941" class="headerlink" title="1941"></a>1941</h2><ul><li>1941.6</li></ul><p>德国巴巴罗萨行动，三路大军入侵苏联。北方集团军群攻占波罗的海三国，保卫列宁格勒，列宁格勒保卫战开始。中央集团军攻克斯摩棱斯克，直指莫斯科。南方军团在基辅大胜苏军，完成了历史上最大规模的歼灭战。</p><ul><li>1941.7</li></ul><p>英美冻结日本的资产，美国对日本实施了石油禁运政策，釜底抽薪之策啊。</p><ul><li>1941.12</li></ul><p>日本在太平洋上对英美发起了进攻。山本五十六偷袭珍珠港（12.7），美国从孤立主义转向参战。美国总统罗斯福对日本宣战，半年内日军依旧在太平洋战场占据优势。德军潜艇部队在邓尼茨的指挥下，运用狼群战术，对盟军航运船只造成了巨大的伤害。 </p><h2 id="1942"><a href="#1942" class="headerlink" title="1942"></a>1942</h2><ul><li>1942.5 </li></ul><p>太平洋珊瑚海，日军对抗盟军航母，日军航母祥凤号被击沉，翔鹤号受到重创，瑞鹤号飞机损耗严重。美军航母列星顿号沉没，约克城号受伤。这是日本在太平洋战场上的扩张势头第一次受到阻遏，盟军保住了美国到澳大利亚间的交通线。</p><ul><li>1942.6 </li></ul><p>中途岛海战爆发。酷炫的圈套和反圈套作战，最终日军四艘航母全沉没了。此战后，日军在太平洋战场上的优势不复存在。</p><ul><li>1942.5-6</li></ul><p>北非战场，“沙漠之狐”隆美尔率领轴心国军队在加查拉战役中战胜了奥金莱克指挥的盟军，盟军向东退守阿拉曼防线。7月，隆美尔进攻阿拉曼防线，奥金莱克率军抵抗，两军打成了消耗战。8月，奥金莱克的指挥职务被蒙哥马利取代。10月，第二次阿拉曼战役打响，在拥有制空权和后勤方面的优势条件下，蒙哥马利击败了隆美尔，一路追到了突尼斯。</p><ul><li>1942.7</li></ul><p>斯大林格勒战役打响，德军攻入了斯大林格勒，但是与苏军展开巷战，遭到英勇抵抗。11月，天王星计划，完成了反包围。德军在整个战争过程中第一个大规模失败，被俘90，000余人。转折点，盟军进入战略反攻阶段。</p><h2 id="1943"><a href="#1943" class="headerlink" title="1943"></a>1943</h2><ul><li>1942.11 </li></ul><p>北非火炬行动，在阿尔及利亚和摩洛哥登陆后，向突尼斯的轴心国军队进攻。到1943年5月，在实力雄厚的盟军的两面夹击之下，轴心国的部队完全失败，除了一部分逃走外，全部向盟军投降。至此盟军取得了在北非战场上的全面胜利，他们可以把目光投向地中海对面的意大利了。</p><ul><li>1943.7 </li></ul><p>盟军进攻西西里岛，取得胜利。</p><p>东线，德军元帅曼施坦因对阵苏军元帅朱可夫。曼施坦因想用钳形攻势攻击突出的库尔斯克地区，却被朱可夫抵挡住。战争发展成了历史上规模最大的坦克大会战，苏联人的损失比德国更大，但他们能承受这些。最后，由于盟军在西西里岛的入侵，希特勒急需从东线抽调兵力，曼施坦因被迫撤退。从此苏联人开始大规模收复失地，德国人节节败退。</p><ul><li>1943.9</li></ul><p>盟军入侵意大利本土，墨索里尼下台，意大利政府投降。</p><ul><li>1943.11</li></ul><p>开罗会议 - 英美中</p><p>德黑兰会议 - 苏美英  商讨进攻轴心国的战略和战后的安排</p><h1 id="1944-1945"><a href="#1944-1945" class="headerlink" title="1944 - 1945"></a>1944 - 1945</h1><ul><li>1944.1 </li></ul><p>长达两年四个月的列宁格勒围城战终于结束了。苏联法功十次斯大林突进。到年底，收回了全部领土，更控制了东欧大部分国家。</p><ul><li>1944.6</li></ul><p>盟军霸王行动，诺曼底登陆，三百万士兵横渡英吉利海峡。巴顿将军率部横扫法兰西。8月，法国解放。</p><ul><li>1944.12</li></ul><p>12月，德国进行最后的挣扎，在阿登地区向盟军发动攻势，莫德尔成功地在布莱德利的防线上打出了一个“突出部”，所以这场战役被称为突出部战役。德军将小股盟军包围在巴斯托尼。在守军即将崩溃的时候，天气放晴，盟军的空军优势得以发挥，他们对德军进行了猛烈的轰炸，并将物资空投到巴斯托尼。巴顿的援军迅速北上，德军大势已去。希特勒终于同意了莫德尔的撤军请求，他的孤注一掷失败了。</p><ul><li>1945.2 </li></ul><p>雅尔塔会议 —— 苏美英</p><ul><li>1945.4</li></ul><p>朱可夫率领苏军攻占柏林，占领国会大厦，希特勒自杀。</p><p>太平洋战场，盟军在麦克阿瑟的率领下，用蛙跳式跃岛战术。冲绳岛作战。</p><ul><li>1945.7 </li></ul><p>波茨坦会议 —— 苏美英，商讨战后欧洲问题及对日本作战的问题</p><ul><li>1945.8 </li></ul><p>广岛长崎原子弹</p><p>苏联红军攻进中国东北，击溃关东军。</p><p>日本宣布接收《波茨坦公告》公告，无条件投降。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> history </tag>
            
            <tag> world war </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读懂财报</title>
      <link href="/%E8%AF%BB%E6%87%82%E8%B4%A2%E6%8A%A5/"/>
      <url>/%E8%AF%BB%E6%87%82%E8%B4%A2%E6%8A%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="1-资产负债表"><a href="#1-资产负债表" class="headerlink" title="1 资产负债表"></a>1 资产负债表</h1><h2 id="1-1-资产负债表-分类"><a href="#1-1-资产负债表-分类" class="headerlink" title="1.1 资产负债表 分类"></a>1.1 资产负债表 分类</h2><p>企业需要做三张报表，分别是</p><ul><li>资产负债表</li><li>利润表</li><li>现金流</li></ul><h2 id="1-2-财务报表是用来做什么的？"><a href="#1-2-财务报表是用来做什么的？" class="headerlink" title="1.2 财务报表是用来做什么的？"></a>1.2 财务报表是用来做什么的？</h2><p>企业从事的经营活动的种类有：</p><ul><li>经营活动</li></ul><p>比如一个企业需要生产产品、销售产品、回收货款等等</p><ul><li>投资活动</li></ul><p>如果一个企业想要到一个新的地区去开展业务，想进入一个新的业务领域，或者想设计生产一个新的产品</p><ul><li>融资活动</li></ul><p>在经营和投资的过程中，当缺钱了的时候，需要去银行借钱，或者找别人来投资自己</p><p>可以这样子说，企业一辈子只做这三件事，经营，投资以及融资。在这整个过程中，无论其处在什么发展阶段，其日常经济活动都可以抽象成这样一个过程，从现金开始，转了一圈再搞到现金的过程。</p><h2 id="1-3-资产负债表详解"><a href="#1-3-资产负债表详解" class="headerlink" title="1.3 资产负债表详解"></a>1.3 资产负债表详解</h2><p>分为如下几个部分： </p><ul><li>资产 - 流动资产</li><li>资产 - 非流动资产</li><li>负债 - 流动负债</li><li>负债 - 非流动负债</li><li>股东权益</li></ul><h3 id="1-3-1-流动资产"><a href="#1-3-1-流动资产" class="headerlink" title="1.3.1 流动资产"></a>1.3.1 流动资产</h3><ul><li>货币资金</li></ul><p>放在银行里面或者放在公司里面的钱。包括库存现金，银行贷款，和其他货币资金三个项目的期末余额。</p><ul><li>应收账款</li></ul><p>销售产品的时候，发生的卖掉产品但是收不到钱的情况。<br>即需要核算的企业因为销售商品、提供劳务等经营活动应收取的款项。</p><ul><li>其他应收款</li></ul><p>企业除了存出保证金（租房子时交付的未来将退回的保证金、押金等）、买入返售的金融资产、应收票据、应收账款、预付账款、应收股利、应收利息、应收代位追偿款、应收分保账款、应收分包合同准备金、长期应收款等以外的其他各种应收及暂付款项。</p><ul><li>预付账款</li></ul><p>基本发生在货品很紧缺，带了一种向卖方收款的权利。预付账款也是一种资产。</p><ul><li>存货</li></ul><p>生产产品所需的原材料，生产出来的产成品，以及尚且处在生产过程中的没有完成的在产品</p><ul><li>待摊费用</li></ul><p>资产 vs 费用。 如果这笔钱可以换来对将来有用的东西，就是资产。如果画完就完了，就是费用。</p><p>各项流动资产在资产负债表中是按照<strong>各自转换为现金的速度</strong>来排序的。</p><h3 id="1-3-2-非流动资产"><a href="#1-3-2-非流动资产" class="headerlink" title="1.3.2 非流动资产"></a>1.3.2 非流动资产</h3><p>返回现金的时间长度，无法在一个循环内完成的。</p><ul><li>长期投资</li></ul><p>指不满足短期投资条件的投资，即不准备在一年或长于一年的经营周期之内转变为现金的投资。可以分为长期股票投资，长期债券投资，其他长期投资</p><ul><li>固定资产</li></ul><p>指同时具有以下特征的有形资产： （1）为生产商品、提供劳务、出租或经营管理而持有的； （2）使用寿命超过了一个会计年度</p><ul><li>无形资产</li></ul><p>专利权，版权等，还有土地使用权</p><p>指企业拥有或者控制的没有实物形态的可辨认的非货币性的资产。包括专利权、非专利技术、商标权、著作权、土地使用权等。</p><h3 id="1-3-3-资产-gt-企业"><a href="#1-3-3-资产-gt-企业" class="headerlink" title="1.3.3 资产 -&gt; 企业"></a>1.3.3 资产 -&gt; 企业</h3><p> 固定资产多，应收账款多，可能是有经营压力的传统企业</p><p> 生物资产，指有生命的动物和植物，生物资产分为消耗性生物资产，生产性生物资产和公益性生物资产。</p><p> 资产的结构会告诉你这家公司是什么样子的。 </p><h3 id="1-3-4-资产如何计价？"><a href="#1-3-4-资产如何计价？" class="headerlink" title="1.3.4 资产如何计价？"></a>1.3.4 资产如何计价？</h3><p> 会计们会用原来购买的资产价格当做这个资产的价值。</p><blockquote><p>历史成本</p></blockquote><blockquote><p>资产在其取得时为其所支付的现金或现金等价物的金额。负债在正常经营活动中为交换而收到或为偿付将要支付的现金或现金等价物的金额。</p></blockquote><blockquote><p>Bug: 历史成本无法体现出资产的变化。故解决方案为： 如果资产价值减小了，就把减值记下来。因为资产计价体系是一个历史成本的体系，一定要在历史成本的基础上扣除这个资产的减值。 </p></blockquote><ul><li>历史成本的含义</li></ul><ol><li>只有花了的钱才能记在账上。</li><li>在历史成本的计价体系下，增加资产价值的唯一途径是发生一个新的交易。</li></ol><h3 id="1-3-5-负债"><a href="#1-3-5-负债" class="headerlink" title="1.3.5 负债"></a>1.3.5 负债</h3><blockquote><p>负债：由于过去的交易或事务所引起的公司企业的现有债务，这种债务需要企业在将来以转移资产或提供劳务加以清偿，从而引起未来经济利益的流出。<br>其他：是为了简化，欠员工的工资，因为是月底发钱； 欠税务局的钱。这些都是流动负债。非流动负债： 应付债券。</p></blockquote><blockquote><p>应付债券：企业为了筹集资金而对外发行的期限在一年以上的长期借款性质的书面证明，约定在一定期限内还本付息的一种书面承诺。</p></blockquote><h3 id="1-3-6-股东权益"><a href="#1-3-6-股东权益" class="headerlink" title="1.3.6 股东权益"></a>1.3.6 股东权益</h3><blockquote><p>股东权益： 公司总资产中扣除负债剩余的部分，也成为净资产，反映了公司的自有资本。</p></blockquote><blockquote><p>股本： 股本金额相当于公司的注册资本。股本的总额体现了这个公司对外承担法律责任的上限。股本的组成则确定了多个股东之间的权利义务关系。</p></blockquote><blockquote><p>资本公积： 企业收到的投资者的超出其在企业注册资本所占份额，以及直接计入所有者权益的利得和损失等。</p></blockquote><blockquote><p>股东权益 + 负债 = 资产</p></blockquote><p>注意资产负债表是一个时间点的概念，是状态，不是过程。</p><h1 id="2-利润表"><a href="#2-利润表" class="headerlink" title="2. 利润表"></a>2. 利润表</h1><p>资产负债表： 可以看到投入的本金是否得到保障。利润表，则能得知投入的本金有没有赚钱。</p><p>毛利 = 营业收入 - 营业成本</p><h2 id="2-1-税种"><a href="#2-1-税种" class="headerlink" title="2.1 税种"></a>2.1 税种</h2><ul><li>营业税</li></ul><p>国家对工商营利事业按照营业额征收的税</p><ul><li>营业税金及附加</li></ul><p>企业经营活动应负担的相关税费，包括营业税、消费税、城市维护建设税、资源税、教育费附加等。不是所得税，是流转税，只要是有业务的企业就得缴纳流转税。</p><ul><li>常见的流转税： 营业税（价内税） + 增值税（价外税）</li><li>价内税： 税金包含在商品价值或价格之内</li><li>价外税： 税款不包括在价格内</li><li>增值税： 一种销售税，是消费者承担的税费，属于累退税，是基于商品或服务的增值而增税的一种间接税</li></ul><h2 id="2-2-其他项目"><a href="#2-2-其他项目" class="headerlink" title="2.2 其他项目"></a>2.2 其他项目</h2><ul><li>补贴收入<br>中国特色： 政府为一些企业提供的补贴。</li></ul><h2 id="2-3-利润表的分析"><a href="#2-3-利润表的分析" class="headerlink" title="2.3 利润表的分析"></a>2.3 利润表的分析</h2><p>告诉了是否赚钱，在哪些方面赚钱的基本信息。同时因为将可持续的和不可持续的营业收入分开，就可以帮助企业推断出自己未来一段时间以内的收益。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> reading </tag>
            
            <tag> finance </tag>
            
            <tag> stock </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
